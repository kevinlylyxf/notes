[TOC]
# 第3章 字符串、向量和数组
- 头文件不应包含using声明
- 字符数组后面加\0,整形数组没有
- char \*s = "abc" 定义字符串，指针指向的区域是不能更改的，末尾加\0，char s1[] = "fffff",作用和前面类似，如果char s2[10] = {'' ''}在赋值时没有\0是字符数组，有的话为字符串。string没有\0
- 指针数组和数组指针，int \*p[5]表示该数组包含5个指向int类型数据的指针，是指针数组。int (\*p2)[5]表示p2是一个指针指向一个包含五个int类型的数组
- 递归调用就是函数自己调用自己，递归要有一个明确的递归终止条件例如斐波那契数列中，if(n == 1 || n ==2) return n;含义为找到最后一个门让其退出递归往回走。因为递归本身也是函数，也有返回值，所以要给每个递归函数有返回值，当函数用递归时就可以使用递归返回值来就行计算，例如斐波那契return f(n - 1) + f(n - 2);每一个递归函数都会返回。
- 二叉树的前中后序遍历时，没有返回值，相当于进入一扇门然后一直进，虽然没有返回值，但是调用了那个函数，用一个函数不一定非得有返回值，干了事情就行了，从后面的门一直往外走，函数调用完了没有返回值的会默认加一个不带返回值的return，当一个函数调用另一个函数时，被调用的函数执行完后返回函数中执行函数剩余的，如果没有剩余的就返回上一个函数的调用。
```c++
void PreOrder(BiTree T) {
    if (T == NULL) return;
    printf("%c", T->data);
    PreOrder(T->lchild);
    PreOrder(T->rchild);
}
```
- 显示类型转换，强制类型转换cast，cast-name<type> (expression) ,const-name是static_cast,const_cast,dynamic_cast,reinterpret_cast中的一种
   - const_cast 只能改变运算对象的底层const，用于将常量对象转换为非常量对象。const char \*pc; char \*p = const_cast<char\*>(pc);const_cast只能修改常量属性。pc变成非常量可以给非常量指针赋值。这样修改就可以对常量对象就行写操作了，只有指针和引用会有底层const,底层const表示指针所指的是一个常量，就是指针指向了一块常量地区，但是指针不是常量，它可以指向别的常量地区。但是这个常量地区是不变的，其只能被常量对象指向和引用。const_cast常常用于有函数重载的上下文中
   - static_cast 用于数据类型的转换
- 给无符号类型赋值超出它表示范围时，结果是取模后的余数， -1给unsigned char是255 ，如果给带符号的类型赋值一个超出表达范围的值会报错误，结果是未定义的。
- 当初始值有多个时，一般来说只能使用直接初始化。
- 输入string时，遇到空格结束。
- 在string中要改变for范围语句中的时要用引用 for(auto &c : s);
- vector是一个类模板。
- vector不能使用下标形式添加元素
- 迭代器的使用:auto b = v.begin(),这个和数组不一样
- 迭代器类型vector<int>::iterator it; string::iterator it2; const_iterator和常量指针差不多，能读取但不能修改它所指元素的值。cbegin和cend返回const_iterator类型的迭代器。
- 任何一个改变vector对象容量的操作，都会使该vector对象的迭代器失效。

# 第9章 顺序容器
- 顺序容器类型
   - vector 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢
   - deque 双端队列，支持快速随机访问，在头尾位置插入删除速度很快
   - list 双向链表，只支持双向顺序访问，在list中任何位置进行插入删除速度都很快
   - forward_list 单向链表，只支持单向顺序访问，在链表任何位置进行插入删除操作都很快
   - array 固定大小数组，支持快速随机访问，不能添加或删除元素
   - string 与vector相似的容器，但专门用于保存字符，随机访问快，在尾部插入删除速度快
- string和vector将元素保存在连续的内存空间中，在中间插入删除要移动很多数据，所以很慢
- forward_list没有size操作，为了实现最大性能。
- 如果不确定使用哪种容器，在程序中只使用vector和list公共的操作:使用迭代器，不使用下标操作，避免随机访问。
- 容器操作
   - 类型别名 
      - iterator 此容器类型的迭代器类型
      - cosnt_iterator 可以读取元素，但不能修改元素的迭代器类型。
      - size_type 无符号整数类型，足够保存此种容器类型最大可能容器的大小
      - difference_type 带符号整数类型，足够保存两个迭代器之间的距离
      - value_type 元素类型
      - reference 元素的左值类型，与value_type&含义相同
      - const_reference 元素的const左值类型，即const value_type&
   - 构造函数
      - C c;默认构造函数，构造空容器(array看后面)
      - C c1(c2);构造c2的拷贝c1
      - C c(b, e);构造c，将迭代器b和e指定的范围内的元素拷贝到c(array不支持)
      - C c{a, b, c...};列表初始化c
   - 赋值与swap
      - c1 = c2;将c1中的元素替换为c2中元素
      - c1 = {a, b, c...};将c1中的元素替换为列表中元素(array不适用)
      - a.swap(b);交换a和b的元素
      - swap(a,b)
   - 大小
      - c.size();c中元素的数目，不支持forward_list
      - c.max_size();c可保存的最大元素数目
      - c.empty();
   - 添加删除元素，不适用array
      - c.insert(args);将args中的元素拷贝进c
      - c.emplace(inits);使用inits构造c中的一个元素
      - c.erase(args);删除args指定的元素
      - c.clear();删除c中的所有元素，返回void
- size_t是sizeof运算符所返回的无符号整数类型，可以存放理论上可能存在对象的最大大小，该对象可以是任何类型，包括数组，作用为适应于程序的移植，64位系统使用unsigned int有时就会出错。size_t通常用于数组索引和循环计数。size_type是基于容器的，没有容器不能单独使用，其和size_t定义相同，size()函数返回的是size_type类型的，相当于int但是可以移植
- 快速随机访问就是使用下标访问，string和vector可以使用下标访问 string[], 使用下标访问可以更改访问元素的值，但是不能使用下标访问给vector添加元素  
- 标准容器迭代器的运算符 \*iter　 iter->mem　 ++iter　--iter　相等和不相等
- 迭代器的算数运算 iter+=n这样的，iter + n　iter - n　类的 迭代器加减
- forward_list 不支持--iter操作，链表不支持迭代器运算，只能顺序调整迭代器,但是list有list.begin()和list.end()
- 算数运算只能应用于string,vector,deque和array
- 与顺序容器大小相关的构造函数，vector<int> iver(10, -1);10个int元素每个都是-1;string s(10, 'c');string是一个类，只存一个字符串，所以是string字符串有10个字符每个都是c，string初始化方式 string s3("value");string s2(s1)
- array定义 array<int, 42>,除了指定元素类型，还要指定容器大小，数组是不允许拷贝的，但是array允许拷贝赋值，大小和类型要一样。
- 赋值，c1 = c2,c1 = {a, b, c},如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同，列表赋值时，c1的大小为3。array不允许右侧是列表初始化，两边大小可能不一样。array不支持assign
- 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，而swap不会(array和string的情况除外)
- 容器赋值运算
   - c1 = c2;将c1中的元素替换为c2中的元素，c1和c2必须具有相同的类型
   - c = {a, b, c...} 将c中元素替换为初始化列表中元素的拷贝(array除外)
   - c1.swap(c2) swap(c1, c2)交换c1和c2中的元素，c1和c2必须具有相同的类型，swap通常比从c2向c1拷贝快的多
   - seq.assign(b,e)将seq中的元素替换为迭代器b和e所表示的范围中的元素，迭代器b和e不能指向seq中的元素
   - seq.assign(n, t)将seq中的元素替换为n个值为t的元素
- 容器赋值是将左侧的容器看成一个空的重新赋值，即便原来有值如果右侧的比它少也是少的东西。
- swap两个array会真正交换他们的元素。
- 每个容器都支持相等和不相等运算符，除了无序关联外的所有容器都支持关系运算符(> >= < <=)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E5%AE%B9%E5%99%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png)
- vector和string不支持push_front，但是可以使用insert插入，不用考虑是否支持push_front
- c.insert(p,b,e) 其中b和e支持的是其他容器，只要元素类型一样就可以。
- emplace理解:emplace是构造而不是拷贝元素，当调用push和insert成员函数时，将元素类型的对象传递给他们，这些对象被拷贝到容器中，当调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数，emplace成员使用这些参数在容器管理的内存空间中直接构造元素。例如，c中保存Sales_data对象，c.emplace("978", 25, 15.99),emplace使用Sales_data构造函数来初始化一个对象然后加到c里面，而push_back是直接加一个对象进去。
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0.png)
- 返回引用的意思是其可以作为左值直接修改值，例c.front() = 42;返回引用也可以在右边，auto &v = c.back();意思是获得了最后一个元素的引用，可以通过v改变最后一个元素的值。
- 下标运算符不检查越界，而at检查。
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.png)
- pop_front返回的是void，不能赋值，需要使用时先用c.front()保存一下。
- 顺序容器大小操作c.resize(n), c.resize(n,t)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/forward_list.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88.png)
- end迭代器肯定会失效，所以不要保存尾后迭代器，直接使用c.end()
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/string%E6%9E%84%E9%80%A0.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/substr.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/string.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/string%E6%90%9C%E7%B4%A2.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/string%E6%90%9C%E7%B4%A2%E5%8F%82%E6%95%B0.png)

- 容器适配器的理解：顺序容器提供了一些基本的接口，比如插入，删除等，但是栈、队列这种数据结构表现出来的形式跟普通的数据结构不一样，但是我们又不用重新定义数据结构，只需要根据他们的接口重新写一下栈队列的数据结构就可以了，这就是容器适配器
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8.png)
- 容器适配器都定义两个构造函数 一个创建空的 另一个拷贝 deque<int> deq ; stack<int> stk(deq);
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E6%A0%88.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E9%98%9F%E5%88%97.png)
# 容器的使用
- queue 队列 queu\<int\> que; que.push(5);入队 que.pop();出队 que.front(); 队首元素 que.size();元素个数 que.empty();是否为空
- stack stack\<int\> sta; sta.push(5); sta.pop(); sta.top();栈顶元素 sta.size(); sta.empty();
- vector vector\<int> v ;
- priority_queue 优先队列; 和stack函数一样,底层基于堆数据结构
- string ; string.find(s);返回查找的位置;if(str.find(s) == std::npos)
- map ;底层基于RBtree，要存储自定义数据结构要重载< 让红黑树知道怎么排序
   - multiple 可以重复出现，底层基于RBtree
   - unordered_map 底层基于hash表，无需排序
- set ; 底层基于RBtree，要存储自定义数据结构要重载，和map类似
- pair
---
# 泛型算法
- 大多数算法都定义在algorithm中，标准库还在头文件中定义了一组数值泛型算法。
- 泛型算法不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作，特殊的数组类型的,其迭代器begin(ia),end(ia), ia+1,ia+4
- 泛型算法中的输入范围中的参数分别是指向要处理的第一个元素和尾元素之后位置的迭代器。所以要处理三个数组元素auto result = find(ia + 1, ia + 4, val),如果找到不就会返回尾后迭代器，和尾后迭代器比较就能知道找到没
- 只读算法，find,count,accumulate,读取其输入范围内的元素，而不改变元素，accumulate接受三个参数，前两个指出了求和的范围，第三个参数是求和的范围，int sum = accumulate(vec.begin(),vec.end(),0),第三个参数确定了求和的起点，即从0开始求，string sum = accumulate(v.begin(), v.end(), string ("")); 字符串相加，字符串存在vector中，第三个参数要显示指出来是string，否则字符串常量是const char\*的，const char\*没有重载+运算符，equal只读算法，三个参数是前两个表示容器的范围，第三个参数是第二个容器的首元素，编程假定第二个比第一个要长
- 写容器元素的算法，算法不会执行容器操作，所以要保证以前有元素，然后重新赋值，fill,fill_n，fill_n接受三个参数，第一个参数是迭代器起始位置，第二个参数是要赋值的个数n，第三个是赋值的值。
   - 拷贝(copy)算法，前两个表示一个输入范围，第三个表示目的序列的起始位置，两个容器的元素要一样多。auto ret = copy(begin(ia), end(ia), a2);这是数组举例，迭代器一样，a2代表第二容器的起始位置，所以用数组名，别的用迭代器。copy返回的是其目的位置迭代器(递增后)的值，即ret恰好指向拷贝后a2的尾元素之后的位置。
   - replace接受4个参数，replace_copy接受五个参数。replace是在原有的容器上替换，原容器被破坏，replace_copy会新建一个拷贝，原容器会保存下来。好多算法会有这种形式算法。
- 重排容器元素的算法，sort，unique(算法将sort排序完相邻出现的重复的放在后面，前面只放出现一次的单词，返回的是指向重复出现的单词的第一个位置)
- sort参数是默认的使用\<运算符来进行比较的，如果比较的是类，其使用的\<是重载过的，如果比较的是数值的就默认的，如果比较类时没有重载小于号，就要给函数传递参数
- 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值，谓词分为一元谓词和二元谓词(参数的不一样)，接受谓词参数的算法对输入系列中的元素调用谓词。有的算法只能接受一元谓词，如find_if，其谓词中只能有一个参数
```c++
bool isShorter(const string &s1, const string &s2) {return s1.size() < s2.size();}
sort(words.begin(), words.end(), isShorter)按长度由短至长排序words，
```
- sort使用了第三个参数，其是一个二元谓词，谓词的作用主要是寻找一些特定的条件，函数的主要功能还是原函数的功能，此函数即为排序，主要的是按什么排序，我们找到vector中的两个元素，我们不知道按什么排序，但是根据谓词我们就知道了按字符长度排序，其它的函数谓词的意思有区别但是主要就是找这个条件，让两个元素根据这个条件来达到函数功能。
- 我们可以向一个算法传递任何类别的可调用对象，对于一个对象或一个表达式，如果可以对其使用调用运算符(即.)则称其可以是调用的。函数和函数指针，lambda和重载了函数调用运算符的类。
- 一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数。
- [capture list] (parameter list) -> return type {function body},必须使用尾置返回类型。可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体
- 参数捕获中的值捕获和引用捕获，值捕获是创建一个新值，引用捕获不是创建新值。
```
void func() {
    size_t v1 = 42;
    auto f = [v1] {return v1;}; auto f = [&v1] {return v1;}
    v1 = 0;
    auto j = f(); 如果是值捕获的话为42，引用捕获为0，引用捕获是捕获谁&后面写谁
}
```
- 隐式捕获，让编译器推断需要使用哪些变量
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/lambda%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8.png)
---
# 关联容器
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B.png)
- 关联容器不支持顺序容器的位置相关的操作，例如push_back,因为没有意义。关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。
- 对于有序容器map,multimap,set,multiset关键字类型必须定义元素比较的方法，默认情况下使用关键字类型的<运算符来比较两个关键字。
- map中的元素是pair的
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/pair.png)
- 使用作用域运算符来提取一个类型的成员，map<string , int>::key_type
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D.png)
- 当解引用一个关联容器时，会得到一个类型为容器的value_type的值的引用，对map而说，value_type是一个pair类型的，其first成员保存const的关键字，second成员保存值，所以不能修改const，map->first = "new key"是错误的，即能改变pair的值，但不能改变关键字成员的值。
- set的迭代器是const的，所以不能修改
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/map_insert.png)
- ++ret.first->second,first是迭代器就好理解了
- multiset和multimap总是会插入，无需返回bool值
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/map%E4%B8%8B%E6%A0%87%E8%8C%83%E6%96%87.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%9F%A5%E6%89%BE.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8.png)
---
# 动态内存和智能指针
- 静态内存和栈内存，定义了一个内存池被称为自由空间或堆。
- 忘记释放内存，就会导致内存泄露
- 标准库提供了两种智能指针，shared_ptr允许多个指针指向同一对象，unique_ptr独占所指的对象，标准库还定义了一个weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象，智能指针也是模板，shared_ptr<string> p1,shared_ptr<list<int>> p2;
- make_shared函数定义在memory头文件中，shared_ptr\<int> p3 = make_shared\<int>(42),最好用auto
- 智能指针会自动释放自己管理的对象，即把指针指向的区域给释放掉了，当有别的指针指向这块，指针不会释放其指向的内存
- 使用动态内存的一个常见原因是允许多个对象共享相同的状态，在一个StrBlob类中设置vector存储东西，如果这个类消失这个vector容器也消失，所以设置一个智能指针指向这个vector，如果有指针指向就不会释放。
- new的使用，int \*pi1 = new int; int \*pi2 = new int();后面跟括号可以进行值初始化，里面可以放值，不放值也得有，默认为0，如果不加括号是未定义的值。
- new和auto的使用，auto p1 = new auto(obj);系统自动判断obj的类型，然后p1指针指向的类型是系统自动判断出来的
- delete指针必须是动态分配的内存，或者是一个空指针，释放的指针必须是new的，内置类型的指针不能delete，删除空指针可以这样
- shared_ptr和new结合使用，shared_ptr\<double> p2(new int(1024)),这样定义，不能shared_ptr\<double> p1 = new int(1024),这样是不对的，智能指针构造函数是explicit的，必须使用直接初始化的方式。
---
# 模板编程

---
# 算法
- 素数筛，素数筛就是用素数将合数标记出来，prime[++prime[0]] = i;功能为prime[0]标记素数的数量，然后将素数放在1开始的数组中依次存放。
- 线性筛，总体思想是用一个整数M去标记合数N,其中N和M具有如下性质:1)N中最小的素数为P,2)N可以表示成为P\*M,3)P一定小于等于M中最小的素因子,4)利用M\*P'(所有不大于M中最小素数的集合)去标记N1，N2，N3...
   - 标记一个合数N，需要找到M和P，其中P是N中最小的素数，M可以是素数可以是合数。例子，N=8时M=4,N=2.反过来M=25时可以标记的合数有50、75、125，因为25的最小素数为5，所以P可以为2、3、5，但是不能大于5.M=45时可以标记的合数有90、135，因为45的最小素数为3，所以P只能为2、3。需要标记的是合数，不是通过合数找M和P，所以不知道N的值，只能通过M和P去标记，例如M=25时标记的值，其中P只要满足规则就行，不是每次标记P都为2.总体来说这相当于找最大的M标记即最后一次才去标记合数，七擒孟获。

---
# 对于书上的理解
- 底层const只有指针和引用才有，底层表示其所指或所引用的对象是个常量,在赋值时右侧是不是const都没关系，底层const意味着不能通过左侧的指针或引用修改右侧的值，但我们可以直接修改右侧变量的值，然后让其重新指向这块区域，其值就改变了。底层仅仅对引用或指针可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。如果对象是一个非常量就可以通过其他方法改变它的值。这相当于指针或引用是形参时，当把常量实参传进来，我们不能通过形参中的指针或引用变量对此常量实参就行修改，但是传进来的常量实参是可以修改的即可以传进实参1也可以传进实参2，一旦传进来我们就不能通过指针或引用修改这个实参，虽然不能通过指针或引用修改，但是可以直接通过修改右侧的变量直接修改，相当于在外面修改了，但是指向还是这块区域，取出来也是修改了的。形参的时候传进来实参不用修改，因为传进来的实参就是不同的常量对象，直接引用就行了。上面的修改是对一个右侧非常量的修改。
- 顶层const表示指针本身是个常量，底层const表示指针指向的对象是一个常量。int \*const表示顶层const，const int \*表示底层const， const int 顶层，const int &r 底层。顶层将bufsize限定为常量，即里面的内容不能改。
- const限定符 const int BufSize = 512,这样把BufSize定义成了一个常量，任何改变其值的操作都是错误的，表示我们将其设定为常量不能更改其值，例如将其设定为缓冲区大小，我们不能改变其值，但定义时可以用各种赋值，是不是常量都无所谓，其只有初始化之后才是不变的，这是顶层const，BufSize是一个常量，其后的不是。const可以进行和非const大概所有的操作，const只有在赋值后才会变成常量，在没有赋值前对其进行各种赋值包括函数赋值，变量赋值都是可以的。默认情况下const对象仅在文件内有效，当在多个文件中出现同名的const对象时，是不同的，如果要在多个文件中共享const对象，必须在变量的定义之前加extern
- const的引用，把引用绑定到const对象上，称之为对常量的引用，与普通引用不同的是对常量的引用不能被用作修改它所绑定的对象。const int ci = 1024;const int &r1 = ci;对常量的引用意思是不能通过修改r1的值来修改ci的值。r1 = 42对常量的引用修改是错误的，int &r2 = ci让一个非常量引用指向一个常量对象是错误的。一般情况下引用的类型与其所引用对象的类型一致。指针和引用一般情况下等号右边都是变量的值，不能直接是字面值，所以右侧可以是常量的或非常量的。
- 指针和const，与引用一样，可以令指针指向常量和非常量，指向常量的指针不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针。const double pi = 3.14;doble \*ptr = &pi,这是错误的，ptr是一个普通指针，必须加const。double dval = 3.14;const double \*ptr = &val;此时\*ptr输出的值是3.14，可以通过改变dval的值改变\*ptr,例如dval = 4.14,此时\*ptr输出的为4.14，可以通过改变变量的值改变，但是不能通过\*ptr = 5.14这样的方法改变其值，普通指针是可以的。const表示指针和一般变量是不一样的，const和指针在一起是底层const即指针指向的对象是常量，const和一般变量在一起是顶层const即将变量表示成常量。
- 常量指针，指针是对象而引用不是，因此可以像其他对象一样，允许将指针本身定义为常量，意思是指针的值是不变的即指针里面的地址是不变的，指向的空间是不变的，但是空间里的值是变的。表示方法，const前面\*,int \*const curErr = &errNumb;此时可以通过\*curErr改变errNumb的值。都是常量可以写成const int \*const 
- 对象是指一块能存储数据并具有某些类型的存储空间。
- 用花括号括起来的方式初始化被称为列表初始化，当作用于内置数据类型时如果数据存在丢失的风险就会报错。例如int a{ld},ld 是long double类型的会报错，int c(ld),小括号不报错，数据强制转换了。
- 默认初始化，定义基本数据类型时可以指定初始值，如果未指定c++会去执行默认初始化，c++保证对象总是会被初始化的，默认初始化就是栈区的和堆区的变量会有不确定的值(堆区的值需要手动释放例如new，栈区的会自己释放)，全局变量和静态变量(包括局部静态变量)会初始化为0，所以定义在函数体外的全局变量会初始化为0。类的初始化由类自己决定。类中如果包含有内置类型或符合类型的成员，其相当于在堆区或栈区，必须要进行初始化，默认初始化其值是不定的。这只是相对于内置类型来说的，像string这种是一个类，其默认情况下被初始化为空，这是正确的。
- 变量的声明和定义，声明不会申请数据空间，定义会申请内存空间，定义只能出现在一个文件中，而用到变量的文件必须对变量进行声明，不能重复定义。extern表示对变量声明不定义，extern int i,声明i不定义，int j，声明并定义j
- constexpr和常量表达式，常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象是不是常量表达式由它的数据类型和初始值共同决定。
- 算数类型、引用、和指针都属于字面值类型，可以定义成constexpr，声明为constexpr变量必须用常量表达式初始化。
## 类
### 类的基本定义
- 类的基本思想是数据抽象(date abstaction)和封装(encapsulation)。数据抽象是一种依赖于接口和实现分离的编程技术，类的接口是包括用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。封装实现了类的接口和实现的分离，封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。
- 类主要是一些数据和一些实现的操作，通过构造函数初始化一个类，通过实例化对象我们最终就是要控制这个实例对象，比如修改数据以及实现类中的某个功能，这些都是通过接口实现的，例如Screen类里面定义了一个显示函数，显示类的长宽高之类的，但是它定义了我们怎么用它，只能通过实例化的类，然后调用那个接口来在main函数里面实现逻辑功能，如果需要修改显示的内容，我们可以修改显示函数传进来的实参，同样是在main函数中，而不需要修改函数，我们主要就是使用这个函数来显示，显示的不同通过实参来决定。调用时分为成员函数和非成员函数的调用。没有其他情况了，因为没有别的情况可以调用这些接口了。调用时这样也就够用了不需要别的方式了。
- 成员函数的声明必须在类的内部，它的定义可以则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数定义和声明都在类的外部。定义在类内部的函数是隐式的inline函数，声明和定义不一样，所以在类内声明类外定义的函数要显示声明为inline，在类内声明和类外声明都是一样的。
- 类里面主要是一些数据变量和一些实现以及接口，平常做的就是实例化一个对象，通过实例化对象取用类里面的东西，取用的本质就是要得到这些数据给外面的变量来用它，例如，total.isbn(),需要将取出来的变量值给另外一些东西来运算，如果isbn有参数需要写上，这就相当于取用类里面的函数给外面的变量进行计算。如果非成员函数是类的接口，其不需要写实例化类调用，例如read，因为其形参就是实例化类，通过形参就能知道了，直接写a = read().
- 成员函数(注意是成员函数)通过this指针来访问调用它的那个对象，通俗来讲就是通过this指针来看是调用了哪个实例对象的成员函数，而不是另一个对象的。其实现是将实例对象的地址初始化为this。例如total.isbn,此时将total的地址给this指针，就可以知道访问的是total的isbn而不是其它的。this是一个常量指针，不允许改变指针的值。在成员函数内部可以直接使用调用该函数对象的成员，不用写成return this->bookNo,直接写成return bookNo.
- 常量对象，以及常量对象的引用或指针都只能调用常量成员函数。
- string isbn() const {return bookNo;}分号在里面。const的作用是修改隐式this指针的类型。this的类型是Sales_data \*const,其要初始化，且我们不能把this绑定到一个常量对象上，这一情况也就使得我们不能在一个常量对象(常量对象在类中就是定义对象时将其定义为常量，例如const Sales_data p)上调用普通的成员函数,此时对象是一个常量对象，this指针要指向常量对象，所以this也要是const Sales_data \*const this,因为this是隐式的，所以将const关键字放在成员函数的参数列表之后，表示this是一个指向常量的指针。使用const的成员函数被称为常量成员函数。常量成员函数不能改变调用它的对象的内容。为什么要弄常量成员函数，因为常量对象只能调用它的常量成员函数而不能调用普通成员函数，普通对象两个都能调用。
- 编译器分两部处理类，首先编译成员的声明，然后才轮到成员函数体。所以可以不用考虑成员的次序。
- 成员函数和非成员函数。类的作者常常需要定义一些辅助函数，比如add、read和print等，尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但他们实际上并不属于类本身。成员函数是属于类本身的，非成员函数就是相对于成员函数来说的，其本质就是普通函数。非成员函数和普通函数一样定义，但是其作为类的接口的一部分，所以其形参传递的是类对象的引用。为什么要用非成员函数，原因如下，如果某个功能用成员函数来实现的话，对象中的变量将对函数彻底开放，同时会将对象中的数据更大程度的暴露出来，尤其是随着开发的进行会设置非常多的成员函数，到时都搞不清哪些数据是封闭的哪些是可供用户操作的，这样很大程度上是破坏了数据的封装性。用非成员函数即普通函数也可以访问类的成员，就是将类对象作为形参传进来。成员函数和非成员函数最大的区别在于成员函数可以是虚拟的而非成员函数不行，所以如果有个函数必须进行动态绑定，就要采用虚拟函数，而虚拟函数必定是某个类的成员函数。如果非成员函数是类接口的组成部分，则这些函数的声明应该是和类在同一个头文件中。
- 构造函数的作用是初始化类对象的数据成员，其实类也是一种类型，大类包含小类时，小类也需要初始化。构造函数初始值列表作为构造函数时，如果只定义了一些数据，其余的用类内初始值(就是已经定义好初值)初始化，如果没有类内初始值的数据，就需要显示的初始化，不能省略。在省略的时候需要将默认构造函数写出来，因为需要它。
- 内联函数inline，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换(相当于将函数体直接放在这而不是去调用编译)，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。
- 访问控制与封装，我们使用访问说明符(access specifiers)加强类的封装性。public在整个程序内可以被访问，public成员定义类的接口。private可以被类的成员函数访问，不能被非成员函数访问(此时可以设置友元函数)，不能被使用该类的代码访问(类似于非成员函数，其使用类但是不能访问private里的东西)，private部分封装了(即隐藏了)类的实现细节。一般情况下，构造函数和接口函数紧跟在public后面，而数据成员和作为实现部分的函数则跟在private后面。类是一种依赖于接口和实现分离的编程技术，意思是将类的接口放在public之后，将类的数据成员(例如int，double这类定义的数据)和实现部分的函数体放在private之后，这样做的意义是尽可能实现了数据的封装，通过接口可以对一些数据进行取用和修改，而不需要将数据暴露出来影响封装性，通过接口可以取用类实现部分的函数体，即通过接口函数调用实现函数，这样做的好处是当实现部分有改动时直接修改实现部分就行了不需要修改接口部分，接口只是调用实现的函数而没有具体的功能。
- 数据成员是private的，read，add，print这些非成员函数无法正常编译，因为其虽然是接口的一部分但不是类的成员，所以不能访问private里面的内容。友元的作用是允许其他类和函数访问类的非公有成员。如果全是public的就不用友元了，因为能直接访问，非成员函数只是不能访问private里面的东西。如果全是public，非成员函数通过传类对象就能访问数据以及实现，就能对其数据进行修改了。类似于需要取用类里面定义的一些数据以及实现时，如果全是public的就可以直接取用，在非成员函数函数体里面修改，相当于直接拿到了数据变量，或是在函数体里面调用public里面的实现，直接就能取到(这基于将类作为形参传进来的)，如果是private的，非成员函数就不能取用了，只能设置友元。
- public和private理解，public是公有的，如果定义了一个非成员函数，其需要访问private就需要设置友元函数，不需要访问的情况下，只访问public的成员，例如非成员函数访问公有的isbn()，isbn访问私有的bookNo，不需要设置友元，因为没有直接访问私有成员，是通过公有成员间接访问的。
- 封装的好处，1、确保用户代码不会无意间破坏封装对象的状态。2、被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。具体来说就是实现部分给封装成了函数，而接口就是调用这个函数，实现部分更改了，类似功能增多之类的，但是接口调用实现这个函数没有改变，所以接口不用改变，所以用户使用这个类的代码也就不会变，即用户的代码不用改变。如果数据和实现部分都是public的，这就相当于没有封装，都能对数据就行修改了，相当于没有接口，实现部分的改变因为没有接口调用，用户代码也得改变。所以封装具有很多好处。类似于在private里面定义了时间这个变量，通过接口可以取用这个变量，也可以通过设置接口修改这个变量，连个接口不一样，所以就不能通过直接调用修改变量来实现这个功能，这样做很有可能出错，设置接口时同样是操作数据，想要什么功能调用什么接口，不是对接口的直接使用。
- Screen & 返回值是其自身的左值引用，在进行操作是返回的是对象本身而非对象的副本，所以不设计拷贝，可以进行myScreen.move(4,0).set('#');这种两个函数在一起可以进行，因为move函数操作完返回的是引用对象本身，如果返回的不是引用就错了。
- 令某个成员函数作为友元，是有一定顺序的，必须满足声明和定义的彼此依赖关系。P252
- 当一个类中出现在类外定义的成员函数，其返回类型是自己定义的，ScreenIndex addScreen(const Screen&);在类外定义成员函数时也要指出其返回类型也是属于某一个类的。
- 构造函数初始化和赋值是有区别的，const或引用都必须是初始化，必须通过初始值列表的方式，不能通过类外定义构造函数的方法，其过程是先定义在赋值，但是const和引用必须初始化。
- 可以定义类似int i这样的句子在类中，可能会想应该初始化，但是类的初始化是在构造函数时初始化的。类中初始化的顺序是和数据定义的顺序一样的，跟初始化列表的顺序没关系，当其中一个数据需要初始化另一个数据就要考虑顺序了。
- 类的静态成员:有时候类需要和它的一些成员与类本身直接相关，而不是与类的各个对象都保持关系。例如银行账户类需要一个数据成员标志基准利率，希望基准利率与类相关，而非与类的每个对象相关。类的静态成员存在于任何对象之外。
- 可以使用作用域运算符直接访问静态成员r = Account::rate();而一般的不可以，通过实例化类可以直接访问静态成员。
- 静态成员初始化一般在类外进行，跟类外定义成员函数类似，指明作用域运算符。
- 隐式的类类型转换，如果构造函数只接受一个实参，它实际上定义了转换为此类类型的隐士转换机制。例如在Sales_data中有一个接受string的实参 item.combine(null_book);null_book是string类型的，combine是非成员函数，null_book应该是类类型的，发生了隐士转化
- 抑制构造函数定义的隐式转换，将构造函数声明成explicit，关键字只对一个实参的构造函数有效，需要多个实参的构造函数不能用于隐式转换，也就无需指定为explicit。
---
### 拷贝、赋值与销毁类
- 如果用等号初始化一个变量，执行的是拷贝初始化即将等号右侧的初始值拷贝到新创建的对象中去，不使用等号执行的是直接初始化。string s = "hiya";拷贝初始化，string s(10, 'c')；直接初始化。拷贝初始化相当于拷贝了一份有两份数据，直接初始化就一份数据。使用拷贝的含义就是对其中一份数据的改变不会影响另一份数据。例如容器的push和insert是拷贝初始化，相当于拷贝一份数据将其放进去，对容器中数据的操作不会影响到原始数据。emplace是直接初始化。
- 函数调用过程中，具有非引用类型的参数要进行拷贝初始化，返回类型不是引用时也是需要拷贝初始化的。因为引用就相当于一个，不需要拷贝。其他的不是一个所以需要拷贝。拷贝构造函数定义Foo(const Foo&);一般是const的
- 拷贝构造函数是在产生新对象的时候用的，拷贝赋值运算符是在已有对象的情况下赋值用的，两者的功能差不多都是对一个对象进行数据操作，区别就是在于是否有新对象的产生。Foo& operator=(const Foo&).
- 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。需要后两个不一定需要前两个。
- default和delete关键字，delete关键字就是阻止拷贝或是赋值操作。
### 运算符重载
- 一个二元运算符，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。
- 如果一个运算符函数是成员函数，this绑定到左侧运算对象，成员运算符函数的参数总是运算对象的参数少一个。
- 对于一个运算符函数来说，它或者是类的成员或者至少含有一个类类型的参数。不能两个都是内置的，operate+(int,int)这是错误的。
- 调用非成员运算符函数 date1 + date2, operate+(date1, date2),两个调用功能一样。调用成员函数运算符date1 += date2, date1.operate+=(date2),两者的重载运算符不一样前面是+后面是+=，this绑定了date1
- 通常情况下不应该重载逗号，取地址，逻辑与和逻辑或运算符。
- 算数运算符(+ - * /)应该返回一个类类型的值，赋值运算符(=)和复合赋值运算符应该返回左侧运算对象的一个引用。左侧运算对象绑定到了this，说明返回类的一个引用，因为左侧绑定了this，类更改了，所以返回左侧对象的引用用return \*this
- 运算符函数作为成员函数或普通的非成员函数选择依据:
   1. 赋值(=)下标([])调用(())和成员访问箭头(->)运算符必须是成员
   2. 复合赋值运算符一般来说应该是成员，但非必须
   3. 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增递减和解引用运算符一般是成员
   4. 具有对称性的运算符可能转换任意一端的运算对象，例如算数、相等性、关系和位运算符应该位普通的非成员函数。例如能求一个int和一个double的和，他们中的任意一个都可以是左侧运算对象或右侧运算对象，所以加法是对称的，所以定义成非成员函数。
- 当把运算符定义成成员函数时，他的左侧运算对象必须是运算符所属类的一个对象。如果string将+定义为成员函数string t = "hi" + s;这是错误的，因为左侧运算对象必须是string类的，如果+定义为非成员函数，上述语法是正确的。因为成员函数调用"hi".operate+(s),没有hi那个对象。非成员函数都能转换。



- 把算数运算符和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转化，因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。通常情况下应该使用复合赋值来实现算数运算符
`Sales_date operate+(const Sales_data &1hs,const Sales_data &rhs) {}`
- 相等运算符，bool operate==(const Sales_data &1hs, const Sales_data &rhs) {return && && },定义不相等时，bool operate!=(和上一个一样) {return !(1hs == rhs)};
---
### 面向对象程序设计
- 面向对象的程序设计的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象将类的接口与实现分离，使用继承可以定义相似的类型并对其相似关系建模，使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象。
- c++中当使用基类的引用调用一个虚函数时将发生动态绑定。
- 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作。
- override(覆盖)重新定义虚函数，任何构造函数之外非静态函数都可以是虚函数。在后面加入override是派生类显示地注明它使用某个成员函数覆盖了它继承的虚函数。final关键字禁止继承。
- 派生类能访问公有成员，而不能访问私有成员。当基类希望它的派生类有权访问该成员，同时禁止其他用户访问，我们用受保护的(protected)访问运算符说明这样的成员。
- 在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当成基类对象来使用。而且能将基类的指针或引用绑定到派生类对象中的基类部分上。Quote item; Bulk_quote bulk; Quote \*p = &item; p = &bulk;p指向bulk的Quote部分。
- 派生类不直接初始化从基类继承而来的成员，派生类必须使用基类的构造函数来初始化他的基类部分。Bulk_quote(const string &book, double p, size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc) {}先初始化基类的部分，然后初始化派生类的成员。
- 派生类可以访问基类的公有成员和受保护的成员。
- 将一个虚函数说明为纯虚函数(=0),纯虚函数就是这个虚函数在这个类中不用定义，其没有实际意义，这个纯虚函数可以是继承自基类的虚函数我们将其设置成纯虚函数，或者是基类中设置成纯虚函数。
- 含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类，抽象基类负责定义接口，而后续的类可以覆盖该接口，不能创建一个抽象基类的对象。
- 重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中，对于面向对象的应用程序来说，重构是一种普遍的现象。Quote的继承体系中增加Disc_quote是重构的一个典型实例。
- protected 1)受保护的成员对于类的用户来说是不可访问的 2)受保护的成员对于派生类的成员和友元来说是可访问的 3)派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问权限
```c++
class Base {
protected:
    int prot_mem; 
};
class Sneaky : public Base {
    friend void clobber(Sneaky&);
    friend void clobber(Base&);
    int j;
};
void clobber (Sneaky &s) {s.j = s.prot_mem = 0;}这是正确的，通过派生类对象可以更改Base中的受保护对象
void clobber (Base &b) {b.prot_mem = 0;}这是错误的,其不是Base的友元，不能改变Base对象中的protected对象
```
- 基类把它希望派生类能够使用的部分声明成受保护的，普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。
- 基类应该将其接口成员声明为公有的，同时将属于其实现的部分分成两组，一组可供派生类访问，另一组只能由基类及基类的友元访问，前者声明成受保护的，后者声明成私有的。
- 派生类访问说明符，意思就是说从基类继承的成员在派生类中的权限，只有公有的和受保护的会被继承下去，即可以访问，私有的是不会继承下去的，即不能访问。private说明从基类继承下来的在派生类中都是私有的，如果下面还有派生类，就不能访问这些了。
- 通过在类的内部使用using声明语句，可以将该类的直接或间接基类中的任何可访问成员标记出来。using Base::size,这样就可以改变某个成员的访问属性，其在哪就是什么访问属性。

---
# 函数
- 函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或函数的指针。
- 引用即为对象起了另外一个名字，引用必须被初始化。定义引用时，程序把引用和它的初始值绑定到了一起，而不是将初始值拷贝给引用，初始化完成，引用将和它的初始值对象绑定到一起。引用并不是对象，它只是为对象起了另外一个名字。
- 和其他变量一样，形参的类型决定了形参和实参交互的方式，如果形参是引用类型，它将绑定到对应的实参上，否则将实参的值拷贝后赋给形参。当形参是引用类型时，引用形参也是它绑定对象的别名，也就是说引用形参是它对应的实参的别名。
- 熟悉C的程序员常常使用指针类型的形参访问函数外部的对象，C++中最好使用引用类型的形参替代指针。当指针为形参是，实参传进去拷贝的是地址，可以根据地址改变其所指的内容。
- 拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型不支持拷贝(IO类型),当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如果函数无需改变形参的值，最好将其声明为常量引用。
- 可以通过引用形参返回额外信息，形参中加入一个引用形参，在函数体里面修改就能改变引用的值，不需要返回。
- 和其他初始化一样，当用实参初始化形参时会忽略掉顶层const，当形参是const时，传给它常量对象或者非常量对象都是可以的。
- 可以使用非常量初始化一个底层const，反过来不行。底层const即是指针或引用指向的值。
- void reset(int &i)，调用引用版本的reset只能使用int类型的对象，不能使用字面值、求值结果为int的表达式、需要转换的对象或者const int类型的对象。但是字面值可以初始化常量引用。
- 尽量使用常量引用
- 数组形参
   - 数组不能拷贝所以不能通过值传递的方式使用形参，使用数组时通常会将其转换成为指针，指向数组首元素。
   - 数组形参的三种定义方法 1)void print(const char #cp)，形参用一个数组指针，要求数组本身包含一个结束标记，c语言中的字符数组，但是int类型就无效了 2)使用标准库管理，传递指向数组首元素和尾后元素的指针，void print(const int \*beg, const int \*end)，调用时可以使用print(begin[j], end[j]),int[j] = {0, 1} 3)显示传递一个表示数组大小的形参 void print (const int ia[], size_t size)
- 与vector和string一样，数组的元素也能使用范围for语句或下标运算符访问，在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计为足够大以便能表示内存中任意对象的大小，在cstddef,遍历数组所有元素时最好使用范围for语句 for(auto i : scores) cout << i << " ";
- 可以定义sting类型的数组 string nums[] = {"one", "two", "three"};
- auto ia2(ia),ia是一个数组名，结果得到ia2是一个整形指针，指向ia的第一个元素，使用decltype上述转化不会发生。
- int arr[] = {0， 1}; int \*p = arr; ++p;这样指向arr[1]
- 标准库函数begin和end，c++引入了begin和end函数，使用时将数组作为他们的参数。int ia[] = {0, 1} int \*beg = begin(ia), int \*last = end(ia),begin和end返回的是指针。函数定义在iterator
- 传多维数组的方式，void print (int (\*matrix)[10], int rowSize) { };等价于void print (int matrix[][10], int rowSize) 编译器会忽略掉第一个维度。
   - 多维数组除了传统的两层for循环，也能使用两层范围for语句,注意每个范围for语句的参数，必须是引用类型，因为要改变元素的值，第一个for循环遍历ia的所有元素，这些元素是大小为4的数组，因此row的类型应该是含有4个整数的数组的引用，第二个for循环遍历那些4元素数组中的某一个，因此col的类型是整数的引用。
```c++
size_t = 0;
for (auto &row : ia)
    for (auto &col : row) {
    col = cnt;
    ++cnl;
}
```
   - 多维数组其实是数组的数组，使用多维数组的名字时，会自动将其转换为指向数组首元素的指针，首元素是包含整数的数组。int ia[3][4]; int (\*p)[4] = ia;表示p指向含有4个这个整数的数组，是一个地址，所以\*p表示4个整数数组的第一个元素，和一维数组定义一起去看，int \*p = ia，ia是指向数组的首元素的地址，ia是一个地址，p也是这个地址，只是表现出来了变量的形式，上面中的二维变量p表示指向的数组和ia类似，所以\*p表示指向第一个元素的地址。尽量使用auto或decltype避免指针类型的使用。也可以使用begin和end来写，for (auto p = begin(ia), p != end(ia); p++)  for (auto q = begin(\*p); q != end(\*p); q++)，如果arr是一维数组，int (\*p)[4] = &arr,因为定义p是指向一维数组的，arr代表一维数组的第一个元素地址，所以要用&，但是二维数组不用这样
```c++
for (auto p = ia; p != ia + 3; ++p) { //p指向含有4个整数的数组
    for (auto q = *p; q != *p + 4; ++q) //q指向4个整数数组的首元素，也就是说q指向一个整数
        cout << *q << " ";
    cout << endl;
}
```
- 不要返回局部对象的引用或指针。
- 调用一个返回引用的函数得到左值，其他返回类型得到右值。可以为返回类型是非常量引用的函数的结果赋值，如果返回类型是常量引用，则不能赋值。如返回指针，指针是一个地址，是右值只是一个值跟123一样，所以定义函数时int \*func();这样就行，使用时其返回的是一个地址没有名字，所以调用时要有左值即等号左边的变量来赋值。
- 返回指针数组的理解，数组不能拷贝，函数可以返回数组的指针或引用
   - int (\*parray) [10] = &arr,parray指向一个含有10个整数的数组，int (&arrref) [10] = arr,arrref引用一个含有10个整数的数组，直接用arr就行，没有=&arr，使用数组的引用时数组和引用名是等价的，即可以通过引用访问数组 arrref[1],引用名也是数组名也是地址。
   - 返回数组的指针，和数组名表示的指向数组首元素的地址是不一样的，数组的指针定义 int (\*parray) [10],所以在使用返回数组的指针时要这么使用 int (\*parray) [10] = func();
   - 声明一个返回数组指针的函数，type (\*function(parameter_list)) [demension], int (\*func(int i)) [10],后面的维度必须写
   - 使用尾置返回类型 auto func(int i) -> int (\*) [10],auto是必须写的
   - 使用decltype，如果知道函数返回的指针指向哪个数组，就可以使用decltype关键字声明返回类型。int odd[] = {},decltype(odd) \*arr(int i) ;返回的是指针
- 对于重载的函数来说，他们应该在形参数量或形参类型上有所不同，不能除了返回类型相同外其他都相同。
- 顶层const不影响传入函数的对象，一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。
- 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const是底层的。
- const_cast用于函数重载，可以在形参定义时定义底层const，但在函数体里面用const_cast去除const来进行运算，返回非const
- 函数重载和作用域，虽然在函数内不应该定义另一个函数，但是如果这么做，当使用函数内定义的这个函数和外面的函数发生了重载，只能使用这里面的函数，如果没有可以调用外面的。
- 默认形参，一个形参被赋予了默认值，其后所有的形参都要有默认值。当给默认形参赋值时，如果赋值后面的默认形参，前面的也得赋值，所以在使用时，将经常使用默认值的放在后面。局部变量不能作为默认形参。
- constexpr函数是指能用于常量表达式的函数，其函数的返回类型和所有形参的类型都是字面值类型，函数必须只有一条return语句。constexpr表示函数的返回值是一个常量表达式，可以给常量表达式赋值，const是否是常量需要确定一下，但是constexpr不用确定。具体用处就是如果一个常量表达式右侧调用函数的返回值必须也是常量的。
- 函数指针，定义指针指向函数时，只需要将函数名改为指针就行，bool (\*pf) (const string &, const string &);定义了pf是一个指针指向形参是如上所写返回值是bool的函数。
- 当把函数名作为右值使用时，该函数自动地转换成指针，pf = lengthcompare ，可以使用指针直接调用函数不用解引用指针。
- 函数指针形参，在函数中使用函数指针形参，可以直接向上面那样定义，也可以使用typedef，定义比较麻烦，网上看一下
- 
---
# 胡船长
- map是基于红黑树,unordered_map是基于哈希表,两者的差别在于红黑树是一种有序树，在对其遍历时按key值输出，而哈希表是没有序的，其输出是按输入来的
- 数据结构是定义一种性质并维护这种性质。
- 二叉排序树的中序遍历是有序的，节点的前驱就是左子树的最大值，后继就是右子树的最小值，所以前驱没有右子树，后继没有左子树。删除度为2的节点就是让其前驱或者后继代替要删除的节点，然后在删除重复的节点，删除度为2的节点转化为找到前驱节点，让前驱节点转化为被删除的节点，然后在删除那个前驱节点，前驱节点只有左子树，转化为删除度为1的节点。基本只度为1的节点也有前驱或者后继，就是中序遍历离它最近的，但是不一定在子树中
```c++
Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->lchild = rchild = NULL;
}
```
```c++
Node *insert(Node *root, int key) {
    if (root == NULL) return getNewNode(key);
    if (root->key == key) return root;
    if (key < root->key) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    return root;
}
```
- 指针说明一种连接关系，如果指针没有指向任何值即指针是NULL的，说明当前节点没有和其他节点相连，在二叉树节点中，最后一个节点的lchild=rchild=NULL，即其没有后续的连接关系。在insert中root == NULL说明找到了最后一个叶子节点，如果是从左侧找到了，说明root->lchild = NULL，此时申请一个节点，新节点的lchild=rchild=NULL，返回得到的新的节点，让节点相连，即让root->lchild = insert()值，return root，函数类型是指针，指针即地址，root是地址，\*root是指针指向的值。
---
## 平衡二叉查找树
- avl左旋，向左旋转调整新的跟节点的子树的位置，原来的右子树变成了新的根节点，原来如果有两个叶子节点，旧的根节点也变成左子树，所以需要调整位置，将右子树的节点调整一下。右子树的左子节点肯定大于原来的根节点小于右子树的结点，所以左旋后变成旧根节点的右子节点。最终右子树的深度减一，左子树的深度加一。右旋相反。
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/avl%E5%A4%B1%E8%A1%A1%E7%B1%BB%E5%9E%8B.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/avl%20ll.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/avllr.png)
![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/cpp/lr%E6%97%8B%E8%BD%AC.png)
- 上述h1，h2，h3，h4只是其子树的高度跟k没关系，要从k看还得加1，要记得从哪看失衡了，只要记得怎么旋转就行了，不用特别记公式。结构体中的h维护的是树的高度，即左子树和右子树中大的值加1就是当前节点的树高。从节点看失衡也是其左右子树的高度差。

## 红黑树
- 红黑树的五个条件
   1. 每个节点非黑即红
   2. 根节点是黑色
   3. 叶节点(NIL)是黑色
   4. 如果一个节点是红色，则它的两个子节点都是黑色的
   5. 从根节点出发到所有叶节点路径上，黑色节点数量相同，第四和第五共同决定了红黑树中最长路径是最短路径的两倍
- 调整策略
   1. 插入调整站在祖父节点看
   2. 删除节点站在父节点看
   3. 插入和删除情况一共五种
- 调整情况
   - 插入黑色节点一定会调整，因为黑色节点数量变化了，插入红色节点不一定会调整，如果插在红色节点下会调整，插在黑色节点下不调整，所以插入的节点是红色
   - 插入情况下原来每条路径能提供几个黑色节点，调整后也提供几个黑色节点
   - 节点下面没有红节点全是黑节点时加一个红节点不影响情况，不需要调整。
### 动态规划
- 递推的实现方式有两种一种是正向的递归加记忆化，一种是逆向的循环











- 析构函数的调用顺序是反着的，先析构最后生成的
- 只有一个参数的构造函数为转换构造函数，其用等号时自动转换
- 深拷贝和浅拷贝问题，相对于指针来说的，所以在拷贝构造函数中如果有指针就需要重新申请空间，在赋值进去，不重新申请空间的为浅拷贝。浅拷贝就是两个指针指向同一块区域
- 在定义时赋值用的是拷贝构造函数，例如Array a = b 和Array a(b)结果是一样的
- 类完成构造是指其进行到构造函数第一行，即Array()这一行，进行到这一行之后其类内定义的变量可以被访问，如果一个类里面有其他类的对象，但是那个类没有显示的指明用哪个构造函数，所以会报错，所以需要用列表初始化为每个对象指明构造函数，默认的或有参的，初始化列表A(int x, int y) : x(x), y(y) {}
- 初始化列表的构造顺序只和定义的顺序有关，跟它初始值列表写的顺序无关
- new和malloc的区别，如果定义的是类的数组，每一个区域都会调用构造函数初始化，A \*data = new A[n], A \*data = (A \*)malloc(sizeof(A) \* n),原地构造使用malloc和new一起完成
- 返回值优化，只调用一次有参构造，A a = func();没有调用拷贝构造，自动优化了，省去了中间变量
- 类的static，在类内声明类外定义，用类限定符直接调用。
- mutable关键字可以在const内部修改定义的数据，mutable int a;
- const方法里面只能调用const类型的方法，如果需要调用，可以使用构造函数定义const的
- 如果类的对象不允许拷贝，需要将拷贝构造函数和拷贝赋值构造函数放到private中或者删除
- 委托构造函数
- +=返回的是引用
- 内存泄露，找不到那块内存
- 仿函数(functor)，就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。
- 继承权限不影响子类对父类内容的访问，父类的东西子类会继承，sizeof查看大小是一样的，但是父类中private子类是不能访问的，子类对父类来说是类外的，如果私有继承自父类，拷贝构造函数是能用的
- 菱形继承问题
- 继承中的拷贝构造和赋值构造问题，子类中的拷贝构造函数设计时要显示指出父类的拷贝构造函数 Cat(const cat& a) : Animal(a) { };要不然不能完成正确的拷贝，父类空间中那一块没拷贝，两个类有子类空间，也有父类空间，子类调用子类的拷贝构造函数，父类调用父类的拷贝构造函数，所以要显示指出父类的拷贝构造函数，赋值运算符一样需要指定，赋值比拷贝不好写，Cat& operate=(const Cat&c) { this->Animal::operate=(c)}
- 父类不能拷贝，子类肯定不能拷贝，子类继承自父类，拷贝构造被删除，默认构造需要显示指出来 = default
- 普通成员方法是跟着类走的，主要看前面定义用的谁就跟谁走，继承的时候，虚函数是跟着对象走的，即指向谁引用谁就是谁，普通成员方法在编译期确定，虚函数在运行期确定。
- virtual, override，final,final标记之后子类不能重载
- 普通指针不能存储成员方法地址
- dynamic_cast 将基类中的地址转换成派生类的地址，失败返回空地址，必须要有虚函数，其要寻找虚函数表来判断，dynamic_cast 被用来执行从基类指针到派生类指针的安全转换，它常常被称为安全的向下转换 downcasting。 当我们必须使用派生类的特性，而该特性又没有出现在基类中时我们常常使用 dynamic_cast，返回的是一个地址， 用指向基类类型的指针来操纵派生类类型的对象，通常通过虚拟函数自动处理 。但是在某些情形下，使用虚拟函数是不可能的 。
- 虚函数表问题
- 将析构函数设置为虚函数，可以解决析构问题。
- 纯虚函数，一般用来设置接口
- typeid用来查看变量类型typeid(a).name
- constexpr是编译器常量，const是运行期常量
- NULL是0和一个空地址，尽量使用nullptr
- 左值和右值，到了下一行是否能通过单一变量访问到，能访问到是左值否则是右值，字面量是右值，一般临时变量是右值，不能访问临时变量，i++是左值，++i是右值，+返回的是右值A，+=返回的是左值。A &，   int &是左值引用，int &&是右值引用，move(x)函数将变量变为右值，forward<int &&>(x)也是右值，
- 移动构造函数，类似拷贝构造函数，只是是右值引用，不用拷贝了，只需要移动赋值
- const的左值引用可以绑定任何值，其余的只能左绑左，右绑右，相当于万能传参

---

- c++基本内置类型:bool，整形，浮点型，字符型。
- 初始化的形式 int sold = 0; int sold = {0}; int sold(0); int sold{0};这四种方式都是初始化，花括号括起来的是列表初始化。
- 在类中定义了一个int变量，默认构造函数会置为0。
- 封装是编译期的概念，是针对类型而非对象的，在类的成员函数中可以访问同类型实例对象的私有成员变量。例子为在类中定义了私有属性int a，实例化了一个对象之后 A a，不能通过实例化对象访问私有的属性a，但是可以设置函数接口来访问，不能直接访问。类里面的拷贝构造函数是成员函数可以访问同类型实例对象的私有成员变量。
- 访问限制标号是针对类而不是针对一个类的不同对象，只要同属一个类就可以不用区分同一个类的不同对象。因为 是类的成员函数，所以有权限访问私有数据成员。如果是在main函数中直接，那肯定就会报错了，不能访问，因为这是在类外不能访问私有数据成员。一个类的成员函数可以访问这个类的私有数据成员，我们要理解这个对类的访问限制，而不是针对对象。在类外是不能访问的，在类内是能访问的。在拷贝构造函数中，拷贝构造函数是类内对象，其参数也是同一个类，要考虑的是类层面上的东西，不是对象层面上的东西，属于同一个类，而且拷贝构造函数在类内，所以就可以访问私有成员属性，不管是谁的。
- 类的非成员函数中参数使用的是类类型的对象，其不能访问类的私有属性，但是可以设置友元函数，
- 在类外访问类里面的东西都是通过类实例对象访问的。
- 委托构造函数，在同一个类中定义了构造函数好几个，可以在一个构造函数初始化一个属性，另外的交给其他的构造函数。
- 父类指针可以指向子类，但是子类指针不能指向父类。如果用子类指针指向父类的话，一旦访问子类特有的方法函数或者成员变量，就会出现非法，因为被子类指针指向的由父类创建的对象，根本没有要访问的那些内容，那些是子类特有的，只有用子类初始化对象时才会有。
- 继承就是继承，在子类中继承了父类的方法和属性，不用访问父类的东西，相当于父类的东西拷贝了一份到子类，直接使用就行了。
- 多态就是用基类的指针和引用指向子类的对象。多态是动态绑定，定义基类，在基类中定义接口，不知道要运行什么函数，进行动态绑定之后就知道了，应用场景，同一个函数有不同的表现形式通过虚函数实现，但是现在不知道需要哪个，有时函数有先后调用顺序。通俗理解就是基类定义接口，然后你来哪个我给你接哪个，你只要符合我的规范。定义一个指向基类对象的指针，然后使该指针指向由该基类派生的子类对象，再然后用这个指针来调用该虚函数，就能实现动态多态。动态绑定书上，定义一个类外函数，其参数为基类的引用，如果基类实现了虚函数多态，传进去的实参可以是基类的也可以是子类的，实现了动态绑定。
- 基类和派生类之间的类型转换:可以将基类的指针或引用绑定到派生类对象上:其含义为当使用基类的引用或指针时，我们并不清楚该引用或指针所绑定对象的真是类型，该对象可能是基类的对象也可能是派生类的对象。如果不是指针或引用时不能这么干
- 友元不能传递也不能继承
- 继承主要实现代码的复用，将相同的放到父类中，子类继承了父类的方法和属性。派生类向基类的转换就是多态，派生类向基类的转换受到派生类的访问说明控制符的影响。

## 类和类之间的关系

- 继承
- 实现，通过虚函数实现，多态
- 依赖，一个类A使用到了另一个类B，但是这种使用关系是偶然的，临时的。语法:类B作为类A的方法的参数或者局部变量。
- 关联，比依赖关系强，必然的长期的强烈的。语法:类B作为成员变量存在于类A中。
- 聚合
- 组合

---

## 模板

- template<typename T>，模板函数模板类，模板需要写在头文件中
- decltype()查看类型，其返回值是一个类型decltype(1+2) x，这是x是int类型
- 返回值后置，auto add(T a, U b) -> decltype(a + b)，现在能看见变量a和b
- 模板类在使用时需要显示指出模板的类型PRINT<int> print,在定义时使用
- 模板类的template声明可以放在类里面成为一个类的方法，就不需要使用尖括号来声明了
- 模板需要在头文件中
- 模板vector的实现

```c++
template<typename T>
class vector {
public:
    vector(int n = 10) : __size(n), data(nullptr) {//此处不用new申请空间，因为如果存的是自定义类型，其没有默认构造函数会报错，因为会调用构造函数
        data = (T *)malloc(sizeof(T) * __size);
        return;
}
    vector(const vector<T> &v) {
        __size = v.size;
        data = (T *)malloc(sizeof(T) * __size);
        for (int i = 0; i < __size; i++) {
            new(data + i) T(v.data[i]);//此处使用的是原地构造，因为要存放自定义结构，不能使用赋值
    }
        return;
}
    vector(vector<T> &&v) : __size(v.size), data(v.data) {
        v.data = nullptr;
        v.size = 0;
}
    T &operate[](int ind) {
        return data[ind];
}
    ~vector() {
        if(data) free(data);
        __size = 0;
        return;
}
private:
    int __size;
    T *data;

};push_back的实现将数组放到空间中
```

- 引用折叠，引用模板推导到实例化类型时会发生将T推导为T&类型的，此时定义T c就变成了int& c
- void swap(T &&a, T&&b),一个&表示为左值引用，两个&&表示为引用，可以是左值的也可以是右值的 
- forward也可以叫万能转发，保留类型又可以转发
- remove_reference<T>::type c, 将T的引用属性去掉
- 模板偏特化和模板特化，就是用来处理特殊的情况的，例如处理指针
- 变参模板，递归展开模板参数，终止递归展开必须要写，就是一个参数的时候，相当于写两个模板







- 拷贝初始化和直接初始化，如果使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号则执行的是直接初始化。直接初始化实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数,直接初始化使用普通的构造函数。拷贝初始化实际上是要求编译器将右侧运算对象拷贝到正在创建的对象中，通常用拷贝构造函数来完成。拷贝初始化不仅在用=定义变量时发生，下列情况也发生
  - 将一个对象作为实参传递给非引用类型的形参时
  - 从一个返回类型为非引用类型的函数返回一个对象
  - 当初始化标准库容器或是调用其insert或push成员时(与之相对，用emplace成员创建的元素都进行直接初始化)
- 拷贝构造函数的形参必须是引用类型的原因:如果不是引用类型，为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环，造成错误。
- 当拷贝构造函数前面加了一个explicit关键字时，调用拷贝构造函数不能进行隐式类型转换，但可以进行显示类型转换，如:vector\<int> v1(10); //正确：直接初始化,vector\<int> v2 = 10;//错误：接受大小参数的构造函数是explicit的,void f(vector\<int>);//f的参数进行拷贝初始化,f(10);//错误：不能用一个explicit的构造函数拷贝一个实参,f(vector\<int>(10));//正确：可以进行显示类型转换（f的参数必须接收一个对象）
- 当构建一个对象不需要设置变量时不需要设置变量名，如vector\<int>(10),直接创建了一个变量，例如string nines = string(100, '9')，没有变量名但是初始化方式是一样的。
- 类在定义的时候就初始化使用的拷贝构造函数，如果有等号。如果先定义在后面赋值，用的是赋值构造函数。
- explicit构造函数只能用于直接初始化，不能用于拷贝初始化，explicit抑制构造函数定义的隐式类型转换，要使用构造函数必须显示指出来类型，不能用隐式转换
- 容器初始化时，C c1(c2)和C c1 = c2是一样的，都是c1初始化为c2的拷贝，在括号里是直接初始化，在等号右侧是拷贝初始化。string s('value') string s = 'value',一个直接初始化一个拷贝初始化两者是一样的，其汇编也是一样的，但是对于vector，其定义往上看，在v2定义时其接受大小参数的构造函数是explicit的，所以不能拷贝初始化，必须直接初始化。
- 直接初始化调用的是与实参匹配的构造函数，一般构造函数会有许多，例如string s('value'),这个调用的构造函数是String(const char\*),拷贝初始化调用的是拷贝构造函数，其必须经过拷贝构造函数，string s = 'value',这样定义为什么也可以呢，拷贝构造函数用的实参必须是同一类型的，所以value必须是string类型的，此时发生了隐形的类类型转换，其首先调用string的构造函数，转换成string对象，然后用这个对象拷贝初始化，相当于调用了两个构造函数。这是一种情况。拷贝初始化创建时要经过一个相同类型的过程，例如上述会创建一个临时对象，但是如果等号右侧是相同的类型时，就会直接省去创建临时对象的过程，直接使用拷贝初始化。上述容器初始化中，两个一个是拷贝初始化一个是直接初始化，拷贝初始化中用的=会显示调用拷贝构造函数，直接初始化是根据括号里的类型选择构造函数，其类型相同，直接匹配的构造函数形参是相同类型的就是拷贝构造函数，直接使用那个。
- 拷贝复制初始化在赋值是才用，上述是拷贝初始化
- 初始化数据成员与对数据成员赋值的含义和区别:
  - 内置数据类型，复合类型（指针，引用）- 在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的
  - 用户定义类型（类类型）- 结果上相同，但是性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）
- 初始化列表的好处，使用初始化列表的构造函数显示的初始化类的成员，而没有初始化列表的的构造函数是对类的成员赋值，因为其先定义了，并不是显示的初始化。初始化和赋值对内置的成员类型没什么影响，但对非内置的类型，避免了两次构造函数。
- 必须使用初始化列表构造函数
  - const 成员或引用类型的成员。因为 const 对象或引用类型只能初始化，不能对他们赋值。
  - 成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。初始化列表构造函数直接使用拷贝构造函数。
- 列表初始化是 C++ 11 新引进的初始化方式，它采用一对花括号（即{}）进行初始化操作。能用直接初始化和拷贝初始化的地方都能用列表初始化，而且列表初始化能对容器进行方便的初始化，因此在新的C++标准中，推荐使用列表初始化的方式进行初始化。
  - 使用拷贝初始化即使用=时，只能提供一个初始值
  - 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化
  - 如果提供的是初始元素的列表则只能把初始值都放在花括号里面进行初始化，不能放在圆括号里
- 上述的理解:
  - 拷贝初始化只能提供一个初始值，因为拷贝构造函数的参数只有一个。
  - 如果是类内初始值，只能使用拷贝初始化或列表初始化，即private: int a = 0; int a{0},这是针对类内初始值方式说的，只是定义数据时给一个初值。只能这两种方式。其中int a = {0},这种定义方式也行。
  - 初始元素列表是可变的参数，需要放在花括号里进行初始化，例如vector初始化时，vector\<int> a{1，2}，使用等号也一样，不使用等号是直接初始化，直接调用构造函数，使用等号相当于转换成vector在调用拷贝构造函数。初始元素的列表最常见的应用是数组。int a[] = {1, 2};vector里面也有很多元素，要给初值只能这样，不能使用圆括号，圆括号使用的是调用构造函数。
- 列表初始化和初始化列表构造函数不同，前者是初始化对象，后者是创建对象。c++11用花括号来初始化变量得到了全面应用。无论是初始化对象还是某些时候为对象赋新值，都可以使用。例如 int a = 0; int a = {0}; int a{0}; int a(0);这四种方式都可以初始化，两种数据类型必须一致，不能进行隐式的类型转换。特殊情况下的使用看上面，为什么vector\<int> a = {1, 2, 3}这种可以用，括号里不是一样的类型，因为vector对象有一个可变形参的构造函数，右侧这个进行了类的隐式转化，因为可变形参这个可以直接转换为vector对象，所以前面不用显示的写上 vector\<int> a = vector\<int>{1, 2, 3},对于上面四种定义情况，分别对应 vector\<int> a = b,vector\<int> a{b},其中里面的b可以是vector对象也可以是不确定的列表，都可以进行转换，vector\<int> a(b),会调用构造函数进行初始化。圆括号是直接初始化不能单独放在等号右边。
- 使用列表初始化会尽可能的使用列表初始化构造函数去创建对象，如果使用的是圆括号就会去匹配构造函数。对于大类包含小类其初始化列表构造函数包含的形参是确定的，可以用圆括号或中括号去初始化，但是对于vector这种不确定的情况下只能使用中括号，圆括号就是调用相匹配的构造函数。
- 对于容器来说使用{}来初始化是因为其中元素是不确定的，对于自己定义的类来说，如果其中的数据是确定的就可以两种方式都用{}(),如果是不确定的就得用{},对于c1(c2)这种就是调用构造函数，和前面说的{}()是一样的，都是调用构造函数来构造对象，只是方式不一样
- 如果用的是花括号，可以表述成我们想列表初始化该vector对象，也就是说初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其它初始化方式。
  - vector\<string> v5{'hi'};列表初始化，v5有一个元素
  - vector\<string> v6('hi');错误，不能使用字符串字面值构建vector对象
  - vector\<string> v7{10};v7有10个默认初始化的元素
  - vector\<string> v8{10, 'hi'};v8有10个值为"hi"的元素
- 在上面的例子中用了花括号，但是只有v5是列表初始化，要想列表初始化vector对象，花括号里的值必须与元素类型相同，显然不能用int初始化string对象，所以v7和v8提供的值不能作为元素的初始值，故无法执行列表初始化，编译器会尝试用默认初始值初始化vector对象。
- 拷贝初始化只能有一个初始值，string s = 'value',只能有一个初始值，但是有多个初始值，string s = string(10, 'c'),必须这样，右侧相当于一个初始值，虽然有10个c。vector\<int> a = 10;这是错误的，因为构造函数是explicit的，不能隐式转化，即不能看见右侧是10，一个整形和int一样，构造函数有接受一个整形的形参就能隐式转换为vector对象，因为explicit限制了，所以这样是错误的，如果没有限制，这样是正确的。

## 类型转换

- 隐式类型转换发生
  - 在大多数表达式中，比int类型小的整形值首先提升为较大的整数类型
  - 在条件中，非布尔型转换成布尔类型。
  - 初始化过程中，初始值转换成变量的类型;在赋值语句中，右侧运算对象转换成左侧运算对象的类型
  - 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
  - 函数调用时也会发生类型转换
- 当赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。int和unsigned运算时，int要转换为unsigned，负数给unsigned赋值时，相当于无符号数表示的范围和负数相加的结果。
  - for (unsigned u = 10; u >= 0; u--) cout << i << endl; 这个循环会一直成立，u为0是循环成立，u--时为-1，此时不满足unsigned，所以要转换为unsigned，所以要进行转换，此时结果错误。
  - 上面的处理方法是写while循环，在里面先--在循环。
- 类类型转换，接受一个形参的构造函数函数可以进行转换，explicit可以抑制这种转换。



