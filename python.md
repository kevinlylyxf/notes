#### python理解

- cpu执行的都是机器码，所以无论是编译型语言还是解释型语言最后都要编译为机器码来运行，不同的操作系统可执行文件的格式不同，例如linux下支持的是ELF格式，windows下使用的是PE格式，编译型语言例如c，要经历预处理、编译、汇编、链接四个过程，最后生成可执行文件，这个可执行文件操作系统是可以直接执行的，不用借助其他的中间件。可执行文件里面都是机器码。可执行文件放在虚拟内存里面，按照分页管理，用到哪部分机器码，就由操作系统按照内存映射将哪部分机器码放到物理内存中。每一个进程按照虚拟内存来说都有独立的内存区域，所以不用担心内存的问题。编译型语言例如python，其没有c语言的四个过程，但是如果想要运行就必须要有机器码，所以python在不同的平台上都实现了解释器，这个解释器是一个可执行程序，在linux下就是ELF文件，在windows下就是PE文件，在运行python程序的时候，由这个python解释器来将源代码编译为机器码来运行，这个过程不是说编译全部的，程序运行时需要哪部分代码就编译哪部分代码为机器码，将机器码放到内存中，这样就能直接运行。至于这个编译是如何控制的，也就是如何确定需要哪部分代码这是python解释器要实现的，使用者不需要管。所以python源文件是不能直接由操作系统执行的，必须借助python解释器。这也是python运行比较慢的原因

- python源码能跨平台运行，其中的差异都由不同平台上的python编译器隐藏了。例如不同的平台对于文件的管理是不同的，对于文件的底层实现是不同的。如果python源码中打开一个文件open(file)这个操作，不同的平台对于打开文件底层都是不同的，机器码也是不同的，但是这个机器码在相同的平台下是固定的，例如打开文件在linux下的机器码是固定的，这样python解释器就能将打开文件这个操作转换为机器码，然后将这个机器码放到内存中(内存中有代码段和数据段)，不同的解释器就是用来隐藏这个差异的，对我们用户来说打开文件都是一样的操作，其实底层都用解释器来隐藏了。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态。比如打开文件读写文件都在内核态，如果要用这些服务时，就会转到内存中的内核态里面去执行。python解释器应该也会实现这些转换，用户态到内核态，因为本身python解释器就是解释代码变成机器码来运行。操作系统只提供最基本的服务，具体的算法实现一般还是在用户态自己实现。

- python需要系统服务的一些会转到内核态，但是一些用户态的还是python本身自己就能实现，不用调用c和c++的库，例如数据计算时，数据计算主要是内存中的计算，定义变量时申请内存，计算时用机器码操作计算。这些python解释器就能转换为机器码来实现，不用先转换为c或者c++的库然后在转换为机器码，python解释器自己就能转换为机器码。所以一些numpy、pandas这些计算模块不用调用c或者c++的代码，用python的语法就能实现，剩下的交给python解释器就行。所以用pip下载的这些模块里面都没有动态库，只有py文件

- cpu指令是固定的，例如加减乘除移动访问，这些机器码对于cpu都是固定的，所有的语言最后都要生成cpu能执行的的这些固定的机器码。内存中有代码段和数据段。其实变量的定义和计算就是申请一个内存，然后计算，这个比较好说。如果涉及到操作系统提供的函数，就会涉及到一些底层的实现，这样生成的机器码比较复杂，放到内存中的也比较复杂，我们用户不用管这些，python解释器帮我们干了这些事情。其实操作系统提供的主要是一些文件操作以及网络服务之类的。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- 不同的编程语言对于操作系统提供的这些服务按照语法来说是不同的，但是最后生成的机器码都是一样的。不同的编程语言在一些功能上实现的方式不同，对于用户来说就是实现的简单与否。但是最后殊途同归，生成的机器码都是一样的。所以会有算法这种东西产生，不同的算法对于一个功能的实现可能是质的飞跃(不同的算法计算方式不一样)，这样生成的机器码就不会很啰嗦，生成的机器码就会很少，这样运算速度就会很快。所以算法对于运算的提升很大。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- python官网上的模块例如numpy，pandas官网上的都是.whl文件，whl文件本质上就是一个压缩文件，安装whl文件很简单，先手动下载文件然后手动安装时使用pip install xxx.whl，pip命令直接安装(不用先手动下载whl文件)也是命令自己下载whl文件，然后在解压安装，原理都是一样的。

- 查看可执行程序，windows下是where python， linux和mac下是which python

- pip安装包的路径查询，在pip install首次安装完成的时候会显示安装位置，如果已经安装使用pip install就会显示安装位置，windows下pip安装的模块一般都放在C:\Users\lylyx\AppData\Local\Programs\Python\Python39\Lib\site-packages里面

- mac下使用homebrew安装软件时使用brew info可以看到软件的依赖以及各种信息，如果直接安装例如brew install python3，里面的idle运行时就会提示Tkinter缺失(Tkinter模块("Tk 接口")是Python的标准Tk GUI工具包的接口。 作为 python 特定的GUI界面，是一个图像的窗口，tkinter是python 自带的，可以编辑的GUI界面)，这样就会出错。但是我们可以使用brew info python3，就是显示各种信息，包括依赖的tkinter问题，这样我们就能根据提示安装thinter，idle就能正常使用了

- pyc文件是py文件编译后生成的字节码文件(byte code)。pyc文件经过python解释器最终会生成机器码运行。为什么要手动提前生成pyc文件呢，主要是不想把源代码暴露出来。生成的pyc文件会放到当前目录下新创建的\__pycache__中

  ```
  命令生成pyc文件
  python -m foo.py
  代码来生成pyc文件
  import py_compile
  py_compile.compile('/path/to/foo.py')
  
  批量生成，针对一个目录下所有的py文件进行编译。python提供了一个模块叫compileall
  import compileall
  compileall.compile_dir(r'/path')
  ```

  - 生成的pyc文件使用python xxx.pyc来运行

#### 变量类型和运算符

- 变量在 Python 内部是有类型的，比如 int、float 等，但是我们在编程时无需关注变量类型，所有的变量都无需提前声明，赋值后就能使用。另外，可以将不同类型的数据赋值给同一个变量，所以变量的类型是可以改变的。

- Python 支持自增和自减运算符，但是它只支持一种形式，就是前自增和前自减，而取消了后自增和后自减，避免了给程序员造成混乱

- 变量（Variable）可以看成一个小箱子，专门用来“盛装”程序中的数据。每个变量都拥有独一无二的名字，通过变量的名字就能找到变量中的数据。

- 从底层看，程序中的数据最终都要放到内存（内存条）中，变量其实就是这块内存的名字。

- 和变量相对应的是常量（Constant），它们都是用来“盛装”数据的小箱子，不同的是：变量保存的数据可以被多次修改，而常量一旦保存某个数据之后就不能修改了。

- id() 内置函数，该函数的功能是获取变量（对象）所在的内存地址

- 在强类型的编程语言中，定义变量时要指明变量的类型，而且赋值的数据也必须是相同类型的，C语言、C++、[Java](http://c.biancheng.net/java/) 是强类型语言的代表。

- 和强类型语言相对应的是弱类型语言，Python、[JavaScript](http://c.biancheng.net/js/)、[PHP](http://c.biancheng.net/php/) 等脚本语言一般都是弱类型的。弱类型语言有两个特点：

  - 变量无须声明就可以直接赋值，对一个不存在的变量赋值就相当于定义了一个新变量。
  - 变量的数据类型可以随时改变，比如，同一个变量可以一会儿被赋值为整数，一会儿被赋值为字符串。

- 弱类型并不等于没有类型！弱类型是说在书写代码时不用刻意关注类型，但是在编程语言的内部仍然是有类型的。我们可以使用 type() 内置函数类检测某个变量或者表达式的类型，其类型的

  ```python
  >>>num = 10
  >>> type(num)
  <class 'int'>
  >>> num = 15.8
  >>> type(num)
  <class 'float'>
  >>> num = 20 + 15j
  >>> type(num)
  <class 'complex'>
  >>> type(3*15.6)
  <class 'float'>
  ```

- 弱类型语言的变量在内存中存储，每一种占据的字节数都是固定的，例如int占用四个字节，float占用8个字节一个。但是我们可以不用管，因为有python解释器，解释器就帮我们干了这个事，所以我们不用考虑变量的类型。

##### 整数

- Python 整数不分类型，或者说它只有一种类型的整数。Python 整数的取值范围是无限的，不管多大或者多小的数字，Python 都能轻松处理。当所用数值超过计算机自身的计算能力时，Python 会自动转用高精度计算（大数计算）。不管对于多大或者多小的整数，Python 只用一种类型存储，就是 int。无论对于多大的整数，type()的结果都为int

- 在 Python 中，可以使用多种进制来表示整数：

  1) 十进制形式

  我们平时常见的整数就是十进制形式，它由 0~9 共十个数字排列组合而成。

  注意，使用十进制形式的整数不能以 0 作为开头，除非这个数值本身就是 0。

  2) 二进制形式

  由 0 和 1 两个数字组成，书写时以`0b`或`0B`开头。例如，101 对应十进制数是 5。

  3) 八进制形式

  八进制整数由 0~7 共八个数字组成，以`0o`或`0O`开头。注意，第一个符号是数字 0，第二个符号是大写或小写的字母 O。

  在 Python 2.x 中，八进制数字还可以直接以`0`（数字零）开头。

  4) 十六进制形式

  由 0~9 十个数字以及 A~F（或 a~f）六个字母组成，书写时以`0x`或`0X`开头

- 为了提高数字的的可读性，Python 3.x 允许使用下划线`_`作为数字（包括整数和小数）的分隔符。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。下划线不会影响数字本身的值。

  ```python
  click = 1_301_547
  distance = 384_000_000
  print("Python教程阅读量：", click)
  print("地球和月球的距离：", distance)
  
  Python教程阅读量：1301547
  地球和月球的距离：384000000
  ```

##### 浮点数

- [Python](http://c.biancheng.net/python/) 中的小数有两种书写形式：

  1) 十进制形式

  这种就是我们平时看到的小数形式，例如 34.6、346.0、0.346。

  书写小数时必须包含一个小数点，否则会被 Python 当作整数处理。

  2) 指数形式

  Python 小数的指数形式的写法为：aEn 或 aen

  a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；`E`或`e`是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 a×10n。

- 只要写成指数形式就是小数，即使它的最终值看起来像一个整数。例如 14E3 等价于 14000，但 14E3 是一个小数。

- Python 只有一种小数类型，就是 float。C语言有两种小数类型，分别是 float 和 double：float 能容纳的小数范围比较小，double 能容纳的小数范围比较大。

- Python 能容纳极小和极大的浮点数。print 在输出浮点数时，会根据浮点数的长度和大小适当的舍去一部分数字，或者采用科学计数法。

  ```python
  f5 = 12e4
  print("f5Value: ", f5)
  print("f5Type: ", type(f5))
  f6 = 12.3 * 0.1
  print("f6Value: ", f6)
  print("f6Type: ", type(f6))
  
  f5Value:  120000.0
  f5Type:  <class 'float'>
  f6Value:  1.2300000000000002
  f6Type:  <class 'float'>
  ```

  - f5 的值是 120000，但是它依然是小数类型，而不是整数类型。

  - f6中`12.3*0.1`的计算结果很明显是 1.23，但是 print 的输出却不精确。这是因为小数在内存中是以二进制形式存储的，小数点后面的部分在转换成二进制时很有可能是一串无限循环的数字，无论如何都不能精确表示，所以小数的计算结果一般都是不精确的

  - 为什么在计算这么简单的问题上，计算机会出现这样的低级错误呢？真正的原因在于十进制和数和二进制数的转换。计算机其实是不认识十进制数，它只认识二进制数，也就是说，当我们以十进制数进行运算的时候，计算机需要将各个十进制数转换成二进制数，然后进行二进制间的计算。以类似 0.1 这样的浮点数为例，如果手动将其转换成二进制，其结果为：

    ```
    0.1(10)=0.00011001100110011...(2)
    ```

    - 可以看到，结果是无限循环的，也就是说，0.1 转换成二进制数后，无法精确到等于十进制数的 0.1。同时，由于计算机存储的位数是有限制的，所以如果要存储的二进制位数超过了计算机存储位数的最大值，其后续位数会被舍弃（舍弃的原则是“0 舍 1 入”）。	

- 如果需要非常精确的结果，可以使用 decimal 模块（其实就是别人开发好的程序，我们可以直接拿来用），它实现的十进制数运算适合会计方面的应用和有高精度要求的应用

  ```python
  #使用模块前，需要使用 import 引入
  import decimal
  a = decimal.Decimal("10.0")
  b = decimal.Decimal("3")
  print(10.0/3)
  print(a/b)
  
  3.3333333333333335
  3.333333333333333333333333333
  ```

- 如果 decimal 模块还是无法满足需求，还可以使用 fractions 模块

  ```python
  #引入 decimal 模块
  from fractions import Fraction
  print(10/3)
  print(Fraction(10,3))
  
  3.3333333333333335
  10/3
  ```

  

##### 复数

- 复数（Complex）是 [Python](http://c.biancheng.net/python/) 的内置类型，直接书写即可。换句话说，Python 语言本身就支持复数，而不依赖于标准库或者第三方库。
- 复数由实部（real）和虚部（imag）构成，在 Python 中，复数的虚部以`j`或者`J`作为后缀，具体格式为：a + bj，a 表示实部，b 表示虚部。

```python
c1 = 12 + 0.2j
print("c1Value: ", c1)
print("c1Type", type(c1))
c2 = 6 - 1.2j
print("c2Value: ", c2)
#对复数进行简单计算
print("c1+c2: ", c1+c2)
print("c1*c2: ", c1*c2)

c1Value:  (12+0.2j)
c1Type <class 'complex'>
c2Value:  (6-1.2j)
c1+c2:  (18-1j)
c1*c2:  (72.24-13.2j)
```

- 复数在 Python 内部的类型是 complex，Python 默认支持对复数的简单计算。

##### 字符串

- Python中的字符串必须由双引号`" "`或者单引号`' '`包围

- Python 字符串中的双引号和单引号没有任何区别。而有些编程语言的双引号字符串可以解析变量，单引号字符串一律原样输出，例如 [PHP](http://c.biancheng.net/php/) 和 [JavaScript](http://c.biancheng.net/js/)。

- 字符串中对引号的处理有两种方案

  - 对引号进行转义，在引号前面添加反斜杠`\`就可以对引号进行转义，让 Python 把它作为普通文本对待
  - 使用不同的引号包围字符串。如果字符串内容中出现了单引号，那么我们可以使用双引号包围字符串，反之亦然

- 字符串的换行。Python 不是格式自由的语言，它对程序的换行、缩进都有严格的语法要求。要想换行书写一个比较长的字符串，必须在行尾添加反斜杠`\`

  ```
  s2 = 'It took me six months to write this Python tutorial. \
      Please give me more support. \
      I will keep it updated.'
  ```

  - 上面 s2 字符串的比较长，所以使用了转义字符`\`对字符串内容进行了换行，这样就可以把一个长字符串写成多行。

  - Python 也支持表达式的换行

    ```
    num = 20 + 3 / 4 + \    2 * 3print(num)
    ```

- 长字符串。使用三个单引号或者双引号可以对多行内容进行注释，这其实是 Python 长字符串的写法。所谓长字符串，就是可以直接换行（不用加反斜杠`\`）书写的字符串。Python 长字符串由三个双引号`"""`或者三个单引号`'''`包围。在长字符串中放置单引号或者双引号不会导致解析错误。如果长字符串没有赋值给任何变量，那么这个长字符串就不会起到任何作用，和一段普通的文本无异，相当于被注释掉了。此时 Python 解释器并不会忽略长字符串，也会按照语法解析，只是长字符串起不到实际作用而已。当程序中有大段文本内容需要定义成字符串时，优先推荐使用长字符串形式，因为这种形式非常强大，可以在字符串中放置任何内容，包括单引号和双引号。长字符串中的换行、空格、缩进等空白符都会原样输出

  ```python
  longstr = '''    It took me 6 months to write this Python tutorial.    Please give me a to 'thumb' to keep it updated.    The Python tutorial is available at http://c.biancheng.net/python/.'''print(longstr)    It took me 6 months to write this Python tutorial.    Please give me a to 'thumb' to keep it updated.    The Python tutorial is available at http://c.biancheng.net/python/.  字符串内容前后多出了两个空行，并且每一行的前面会多出四个空格。
  ```

- 原始字符串。Python 字符串中的反斜杠`\`有着特殊的作用，就是转义字符。转义字符有时候会带来一些麻烦，例如我要表示一个包含 Windows 路径`D:\Program Files\Python 3.8\python.exe`这样的字符串，在 Python 程序中直接这样写肯定是不行的，不管是普通字符串还是长字符串。因为`\`的特殊性，我们需要对字符串中的每个`\`都进行转义，也就是写成`D:\\Program Files\\Python 3.8\\python.exe\`这种形式才行。这种写法需要特别谨慎，稍有疏忽就会出错。为了解决转义字符的问题，Python 支持原始字符串。在原始字符串中，`\`不会被当作转义字符，所有的内容都保持“原汁原味”的样子。

  - 在普通字符串或者长字符串的开头加上`r`前缀，就变成了原始字符串

    ```
    str1 = r'原始字符串内容'str2 = r"""原始字符串内容"""rstr = r'D:\Program Files\Python 3.8\python.exe'print(rstr)
    ```

  - 如果普通格式的原始字符串中出现引号，程序同样需要对引号进行转义，否则 Python 照样无法对字符串的引号精确配对；但是和普通字符串不同的是，此时用于转义的反斜杠会变成字符串内容的一部分。

    ```
    str1 = r'I\'m a great coder!'print(str1)I\'m a great coder!
    ```

    - 需要注意的是，Python 原始字符串中的反斜杠仍然会对引号进行转义，因此原始字符串的结尾处不能是反斜杠，否则字符串结尾处的引号会被转义，导致字符串不能正确结束。

  - 在 Python 中有两种方式解决原始字符串中\这个问题：一种方式是改用长字符串的写法，不要使用原始字符串；另一种方式是单独书写反斜杠

    - 例如想表示`D:\Program Files\Python 3.8\`，可以这样写：

      ```
      str1 = r'D:\Program Files\Python 3.8' '\\'print(str1)我们先写了一个原始字符串r'D:\Program Files\Python 3.8'，紧接着又使用'\\'写了一个包含转义字符的普通字符串，Python 会自动将这两个字符串拼接在一起D:\Program Files\Python 3.8\
      ```

##### bytes

- bytes 类型用来表示一个字节串。“字节串“不是编程术语，是我自己“捏造”的一个词，用来和字符串相呼应。

- 字节串（bytes）和字符串（string）的对比：

  - 字符串由若干个字符组成，以字符为单位进行操作；字节串由若干个字节组成，以字节为单位进行操作。
  - 字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法都基本相同。
  - 字节串和字符串都是不可变序列，不能随意增加和删除数据。

- bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。说白了，bytes 只是简单地记录内存中的原始数据，至于如何使用这些数据，bytes 并不在意，你想怎么使用就怎么使用，bytes 并不约束你的行为。bytes 类型的数据非常适合在互联网上传输，可以用于网络通信编程；bytes 也可以用来存储图片、音频、视频等二进制格式的文件。

- 字符串和 bytes 存在着千丝万缕的联系，我们可以通过字符串来创建 bytes 对象，或者说将字符串转换成 bytes 对象。有以下三种方法可以达到这个目的：

  - 如果字符串的内容都是 ASCII 字符，那么直接在字符串前面添加`b`前缀就可以转换成 bytes。
  - bytes 是一个类，调用它的构造方法，也就是 bytes()，可以将字符串按照指定的字符集转换成 bytes；如果不指定字符集，那么默认采用 UTF-8。
  - 字符串本身有一个 encode() 方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8。

  ```
  #通过构造函数创建空 bytesb1 = bytes()#通过空字符串创建空 bytesb2 = b''#通过b前缀将字符串转换成 bytesb3 = b'http://c.biancheng.net/python/'print("b3: ", b3)print(b3[3])print(b3[7:22])#为 bytes() 方法指定字符集b4 = bytes('C语言中文网8岁了', encoding='UTF-8')print("b4: ", b4)#通过 encode() 方法将字符串转换成 bytesb5 = "C语言中文网8岁了".encode('UTF-8')print("b5: ", b5)b3:  b'http://c.biancheng.net/python/'112b'c.biancheng.net'b4:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'b5:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
  ```

  - 从运行结果可以发现，对于非 ASCII 字符，print 输出的是它的字符编码值（十六进制形式），而不是字符本身。非 ASCII 字符一般占用两个字节以上的内存，而 bytes 是按照单个字节来处理数据的，所以不能一次处理多个字节。

- bytes 类也有一个 decode() 方法，通过该方法可以将 bytes 对象转换为字符串

  ```
  #通过 decode() 方法将 bytes 转换成字符串str1 = b5.decode('UTF-8')print("str1: ", str1)str1:  C语言中文网8岁了
  ```

##### bool

- True 和 False 是 Python 中的关键字，当作为 Python 代码输入时，一定要注意字母的大小写，否则解释器会报错。

- 布尔类型可以当做整数来对待，即 True 相当于整数值 1，False 相当于整数值 0。

  ```
  >>> False+11>>> True+12
  ```

- 在 Python 中，所有的对象都可以进行真假值的测试，包括字符串、元组、列表、字典、对象等

##### input()函数

- input() 是 [Python](http://c.biancheng.net/python/) 的内置函数，用于从控制台读取用户输入的内容。input() 函数总是以字符串的形式来处理用户输入的内容，所以用户输入的内容可以包含任何字符。

  ```
  str = input(tipmsg)
  ```

  - str 表示一个字符串类型的变量，input 会将读取到的字符串放入 str 中。
  - tipmsg 表示提示信息，它会显示在控制台上，告诉用户应该输入什么样的内容；如果不写 tipmsg，就不会有任何提示信息。

- 我们可以使用 Python 内置函数将字符串转换成想要的类型，比如：

  - int(string) 将字符串转换成 int 类型；
  - float(string) 将字符串转换成 float 类型；
  - bool(string) 将字符串转换成 bool 类型。

##### print

- print() 函数完全可以同时输出多个变量

- print() 函数的详细语法格式如下：

  ```
  print (value,...,sep='',end='\n',file=sys.stdout,flush=False)
  ```

  - value 参数可以接受任意多个变量或值，因此 print() 函数完全可以输出多个值

    ```
    user_name ＝ 'Charlie'user_age = 8#同时输出多个变量和字符串print("读者名：",user_name,"年龄：",user_age)读者名： Charlie 年龄： 8
    ```

  - 从输出结果来看，使用 print() 函数输出多个变量时，print() 函数默认以空格隔开多个变量，如果读者希望改变默认的分隔符，可通过 sep 参数进行设置。例如输出语句：

    ```
    #同时输出多个变量和字符串，指定分隔符print("读者名：" ,user_name,"年龄：",user_age,sep='|')读者名：|Charlie|年龄：|8
    ```

  - 在默认情况下，print() 函数输出之后总会换行，这是因为 print() 函数的 end 参数的默认值是“\n”，这个“\n”就代表了换行。如果希望 print() 函数输出之后不会换行，则重设 end 参数即可

    ```
    #设置end 参数，指定输出之后不再换行print(40,'\t',end＝"")print(5O,'\t',end＝"")print(60,'\t',end＝"")40    50    60
    ```

  - file 参数指定 print() 函数的输出目标，file 参数的默认值为 sys.stdout，该默认值代表了系统标准输出，也就是屏幕，因此 print() 函数默认输出到屏幕。实际上，完全可以通过改变该参数让 print() 函数输出到特定文件中

    ```
    f = open("demo.txt","w")#打开文件以便写入print('沧海月明珠有泪',file=f)print('蓝回日暖玉生烟',file=f)f.close()
    ```

  - print() 函数的 flush 参数用于控制输出缓存，该参数一般保持为 False 即可，这样可以获得较好的性能。

- print() 函数使用以`%`开头的转换说明符对各种类型的数据进行格式化输出

  | 转换说明符 | 解释                                   |
  | ---------- | -------------------------------------- |
  | %d、%i     | 转换为带符号的十进制整数               |
  | %o         | 转换为带符号的八进制整数               |
  | %x、%X     | 转换为带符号的十六进制整数             |
  | %e         | 转化为科学计数法表示的浮点数（e 小写） |
  | %E         | 转化为科学计数法表示的浮点数（E 大写） |
  | %f、%F     | 转化为十进制浮点数                     |
  | %g         | 智能选择使用 %f 或 %e 格式             |
  | %G         | 智能选择使用 %F 或 %E 格式             |
  | %c         | 格式化字符及其 ASCII 码                |
  | %r         | 使用 repr() 函数将表达式转换为字符串   |
  | %s         | 使用 str() 函数将表达式转换为字符串    |

  ```
  age = 8print("C语言中文网已经%d岁了！" % age)输出结果  C语言中文网已经8岁了！在 print() 函数中，由引号包围的是格式化字符串，它相当于一个字符串模板，可以放置一些转换说明符（占位符）。本例的格式化字符串中包含一个%d说明符，它最终会被后面的 age 变量的值所替代。中间的%是一个分隔符，它前面是格式化字符串，后面是要输出的表达式。格式化字符串中也可以包含多个转换说明符，这个时候也得提供多个表达式，用以替换对应的转换说明符；多个表达式必须使用小括号( )包围起来。name = "C语言中文网"age = 8url = "http://c.biancheng.net/"print("%s已经%d岁了，它的网址是%s。" % (name, age, url))C语言中文网已经8岁了，它的网址是http://c.biancheng.net/。如果没有中间的%分割就会出错，另外如果没有% ，两个中间有逗号分隔输出结果为  C语言中文网已经%d岁了！ 8
  ```

- 指定最小输出宽度

  - %10d 表示输出的整数宽度至少为 10；

  - %20s 表示输出的字符串宽度至少为 20。

    ```
    n = 1234567
    print("n(10):%10d." % n)
    print("n(5):%5d." % n)
    url = "http://c.biancheng.net/python/"
    print("url(35):%35s." % url)
    print("url(20):%20s." % url)
    
    n(10):   1234567.
    n(5):1234567.
    url(35):     http://c.biancheng.net/python/.
    url(20):http://c.biancheng.net/python/.
    ```

  - 从运行结果可以发现，对于整数和字符串，当数据的实际宽度小于指定宽度时，会在左侧以空格补齐；当数据的实际宽度大于指定宽度时，会按照数据的实际宽度输出。

- 指定对齐方式

  - 默认情况下，print() 输出的数据总是右对齐的。也就是说，当数据不够宽时，数据总是靠右边输出，而在左边补充空格以达到指定的宽度。Python 允许在最小宽度之前增加一个标志来改变对齐方式

    | 标志 | 说明                                               |
    | ---- | -------------------------------------------------- |
    | -    | 指定左对齐                                         |
    | +    | 表示输出的数字总要带着符号；正数带`+`，负数带`-`。 |
    | 0    | 表示宽度不足时补充 0，而不是补充空格。             |

    - 对于整数，指定左对齐时，在右边补 0 是没有效果的，因为这样会改变整数的值。
    - 对于小数，以上三个标志可以同时存在。
    - 对于字符串，只能使用`-`标志，因为符号对于字符串没有意义，而补 0 会改变字符串的值。

    ```
    n = 123456
    # %09d 表示最小宽度为9，左边补0
    print("n(09):%09d" % n)
    # %+9d 表示最小宽度为9，带上符号
    print("n(+9):%+9d" % n)
    f = 140.5
    # %-+010f 表示最小宽度为10，左对齐，带上符号
    print("f(-+0):%-+010f" % f)
    s = "Hello"
    # %-10s 表示最小宽度为10，左对齐
    print("s(-10):%-10s." % s)
    
    n(09):000123456
    n(+9):  +123456
    f(-+0):+140.500000
    s(-10):Hello     .
    ```

- 指定小数精度

  - 对于小数（浮点数），print() 还允许指定小数点后的数字位数，也即指定小数的输出精度。

  - 精度值需要放在最小宽度之后，中间用点号`.`隔开；也可以不写最小宽度，只写精度。具体格式如下：

    ```
    %m.nf%.nfm 表示最小宽度，n 表示输出精度，.是必须存在的。f = 3.141592653# 最小宽度为8，小数点后保留3位print("%8.3f" % f)# 最小宽度为8，小数点后保留3位，左边补0print("%08.3f" % f)# 最小宽度为8，小数点后保留3位，左边补0，带符号print("%+08.3f" % f)   3.1420003.142+003.142
    ```

    

##### 转义字符

- 转义字符，就是那些以反斜杠`\`开头的字符。

- ASCII 编码为每个字符都分配了唯一的编号，称为编码值。在 [Python](http://c.biancheng.net/python/) 中，一个 ASCII 字符除了可以用它的实体（也就是真正的字符）表示，还可以用它的编码值表示。这种使用编码值来间接地表示字符的方式称为转义字符（Escape Character）。

- 转义字符以`\0`或者`\x`开头，以`\0`开头表示后跟八进制形式的编码值，以`\x`开头表示后跟十六进制形式的编码值，Python 中的转义字符只能使用八进制或者十六进制。

  ```
  \0dd\xhh
  ```

  - dd 表示八进制数字，hh 表示十六进制数字。

- ASCII 编码共收录了 128 个字符，`\0`和`\x`后面最多只能跟两位数字，所以八进制形式`\0`并不能表示所有的 ASCII 字符，只有十六进制形式`\x`才能表示所有 ASCII 字符。

- 字符 1、2、3、x、y、z 对应的 ASCII 码的八进制形式分别是 61、62、63、170、171、172，十六进制形式分别是 31、32、33、78、79、7A。下面的例子演示了转义字符的用法：使用八进制形式的转义字符没法表示 xyz，因为它们的编码值转换成八进制以后有三位。

  ```python
  str1 = "Oct: \061\062\063"str2 = "Hex: \x31\x32\x33\x78\x79\x7A"print(str1)print(str2)Oct: 123Hex: 123xyz
  ```

- 对于 ASCII 编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能用转义字符的形式来表示。不过，直接使用 ASCII 码记忆不方便，也不容易理解，所以，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下。

  | 转义字符 | 说明                                                         |
  | -------- | ------------------------------------------------------------ |
  | \n       | 换行符，将光标位置移到下一行开头。                           |
  | \r       | 回车符，将光标位置移到本行开头。                             |
  | \t       | 水平制表符，也即 Tab 键，一般相当于四个空格。                |
  | \a       | 蜂鸣器响铃。注意不是喇叭发声，现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效。 |
  | \b       | 退格（Backspace），将光标位置移到前一列。                    |
  | \\\      | 反斜线                                                       |
  | \\'      | 单引号                                                       |
  | \\"      | 双引号                                                       |
  | \\       | 在字符串行尾的续行符，即一行未完，转到下一行继续写。         |

```python
#使用\t排版str1 = '网站\t\t域名\t\t\t年龄\t\t价值'str2 = 'C语言中文网\tc.biancheng.net\t\t8\t\t500W'str3 = '百度\t\twww.baidu.com\t\t20\t\t500000W'print(str1)print(str2)print(str3)print("--------------------")# \n在输出时换行，\在书写字符串时换行info = "Python教程：http://c.biancheng.net/python/\n\C++教程：http://c.biancheng.net/cplus/\n\Linux教程：http://c.biancheng.net/linux_tutorial/"print(info)网站        域名                年龄    价值C语言中文网 c.biancheng.net     8       500W百度        www.baidu.com       20      500000W--------------------Python教程：http://c.biancheng.net/python/C++教程：http://c.biancheng.net/cplus/Linux教程：http://c.biancheng.net/linux_tutorial/
```

##### 数据类型转换

- 虽然 [Python](http://c.biancheng.net/python/) 是弱类型编程语言，不需要像 [Java](http://c.biancheng.net/java/) 或 C 语言那样还要在使用变量前声明变量的类型，但在一些特定场景中，仍然需要用到类型转换。

  | 函 数                  | 作 用                                              |
  | ---------------------- | -------------------------------------------------- |
  | int(x)                 | 将 x 转换成整数类型                                |
  | float(x)               | 将 x 转换成浮点数类型                              |
  | complex(real，[,imag]) | 创建一个复数                                       |
  | str(x)                 | 将 x 转换为字符串                                  |
  | repr(x)                | 将 x 转换为表达式字符串                            |
  | eval(str)              | 计算在字符串中的有效 Python 表达式，并返回一个对象 |
  | chr(x)                 | 将整数 x 转换为一个字符                            |
  | ord(x)                 | 将一个字符 x 转换为它对应的整数值                  |
  | hex(x)                 | 将一个整数 x 转换为一个十六进制字符串              |
  | oct(x)                 | 将一个整数 x 转换为一个八进制的字符串              |

- 需要注意的是，在使用类型转换函数时，提供给它的数据必须是有意义的。例如，int() 函数无法将一个非数字字符串转换成整数

  ```
  >>> int("123") #转换成功123>>> int("123个") #转换失败Traceback (most recent call last):  File "<pyshell#3>", line 1, in <module>    int("123个")ValueError: invalid literal for int() with base 10: '123个'
  ```

##### 运算符

###### 算数运算符

| 运算符 | 说明                                | 实例        | 结果      |
| ------ | ----------------------------------- | ----------- | --------- |
| +      | 加                                  | 12.45 + 15  | 27.45     |
| -      | 减                                  | 4.56 - 0.26 | 4.3       |
| *      | 乘                                  | 5 * 3.6     | 18.0      |
| /      | 除法（和数学中的规则一样）          | 7 / 2       | 3.5       |
| //     | 整除（只保留商的整数部分）          | 7 // 2      | 3         |
| %      | 取余，即返回除法的余数              | 7 % 2       | 1         |
| **     | 幂运算/次方运算，即返回 x 的 y 次方 | 2 ** 4      | 16，即 24 |

- 当`+`用于数字时表示加法，但是当`+`用于字符串时，它还有拼接字符串（将两个字符串连接为一个）的作用

  ```
  name = "C语言中文网"url = "http://c.biancheng.net/"age = 8info = name + "的网址是" + url + "，它已经" + str(age) + "岁了。"print(info)
  ```

  - str() 函数用来将整数类型的 age 转换成字符串。

- `*`除了可以用作乘法运算，还可以用来重复字符串，也即将 n 个同样的字符串连接起来

  ```
  str1 = "hello "print(str1 * 4)hello hello hello hello 
  ```

- Python 支持`/`和`//`两个除法运算符，但它们之间是有区别的：

  - `/`表示普通除法，使用它计算出来的结果和数学中的计算结果相同。
  - `//`表示整除，只保留结果的整数部分，舍弃小数部分；注意是直接丢掉小数部分，而不是四舍五入。
  - `/`的计算结果总是小数，不管是否能除尽，也不管参与运算的是整数还是小数。
  - 当有小数参与运算时，`//`结果才是小数，否则就是整数。
  - 除数始终不能为 0，除以 0 是没有意义的，这将导致 ZeroDivisionError 错误

- Python ** 运算符用来求一个 x 的 y 次方，也即次方（乘方）运算符。由于开方是次方的逆运算，所以也可以使用 ** 运算符间接地实现开方运算。

  ```
  print('----次方运算----')print('3**4 =', 3**4)print('2**5 =', 2**5)print('----开方运算----')print('81**(1/4) =', 81**(1/4))print('32**(1/5) =', 32**(1/5))
  ```

###### 赋值运算符

- 连续赋值，Python 中的赋值表达式也是有值的，它的值就是被赋的那个值，或者说是左侧变量的值；如果将赋值表达式的值再赋值给另外一个变量，这就构成了连续赋值。

  ```
  a = b = c = 100
  ```

  - `=`具有右结合性，我们从右到左分析这个表达式：
    - c = 100 表示将 100 赋值给 c，所以 c 的值是 100；同时，c = 100 这个子表达式的值也是 100。
    - b = c = 100 表示将 c = 100 的值赋给 b，因此 b 的值也是 100。
    - 以此类推，a 的值也是 100。

  | 运算符 | 说 明            | 用法举例 | 等价形式                              |
  | ------ | ---------------- | -------- | ------------------------------------- |
  | =      | 最基本的赋值运算 | x = y    | x = y                                 |
  | +=     | 加赋值           | x += y   | x = x + y                             |
  | -=     | 减赋值           | x -= y   | x = x - y                             |
  | *=     | 乘赋值           | x *= y   | x = x * y                             |
  | /=     | 除赋值           | x /= y   | x = x / y                             |
  | %=     | 取余数赋值       | x %= y   | x = x % y                             |
  | **=    | 幂赋值           | x **= y  | x = x ** y                            |
  | //=    | 取整数赋值       | x //= y  | x = x // y                            |
  | &=     | 按位与赋值       | x &= y   | x = x & y                             |
  | \|=    | 按位或赋值       | x \|= y  | x = x \| y                            |
  | ^=     | 按位异或赋值     | x ^= y   | x = x ^ y                             |
  | <<=    | 左移赋值         | x <<= y  | x = x << y，这里的 y 指的是左移的位数 |
  | >>=    | 右移赋值         | x >>= y  | x = x >> y，这里的 y 指的是右移的位数 |

###### 位运算符

- [Python](http://c.biancheng.net/python/) 位运算按照数据在内存中的二进制位（Bit）进行操作，它一般用于底层开发（算法设计、驱动、图像处理、单片机等），在应用层开发（Web 开发、Linux 运维等）中并不常见。

  | 位运算符 | 说明     | 使用形式 | 举 例                            |
  | -------- | -------- | -------- | -------------------------------- |
  | &        | 按位与   | a & b    | 4 & 5                            |
  | \|       | 按位或   | a \| b   | 4 \| 5                           |
  | ^        | 按位异或 | a ^ b    | 4 ^ 5                            |
  | ~        | 按位取反 | ~a       | ~4                               |
  | <<       | 按位左移 | a << b   | 4 << 2，表示整数 4 按位左移 2 位 |
  | >>       | 按位右移 | a >> b   | 4 >> 2，表示整数 4 按位右移 2 位 |

- Python 左移运算符`<<`用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补 0。

- Python 右移运算符`>>`用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。

###### 比较运算符

| 比较运算符 | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| >          | 大于，如果`>`前面的值大于后面的值，则返回 True，否则返回 False。 |
| <          | 小于，如果`<`前面的值小于后面的值，则返回 True，否则返回 False。 |
| ==         | 等于，如果`==`两边的值相等，则返回 True，否则返回 False。    |
| >=         | 大于等于（等价于数学中的 ≥），如果`>=`前面的值大于或者等于后面的值，则返回 True，否则返回 False。 |
| <=         | 小于等于（等价于数学中的 ≤），如果`<=`前面的值小于或者等于后面的值，则返回 True，否则返回 False。 |
| !=         | 不等于（等价于数学中的 ≠），如果`!=`两边的值不相等，则返回 True，否则返回 False。 |
| is         | 判断两个变量所引用的对象是否相同，如果相同则返回 True，否则返回 False。 |
| is not     | 判断两个变量所引用的对象是否不相同，如果不相同则返回 True，否则返回 False。 |

- 初学 Python，大家可能对 is 比较陌生，很多人会误将它和 == 的功能混为一谈，但其实 is 与 == 有本质上的区别，完全不是一码事儿。== 用来比较两个变量的值是否相等，而 is 则用来比对两个变量引用的是否是同一个对象

  ```
  import time  #引入time模块t1 = time.gmtime() # gmtime()用来获取当前时间t2 =  time.gmtime()print(t1 == t2) #输出Trueprint(t1 is t2) #输出FalseTrueFalse
  ```

  - time 模块的 gmtime() 方法用来获取当前的系统时间，精确到秒级，因为程序运行非常快，所以 t1 和 t1 得到的时间是一样的。== 用来判断 t1 和 t2 的值是否相等，所以返回 True。
  - 虽然 t1 和 t2 的值相等，但它们是两个不同的对象（每次调用 gmtime() 都返回不同的对象），所以`t1 is t2`返回 False。这就好像两个双胞胎姐妹，虽然她们的外貌是一样的，但它们是两个人。
  - 那么，如何判断两个对象是否相同呢？答案是判断两个对象的内存地址。如果内存地址相同，说明两个对象使用的是同一块内存，当然就是同一个对象了；这就像两个名字使用了同一个身体，当然就是同一个人了。

###### 逻辑运算符

| 逻辑运算符 | 含义                           | 基本格式 | 说明                                                         |
| ---------- | ------------------------------ | -------- | ------------------------------------------------------------ |
| and        | 逻辑与运算，等价于数学中的“且” | a and b  | 当 a 和 b 两个表达式都为真时，a and b 的结果才为真，否则为假。 |
| or         | 逻辑或运算，等价于数学中的“或” | a or b   | 当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。 |
| not        | 逻辑非运算，等价于数学中的“非” | not a    | 如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。 |

- 有些不负责任的 Python 教程说：Python 逻辑运算符用于操作 bool 类型的表达式，执行结果也是 bool 类型，这两点其实都是错误的！Python 逻辑运算符可以用来操作任何类型的表达式，不管表达式是不是 bool 类型；同时，逻辑运算的结果也不一定是 bool 类型，它也可以是任意类型。

  ```
  print(100 and 200)print(45 and 0)print("" or "http://c.biancheng.net/python/")print(18.5 or "http://c.biancheng.net/python/")2000http://c.biancheng.net/python/18.5
  ```

  - 在 Python 中，and 和 or 不一定会计算右边表达式的值，有时候只计算左边表达式的值就能得到最终结果。
  - 另外，and 和 or 运算符会将其中一个表达式的值作为最终结果，而不是将 True 或者 False 作为最终结果。

- 对于 and 运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 Python 按照下面的规则执行 and 运算：

  - 如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时 and 会把左边表达式的值作为最终结果。
  - 如果左边表达式的值为真，那么最终值是不能确定的，and 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

- 对于 or 运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以 Python 按照下面的规则执行 or 运算：

  - 如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时 or 会把左边表达式的值作为最终结果。
  - 如果左边表达式的值为假，那么最终值是不能确定的，or 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

###### 三目运算符

- 假设现在有两个数字，我们希望获得其中较大的一个，那么可以使用 if else 语句

  ```
  if a>b:    max = a;else:    max = b;但是 Python 提供了一种更加简洁的写法max = a if a>b else b
  ```

  - 这是一种类似于其它编程语言中三目运算符`? :`的写法。Python 是一种极简主义的编程语言，它没有引入`? :`这个新的运算符，而是使用已有的 if else 关键字来实现相同的功能。

- 使用 if else 实现三目运算符（条件运算符）的格式如下：

  ```
  exp1 if contion else exp2
  ```

  - condition 是判断条件，exp1 和 exp2 是两个表达式。如果 condition 成立（结果为真），就执行 exp1，并把 exp1 的结果作为整个表达式的结果；如果 condition 不成立（结果为假），就执行 exp2，并把 exp2 的结果作为整个表达式的结果。

- 前面的语句`max = a if a>b else b`的含义是：

  - 如果 a>b 成立，就把 a 作为整个表达式的值，并赋给变量 max；
  - 如果 a> b 不成立，就把 b 作为整个表达式的值，并赋给变量 max。

- Python 三目运算符支持嵌套，如此可以构成更加复杂的表达式。在嵌套时需要注意 if 和 else 的配对

  ```
  a if a>b else c if c>d else d应该理解为：a if a>b else ( c if c>d else d )
  ```

###### 运算符优先级和结合性

| 运算符说明 | Python运算符            | 优先级 | 结合性 | 优先级顺序 |
| ---------- | ----------------------- | ------ | ------ | ---------- |
| 小括号     | ( )                     | 19     | 无     | 最高       |
| 索引运算符 | x[i] 或 x[i1: i2 [:i3]] | 18     | 左     |            |
| 属性访问   | x.attribute             | 17     | 左     |            |
| 乘方       | **                      | 16     | 右     |            |
| 按位取反   | ~                       | 15     | 右     |            |
| 符号运算符 | +（正号）、-（负号）    | 14     | 右     |            |
| 乘除       | *、/、//、%             | 13     | 左     |            |
| 加减       | +、-                    | 12     | 左     |            |
| 位移       | >>、<<                  | 11     | 左     |            |
| 按位与     | &                       | 10     | 右     |            |
| 按位异或   | ^                       | 9      | 左     |            |
| 按位或     | \|                      | 8      | 左     |            |
| 比较运算符 | ==、!=、>、>=、<、<=    | 7      | 左     |            |
| is 运算符  | is、is not              | 6      | 左     |            |
| in 运算符  | in、not in              | 5      | 左     |            |
| 逻辑非     | not                     | 4      | 右     |            |
| 逻辑与     | and                     | 3      | 左     |            |
| 逻辑或     | or                      | 2      | 左     |            |
| 逗号运算符 | exp1, exp2              | 1      | 左     | 最低       |

- 所谓结合性，就是当一个表达式中出现多个优先级相同的运算符时，先执行哪个运算符：先执行左边的叫左结合性，先执行右边的叫右结合性。
- 例如对于表达式对于`100 / 25 * 16`，`/`和`*`的优先级相同，应该先执行哪一个呢？这个时候就不能只依赖运算符优先级决定了，还要参考运算符的结合性。`/`和`*`都具有左结合性，因此先执行左边的除法，再执行右边的乘法，最终结果是 64。
- Python 中大部分运算符都具有左结合性，也就是从左到右执行；只有 ** 乘方运算符、单目运算符（例如 not 逻辑非运算符）、赋值运算符和三目运算符例外，它们具有右结合性，也就是从右向左执行
- 当一个表达式中出现多个运算符时，Python 会先比较各个运算符的优先级，按照优先级从高到低的顺序依次执行；当遇到优先级相同的运算符时，再根据结合性决定先执行哪个运算符：如果是左结合性就先执行左边的运算符，如果是右结合性就先执行右边的运算符。

#### 列表、元组、字典、集合

- Python 序列（Sequence）是指按特定顺序依次排列的一组数据，它们可以占用一块连续的内存，也可以分散到多块内存中。Python 中的序列类型包括列表（list）、元组（tuple）、字典（dict）和集合（set）。
- 在 Python 编程中，我们既需要独立的变量来保存一份数据，也需要序列来保存大量数据。
- 列表（list）和元组（tuple）比较相似，它们都按顺序保存元素，所有的元素占用一块连续的内存，每个元素都有自己的索引，因此列表和元组的元素都可以通过索引（index）来访问。它们的区别在于：列表是可以修改的，而元组是不可修改的。
- 字典（dict）和集合（set）存储的数据都是无序的，每份元素占用不同的内存，其中字典元素以 `key-value` 的形式保存。

##### 序列

- 所谓序列，指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可通过每个值所在位置的编号（称为索引）访问它们。
- 在 [Python](http://c.biancheng.net/python/) 中，序列类型包括字符串、列表、元组、集合和字典，这些序列支持以下几种通用的操作，但比较特殊的是，集合和字典不支持索引、切片、相加和相乘操作。
- 字符串也是一种常见的序列，它也可以直接通过索引访问字符串内的字符。

###### 序列索引

- 序列中，每个元素都有属于自己的编号（索引）。从起始元素开始，索引值从 0 开始递增
- Python 还支持索引值是负数，此类索引是从右向左计数，换句话说，从最后一个元素开始计数，从索引值 -1 开始。在使用负值作为列序中各元素的索引值时，是从 -1 开始，而不是从 0 开始。

###### 序列切片

- 切片操作是访问序列中元素的另一种方法，它可以访问一定范围内的元素，通过切片操作，可以生成一个新的序列。

- 序列实现切片操作的语法格式如下：

  ```
  sname[start : end : step]
  ```

  - sname：表示序列的名称；

  - start：表示切片的开始索引位置（包括该位置），此参数也可以不指定，会默认为 0，也就是从序列的开头进行切片；

  - end：表示切片的结束索引位置（不包括该位置），如果不指定，则默认为序列的长度；

  - step：表示在切片过程中，隔几个存储位置（包含当前位置）取一次元素，也就是说，如果 step 的值大于 1，则在进行切片去序列元素时，会“跳跃式”的取元素。如果省略设置 step 的值，则最后一个冒号就可以省略。

    ```
    str="C语言中文网"#取索引区间为[0,2]之间（不包括索引2处的字符）的字符串print(str[:2])#隔 1 个字符取一个字符，区间是整个字符串print(str[::2])#取整个字符串，此时 [] 中只需一个冒号即可print(str[:])
    ```

###### 序列相加

- Python 中，支持两种类型相同的序列使用“+”运算符做相加操作，它会将两个序列进行连接，但不会去除重复的元素。这里所说的“类型相同”，指的是“+”运算符的两侧序列要么都是列表类型，要么都是元组类型，要么都是字符串。

###### 序列相乘

- Python 中，使用数字 n 乘以一个序列会生成新的序列，其内容为原来序列被重复 n 次的结果

- 比较特殊的是，列表类型在进行乘法运算时，还可以实现初始化指定长度列表的功能。例如如下的代码，将创建一个长度为 5 的列表，列表中的每个元素都是 None，表示什么都没有。

  ```
  #列表的创建用 []，后续讲解列表时会详细介绍list = [None]*5print(list)[None, None, None, None, None]
  ```

###### 检查元素是否包含在序列中

- Python 中，可以使用 in 关键字检查某元素是否为序列的成员

  ```
  value in sequence
  ```

  - value 表示要检查的元素，sequence 表示指定的序列。

  - 例如，检查字符‘c’是否包含在字符串“c.biancheng.net”中

    ```
    str="c.biancheng.net"print('c'in str)True
    ```

- 和 in 关键字用法相同，但功能恰好相反的，还有 not in 关键字，它用来检查某个元素是否不包含在指定的序列中

###### 内置函数

| 函数        | 功能                                                         |
| ----------- | ------------------------------------------------------------ |
| len()       | 计算序列的长度，即返回序列中包含多少个元素。                 |
| max()       | 找出序列中的最大元素。注意，对序列使用 sum() 函数时，做加和操作的必须都是数字，不能是字符或字符串，否则该函数将抛出异常，因为解释器无法判定是要做连接操作（+ 运算符可以连接两个序列），还是做加和操作。 |
| min()       | 找出序列中的最小元素。                                       |
| list()      | 将序列转换为列表。                                           |
| str()       | 将序列转换为字符串。                                         |
| sum()       | 计算元素和。                                                 |
| sorted()    | 对元素进行排序。                                             |
| reversed()  | 反向序列中的元素。                                           |
| enumerate() | 将序列组合为一个索引序列，多用在 for 循环中。                |

##### 列表

- [Python](http://c.biancheng.net/python/) 中没有数组，但是加入了更加强大的列表。如果把数组看做是一个集装箱，那么 Python 的列表就是一个工厂的仓库。

- 从形式上看，列表会将所有元素都放在一对中括号`[ ]`里面，相邻元素之间用逗号`,`分隔

- 从内容上看，列表可以存储整数、小数、字符串、列表、元组等任何类型的数据，并且同一个列表中元素的类型也可以不同

  ```
  ["http://c.biancheng.net/python/", 1, [2,3,4] , 3.0]
  ```

  - 列表中同时包含字符串、整数、列表、浮点数这些数据类型。

- 在使用列表时，虽然可以将不同类型的数据放入到同一个列表中，但通常情况下不这么做，同一列表中只放入同一类型的数据，这样可以提高程序的可读性。

- 在其它 Python 教程中，经常用 list 代指列表，这是因为列表的数据类型就是 list，通过 type() 函数就可以知道

###### 创建列表

- 使用[]直接创建列表

- 使用list()函数创建列表，内置的函数 list()，使用它可以将其它数据类型转换为列表类型

  ```python
  #将字符串转换成列表list1 = list("hello")print(list1)#将元组转换成列表tuple1 = ('Python', 'Java', 'C++', 'JavaScript')list2 = list(tuple1)print(list2)#将字典转换成列表dict1 = {'a':100, 'b':42, 'c':9}list3 = list(dict1)print(list3)#将区间转换成列表range1 = range(1, 6)list4 = list(range1)print(list4)#创建空列表print(list())['h', 'e', 'l', 'l', 'o']['Python', 'Java', 'C++', 'JavaScript']['a', 'b', 'c'][1, 2, 3, 4, 5][]
  ```

- 访问列表元素使用索引或者切片

- 删除列表，对于已经创建的列表，如果不再使用，可以使用`del`关键字将其删除。实际开发中并不经常使用 del 来删除列表，因为 Python 自带的垃圾回收机制会自动销毁无用的列表，即使开发者不手动删除，Python 也会自动将其回收。

###### 列表添加元素

- 使用`+`运算符可以将多个序列连接起来；列表是序列的一种，所以也可以使用`+`进行连接，这样就相当于在第一个列表的末尾添加了另一个列表。`+`更多的是用来拼接列表，而且执行效率并不高

- append() 方法用于在列表的末尾追加元素

  ```
  listname.append(obj)
  ```

  - obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等

    ```
    l = ['Python', 'C++', 'Java']#追加元素l.append('PHP')print(l)#追加元组，整个元组被当成一个元素t = ('JavaScript', 'C#', 'Go')l.append(t)print(l)#追加列表，整个列表也被当成一个元素l.append(['Ruby', 'SQL'])print(l)['Python', 'C++', 'Java', 'PHP']['Python', 'C++', 'Java', 'PHP', ('JavaScript', 'C#', 'Go')]['Python', 'C++', 'Java', 'PHP', ('JavaScript', 'C#', 'Go'), ['Ruby', 'SQL']]
    ```

  - 当给 append() 方法传递列表或者元组时，此方法会将它们视为一个整体，作为一个元素添加到列表中，从而形成包含列表和元组的新列表

- extend()方法添加元素。extend() 和 append() 的不同之处在于：extend() 不会把列表或者元祖视为一个整体，而是把它们包含的元素逐个添加到列表中。

  ```
  listname.extend(obj)
  ```

  - obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等，但不能是单个的数字

- insert()方法插入元素。append() 和 extend() 方法只能在列表末尾插入元素，如果希望在列表中间某个位置插入元素，那么可以使用 insert() 方法。

  ```
  listname.insert(index , obj)
  ```

  - index 表示指定位置的索引值。insert() 会将 obj 插入到 listname 列表第 index 个元素的位置。
  - 当插入列表或者元祖时，insert() 也会将它们视为一个整体，作为一个元素插入到列表中，这一点和 append() 是一样的。

###### 删除元素

- 在 [Python](http://c.biancheng.net/python/) 列表中删除元素主要分为以下 3 种场景：

  - 根据目标元素所在位置的索引进行删除，可以使用 del 关键字或者 pop() 方法；
  - 根据元素本身的值进行删除，可使用列表（list类型）提供的 remove() 方法；
  - 将列表中所有元素全部删除，可使用列表（list类型）提供的 clear() 方法。

- del根据索引值删除元素

  - del 是 Python 中的关键字，专门用来执行删除操作，它不仅可以删除整个列表，还可以删除列表中的某些元素

  - del 可以删除列表中的单个元素

    ```
    del listname[index]
    ```

  - del 也可以删除中间一段连续的元素

    ```
    del listname[start : end]del 会删除从索引 start 到 end 之间的元素，不包括 end 位置的元素。
    ```

- pop()根据索引值删除元素

  - pop() 方法用来删除列表中指定索引处的元素

    ```
    listname.pop(index)
    ```

    - index 表示索引值。如果不写 index 参数，默认会删除列表中的最后一个元素，类似于[数据结构](http://c.biancheng.net/data_structure/)中的“出栈”操作。

  - 大部分编程语言都会提供和 pop() 相对应的方法，就是 push()，该方法用来将元素添加到列表的尾部，类似于数据结构中的“入栈”操作。但是 Python 是个例外，Python 并没有提供 push() 方法，因为完全可以使用 append() 来代替 push() 的功能。

- remove()根据元素值进行删除

  - 除了 del 关键字，Python 还提供了 remove() 方法，该方法会根据元素本身的值来进行删除操作。
  - remove() 方法只会删除第一个和指定值相同的元素，而且必须保证该元素是存在的，否则会引发 ValueError 错误。所以我们在使用 remove() 删除元素时最好提前判断一下。

- clear()删除列表所有元素

###### 修改元素

- 提供了两种修改列表（list）元素的方法，你可以每次修改单个元素，也可以每次修改一组元素（多个）。

- 修改单个元素非常简单，直接对元素赋值即可

  ```
  nums = [40, 36, 89, 2, 36, 100, 7]nums[2] = -26  #使用正数索引nums[-3] = -66.2  #使用负数索引print(nums)[40, 36, -26, 2, -66.2, 100, 7]
  ```

  - 使用索引得到列表元素后，通过`=`赋值就改变了元素的值。

- Python 支持通过切片语法给一组元素赋值。在进行这种操作时，如果不指定步长（step 参数），Python 就不要求新赋值的元素个数与原来的元素个数相同；这意味，该操作既可以为列表添加元素，也可以为列表删除元素。

  ```
  修改一组元素的值nums = [40, 36, 89, 2, 36, 100, 7]#修改第 1~4 个元素的值（不包括第4个元素）nums[1: 4] = [45.25, -77, -52.5]print(nums)[40, 45.25, -77, -52.5, 36, 100, 7]如果对空切片（slice）赋值，就相当于插入一组新的元素：nums = [40, 36, 89, 2, 36, 100, 7]#在4个位置插入元素nums[4: 4] = [-77, -52.5, 999]print(nums)[40, 36, 89, 2, -77, -52.5, 999, 36, 100, 7]使用切片语法赋值时，Python 不支持单个值，例如下面的写法就是错误的：nums[4: 4] = -77但是如果使用字符串赋值，Python 会自动把字符串转换成序列，其中的每个字符都是一个元素s = list("Hello")s[2:4] = "XYZ"print(s)['H', 'e', 'X', 'Y', 'Z', 'o']
  ```

- 使用切片语法时也可以指定步长（step 参数），但这个时候就要求所赋值的新元素的个数与原有元素的个数相同

  ```
  nums = [40, 36, 89, 2, 36, 100, 7]#步长为2，为第1、3、5个元素赋值nums[1: 6: 2] = [0.025, -99, 20.5]print(nums)[40, 0.025, 89, -99, 36, 20.5, 7]
  ```

###### 查找元素

- 提供了 index() 和 count() 方法，它们都可以用来查找元素。

- index() 方法用来查找某个元素在列表中出现的位置（也就是索引），如果该元素不存在，则会导致 ValueError 错误，所以在查找之前最好使用 count() 方法判断一下。

  ```
  listname.index(obj, start, end)
  ```

  - start 和 end 参数用来指定检索范围：
    - start 和 end 可以都不写，此时会检索整个列表；
    - 如果只写 start 不写 end，那么表示检索从 start 到末尾的元素；
    - 如果 start 和 end 都写，那么表示检索 start 和 end 之间的元素。
  - index() 方法会返回元素所在列表中的索引值。

- count() 方法用来统计某个元素在列表中出现的次数

  ```
  listname.count(obj)
  ```

  - 如果 count() 返回 0，就表示列表中不存在该元素，所以 count() 也可以用来判断列表中的某个元素是否存在。

###### range()快速初始化数字列表

- 列表非常适合用于存储数字集合，并且 Python 提供了 range() 函数，可帮助我们高效地处理数字列表，即便列表需要包含数百万个元素，也可以快速实现。

- Python range() 函数能够轻松地生成一系列的数字

  ```
  for value in range(1,5):
      print(value)
      
  1
  2
  3
  4
  ```

  - 在这个示例程序中，range() 只是打印数字 1~4，因为range() 函数的用法是：让 Python 从指定的第一个值开始，一直数到指定的第二个值停止，但不包含第二个值（这里为 5）。

- 另外需要指明的是，range() 函数的返回值并不直接是列表类型（list）

  ```
  >>> type([1,2,3,4,5])
  <class 'list'>
  >>> type(range(1,6))
  <class 'range'>
  ```

  - range() 函数的返回值类型为 range，而不是 list。而如果想要得到 range() 函数创建的数字列表，还需要借助 list() 函数

- 在使用 range() 函数时，还可以指定步长。例如，下面的代码打印 1~10 内的偶数：

  ```
  even_numbers = list(range(2,11,2))
  print(even_numbers)
  
  [2, 4, 6, 8, 10]
  ```

  - 函数 range() 从 2 开始数，然后不断地加 2，直到达到或超过终值

##### 元组

- 元组和列表（list）的不同之处在于：

  - 列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列；
  - 而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。

- 元组也可以看做是不可变的列表，通常情况下，元组用于保存无需修改的内容。

- 从形式上看，元组的所有元素都放在一对小括号`( )`中，相邻元素之间用逗号`,`分隔

- 从存储内容上看，元组可以存储整数、实数、字符串、列表、元组等任何类型的数据，并且在同一个元组中，元素的类型可以不同

- 元组的类型位tuple，可以使用type查看

- 在 Python 中，元组通常都是使用一对小括号将所有元素包围起来的，但小括号不是必须的，只要将各元素用逗号隔开，Python 就会将其视为元组

  ```
  course = "Python教程", "http://c.biancheng.net/python/"print(course)('Python教程', 'http://c.biancheng.net/python/')
  ```

- 需要注意的一点是，当创建的元组中只有一个字符串类型的元素时，该元素后面必须要加一个逗号`,`，否则 Python 解释器会将它视为字符串

- 除了使用`( )`创建元组外，Python 还提供了一个内置的函数 tuple()，用来将其它数据类型转换为元组类型。

- 和列表一样，我们可以使用索引（Index）访问元组中的某个元素（得到的是一个元素的值），也可以使用切片访问元组中的一组元素（得到的是一个新的子元组）。

- 元组是不可变序列，元组中的元素不能被修改，所以我们只能创建一个新的元组去替代旧的元组。

- 还可以通过连接多个元组（使用`+`可以拼接元组）的方式向元组中添加新元素

- 当创建的元组不再使用时，可以通过 del 关键字将其删除。Python 自带垃圾回收功能，会自动销毁不用的元组，所以一般不需要通过 del 来手动删除。

- 总的来说，元组确实没有列表那么多功能，但是元组依旧是很重要的序列类型之一，元组的不可替代性体现在以下这些场景中：

  1. 元组作为很多内置函数和序列类型方法的返回值存在，也就是说，在使用某些函数或者方法时，它的返回值会元组类型，因此你必须对元组进行处理。
  2. 元组比列表的访问和处理速度更快，因此，当需要对指定元素进行访问，且不涉及修改元素的操作时，建议使用元组。
  3. 元组可以在映射（和集合的成员）中当做“键”使用，而列表不行。

###### 元组解包

- 赋值给多个变量的元组解包，一对一解包

  ```
  temp = ("hi","yuan","wai") first,second,third = temp等同于temp = ("hi","yuan","wai") first = temp[0] second = temp[1] third = temp[2]
  ```

- 元组的每个元素作为位置参数的元组解包

  ```
  temp = (1,2,3) def hello(first,second,third):    print(first)    print(second)    print(third)    hello(*temp)等同于hello(1,2,3)
  ```

- 遍历的元素为元组对象时，同时赋值给对应的变量，自动完成元组解包

  ```
  temp_list = [            ('测试人员', self.tester),            ('开始时间', start_time),            ('合计耗时', duration),            ('测试结果', status + "，通过率= " + self.pass_rate)] for first, second in temp_list:    print(first)    print(second)
  ```

  - temp_list是一个list，每个元素为tuple，遍历temp_list时，将每次的获取到tuple对象，自动解包到2个变量first和second

- *的使用

  ```
  >>> first, *new, last = [94, 85, 73, 46]>>> new[85, 73]
  ```

  - *在函数里面表示可变参数，在这里面也表示解包获取多个值，将多个值拼成一个列表返回到new，说明现在new是一个list类型，如果后面是元组，返回的也是list类型

- 压包过程，压包是解包的逆过程，用zip函数实现

  ```
  >>> a = ['a', 'b', 'c']>>> b = [1, 2, 3]>>> for i in zip(a, b):...     print(i)...('a', 1)('b', 2)('c', 3)
  ```

- 压包与解包混合

  ```
  >>> a = [0, 1, 2]>>> b = [1, 2, 3]>>> for i, j in zip(a, b):...     print(i+j)...135
  ```

  - 先是`zip`函数将`a b`压包成为一个可迭代对象
  - 对可迭代对象的每一个元素（`('a', 1)`）进行解包（`i, j = ('a', 1)`）
  - 此时就可以分别调用`i j`变量进行计算
  - 加入星号如下

  ```
  >>> l = [('Bob', '1990-1-1', 60),...     ('Mary', '1996-1-4', 50),...     ('Nancy', '1993-3-1', 55),]>>> for name, *args in l:...     print(name, args)...Bob ['1990-1-1', 60]Mary ['1996-1-4', 50]Nancy ['1993-3-1', 55]
  ```

  - 解包与压包结合可以实现类似矩阵转置的操作

  ```
  a = [[1, 2, 3], [4, 5, 6]]for x, y in zip(*a):    print(x, y)# 1 4# 2 5# 3 6
  ```

- _的用法，当一些元素不用时，用`_`表示是更好的写法，可以让读代码的人知道这个元素是不要的

  ```
  >>> person = ('Bob', 20, 50, (11, 20, 2000))>>> name, *_, (*_, year) = person>>> name'Bob'>>> year2000
  ```

- 多变量同时赋值，之前赋值符号右侧都是可迭代对象，其实左侧也可以是多个变量

  ```
  >>> a, b = 1, 2>>> a1>>> b2>>> a = 1, 2>>> a(1, 2)下面的语法是错误的*a = 1, 2  //如果只有一个参数，编译器会当作字符串，不能作为元组处理，可以在后面加一个逗号来表示元组a, b, c = 1, 2  可以这样写*a, = 1, 2
  ```

- *之可变参数，函数定义时，我们使用`*`的可变参数，其实也是压包解包过程

  ```
  >>> def myfun(*num):...     print(num)...>>> myfun(1,2,5,6)(1, 2, 5, 6)
  ```

  - 参数用`*num`表示，`num`变量就可以当成元组调用了。其实这个过程相当于`*num, = 1,2,5,6`

- *之关键字参数

  ```
  >>> def myfun(**kw):...     print(kw)...>>> myfun(name = "Bob", age = 20, weight = 50){'weight': 50, 'name': 'Bob', 'age': 20}
  ```

  - 键值对传入`**kw`，`kw`就可以表示相应字典。`**`的用法只在函数定义中使用，不能这样使用

    ```
    a, **b = {'weight': 50, 'name': 'Bob', 'age': 20}
    ```

- 可变参数与关键字参数的细节问题

  - 函数传入实参时，可变参数(`*`)之前的参数不能指定参数名

    ```
    >>> def myfun(a, *b):...     print(a)...     print(b)...>>> myfun(a=1, 2,3,4)  File "<stdin>", line 1SyntaxError: positional argument follows keyword argument>>> myfun(1, 2,3,4)1(2, 3, 4)
    ```

  - 函数传入实参时，可变参数(`*`)之后的参数必须指定参数名，否则就会被归到可变参数之中

    ```
    >>> def myfun(a, *b, c=None):...     print(a)...     print(b)...     print(c)...>>> myfun(1, 2,3,4)1(2, 3, 4)None>>> myfun(1, 2,3,c=4)1(2, 3)4
    ```

  - 关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以

    ```
    >>> def myfun(a, *b, c, **d):...     print(a)...     print(b)...     print(c)...     print(d)...>>> myfun(1, 2, 3, c= 4, m = 5, n = 6)1(2, 3)4{'n': 6, 'm': 5}
    ```

  - 可变参数与关键词参数共同使用以表示任意参数，下面是这一点在装饰器当中的使用

    ```
    >>> def mydecorator(func):...     def wrapper(*args, **kw):...         print('I am using a decorator.')...         return func(*args, **kw)...     return wrapper...>>> @mydecorator... def myfun(a, b):...     print(a)...     print(b)...>>> myfun(1, b = 2)I am using a decorator.12
    ```

    - (如果有的读者不熟悉装饰器，只需要知道，使用`@`定义`myfun`相当于`myfun = mydecorator(myfun)`，定义出来的`myfun`其实是返回结果`wrapper`函数)
    - `wrapper`函数使用`*args, **kw`作为参数，则被修饰的`myfun`函数需要的参数无论是什么样的，传入`wrapper`都不会报错，这保证了装饰器可以修饰各种各样函数的灵活性。毕竟我们一般在函数中传入参数时，要么所有参数名都写，要么前面几个不写，后面的会写，这样使用`*args, **kw`完全没有问题。

- 解包作为参数传入函数中

  ```
  def myfun(a, b):    print(a + b)列表元组的解包   >>> n = [1, 2]>>> myfun(*n)3>>> m = (1, 2)>>> myfun(*m)3字典的解包>>> mydict = {'a':1, 'b': 2}>>> myfun(**mydict)3>>> myfun(*mydict)ba应用>>> bob = {'name': 'Bob', 'age': 30}>>> "{name}'s age is {age}".format(**bob)"Bob's age is 30"
  ```

- 多返回值函数

  ```
  def myfun(a, b):    return a + 1, b + 2>>> m, n = myfun(1, 2)>>> m2>>> n4>>> p = myfun(1, 2)>>> p(2, 4)
  ```

  

- 其实在python中元组解包不仅仅只限于元组，只要是可迭代的如列表、元组、字典、字符串、range()等，都是可以的

##### 字典dict

| 主要特征                       | 解释                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 通过键而不是通过索引来读取元素 | 字典类型有时也称为关联数组或者散列表（hash）。它是通过键将一系列的值联系起来的，这样就可以通过键从字典中获取指定项，但不能通过索引来获取。 |
| 字典是任意数据类型的无序集合   | 和列表、元组不同，通常会将索引值 0 对应的元素称为第一个元素，而字典中的元素是无序的。 |
| 字典是可变的，并且可以任意嵌套 | 字典可以在原处增长或者缩短（无需生成一个副本），并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其它的字典。 |
| 字典中的键必须唯一             | 字典中，不支持同一个键出现多次，否则只会保留最后一个键值对。 |
| 字典中的键必须不可变           | 字典中每个键值对的键是不可变的，只能使用数字、字符串或者元组，不能使用列表。 |

###### 创建字典

- 使用{}创建字典，由于字典中每个元素都包含两部分，分别是键（key）和值（value），因此在创建字典时，键和值之间使用冒号`:`分隔，相邻元素之间使用逗号`,`分隔，所有元素放在大括号`{ }`中。需要注意的是，同一字典中的各个键必须唯一，不能重复。

- 通过fromkeys()创建字典，使用 dict 字典类型提供的 fromkeys() 方法创建带有默认值的字典

  ```
  dictname = dict.fromkeys(list，value=None)
  ```

  - list 参数表示字典中所有键的列表（list）；value 参数表示默认值，如果不写，则为空值 None。

    ```
    knowledge = ['语文', '数学', '英语']scores = dict.fromkeys(knowledge, 60)print(scores){'语文': 60, '英语': 60, '数学': 60}
    ```

- 通过dict()映射函数创建字典

  | 创建格式                                                     | 注意事项                                                     |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | a = dict(str1=value1, str2=value2, str3=value3)              | str 表示字符串类型的键，value 表示键对应的值。使用此方式创建字典时，字符串不能带引号。 |
  | #方式1 demo = [('two',2), ('one',1), ('three',3)]                                                                          #方式2 demo = [['two',2], ['one',1], ['three',3]]                                                                               #方式3 demo = (('two',2), ('one',1), ('three',3))                                                                                 #方式4 demo = (['two',2], ['one',1], ['three',3]) a = dict(demo) | 向 dict() 函数传入列表或元组，而它们中的元素又各自是包含 2 个元素的列表或元组，其中第一个元素作为键，第二个元素作为值。 |
  | keys = ['one', 'two', 'three'] #还可以是字符串或元组 values = [1, 2, 3] #还可以是字符串或元组 a = dict( zip(keys, values) ) | 通过应用 dict() 函数和 zip() 函数，可将前两个列表转换为对应的字典。 |

- 访问字典

  - 列表和元组是通过下标来访问元素的，而字典不同，它通过键来访问对应的值。因为字典中的元素是无序的，每个元素的位置都不固定，所以字典也不能像列表和元组那样，采用切片的方式一次性访问多个元素。

    ```
    dictname[key]
    ```

    - dictname 表示字典变量的名字，key 表示键名。注意，键必须是存在的，否则会抛出异常。

    ```
    tup = (['two',26], ['one',88], ['three',100], ['four',-59])dic = dict(tup)print(dic['one'])  #键存在print(dic['five'])  #键不存在88Traceback (most recent call last):    File "C:\Users\mozhiyan\Desktop\demo.py", line 4, in <module>        print(dic['five'])  #键不存在KeyError: 'five'
    ```

  - 除了上面这种方式外，Python 更推荐使用 dict 类型提供的 get() 方法来获取指定键对应的值。当指定的键不存在时，get() 方法不会抛出异常。

    ```
    dictname.get(key[,default])
    ```

    - key 表示指定的键；default 用于指定要查询的键不存在时，此方法返回的默认值，如果不手动指定，会返回 None。

      ```
      a = dict(two=0.65, one=88, three=100, four=-59)print( a.get('one') )88
      ```

    - 当键不存在时，get() 返回空值 None，如果想明确地提示用户该键不存在，那么可以手动设置 get() 的第二个参数

      ```
      a = dict(two=0.65, one=88, three=100, four=-59)print( a.get('five', '该键不存在') )该键不存在
      ```

  - 和删除列表、元组一样，手动删除字典也可以使用 del 关键字

###### 字典基本操作

- 由于字典属于可变序列，所以我们可以任意操作字典中的键值对（key-value）。[Python](http://c.biancheng.net/python/) 中，常见的字典操作有以下几种：

  - 向现有字典中添加新的键值对。
  - 修改现有字典中的键值对。
  - 从现有字典中删除指定的键值对。
  - 判断现有字典中是否存在指定的键值对。

- 字典是由一个一个的 key-value 构成的，key 是找到数据的关键，Python 对字典的操作都是通过 key 来完成的。

- 为字典添加新的键值对很简单，直接给不存在的 key 赋值即可

  ```
  dictname[key] = value
  ```

- Python 字典中键（key）的名字不能被修改，我们只能修改值（value）。字典中各元素的键必须是唯一的，因此，如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的。

- 如果要删除字典中的键值对，还是可以使用 del 语句

  ```
  # 使用del语句删除键值对a = {'数学': 95, '语文': 89, '英语': 90}del a['语文']del a['数学']print(a){'英语': 90}
  ```

- 如果要判断字典中是否存在指定键值对，首先应判断字典中是否有对应的键。判断字典是否包含指定键值对的键，可以使用 in 或 not in 运算符。对于 dict 而言，in 或 not in 运算符都是基于 key 来判断的。

  ```
  a = {'数学': 95, '语文': 89, '英语': 90}# 判断 a 中是否包含名为'数学'的keyprint('数学' in a) # True# 判断 a 是否包含名为'物理'的keyprint('物理' in a) # FalseTrueFalse
  ```

  - 通过 in（或 not in）运算符，我们可以很轻易地判断出现有字典中是否包含某个键，如果存在，由于通过键可以很轻易的获取对应的值，因此很容易就能判断出字典中是否有指定的键值对。

###### dict字典方法

- [Python](http://c.biancheng.net/python/) 字典的数据类型为 dict，我们可使用 `dir(dict)` 来查看该类型包含哪些方法

  ```
  >>> dir(dict)['clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
  ```

- keys、values和items方法，将这三个方法放在一起介绍，是因为它们都用来获取字典中的特定数据：

  - keys() 方法用于返回字典中的所有键（key）；

  - values() 方法用于返回字典中所有键对应的值（value）；

  - items() 用于返回字典中所有的键值对（key-value）。

    ```
    scores = {'数学': 95, '语文': 89, '英语': 90}print(scores.keys())print(scores.values())print(scores.items())dict_keys(['数学', '语文', '英语'])dict_values([95, 89, 90])dict_items([('数学', 95), ('语文', 89), ('英语', 90)])
    ```

  - keys()、values() 和 items() 返回值的类型分别为 dict_keys、dict_values 和 dict_items。

- 在 Python 3.x 中如果想使用这三个方法返回的数据，一般有下面两种方案：

  - 使用 list() 函数，将它们返回的数据转换成列表

    ```
    a = {'数学': 95, '语文': 89, '英语': 90}b = list(a.keys())print(b)['数学', '语文', '英语']
    ```

  - 使用 for in 循环遍历它们的返回值

    ```
    a = {'数学': 95, '语文': 89, '英语': 90}
    for k in a.keys():
        print(k,end=' ')
    print("\n---------------")
    for v in a.values():
        print(v,end=' ')
    print("\n---------------")
    for k,v in a.items():
        print("key:",k," value:",v)
        
    数学 语文 英语
    ---------------
    95 89 90
    ---------------
    key: 数学  value: 95
    key: 语文  value: 89
    key: 英语  value: 90
    ```

- copy()方法，copy() 方法返回一个字典的拷贝，也即返回一个具有相同键值对的新字典

  ```
  a = {'one': 1, 'two': 2, 'three': [1,2,3]}
  b = a.copy()
  print(b)
  
  {'one': 1, 'two': 2, 'three': [1, 2, 3]}
  ```

  - copy() 方法所遵循的拷贝原理，既有深拷贝，也有浅拷贝。拿拷贝字典 a 为例，copy() 方法只会对最表层的键值对进行深拷贝，也就是说，它会再申请一块内存用来存放 {'one': 1, 'two': 2, 'three': []}；而对于某些列表类型的值来说，此方法对其做的是浅拷贝，也就是说，b 中的 [1,2,3] 的值不是自己独有，而是和 a 共有。

- update() 方法可以使用一个字典所包含的键值对来更新己有的字典。在执行 update() 方法时，如果被更新的字典中己包含对应的键值对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的键值对，则该键值对被添加进去。

  ```
  a = {'one': 1, 'two': 2, 'three': 3}
  a.update({'one':4.5, 'four': 9.3})
  print(a)
  
  {'one': 4.5, 'two': 2, 'three': 3, 'four': 9.3}
  ```

- pop() 和 popitem() 都用来删除字典中的键值对，不同的是，pop() 用来删除指定的键值对，而 popitem() 用来随机删除一个键值对

  ```
  dictname.pop(key)
  dictname.popitem()
  ```

  - 说 popitem() 随机删除字典中的一个键值对是不准确的，虽然字典是一种无须的列表，但键值对在底层也是有存储顺序的，popitem() 总是弹出底层中的最后一个 key-value，这和列表的 pop() 方法类似，都实现了[数据结构](http://c.biancheng.net/data_structure/)中“出栈”的操作。

- setdefault() 方法用来返回某个 key 对应的 value。

  ```
  dictname.setdefault(key, defaultvalue)
  ```

  - dictname 表示字典名称，key 表示键，defaultvalue 表示默认值（可以不写，不写的话是 None）。
  - 当指定的 key 不存在时，setdefault() 会先为这个不存在的 key 设置一个默认的 defaultvalue，然后再返回 defaultvalue。
  - 也就是说，setdefault() 方法总能返回指定 key 对应的 value：
    - 如果该 key 存在，那么直接返回该 key 对应的 value；
    - 如果该 key 不存在，那么先为该 key 设置默认的 defaultvalue，然后再返回该 key 对应的 defaultvalue。

##### set集合

- [Python](http://c.biancheng.net/python/) 中的集合，和数学中的集合概念一样，用来保存不重复的元素，即集合中的元素都是唯一的，互不相同。

- 从形式上看，和字典类似，Python 集合会将所有元素放在一对大括号 {} 中，相邻元素之间用“,”分隔

- 从内容上看，同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型，否则 Python 解释器会抛出 TypeError 错误

- 由于 Python 中的 set 集合是无序的，所以每次输出时元素的排序顺序可能都不相同。

- Python 中有两种集合类型，一种是 set 类型的集合，另一种是 frozenset 类型的集合，它们唯一的区别是，set 类型集合可以做添加、删除元素的操作，而 forzenset 类型集合不行。

- Python 提供了 2 种创建 set 集合的方法，分别是使用 {} 创建和使用 set() 函数将列表、元组等类型数据转换为集合。

  - 创建 set 集合可以像列表、元素和字典一样，直接将集合赋值给变量，从而实现创建集合的目的

    ```
    a = {1,'c',1,(1,2,3),'c'}print(a){1, 'c', (1, 2, 3)}
    ```

  - set() 函数为 Python 的内置函数，其功能是将字符串、列表、元组、range 对象等可迭代对象转换成集合

    ```
    setname = set(iteration)
    ```

    - iteration 就表示字符串、列表、元组、range 对象等数据。

  - 如果要创建空集合，只能使用 set() 函数实现。因为直接使用一对 {}，Python 解释器会将其视为一个空字典。

- 由于集合中的元素是无序的，因此无法向列表那样使用下标访问元素。Python 中，访问集合元素最常用的方法是使用循环结构，将集合中的数据逐一读取出来。

- 和其他序列类型一样，也可以使用 del() 语句来删除集合

- Python set 集合最常用的操作是向集合中添加、删除元素，以及集合之间做交集、并集、差集等运算

  - set 集合中添加元素，可以使用 set 类型提供的 add() 方法实现，使用 add() 方法添加的元素，只能是数字、字符串、元组或者布尔类型（True 和 False）值，不能添加列表、字典、集合这类可变的数据
  - 删除现有 set 集合中的指定元素，可以使用 remove() 方法，使用此方法删除集合中元素，需要注意的是，如果被删除元素本就不包含在集合中，则此方法会抛出 KeyError 错误。如果我们不想在删除失败时令解释器提示 KeyError 错误，还可以使用 discard() 方法，此方法和 remove() 方法的用法完全相同，唯一的区别就是，当删除集合中元素失败时，此方法不会抛出任何错误。

  | 运算操作 | Python运算符 | 含义                              | 例子                                        |
  | -------- | ------------ | --------------------------------- | ------------------------------------------- |
  | 交集     | &            | 取两集合公共的元素                | >>> set1 & set2 {3}                         |
  | 并集     | \|           | 取两集合全部的元素                | >>> set1 \| set2 {1,2,3,4,5}                |
  | 差集     | -            | 取一个集合中另一集合没有的元素    | >>> set1 - set2 {1,2} >>> set2 - set1 {4,5} |
  | 对称差集 | ^            | 取集合 A 和 B 中不属于 A&B 的元素 | >>> set1 ^ set2 {1,2,4,5}                   |

- 通过 dir(set) 命令可以查看它有哪些方法

- set 集合是可变序列，程序可以改变序列中的元素；frozenset 集合是不可变序列，程序不能改变序列中的元素。set 集合中所有能改变集合本身的方法，比如 remove()、discard()、add() 等，frozenset 都不支持；set 集合中不改变集合本身的方法，fronzenset 都支持。

  - 两种情况下可以使用 fronzenset：
    - 当集合的元素不需要改变时，我们可以使用 fronzenset 替代 set，这样更加安全。
    - 有时候程序要求必须是不可变对象，这个时候也要使用 fronzenset 替代 set。比如，字典（dict）的键（key）就要求是不可变对象。

  ```
  s = {'Python', 'C', 'C++'}fs = frozenset(['Java', 'Shell'])s_sub = {'PHP', 'C#'}#向set集合中添加frozensets.add(fs)print('s =', s)#向为set集合添加子set集合s.add(s_sub)print('s =', s)
  ```

  - set 集合本身的元素必须是不可变的， 所以 set 的元素不能是 set，只能是 frozenset。第 6 行代码向 set 中添加 frozenset 是没问题的，因为 frozenset 是不可变的；但是，第 10 行代码中尝试向 set 中添加子 set，这是不允许的，因为 set 是可变的。

#### 字符串

###### 字符串拼接

- 在 [Python](http://c.biancheng.net/python/) 中拼接（连接）字符串很简单，可以直接将两个字符串紧挨着写在一起，这种写法只能拼接字符串常量。如果需要使用变量，就得借助`+`运算符来拼接，当然，`+`运算符也能拼接字符串常量。

  ```
  name = "C++教程"url = "http://c.biancheng.net/cplus/"info = name + "的网址是：" + urlprint(info)C++教程的网址是：http://c.biancheng.net/cplus/
  ```

- 在很多应用场景中，我们需要将字符串和数字拼接在一起，而 Python 不允许直接拼接数字和字符串，所以我们必须先将数字转换成字符串。可以借助 str() 和 repr() 函数将数字转换为字符串

  ```
  str(obj)repr(obj)
  ```

  - obj 表示要转换的对象，它可以是数字、列表、元组、字典等多种类型的数据。

  - str() 和 repr() 函数虽然都可以将数字转换成字符串，但它们之间是有区别的：

    - str() 用于将数据转换成适合人类阅读的字符串形式。
    - repr() 用于将数据转换成适合解释器阅读的字符串形式（Python 表达式的形式），适合在开发和调试阶段使用；如果没有等价的语法，则会发生 SyntaxError 异常。

    ```
    s = "http://c.biancheng.net/shell/"s_str = str(s)s_repr = repr(s)print( type(s_str) )print (s_str)print( type(s_repr) )print (s_repr)<class 'str'>http://c.biancheng.net/shell/<class 'str'>'http://c.biancheng.net/shell/'s 本身就是一个字符串，但是我们依然使用 str() 和 repr() 对它进行了转换。从运行结果可以看出，str() 保留了字符串最原始的样子，而 repr() 使用引号将字符串包围起来，这就是 Python 字符串的表达式形式。
    ```

    - 在 Python 交互式编程环境中输入一个表达式（变量、加减乘除、逻辑运算等）时，Python 会自动使用 repr() 函数处理该表达式。

###### 截取字符串

- 字符串是由多个字符构成的，字符之间是有顺序的，这个顺序号就称为索引（index）。[Python](http://c.biancheng.net/python/) 允许通过索引来操作字符串中的单个或者多个字符，比如获取指定索引处的字符，返回指定字符的索引值等。

- 获取单个字符，知道字符串名字以后，在方括号`[ ]`中使用索引即可访问对应的字符

  - Python 允许从字符串的两端使用索引：
    - 当以字符串的左端（字符串的开头）为起点时，索引是从 0 开始计数的；字符串的第一个字符的索引为 0，第二个字符的索引为 1，第三个字符串的索引为 2 ……
    - 当以字符串的右端（字符串的末尾）为起点时，索引是从 -1 开始计数的；字符串的倒数第一个字符的索引为 -1，倒数第二个字符的索引为 -2，倒数第三个字符的索引为 -3 ……

- 获取多个字符，使用`[ ]`除了可以获取单个字符外，还可以指定一个范围来获取多个字符，也就是一个子串或者片段

  ```
  strname[start : end : step]
  ```

  - start：表示要截取的第一个字符所在的索引（截取时包含该字符）。如果不指定，默认为 0，也就是从字符串的开头截取；
  - end：表示要截取的最后一个字符所在的索引（截取时不包含该字符）。如果不指定，默认为字符串的长度；
  - step：指的是从 start 索引处的字符开始，每 step 个距离获取一个字符，直至 end 索引出的字符。step 默认值为 1，当省略该值时，最后一个冒号也可以省略。

###### 获取字符串长度

- 要想知道一个字符串有多少个字符（获得字符串长度），或者一个字符串占用多少个字节，可以使用 len 函数。

- 在实际开发中，除了常常要获取字符串的长度外，有时还要获取字符串的字节数。在 Python 中，不同的字符所占的字节数不同，数字、英文字母、小数点、下划线以及空格，各占一个字节，而一个汉字可能占 2~4 个字节，具体占多少个，取决于采用的编码方式。例如，汉字在 GBK/GB2312 编码中占用 2 个字节，而在 UTF-8 编码中一般占用 3 个字节。以 UTF-8 编码为例，字符串“人生苦短，我用Python”所占用的字节数如图 1 所示。

  ![](http://c.biancheng.net/uploads/allimg/190701/2-1ZF1140302452.gif)

- 我们可以通过使用 encode() 方法，将字符串进行编码后再获取它的字节数。例如，采用 UTF-8 编码方式，计算“人生苦短，我用Python”的字节数，可以执行如下代码：

  ```
  >>> str1 = "人生苦短，我用Python">>> len(str1.encode())27如果要获取采用 GBK 编码的字符串的长度>>> str1 = "人生苦短，我用Python">>> len(str1.encode('gbk'))20
  ```

###### split()分隔字符串

- 除了可以使用一些内建函数获取字符串的相关信息外（例如 len() 函数获取字符串长度），字符串类型本身也拥有一些方法供我们使用。

- split() 方法可以实现将一个字符串按照指定的分隔符切分成多个子串，这些子串会被保存到列表中（不包含分隔符），作为方法的返回值反馈回来。

  ```
  str.split(sep,maxsplit)
  ```

  - str：表示要进行分割的字符串；
  - sep：用于指定分隔符，可以包含多个字符。此参数默认为 None，表示所有空字符，包括空格、换行符“\n”、制表符“\t”等。
  - maxsplit：可选参数，用于指定分割的次数，最后列表中子串的个数最多为 maxsplit+1。如果不指定或者指定为 -1，则表示分割次数没有限制。

- 在 split 方法中，如果不指定 sep 参数，那么也不能指定 maxsplit 参数。同内建函数（如 len）的使用方式不同，字符串变量所拥有的方法，只能采用“字符串.方法名()”的方式调用

- 需要注意的是，在未指定 sep 参数时，split() 方法默认采用空字符进行分割，但当字符串中有连续的空格或其他空字符时，都会被视为一个分隔符对字符串进行分割

###### join()合并字符串

- join() 方法也是非常重要的字符串方法，它是 split() 方法的逆方法，用来将列表（或元组）中包含的多个字符串连接成一个字符串。

- 使用 join() 方法合并字符串时，它会将列表（或元组）中多个字符串采用固定的分隔符连接在一起。例如，字符串“c.biancheng.net”就可以看做是通过分隔符“.”将 ['c','biancheng','net'] 列表合并为一个字符串的结果。

  ```
  newstr = str.join(iterable)
  ```

  - newstr：表示合并后生成的新字符串；
  - str：用于指定合并时的分隔符；
  - iterable：做合并操作的源字符串数据，允许以列表、元组等形式提供。

  ```
  将列表中的字符串合并成一个字符串。>>> list = ['c','biancheng','net']>>> '.'.join(list)'c.biancheng.net'将元组中的字符串合并成一个字符串。>>> dir = '','usr','bin','env'>>> type(dir)<class 'tuple'>>>> '/'.join(dir)'/usr/bin/env'
  ```

###### count()统计字符串出现的次数

- count 方法用于检索指定字符串在另一字符串中出现的次数，如果检索的字符串不存在，则返回 0，否则返回出现的次数。

  ```
  str.count(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：表示要检索的字符串；
  - start：指定检索的起始位置，也就是从什么位置开始检测。如果不指定，默认从头开始检索；
  - end：指定检索的终止位置，如果不指定，则表示一直检索到结尾。

  ```
  检索字符串“c.biancheng.net”中“.”出现的次数。>>> str = "c.biancheng.net">>> str.count('.')2>>> str = "c.biancheng.net">>> str.count('.',1)2>>> str.count('.',2)1字符串中各字符对应的检索值，从 0 开始，因此，本例中检索值 1 对应的是第 2 个字符‘.’，从输出结果可以分析出，从指定索引位置开始检索，其中也包含此索引位置。>>> str = "c.biancheng.net">>> str.count('.',2,-3)1>>> str.count('.',2,-4)0
  ```

###### find()

- find() 方法用于检索字符串中是否包含目标字符串，如果包含，则返回第一次出现该字符串的索引；反之，则返回 -1。

  ```
  str.find(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：表示要检索的目标字符串；
  - start：表示开始检索的起始位置。如果不指定，则默认从头开始检索；
  - end：表示结束检索的结束位置。如果不指定，则默认一直检索到结尾。

- [Python](http://c.biancheng.net/python/) 还提供了 rfind() 方法，与 find() 方法最大的不同在于，rfind() 是从字符串右边开始检索

###### index()

- 同 find() 方法类似，index() 方法也可以用于检索是否包含指定的字符串，不同之处在于，当指定的字符串不存在时，index() 方法会抛出异常。

  ```
  str.index(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：表示要检索的子字符串；
  - start：表示检索开始的起始位置，如果不指定，默认从头开始检索；
  - end：表示检索的结束位置，如果不指定，默认一直检索到结尾。

- 同 find() 和 rfind() 一样，字符串变量还具有 rindex() 方法，其作用和 index() 方法类似，不同之处在于它是从右边开始检索

###### ljust()、rjust()、center()

- [Python](http://c.biancheng.net/python/) str 提供了 3 种可用来进行文本对齐的方法，分别是 ljust()、rjust() 和 center() 方法

- ljust() 方法的功能是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。

  ```
  S.ljust(width[, fillchar])
  ```

  - S：表示要进行填充的字符串；
  - width：表示包括 S 本身长度在内，字符串要占的总长度；
  - fillchar：作为可选参数，用来指定填充字符串时所用的字符，默认情况使用空格。

  ```
  S = 'http://c.biancheng.net/python/'addr = 'http://c.biancheng.net'print(S.ljust(35,'-'))print(addr.ljust(35,'-'))http://c.biancheng.net/python/-----http://c.biancheng.net-------------
  ```

- rjust() 和 ljust() 方法类似，唯一的不同在于，rjust() 方法是向字符串的左侧填充指定字符，从而达到右对齐文本的目的。

  ```
  S = 'http://c.biancheng.net/python/'addr = 'http://c.biancheng.net'print(S.rjust(35))print(addr.rjust(35))     http://c.biancheng.net/python/             http://c.biancheng.net   
  ```

  - 每行字符串都占用 35 个字节的位置，实现了整体的右对齐效果

- center() 字符串方法与 ljust() 和 rjust() 的用法类似，但它让文本居中，而不是左对齐或右对齐。

###### startswith() 和endswith() 

- startswith() 方法用于检索字符串是否以指定字符串开头，如果是返回 True；反之返回 False

  ```
  str.startswith(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：要检索的子串；
  - start：指定检索开始的起始位置索引，如果不指定，则默认从头开始检索；
  - end：指定检索的结束位置索引，如果不指定，则默认一直检索在结束。

  ```
  >>> str = "c.biancheng.net">>> str.startswith("c")True>>> str = "c.biancheng.net">>> str.startswith("http")False>>> str = "c.biancheng.net">>> str.startswith("b",2)True
  ```

- endswith() 方法用于检索字符串是否以指定字符串结尾，如果是则返回 True；反之则返回 False

###### 大小写转换

- 为了方便对字符串中的字母进行大小写转换，字符串变量提供了 3 种方法，分别是 title()、lower() 和 upper()。

- title() 方法用于将字符串中每个单词的首字母转为大写，其他字母全部转为小写，转换完成后，此方法会返回转换得到的字符串。如果字符串中没有需要被转换的字符，此方法会将字符串原封不动地返回。

  ```
  >>> str = "c.biancheng.net">>> str.title()'C.Biancheng.Net'>>> str = "I LIKE C">>> str.title()'I Like C'
  ```

- lower() 方法用于将字符串中的所有大写字母转换为小写字母，转换完成后，该方法会返回新得到的字符串。如果字符串中原本就都是小写字母，则该方法会返回原字符串。

  ```
  >>> str = "I LIKE C">>> str.lower()'i like c'
  ```

- upper() 的功能和 lower() 方法恰好相反，它用于将字符串中的所有小写字母转换为大写字母，和以上两种方法的返回方式相同，即如果转换成功，则返回新字符串；反之，则返回原字符串。

###### 去除空格

- 用户输入数据时，很有可能会无意中输入多余的空格，或者在一些场景中，字符串前后不允许出现空格和特殊字符，此时就需要去除字符串中的空格和特殊字符。这里的特殊字符，指的是制表符（\t）、回车符（\r）、换行符（\n）等。

- [Python](http://c.biancheng.net/python/) 中，字符串变量提供了 3 种方法来删除字符串中多余的空格和特殊字符，它们分别是：

  1. strip()：删除字符串前后（左右两侧）的空格或特殊字符。
  2. lstrip()：删除字符串前面（左边）的空格或特殊字符。
  3. rstrip()：删除字符串后面（右边）的空格或特殊字符。

- Python 的 str 是不可变的（不可变的意思是指，字符串一旦形成，它所包含的字符序列就不能发生任何改变），因此这三个方法只是返回字符串前面或后面空白被删除之后的副本，并不会改变字符串本身。

- strip() 方法用于删除字符串左右两个的空格和特殊字符

  ```
  str.strip([chars])
  ```

  - str 表示原字符串，[chars] 用来指定要删除的字符，可以同时指定多个，如果不手动指定，则默认会删除空格以及制表符、回车符、换行符等特殊字符。

  ```
  >>> str = "  c.biancheng.net \t\n\r">>> str.strip()'c.biancheng.net'>>> str.strip(" ,\r")'c.biancheng.net \t\n'>>> str'  c.biancheng.net \t\n\r'通过 strip() 确实能够删除字符串左右两侧的空格和特殊字符，但并没有真正改变字符串本身。
  ```

- lstrip() 方法用于去掉字符串左侧的空格和特殊字符

- rstrip() 方法用于删除字符串右侧的空格和特殊字符

###### format()格式化

- 前面章节介绍了如何使用 % 操作符对各种类型的数据进行格式化输出，这是早期 [Python](http://c.biancheng.net/python/) 提供的方法。自 Python 2.6 版本开始，字符串类型（str）提供了 format() 方法对字符串进行格式化

  ```
  str.format(args)
  ```

  - str 用于指定字符串的显示样式；args 用于指定要进行格式转换的项，如果有多项，之间有逗号进行分割。

- 学习 format() 方法的难点，在于搞清楚 str 显示样式的书写格式。在创建显示样式模板时，需要使用`{}`和`：`来指定占位符，其完整的语法格式为：

  ```
  { [index][ : [ [fill] align] [sign] [#] [width] [.precision] [type] ] }
  ```

  - 格式中用 [] 括起来的参数都是可选参数，即可以使用，也可以不使用。各个参数的含义如下：

    - index：指定：后边设置的格式要作用到 args 中第几个数据，数据的索引值从 0 开始。如果省略此选项，则会根据 args 中数据的先后顺序自动分配。
    - fill：指定空白处填充的字符。注意，当填充字符为逗号(,)且作用于整数或浮点数时，该整数（或浮点数）会以逗号分隔的形式输出，例如（1000000会输出 1,000,000）。
    - align：指定数据的对齐方式

    | align | 含义                                                         |
    | ----- | ------------------------------------------------------------ |
    | <     | 数据左对齐。                                                 |
    | >     | 数据右对齐。                                                 |
    | =     | 数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对数字类型有效。 |
    | ^     | 数据居中，此选项需和 width 参数一起使用。                    |

    - sign：指定有无符号数

    | sign参数 | 含义                                                         |
    | -------- | ------------------------------------------------------------ |
    | +        | 正数前加正号，负数前加负号。                                 |
    | -        | 正数前不加正号，负数前加负号。                               |
    | 空格     | 正数前加空格，负数前加负号。                                 |
    | #        | 对于二进制数、八进制数和十六进制数，使用此参数，各进制数前会分别显示 0b、0o、0x前缀；反之则不显示前缀。 |

    - width：指定输出数据时所占的宽度。
    - .precision：指定保留的小数位数。
    - type：指定输出数据的具体类型

    | type类型值 | 含义                                                  |
    | ---------- | ----------------------------------------------------- |
    | s          | 对字符串类型格式化。                                  |
    | d          | 十进制整数。                                          |
    | c          | 将十进制整数自动转换成对应的 Unicode 字符。           |
    | e 或者 E   | 转换成科学计数法后，再格式化输出。                    |
    | g 或 G     | 自动在 e 和 f（或 E 和 F）中切换。                    |
    | b          | 将十进制数自动转换成二进制表示，再格式化输出。        |
    | o          | 将十进制数自动转换成八进制表示，再格式化输出。        |
    | x 或者 X   | 将十进制数自动转换成十六进制表示，再格式化输出。      |
    | f 或者 F   | 转换为浮点数（默认小数点后保留 6 位），再格式化输出。 |
    | %          | 显示百分比（默认显示小数点后 6 位）。                 |

```
str="网站名称：{:>9s}\t网址：{:s}"print(str.format("C语言中文网","c.biancheng.net"))Traceback (most recent call last):  File "C:\Users\mengma\Desktop\1.py", line 2, in    print(str.format("C语言中文网","c.biancheng.net"))ValueError: cannot switch from automatic field numbering to manual field specification在实际开发中，数值类型有多种显示需求，比如货币形式、百分比形式等，使用 format() 方法可以将数值格式化为不同的形式。#以货币形式显示print("货币形式：{:,d}".format(1000000))#科学计数法表示print("科学计数法：{:E}".format(1200.12))#以十六进制表示print("100的十六进制：{:#x}".format(100))#输出百分比形式print("0.01的百分比表示：{:.0%}".format(0.01))货币形式：1,000,000科学计数法：1.200120E+03100的十六进制：0x640.01的百分比表示：1%
```

###### encode() 和 decode()

- 在 Python 中，有 2 种常用的字符串类型，分别为 str 和 bytes 类型，其中 str 用来表示 Unicode 字符，bytes 用来表示二进制数据。str 类型和 bytes 类型之间就需要使用 encode() 和 decode() 方法进行转换。

- encode() 方法为字符串类型（str）提供的方法，用于将 str 类型转换成 bytes 类型，这个过程也称为“编码”。

  ```
  str.encode([encoding="utf-8"][,errors="strict"])
  ```

| 参数               | 含义                                                         |
| ------------------ | ------------------------------------------------------------ |
| str                | 表示要进行转换的字符串。                                     |
| encoding = "utf-8" | 指定进行编码时采用的字符编码，该选项默认采用 utf-8 编码。例如，如果想使用简体中文，可以设置 gb2312。  当方法中只使用这一个参数时，可以省略前边的“encoding=”，直接写编码格式，例如 str.encode("UTF-8")。 |
| errors = "strict"  | 指定错误处理方式，其可选择值可以是：strict：遇到非法字符就抛出异常。ignore：忽略非法字符。replace：用“？”替换非法字符。xmlcharrefreplace：使用 xml 的字符引用。该参数的默认值为 strict。 |

```
>>> str = "C语言中文网">>> str.encode()b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x91'
```

- 和 encode() 方法正好相反，decode() 方法用于将 bytes 类型的二进制数据转换为 str 类型，这个过程也称为“解码”。

  ```
  bytes.decode([encoding="utf-8"][,errors="strict"])
  ```

###### dir()和help()

- [Python](http://c.biancheng.net/python/) dir() 函数用来列出某个类或者某个模块中的全部内容，包括变量、方法、函数和类等

  ```
  dir(obj)
  ```

  - obj 表示要查看的对象。obj 可以不写，此时 dir() 会列出当前范围内的变量、方法和定义的类型。

- Python help() 函数用来查看某个函数或者模块的帮助文档

  ```
  help(obj)
  ```

- 在 Python 标准库中，以`__`开头和结尾的方法都是私有的，不能在类的外部调用。

  ```
  使用 help() 查看 str 类型中 lower() 函数的用法：>>> help(str.lower)Help on method_descriptor:lower(self, /)    Return a copy of the string converted to lowercase.
  ```

  - 使用 help() 查看某个函数的用法时，函数名后边不能带括号，例如将上面的命令写作`help(str.lower())`就是错误的。

#### 流程控制

- 在其他语言中（如 C语言、[C++](http://c.biancheng.net/cplus/)、[Java](http://c.biancheng.net/java/) 等），选择结构还包括 switch 语句，也可以实现多重选择，但是在 Python 中没有 switch 语句，所以当要实现多重选择的功能时，只能使用 if else 分支语句。if   elif   else

- 布尔类型（bool）只有两个值，分别是 True 和 False，Python 会把 True 当做“真”，把 False 当做“假”。对于数字，Python 会把 0 和 0.0 当做“假”，把其它值当做“真”。对于其它类型，当对象为空或者为 None 时，Python 会把它们当做“假”，其它情况当做真。

  ```
  ""  #空字符串[ ]  #空列表( )  #空元组{ }  #空字典None  #空值
  ```

- 对于没有 return 语句的函数，返回值为空，也即 None。

###### Pass

- 在实际开发中，有时候我们会先搭建起程序的整体逻辑结构，但是暂时不去实现某些细节，而是在这些地方加一些注释，方面以后再添加代码

  ```
  age = int( input("请输入你的年龄：") )if age < 12 :    print("婴幼儿")elif age >= 12 and age < 18:    print("青少年")elif age >= 18 and age < 30:    print("成年人")elif age >= 30 and age < 50:    #TODO: 成年人else:    print("老年人")
  ```

  - 当年龄大于等于 30 并且小于 50 时，我们没有使用 print() 语句，而是使用了一个注释，希望以后再处理成年人的情况。当 [Python](http://c.biancheng.net/python/) 执行到该 elif 分支时，会跳过注释，什么都不执行。

  - 但是 Python 提供了一种更加专业的做法，就是空语句 pass。**pass** 是 Python 中的关键字，用来让解释器跳过此处，什么都不做。

  - 就像上面的情况，有时候程序需要占一个位置，或者放一条语句，但又不希望这条语句做任何事情，此时就可以通过 pass 语句来实现。使用 pass 语句比使用注释更加优雅。

    ```
    age = int( input("请输入你的年龄：") )if age < 12 :    print("婴幼儿")elif age >= 12 and age < 18:    print("青少年")elif age >= 18 and age < 30:    print("成年人")elif age >= 30 and age < 50:    passelse:    print("老年人")
    ```

###### Assert断言函数

- [Python](http://c.biancheng.net/python/) assert 语句，又称断言语句，可以看做是功能缩小版的 if 语句，它用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报 AssertionError 错误。

  ```
  assert 表达式assert 语句的执行流程可以用 if 判断语句表示if 表达式==True:    程序继续执行else:    程序报 AssertionError 错误
  ```

  - 有读者可能会问，明明 assert 会令程序崩溃，为什么还要使用它呢？这是因为，与其让程序在晚些时候崩溃，不如在错误条件出现时，就直接让程序崩溃，这有利于我们对程序排错，提高程序的健壮性。
  - 因此，assert 语句通常用于检查用户的输入是否符合规定，还经常用作程序初期测试和调试过程中的辅助工具。

  ```
  mathmark = int(input())#断言数学考试分数是否位于正常范围内assert 0 <= mathmark <= 100#只有当 mathmark 位于 [0,100]范围内，程序才会继续执行print("数学考试分数为：",mathmark)90数学考试分数为： 90再次运行159Traceback (most recent call last):  File "C:\Users\mengma\Desktop\file.py", line 3, in <module>    assert 0 <= mathmark <= 100AssertionError
  ```

  - 当 assert 语句后的表达式值为真时，程序继续执行；反之，程序停止执行，并报 AssertionError 错误。

- 另外，在实际工作中，assert 还有一些很常见的用法

  ```
  def func(input):    assert isinstance(input, list), '输入内容必须是列表'    # 下面的操作都是基于前提：input 必须是 list    if len(input) == 1:        ...    elif len(input) == 2:        ...    else:        ...
  ```

  - 上面代码中，func() 函数中的所有操作都基于输入必须是列表这个前提。所以很有必要在开头加一句 assert 的检查，防止程序出错。

- assert 的检查是可以被关闭的，比如在命令行模式下运行 Python 程序时，加入 -O 选项就可以使程序中的 assert 失效。一旦 assert 失效，其包含的语句也就不会被执行。

###### 循环结构while

- 除了数字，while 循环还常用来遍历列表、元组和字符串，因为它们都支持通过下标索引获取指定位置的元素

  ```
  my_char="http://c.biancheng.net/python/"
  i = 0;
  while i<len(my_char):
      print(my_char[i],end="")
      i = i + 1
      
  http://c.biancheng.net/python/
  ```

###### for循环

- for 循环，它常用于遍历字符串、列表、元组、字典、集合等序列类型，逐个获取序列中的各个元素。

  ```
  for 迭代变量 in 字符串|列表|元组|字典|集合：
      代码块
  ```

  - 格式中，迭代变量用于存放从序列类型变量中读取出来的元素，所以一般不会在循环中对迭代变量手动赋值；代码块指的是具有相同缩进格式的多行代码（和 while 一样），由于和循环结构联用，因此代码块又称为循环体。

  ```
  add = "http://c.biancheng.net/python/"
  #for循环，遍历 add 字符串
  for ch in add:
      print(ch,end="")
      
  http://c.biancheng.net/python/
  ```

  - 使用 for 循环遍历 add 字符串的过程中，迭代变量 ch 会先后被赋值为 add 字符串中的每个字符，并代入循环体中使用。只不过例子中的循环体比较简单，只有一行输出语句。

- 在使用 for 循环时，最基本的应用就是进行数值循环。比如说，想要实现从 1 到 100 的累加

  ```
  print("计算 1+2+...+100 的结果为：")
  #保存累加结果的变量
  result = 0
  #逐个获取从 1 到 100 这些值，并做累加操作
  for i in range(101):
      result += i
  print(result)
  ```

  - 上面代码中，使用了 range() 函数，此函数是 Python 内置函数，用于生成一系列连续整数，多用于 for 循环中。

- 当用 for 循环遍历 list 列表或者 tuple 元组时，其迭代变量会先后被赋值为列表或元组中的每个元素并执行一次循环体。

  ```
  my_list = [1,2,3,4,5]for ele in my_list:    print('ele =', ele)    ele = 1ele = 2ele = 3ele = 4ele = 5
  ```

- 在使用 for 循环遍历字典时，经常会用到和字典相关的 3 个方法，即 items()、keys() 以及 values()，它们各自的用法已经在前面章节中讲过，这里不再赘述。当然，如果使用 for 循环直接遍历字典，则迭代变量会被先后赋值为每个键值对中的键。

  ```
  my_dic = {'python教程':"http://c.biancheng.net/python/",\          'shell教程':"http://c.biancheng.net/shell/",\          'java教程':"http://c.biancheng.net/java/"}for ele in my_dic.items():    print('ele =', ele)    ele = ('python教程', 'http://c.biancheng.net/python/')ele = ('shell教程', 'http://c.biancheng.net/shell/')ele = ('java教程', 'http://c.biancheng.net/java/')
  ```

- 使用 for 循环实现用冒泡排序算法对 [5,8,4,1] 进行排序：

  ```
  data = [5,8,4,1]#实现冒泡排序for i in range(len(data)-1):    for j in range(len(data)-i-1):        if(data[j]>data[j+1]):            data[j],data[j+1] = data[j+1],data[j]print("排序后：",data)
  ```

###### 推导式快速初始化各种序列

- 推导式（又称解析器），是 Python 独有的一种特性。使用推导式可以快速生成列表、元组、字典以及集合类型的数据，因此推导式又可细分为列表推导式、元组推导式、字典推导式以及集合推导式。

- 列表推导式，列表推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的列表。

  ```
  [表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ]
  ```

  - [if 条件表达式] 不是必须的，可以使用，也可以省略。

  - 通过列表推导式的语法格式，明显会感觉到它和 for 循环存在某些关联。其实，除去 [if 条件表达式] 部分，其余各部分的含义以及执行顺序和 for 循环是完全一样的（表达式其实就是 for 循环中的循环体），即它的执行顺序如下所示：

    ```
    for 迭代变量 in 可迭代对象    表达式
    ```

  - 初学者可以这样认为，它只是对 for 循环语句的格式做了一下简单的变形，并用 [] 括起来而已，只不过最大的不同之处在于，列表推导式最终会将循环过程中，计算表达式得到的一系列值组成一个列表。

    ```
    a_range = range(10)# 对a_range执行for表达式a_list = [x * x for x in a_range]# a_list集合包含10个元素print(a_list)[0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64, 81]我们还可以在列表推导式中添加 if 条件语句，这样列表推导式将只迭代那些符合条件的元素b_list = [x * x for x in a_range if x % 2 == 0]# a_list集合包含5个元素print(b_list)[0 ,4 , 16, 36, 64]
    ```

  - 以上所看到的列表推导式都只有一个循环，实际上它可使用多个循环，就像嵌套循环一样。

    ```
    d_list = [(x, y) for x in range(5) for y in range(4)]# d_list列表包含20个元素print(d_list)上面代码中，x 是遍历 range(5) 的迭代变量（计数器），因此该 x 可迭代 5 次；y 是遍历 range(4) 的计数器，因此该 y 可迭代 4 次。因此，该（x,y）表达式一共会迭代 20 次。上面的 for 表达式相当于如下嵌套循环：dd_list = []for x in range(5):    for y in range(4):        dd_list.append((x, y))        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3)]
    ```

  - 对于包含多个循环的 for 表达式，同样可指定 if 条件。假如我们有一个需求：程序要将两个列表中的数值按“能否整除”的关系配对在一起。比如 src_a 列表中包含 30，src_b 列表中包含 5，其中 30 可以整除 5，那么就将 30 和 5 配对在一起。对于上面的需求使用 for 表达式来实现非常简单，例如如下代码：

    ```
    src_a = [30, 12, 66, 34, 39, 78, 36, 57, 121]src_b = [3, 5, 7, 11]# 只要y能整除x，就将它们配对在一起result = [(x, y) for x in src_b for y in src_a if y % x == 0]print(result)[(3, 30), (3, 12), (3, 66), (3, 39), (3, 78), (3, 36), (3, 57), (5, 30), (11, 66), (11, 121)]
    ```

- 元组推导式，元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。通过和列表推导式做对比，你会发现，除了元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是 []，其它完全相同。不仅如此，元组推导式和列表推导式的用法也完全相同。

  ```
  a = (x for x in range(1,10))print(a)<generator object <genexpr> at 0x0000020BAD136620>从上面的执行结果可以看出，使用元组推导式生成的结果并不是一个元组，而是一个生成器对象（后续会介绍），这一点和列表推导式是不同的。
  ```

  - 如果我们想要使用元组推导式获得新元组或新元组中的元素，有以下三种方式：

    - 使用 tuple() 函数，可以直接将生成器对象转换成元组

      ```
      a = (x for x in range(1,10))print(tuple(a))运行结果为：(1, 2, 3, 4, 5, 6, 7, 8, 9)
      ```

    - 直接使用 for 循环遍历生成器对象，可以获得各个元素

      ```
      a = (x for x in range(1,10))for i in a:    print(i,end=' ')print(tuple(a))1 2 3 4 5 6 7 8 9 ()
      ```

    - 使用 __next__() 方法遍历生成器对象，也可以获得各个元素

      ```
      a = (x for x in range(3))print(a.__next__())print(a.__next__())print(a.__next__())a = tuple(a)print("转换后的元组：",a)012转换后的元组： ()
      ```

  - 无论是使用 for 循环遍历生成器对象，还是使用 __next__() 方法遍历生成器对象，遍历后原生成器对象将不复存在，这就是遍历后转换原生成器对象却得到空元组的原因。

- 字典推导式

  ```
  {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}
  ```

  ```
  listdemo = ['C语言中文网','c.biancheng.net']#将列表中各字符串值为键，各字符串的长度为值，组成键值对newdict = {key:len(key) for key in listdemo}print(newdict){'C语言中文网': 6, 'c.biancheng.net': 15}交换现有字典中各键值对的键和值。olddict={'C语言中文网': 6, 'c.biancheng.net': 15}newdict = {v: k for k, v in olddict.items()}print(newdict){6: 'C语言中文网', 15: 'c.biancheng.net'}
  ```

- 集合推导式

  ```
  { 表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] }
  ```

  - 有读者可能会问，集合推导式和字典推导式的格式完全相同，那么给定一个类似的推导式，如何判断是哪种推导式呢？最简单直接的方式，就是根据表达式进行判断，如果表达式以键值对（key：value）的形式，则证明此推导式是字典推导式；反之，则是集合推导式。
  - 既然生成的是集合，那么其保存的元素必须是唯一的。

###### zip函数

- zip() 函数是 [Python](http://c.biancheng.net/python/) 内置函数之一，它可以将多个序列（列表、元组、字典、集合、字符串以及 range() 区间构成的列表）“压缩”成一个 zip 对象。所谓“压缩”，其实就是将这些序列中对应位置的元素重新组合，生成一个个新的元组。

  ```
  zip(iterable, ...)
  ```

  - 其中 iterable,... 表示多个列表、元组、字典、集合、字符串，甚至还可以为 range() 区间。

    ```
    my_list = [11,12,13]my_tuple = (21,22,23)print([x for x in zip(my_list,my_tuple)])my_dic = {31:2,32:4,33:5}my_set = {41,42,43,44}print([x for x in zip(my_dic)])my_pychar = "python"my_shechar = "shell"print([x for x in zip(my_pychar,my_shechar)])[(11, 21), (12, 22), (13, 23)][(31,), (32,), (33,)][('p', 's'), ('y', 'h'), ('t', 'e'), ('h', 'l'), ('o', 'l')]
    ```

    - 读者分析以上的程序和相应的输出结果不难发现，在使用 zip() 函数“压缩”多个序列时，它会分别取各序列中第 1 个元素、第 2 个元素、... 第 n 个元素，各自组成新的元组。需要注意的是，当多个序列中元素个数不一致时，会以最短的序列为准进行压缩。

  - 对于 zip() 函数返回的 zip 对象，既可以像上面程序那样，通过遍历提取其存储的元组，也可以向下面程序这样，通过调用 list() 函数将 zip() 对象强制转换成列表：

    ```
    my_list = [11,12,13]my_tuple = (21,22,23)print(list(zip(my_list,my_tuple)))
    ```

###### reversed函数

- reserved() 是 Pyton 内置函数之一，其功能是对于给定的序列（包括列表、元组、字符串以及 range(n) 区间），该函数可以返回一个逆序序列的迭代器（用于遍历该逆序序列）。

  ```
  reversed(seq)
  ```

  - seq 可以是列表，元素，字符串以及 range() 生成的区间列表。

  ```
  #将列表进行逆序print([x for x in reversed([1,2,3,4,5])])#将元组进行逆序print([x for x in reversed((1,2,3,4,5))])#将字符串进行逆序print([x for x in reversed("abcdefg")])#将 range() 生成的区间列表进行逆序print([x for x in reversed(range(10))])[5, 4, 3, 2, 1][5, 4, 3, 2, 1]['g', 'f', 'e', 'd', 'c', 'b', 'a'][9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
  ```

- 除了使用列表推导式的方式，还可以使用 list() 函数，将 reversed() 函数逆序返回的迭代器，直接转换成列表

  ```
  #将列表进行逆序print(list(reversed([1,2,3,4,5])))[5, 4, 3, 2, 1]
  ```

- 再次强调，使用 reversed() 函数进行逆序操作，并不会修改原来序列中元素的顺序

###### sorted函数

- sorted() 作为 [Python](http://c.biancheng.net/python/) 内置函数之一，其功能是对序列（列表、元组、字典、集合、还包括字符串）进行排序。

  ```
  list = sorted(iterable, key=None, reverse=False)  
  ```

  - iterable 表示指定的序列，key 参数可以自定义排序规则；reverse 参数指定以升序（False，默认）还是降序（True）进行排序。sorted() 函数会返回一个排好序的列表。

    ```
    #对列表进行排序a = [5,3,4,2,1]print(sorted(a))#对元组进行排序a = (5,4,3,1,2)print(sorted(a))#字典默认按照key进行排序a = {4:1,\     5:2,\     3:3,\     2:6,\     1:8}print(sorted(a.items()))#对集合进行排序a = {1,5,3,2,4}print(sorted(a))#对字符串进行排序a = "51423"print(sorted(a))[1, 2, 3, 4, 5][1, 2, 3, 4, 5][(1, 8), (2, 6), (3, 3), (4, 1), (5, 2)][1, 2, 3, 4, 5]['1', '2', '3', '4', '5']
    ```

- 使用 sorted() 函数对序列进行排序， 并不会在原序列的基础进行修改，而是会重新生成一个排好序的列表。

- sorted(）函数默认对序列中元素进行升序排序，通过手动将其 reverse 参数值改为 True，可实现降序排序

- 另外在调用 sorted() 函数时，还可传入一个 key 参数，它可以接受一个函数，该函数的功能是指定 sorted() 函数按照什么标准进行排序

  ```
  chars=['http://c.biancheng.net',\       'http://c.biancheng.net/python/',\       'http://c.biancheng.net/shell/',\       'http://c.biancheng.net/java/',\       'http://c.biancheng.net/golang/']#默认排序print(sorted(chars))#自定义按照字符串长度排序print(sorted(chars,key=lambda x:len(x)))
  ```

#### 函数和lambda表达式

- 在创建函数时，即使函数不需要参数，也必须保留一对空的“()”，否则 Python 解释器将提示“invaild syntax”错误。另外，如果想定义一个没有任何功能的空函数，可以使用 pass 语句作为占位符。

- 通过调用 Python 的 help() 内置函数或者 __doc__ 属性，我们可以查看某个函数的使用说明文档。事实上，无论是 Python 提供给我们的函数，还是自定义的函数，其说明文档都需要设计该函数的程序员自己编写。其实，函数的说明文档，本质就是一段字符串，只不过作为说明文档，字符串的放置位置是有讲究的，函数的说明文档通常位于函数内部、所有代码的最前面。

  ```
  #定义一个比较字符串大小的函数def str_max(str1,str2):    '''    比较 2 个字符串的大小    '''    str = str1 if str1 > str2 else str2    return strhelp(str_max)#print(str_max.__doc__)Help on function str_max in module __main__:str_max(str1, str2)    比较 2 个字符串的大小
  ```

  - 上面程序中，还可以使用 __doc__ 属性来获取 str_max() 函数的说明文档，即使用最后一行的输出语句，其输出结果为

    ```
      比较 2 个字符串的大小
    ```

- [Python](http://c.biancheng.net/python/) 中，根据实际参数的类型不同，函数参数的传递方式可分为 2 种，分别为值传递和引用（地址）传递：

  1. 值传递：适用于实参类型为不可变类型（字符串、数字、元组）；
  2. 引用（地址）传递：适用于实参类型为可变类型（列表，字典）；
  3. 值传递和引用传递的区别是，函数参数进行值传递后，若形参的值发生改变，不会影响实参的值；而函数参数继续引用传递后，改变形参的值，实参的值也会一同改变。

- 位置参数，有时也称必备参数，指的是必须按照正确的顺序将实际参数传到函数中，换句话说，调用函数时传入实际参数的数量和位置都必须和定义函数时保持一致。

- 关键字参数，关键字参数是指使用形式参数的名字来确定输入的参数值。通过此方式指定函数实参时，不再需要与形参的位置完全一致，只要将参数名写正确即可。因此，[Python](http://c.biancheng.net/python/) 函数的参数名应该具有更好的语义，这样程序可以立刻明确传入函数的每个参数的含义。

  ```
  def dis_str(str1,str2):    print("str1:",str1)    print("str2:",str2)#位置参数dis_str("http://c.biancheng.net/python/","http://c.biancheng.net/shell/")#关键字参数dis_str("http://c.biancheng.net/python/",str2="http://c.biancheng.net/shell/")dis_str(str2="http://c.biancheng.net/python/",str1="http://c.biancheng.net/shell/")
  ```

  - 在调用有参函数时，既可以根据位置参数来调用，也可以使用关键字参数（程序中第 8 行）来调用。在使用关键字参数调用时，可以任意调换参数传参的位置。
  - 使用位置参数和关键字参数混合传参的方式。但需要注意，混合传参时关键字参数必须位于所有的位置参数之后。也就是说

- 默认参数

  ```
  def 函数名(...，形参名，形参名=默认值)：    代码块
  ```

  - 在使用此格式定义函数时，指定有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误。

###### 可变参数

- Python 在定义函数时也可以使用可变参数，即允许定义参数个数可变的函数。这样当调用该函数时，可以向其传入任意多个参数。可变参数，又称不定长参数，即传入函数中的实际参数可以是任意多个。Python 定义可变参数，主要有以下 2 种形式。

  - 形参前面加一个*

    ```
    *args
    ```

    - args 表示创建一个名为 args 的空元组，该元组可接受任意多个外界传入的非关键字实参。

    ```
    # 定义了支持参数收集的函数def dis_str(home, *str) :    print(home)    # 输出str元组中的元素    print("str=",str)    for s in str :        print(s)#可传入任何多个参数dis_str("http://c.biancheng.net","http://c.biancheng.net/python/","http://c.biancheng.net/shell/")dis_str() 函数的最后一个参数就是 str 元组，这样在调用该函数时，除了前面位置参数接收对应位置的实参外，其它非关键字参数都会由 str 元组接收。
    ```

    - 可变参数并不一定必须为最后一个函数参数，例如修改 dis_str() 函数为：

    ```
    # 定义了支持参数收集的函数def dis_str(*str,home) :    print(home)    # 输出str元组中的元素    print("str=",str)    for s in str :        print(s)dis_str("http://c.biancheng.net","http://c.biancheng.net/python/",home="http://c.biancheng.net/shell/")str 可变参数作为 dis_str() 函数的第一个参数。但需要注意的是，在调用该函数时，必须以关键字参数的形式给普通参数传值，否则 Python 解释器会把所有参数都优先传给可变参数，如果普通参数没有默认值，就会报错。
    ```

  - 形参前面加两个*

    ```
    **kwargs
    ```

    - **kwargs 表示创建一个名为 kwargs 的空字典，该字典可以接收任意多个以关键字参数赋值的实际参数。

    ```
    # 定义了支持参数收集的函数def dis_str(home,*str,**course) :    print(home)    print(str)    print(course)#调用函数dis_str("C语言中文网",\        "http://c.biancheng.net",\        "http://c.biancheng.net/python/",\        shell教程="http://c.biancheng.net/shell/",\        go教程="http://c.biancheng.net/golang/",\        java教程="http://c.biancheng.net/java/")        C语言中文网('http://c.biancheng.net', 'http://c.biancheng.net/python/'){'shell教程': 'http://c.biancheng.net/shell/', 'go教程': 'http://c.biancheng.net/golang/', 'java教程': 'http://c.biancheng.net/java/'}
    ```

    - 第 1 个参数传递给 home 参数，第 2、3 个非关键字参数传递给 str 元组，最后 2 个关键字参数将由 course 字典接收。
    - *args 可变参数的值默认是空元组，**kwargs 可变参数的值默认是空字典。因此，在调用具有可变参数的函数时，不一定非要给它们传值

###### 逆向参数收集

- Python 支持定义具有可变参数的函数，即该函数可以接收任意多个参数，其中非关键字参数会集中存储到元组参数（*args）中，而关键字参数则集中存储到字典参数（**kwargs）中，这个过程可称为参数收集。

- 不仅如此，Python 还支持逆向参数收集，即直接将列表、元组、字典作为函数参数，Python 会将其进行拆分，把其中存储的元素按照次序分给函数中的各个形参。

- 在以逆向参数收集的方式向函数参数传值时，Pyhon 语法规定，当传入列表或元组时，其名称前要带一个 * 号，当传入字典时，其名称前要带有 2 个 * 号。

  ```
  def dis_str(name,add) :
      print("name:",name)
      print("add",add)
  data = ["Python教程","http://c.biancheng.net/python/"]
  #使用逆向参数收集方式传值
  dis_str(*data)
  
  name: Python教程
  add http://c.biancheng.net/python/
  
  def dis_str(name,add) :
      print("name:",name)
      print("add:",add)
  data = {'name':"Python教程",'add':"http://c.biancheng.net/python/"}
  #使用逆向参数收集方式传值
  dis_str(**data)
  
  name: Python教程
  add: http://c.biancheng.net/python/
  
  以逆向参数收集的方式，还可以给拥有可变参数的函数传参
  def dis_str(name,*add) :
      print("name:",name)
      print("add:",add)
  data = ["http://c.biancheng.net/python/",\
          "http://c.biancheng.net/shell/",\
          "http://c.biancheng.net/golang/"]
  #使用逆向参数收集方式传值
  dis_str("Python教程",*data)
  
  name: Python教程
  add: ('http://c.biancheng.net/python/', 'http://c.biancheng.net/shell/', 'http://c.biancheng.net/golang/')
  ```

- None(空值)，在 [Python](http://c.biancheng.net/python/) 中，有一个特殊的常量 None（N 必须大写）。和 False 不同，它不表示 0，也不表示空字符串，而表示没有值，也就是空值。

  - 这里的空值并不代表空对象，即 None 和 []、“” 不同：

    ```
    >>> None is []
    False
    >>> None is ""
    False
    ```

  - None 有自己的数据类型，我们可以在 IDLE 中使用 type() 函数查看它的类型

    ```
    >>> type(None)<class 'NoneType'>
    ```

  - None 是 NoneType 数据类型的唯一值（其他编程语言可能称这个值为 null、nil 或 undefined），也就是说，我们不能再创建其它 NoneType 类型的变量，但是可以将 None 赋值给任何变量。如果希望变量中存储的东西不与任何其它值混淆，就可以使用 None。

  - 除此之外，None 常用于 assert、判断以及函数无返回值的情况。举个例子，在前面章节中我们一直使用 print() 函数输出数据，其实该函数的返回值就是 None。因为它的功能是在屏幕上显示文本，根本不需要返回任何值，所以 print() 就返回 None。

    ```
    >>> spam = print('Hello!')Hello!>>> None == spamTrue
    ```

  - 对于所有没有 return 语句的函数定义，Python 都会在末尾加上 return None，使用不带值的 return 语句（也就是只有 return 关键字本身），那么就返回 None。

###### 函数返回多个值

- 通常情况下，一个函数只有一个返回值，实际上 Python 也是如此，只不过 Python 函数能以返回列表或者元组的方式，将要返回的多个值保存到序列中，从而间接实现返回多个值的目的。

- 因此，实现 Python 函数返回多个值，有以下 2 种方式：

  1. 在函数中，提前将要返回的多个值存储到一个列表或元组中，然后函数返回该列表或元组；
  2. 函数直接返回多个值，之间用逗号（ , ）分隔，Python 会自动将多个值封装到一个元组中，其返回值仍是一个元组。

  ```
  def retu_list() :    add = ["http://c.biancheng.net/python/",\            "http://c.biancheng.net/shell/",\            "http://c.biancheng.net/golang/"]    return adddef retu_tuple() :    return "http://c.biancheng.net/python/",\           "http://c.biancheng.net/golang/",\           "http://c.biancheng.net/golang/"print("retu_list = ",retu_list())print("retu_tuple = ",retu_tuple())retu_list =  ['http://c.biancheng.net/python/', 'http://c.biancheng.net/shell/', 'http://c.biancheng.net/golang/']retu_tuple =  ('http://c.biancheng.net/python/', 'http://c.biancheng.net/golang/', 'http://c.biancheng.net/golang/')
  ```

  ```
  在此基础上，我们可以利用 Python 提供的序列解包功能，之间使用对应数量的变量，直接接收函数返回列表或元组中的多个值。这里以 retu_list() 为例：def retu_list() :    add = ["http://c.biancheng.net/python/",\            "http://c.biancheng.net/shell/",\            "http://c.biancheng.net/golang/"]    return addpythonadd,shelladd,golangadd = retu_list()print("pythonadd=",pythonadd)print("shelladd=",shelladd)print("golangadd=",golangadd)pythonadd= http://c.biancheng.net/python/shelladd= http://c.biancheng.net/shell/golangadd= http://c.biancheng.net/golang/
  ```

###### partial偏函数

- 简单的理解偏函数，它是对原始函数的二次封装，是将现有函数的部分参数预先绑定为指定值，从而得到一个新的函数，该函数就称为偏函数。相比原函数，偏函数具有较少的可变参数，从而降低了函数调用的难度。

- 定义偏函数，需使用 partial 关键字（位于 functools 模块中），其语法格式如下：

  ```
  偏函数名 = partial(func, *args, **kwargs)
  ```

  - func 指的是要封装的原函数，*args 和 **kwargs 分别用于接收无关键字实参和关键字实参。

  ```
  from functools import partial#定义个原函数def display(name,age):    print("name:",name,"age:",age)#定义偏函数，其封装了 display() 函数，并为 name 参数设置了默认参数GaryFun = partial(display,name = 'Gary')#由于 name 参数已经有默认值，因此调用偏函数时，可以不指定GaryFun(age = 13)name: Gary age: 13
  ```

  - 此程序的第 8 行代码中，必须采用关键字参数的形式给 age 形参传参，因为如果以无关键字参数的方式，该实参将试图传递给 name 形参，Python解释器会报 TypeError 错误。

  ```
  from functools import partial
  def mod( n, m ):
    return n % m
  #定义偏函数，并设置参数 n 对应的实参值为 100
  mod_by_100 = partial( mod, 100 )
  print(mod( 100, 7 ))
  print(mod_by_100( 7 ))
  
  2
  2
  ```

- 结合以上示例不难分析出，偏函数的本质是将函数式编程、默认参数和冗余参数结合在一起，通过偏函数传入的参数调用关系，与正常函数的参数调用关系是一致的。

- 偏函数通过将任意数量（顺序）的参数，转化为另一个带有剩余参数的函数对象，从而实现了截取函数功能（偏向）的效果。在实际应用中，可以使用一个原函数，然后将其封装多个偏函数，在调用函数时全部调用偏函数，一定程序上可以提高程序的可读性。

###### 函数递归

- 一个函数在它的函数体内调用它自身称为递归调用，这种函数称为递归函数。执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。

- 有这样一个数学题。己知有一个数列：f(0) = 1，f(1) = 4，f(n + 2) = 2*f(n+ 1) +f(n)，其中 n 是大于 0 的整数，求 f(10) 的值。这道题可以使用递归来求得。下面程序将定义一个 fn() 函数，用于计算 f(10) 的值。

  ```
  def fn(n) :
      if n == 0 :
          return 1
      elif n == 1 :
          return 4
      else :
          # 函数中调用它自身，就是函数递归
          return 2 * fn(n - 1) + fn(n - 2)
  # 输出fn(10)的结果
  print("fn(10)的结果是:", fn(10))
  ```

- 仔细看上面递归的过程，当一个函数不断地调用它自身时，必须在某个时刻函数的返回值是确定的，即不再调用它自身：否则，这种递归就变成了无穷递归，类似于死循环。因此，在定义递归函数时有一条最重要的规定： 递归一定要向已知方向进行。

- 递归是非常有用的，例如程序希望遍历某个路径下的所有文件，但这个路径下的文件夹的深度是未知的，那么就可以使用递归来实现这个需求。系统可定义一个函数，该函数接收一个文件路径作为参数，该函数可遍历出当前路径下的所有文件和文件路径，即在该函数的函数体中再次调用函数自身来处理该路径下的所有文件路径。

###### 变量作用域

- 定义全局变量的方式有以下 2 种：

  - 在函数体外定义的变量，一定是全局变量

  - 在函数体内定义全局变量。即使用 global 关键字对变量进行修饰后，该变量就会变为全局变量。

    ```
    def text():
        global add
        add= "http://c.biancheng.net/java/"
        print("函数体内访问：",add)
    text()
    print('函数体外访问：',add)
    ```

- 在一些特定场景中，我们可能需要获取某个作用域内（全局范围内或者局部范围内）所有的变量，Python 提供了以下 3 种方式：

  - globals() 函数为 Python 的内置函数，它可以返回一个包含全局范围内所有变量的字典，该字典中的每个键值对，键为变量名，值为该变量的值。

    ```
    #全局变量
    Pyname = "Python教程"
    Pyadd = "http://c.biancheng.net/python/"
    def text():
        #局部变量
        Shename = "shell教程"
        Sheadd= "http://c.biancheng.net/shell/"
    print(globals())
    
    { ...... , 'Pyname': 'Python教程', 'Pyadd': 'http://c.biancheng.net/python/', ......}
    
    globals() 函数返回的字典中，会默认包含有很多变量，这些都是 Python 主程序内置的，读者暂时不用理会它们。
    ```

    - 通过调用 globals() 函数，我们可以得到一个包含所有全局变量的字典。并且，通过该字典，我们还可以访问指定变量，甚至如果需要，还可以修改它的值。

      ```
      print(globals()['Pyname'])
      globals()['Pyname'] = "Python入门教程"
      print(Pyname)
      
      Python教程
      Python入门教程
      ```

  - locals() 函数也是 Python 内置函数之一，通过调用该函数，我们可以得到一个包含当前作用域内所有变量的字典。这里所谓的“当前作用域”指的是，在函数内部调用 locals() 函数，会获得包含所有局部变量的字典；而在全局范文内调用 locals() 函数，其功能和 globals() 函数相同。

    ```
    #全局变量
    Pyname = "Python教程"
    Pyadd = "http://c.biancheng.net/python/"
    def text():
        #局部变量
        Shename = "shell教程"
        Sheadd= "http://c.biancheng.net/shell/"
        print("函数内部的 locals:")
        print(locals())
    text()
    print("函数外部的 locals:")
    print(locals())
    
    函数内部的 locals:
    {'Sheadd': 'http://c.biancheng.net/shell/', 'Shename': 'shell教程'}
    函数外部的 locals:
    {...... , 'Pyname': 'Python教程', 'Pyadd': 'http://c.biancheng.net/python/', ...... }
    
    当使用 locals() 函数获取所有全局变量时，和 globals() 函数一样，其返回的字典中会默认包含有很多变量，这些都是 Python 主程序内置的，
    ```

    - 当使用 locals() 函数获得所有局部变量组成的字典时，可以向 globals() 函数那样，通过指定键访问对应的变量值，但无法对变量值做修改。

  - vars() 函数也是 Python 内置函数，其功能是返回一个指定 object 对象范围内所有变量组成的字典。如果不传入object 参数，vars() 和 locals() 的作用完全相同。

    ```
    #全局变量
    Pyname = "Python教程"
    Pyadd = "http://c.biancheng.net/python/"
    class Demo:
        name = "Python 教程"
        add = "http://c.biancheng.net/python/"
    print("有 object：")
    print(vars(Demo))
    print("无 object：")
    print(vars())
    
    有 object：
    {...... , 'name': 'Python 教程', 'add': 'http://c.biancheng.net/python/', ......}
    无 object：
    {...... , 'Pyname': 'Python教程', 'Pyadd': 'http://c.biancheng.net/python/', ...... }
    ```

- 全局变量可以在程序中任何位置被访问甚至修改，但是，当函数中定义了和全局变量同名的局部变量时，那么在当前函数中，无论是访问还是修改该同名变量，操作的都是局部变量，而不再是全局变量。

  ```
  name = "Python教程"
  def demo ():
      #访问全局变量
      print(name)
      name = "shell教程"
  demo()
  
  UnboundLocalError: local variable 'name' referenced before assignment
  ```

  - 该错误直译过来的意思是：所访问的 name 变量还未定义。这是什么原因呢？就是我们添加第 5 行代码导致的。
  - Python 语法规定，在函数内部对不存在的变量赋值时，默认就是重新定义新的局部变量。上面程序中，第 5 行就定义了一个新的 name 局部变量，由于该局部变量名和全局变量名 name 同名，局部 name 变量就会“遮蔽”全局 name 变量，再加上局部变量 name 在 print(name) 后才被初始化，违反了“先定义后使用”的原则，因此程序会报错。

- 那么，如果就是想在函数中访问甚至修改被“遮蔽”的变量，怎么办呢？可以采取以下 2 中方法：

  - 直接访问被遮蔽的全局变量。如果希望程序依然能访问 name 全局变量，且在函数中可重新定义 name 局部变量，也就是在函数中可以访问被遮蔽的全局变量，此时可通过 globals() 函数来实现

    ```
    name = "Python教程"
    def demo ():
        #通过 globals() 函数访问甚至修改全局变量
        print(globals()['name'])
        globals()['name']="Java教程"
        #定义局部变量
        name = "shell教程"
    demo()
    print(name)
    
    Python教程
    Java教程
    ```

  - 在函数中声明全局变量。为了避免在函数中对全局变量赋值（不是重新定义局部变量），可使用 global 语句来声明全局变量。

    ```
    name = "Python教程"
    def demo ():
        global name
        #访问全局name变量
        print(name)
        #修改全局name变量的值
        name = "shell教程"
    demo()
    print(name)
    
    Python教程
    shell教程
    ```

    - 增加了“global name”声明之后，程序会把 name 变量当成全局变量，这意味着 demo() 函数后面对 name 赋值的语句只是对全局变量赋值，而不是重新定义局部变量。

###### 局部函数

- Python 支持在函数内部定义函数，此类函数又称为局部函数。

- 和局部变量一样，默认情况下局部函数只能在其所在函数的作用域内使用

  ```
  #全局函数def outdef ():    #局部函数    def indef():        print("http://c.biancheng.net/python/")    #调用局部函数    indef()#调用全局函数outdef()http://c.biancheng.net/python/
  ```

- 就如同全局函数返回其局部变量，就可以扩大该变量的作用域一样，通过将局部函数作为所在函数的返回值，也可以扩大局部函数的使用范围。

  ```
  #全局函数def outdef ():    #局部函数    def indef():        print("调用局部函数")    #调用局部函数    return indef#调用全局函数new_indef = outdef()调用全局函数中的局部函数new_indef()调用局部函数
  ```

  - 以上面程序中的 outdef() 和 indef() 为例，如果 outdef() 不将 indef 作为返回值，则 indef() 只能在 outdef() 函数内部使用；反之，则 indef() 函数既可以在 outdef() 函数内部使用，也可以在 outdef() 函数的作用域，也就是全局范围内使用。

- 如果局部函数中定义有和所在函数中变量同名的变量，也会发生“遮蔽”的问题

  ```
  #全局函数
  def outdef ():
      name = "所在函数中定义的 name 变量"
      #局部函数
      def indef():
          print(name)
          name = "局部函数中定义的 name 变量"
      indef()
  #调用全局函数
  outdef()
  
  UnboundLocalError: local variable 'name' referenced before assignment
  ```

  - 由于这里的 name 变量也是局部变量，因此前面章节讲解的 globals() 函数或者 globals 关键字，并不适用于解决此问题。这里可以使用 Python 提供的 nonlocal 关键字。

    ```
    #全局函数
    def outdef ():
        name = "所在函数中定义的 name 变量"
        #局部函数
        def indef():
            nonlocal name
            print(name)
            #修改name变量的值
            name = "局部函数中定义的 name 变量"
        indef()
    #调用全局函数
    outdef()
    
    所在函数中定义的 name 变量
    ```

###### 函数指针

- Python 函数还支持赋值、作为其他函数的参数以及作为其他函数的返回值。

- Python 允许直接将函数赋值给其它变量，这样做的效果是，程序中也可以用其他变量来调用该函数，更加灵活

  ```
  def my_def ():
      print("正在执行 my_def 函数")
  #将函数赋值给其他变量   
  other = my_def
  #间接调用 my_def() 函数
  other()
  
  正在执行 my_def 函数
  ```

- Python 还支持将函数以参数的形式传入其他函数中

  ```
  def add (a,b):
      return a+b
  def multi(a,b):
      return a*b
  def my_def(a,b,dis):
      return dis(a,b)
     
  #求 2 个数的和
  print(my_def(3,4,add))
  #求 2 个数的乘积
  print(my_def(3,4,multi))
  
  7
  12
  ```

  - 通过使用函数作为参数，可以在调用函数时动态传入函数，从而实现动态改变函数中的部分实现代码，在不同场景中赋予函数不同的作用。

- Python 还支持函数的返回值也为函数。

  ```
  def my_def ():
      #局部函数
      def indef():
          print("调用局部函数")
      #调用局部函数
      return indef
  other_def = my_def()
  #调用局部的 indef() 函数
  other_def()
  
  调用局部函数
  ```

  - 通过返回值为函数的形式，可以扩大局部函数的作用域。

###### 闭包函数

- 闭包，又称闭包函数或者闭合函数，其实和前面讲的嵌套函数类似，不同之处在于，闭包中外部函数返回的不是一个具体的值，而是一个函数。一般情况下，返回的函数会赋值给一个变量，这个变量可以在后面被继续执行调用。

- 计算一个数的 n 次幂，用闭包可以写成下面的代码

  ```
  #闭包函数，其中 exponent 称为自由变量
  def nth_power(exponent):
      def exponent_of(base):
          return base ** exponent
      return exponent_of # 返回值是 exponent_of 函数
  square = nth_power(2) # 计算一个数的平方
  cube = nth_power(3) # 计算一个数的立方
  print(square(2))  # 计算 2 的平方
  print(cube(2)) # 计算 2 的立方
  
  4
  8
  ```

  - 外部函数 nth_power() 的返回值是函数 exponent_of()，而不是一个具体的数值。

  - 在执行完 square = nth_power(2) 和 cube = nth_power(3) 后，外部函数 nth_power() 的参数 exponent 会和内部函数 exponent_of 一起赋值给 squre 和 cube，这样在之后调用 square(2) 或者 cube(2) 时，程序就能顺利地输出结果，而不会报错说参数 exponent 没有定义。

  - 读者可能会问，为什么要闭包呢？上面的程序，完全可以写成下面的形式：

    ```
    def nth_power_rewrite(base, exponent):
        return base ** exponent
    ```

  - 上面程序确实可以实现相同的功能，不过使用闭包，可以让程序变得更简洁易读。设想一下，比如需要计算很多个数的平方

    ```
    # 不使用闭包
    res1 = nth_power_rewrite(base1, 2)
    res2 = nth_power_rewrite(base2, 2)
    res3 = nth_power_rewrite(base3, 2)
    # 使用闭包
    square = nth_power(2)
    res1 = square(base1)
    res2 = square(base2)
    res3 = square(base3)
    ```

  - 和缩减嵌套函数的优点类似，函数开头需要做一些额外工作，当需要多次调用该函数时，如果将那些额外工作的代码放在外部函数，就可以减少多次调用导致的不必要开销，提高程序的运行效率。

- 闭包比普通的函数多了一个 __closure__ 属性，该属性记录着自由变量的地址。当闭包被调用时，系统就会根据该地址找到对应的自由变量，完成整体的函数调用。

  - 以 nth_power() 为例，当其被调用时，可以通过 __closure__ 属性获取自由变量（也就是程序中的 exponent 参数）存储的地址，

    ```
    def nth_power(exponent):
        def exponent_of(base):
            return base ** exponent
        return exponent_of
    square = nth_power(2)
    #查看 __closure__ 的值
    print(square.__closure__)
    
    (<cell at 0x0000014454DFA948: int object at 0x00000000513CC6D0>,)
    ```

    - 可以看到，显示的内容是一个 int 整数类型，这就是 square 中自由变量 exponent 的初始值。还可以看到，__closure__ 属性的类型是一个元组，这表明闭包可以支持多个自由变量的形式。

###### lambda函数

- lambda 表达式，又称匿名函数，常用来表示内部仅包含 1 行表达式的函数。如果一个函数的函数体仅有 1 行表达式，则该函数就可以用 lambda 表达式来代替。

  ```
  name = lambda [list] : 表达式
  ```

  - 定义 lambda 表达式，必须使用 lambda 关键字；[list] 作为可选参数，等同于定义函数是指定的参数列表；value 为该表达式的名称。

- 举个例子，如果设计一个求 2 个数之和的函数，使用普通函数的方式

  ```
  def add(x, y):
      return x+ y
  print(add(3,4))
  
  7
  
  add = lambda x,y:x+y
  print(add(3,4))
  
  7
  ```

- 可以这样理解 lambda 表达式，其就是简单函数（函数体仅是单行的表达式）的简写版本。相比函数，lamba 表达式具有以下 2 个优势：

  - 对于单行函数，使用 lambda 表达式可以省去定义函数的过程，让代码更加简洁；
  - 对于不需要多次复用的函数，使用 lambda 表达式可以在用完之后立即释放，提高程序执行的性能。

###### eval()和exec()

- eval() 和 exec() 函数的功能是相似的，都可以执行一个字符串形式的 Python 代码（代码以字符串的形式提供），相当于一个 Python 的解释器。二者不同之处在于，eval() 执行完要返回结果，而 exec() 执行完不返回结果

  ```
  eval(source, globals=None, locals=None, /)
  
  exec(source, globals=None, locals=None, /)
  ```

  - 二者的语法格式除了函数名，其他都相同，其中各个参数的具体含义如下：

    - expression：这个参数是一个字符串，代表要执行的语句 。该语句受后面两个字典类型参数 globals 和 locals 的限制，只有在 globals 字典和 locals 字典作用域内的函数和变量才能被执行。
    - globals：这个参数管控的是一个全局的命名空间，即 expression 可以使用全局命名空间中的函数。如果只是提供了 globals 参数，而没有提供自定义的 __builtins__，则系统会将当前环境中的 __builtins__ 复制到自己提供的 globals 中，然后才会进行计算；如果连 globals 这个参数都没有被提供，则使用 Python 的全局命名空间。
    - locals：这个参数管控的是一个局部的命名空间，和 globals 类似，当它和 globals 中有重复或冲突时，以 locals 的为准。如果 locals 没有被提供，则默认为 globals。
    - __builtins__ 是 Python 的内建模块，平时使用的 int、str、abs 都在这个模块中。通过 print(dic["__builtins__"]) 语句可以查看 __builtins__ 所对应的 value。

    ```
    通过如下的例子来演示参数 globals 作用域的作用，注意观察它是何时将 __builtins__ 复制 globals 字典中去的
    dic={} #定义一个字
    dic['b'] = 3 #在 dic 中加一条元素，key 为 b
    print (dic.keys()) #先将 dic 的 key 打印出来，有一个元素 b
    exec("a = 4", dic) #在 exec 执行的语句后面跟一个作用域 dic
    print(dic.keys()) #exec 后，dic 的 key 多了一个
    
    dict_keys(['b'])
    dict_keys(['b', '__builtins__', 'a'])
    ```

    - 上面的代码是在作用域 dic 下执行了一句 a = 4 的代码。可以看出，exec() 之前 dic 中的 key 只有一个 b。执行完 exec() 之后，系统在 dic 中生成了两个新的 key，分别是 a 和 __builtins__。其中，a 为执行语句生成的变量，系统将其放到指定的作用域字典里；__builtins__ 是系统加入的内置 key。

    - locals参数的用法就很简单了

      ```
      a=10
      b=20
      c=30
      g={'a':6, 'b':8} #定义一个字典
      t={'b':100, 'c':10} #定义一个字典
      print(eval('a+b+c', g, t)) #定义一个字典 116
      
      116
      ```

- exe()和eval()的区别

  - 它们的区别在于，eval() 执行完会返回结果，而 exec() 执行完不返回结果。

    ```
    a = 1
    exec("a = 2") #相当于直接执行 a=2
    print(a)
    a = exec("2+3") #相当于直接执行 2+3，但是并没有返回值，a 应为 None
    print(a)
    a = eval('2+3') #执行 2+3，并把结果返回给 a
    print(a)
    
    2
    None
    5
    ```

    - exec() 中最适合放置运行后没有结果的语句，而 eval() 中适合放置有结果返回的语句。

    - 如果 eval() 里放置一个没有结果返回的语句

      ```
      a= eval("a = 2")
      ```

    - 这时 Python 解释器会报 SyntaxError 错误，提示 eval() 中不识别等号语法。

- 应用场景

  - 在使用 Python 开发服务端程序时，这两个函数应用得非常广泛。例如，客户端向服务端发送一段字符串代码，服务端无需关心具体的内容，直接跳过 eval() 或 exec() 来执行，这样的设计会使服务端与客户端的耦合度更低，系统更易扩展。
  - 另外，如果读者以后接触 [TensorFlow](http://c.biancheng.net/tensorflow/) 框架，就会发现该框架中的静态图就是类似这个原理实现的：
    - TensorFlow 中先将张量定义在一个静态图里，这就相当将键值对添加到字典里一样；
    - TensorFlow 中通过 session 和张量的 eval() 函数来进行具体值的运算，就当于使用 eval() 函数进行具体值的运算一样。
  - 需要注意的是，在使用 eval() 或是 exec() 来处理请求代码时，函数 eval() 和 exec() 常常会被黑客利用，成为可以执行系统级命令的入口点，进而来攻击网站。解决方法是：通过设置其命名空间里的可执行函数，来限制 eval() 和 exec() 的执行范围。

- 使用 exec() 和 eval() 函数时，一定要记住，它们的第一个参数是字符串，而字符串的内容一定要是可执行的代码。

- 以 eval() 函数为例，用代码演示常犯的错误

  ```
  s="hello"
  print(eval(s))
  
  Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\demo.py", line 2, in <module>
      print(eval(s))
    File "<string>", line 1, in <module>
  NameError: name 'hello' is not defined
  ```

  - 上面例子出错的地方在于，字符串的内容是 hello，而 hello 并不是可执行的代码（除非定义了一个变量叫作 hello）。

  - 如果要将字符串 hello 通过 print 函数打印出来

    ```
    s="hello"
    print(eval('s'))
    
    hello
    ```

    - 这种写法是要 eval() 执行 "hello" 这句代码。这个 hello 是有引号的，在代码中代表字符串的意思，所以可以执行。

  - 同理，也可以写成这样：

    ```
    s='"hello"' #s 是个字符串，字符串的内容是带引号的 hello
    print(eval(s))
    
    hello
    ```

    - 这种写法的意思是 s 是个字符串，并且其内容是个带引号的 hello。所以直接将 s 放入到函数 eval() 中也可以执行。

  - 除了以上这种方式，还可以不去改变原有字符串 s 的写法，直接使用 repr() 函数来进行转化，也可以得到同样的效果

    ```
    s="hello"
    print(eval(repr(s))) #使用函数 repr() 进行转化
    
    hello
    ```

  - 注意，虽然函数 eval() 与 str() 的返回值都是字符串。但是使用 str() 函数对 s 进行转化，程序同样会报错

    ```
    s="hello"
    print(eval(str(s)))
    
    Traceback (most recent call last):
      File "C:\Users\mengma\Desktop\demo.py", line 2, in <module>
        print(eval(str(s)))
      File "<string>", line 1, in <module>
    NameError: name 'hello' is not defined
    ```

  - 为什么会有这个区别呢？同样对带字符串 s 的转化，使用 repr() 与 str() 得到的结果是有差别的，直接将二者的结果打印出来，就可以很明显地看出不同。见下面代码：

    ```
    s="hello"
    print(repr(s))
    print(str(s))
    
    'hello'
    hello
    ```

    - 可见使用 repr() 返回的内容，输出后会在两边多一个单引号。

  - 在编写代码时，一般会使 repr() 函数来生成动态的字符串，再传入到 eval() 或 exec() 函数内，实现动态执行代码的功能。

###### 函数式编程

- 所谓函数式编程，是指代码中每一块都是不可变的，都由纯函数的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出。

- 除此之外，函数式编程还具有一个特点，即允许把函数本身作为参数传入另一个函数，还允许返回一个函数。

- 例如，想让列表中的元素值都变为原来的两倍，可以使用如下函数实现：

  ```
  def multiply_2(list):
      for index in range(0, len(list)):
          list[index] *= 2
      return list
  ```

  - 需要注意的是，这段代码不是一个纯函数的形式，因为列表中元素的值被改变了，如果多次调用 multiply_2() 函数，那么每次得到的结果都不一样。

  - 而要想让 multiply_2() 成为一个纯函数的形式，就得重新创建一个新的列表并返回

    ```
    def multiply_2_pure(list):
        new_list = []
        for item in list:
            new_list.append(item * 2)
        return new_list
    ```

- 函数式编程的优点，主要在于其纯函数和不可变的特性使程序更加健壮，易于调试和测试；缺点主要在于限制多，难写。

- Python 允许使用变量，所以它并不是一门纯函数式编程语言。Python 仅对函数式编程提供了部分支持，主要包括 map()、filter() 和 reduce() 这 3 个函数，它们通常都结合 lambda 匿名函数一起使用。接下来就对这 3 个函数的用法做逐一介绍。

- map() 函数的基本语法格式

  ```
  map(function, iterable)
  ```

  - function 参数表示要传入一个函数，其可以是内置函数、自定义函数或者 lambda 匿名函数；iterable 表示一个或多个可迭代对象，可以是列表、字符串等。

  - map() 函数的功能是对可迭代对象中的每个元素，都调用指定的函数，并返回一个 map 对象。

  - 该函数返回的是一个 map 对象，不能直接输出，可以通过 for 循环或者 list() 函数来显示。

    ```
    listDemo = [1, 2, 3, 4, 5]
    new_list = map(lambda x: x * 2, listDemo)
    print(list(new_list))
    
    [2， 4， 6， 8， 10]
    
    map() 函数可传入多个可迭代对象作为参数。
    listDemo1 = [1, 2, 3, 4, 5]
    listDemo2 = [3, 4, 5, 6, 7]
    new_list = map(lambda x,y: x + y, listDemo1,listDemo2)
    print(list(new_list))
    
    [4, 6, 8, 10, 12]
    ```

  - 由于 map() 函数是直接由用 C 语言写的，运行时不需要通过 Python 解释器间接调用，并且内部做了诸多优化，所以相比其他方法，此方法的运行效率最高。

- filter()函数的基本语法格式

  ```
  filter(function, iterable)
  ```

  - 此格式中，funcition 参数表示要传入一个函数，iterable 表示一个可迭代对象。

  - filter() 函数的功能是对 iterable 中的每个元素，都使用 function 函数判断，并返回 True 或者 False，最后将返回 True 的元素组成一个新的可遍历的集合。

    ```
    返回一个列表中的所有偶数。
    listDemo = [1, 2, 3, 4, 5]
    new_list = filter(lambda x: x % 2 == 0, listDemo)
    print(list(new_list))
    
    [2, 4]
    
    filter() 函数可以接受多个可迭代对象。
    listDemo = [1, 2, 3, 4, 5]
    new_list = map(lambda x,y: x-y>0,[3,5,6],[1,5,8] )
    print(list(new_list))
    
    [True, False, False]
    ```

- reduce() 函数通常用来对一个集合做一些累积操作

  ```
  reduce(function, iterable)
  ```

  - function 规定必须是一个包含 2 个参数的函数；iterable 表示可迭代对象。

  - 由于 reduce() 函数在 Python 3.x 中已经被移除，放入了 functools 模块，因此在使用该函数之前，需先导入 functools 模块。

  - 计算某个列表元素的乘积。

    ```
    import functools
    listDemo = [1, 2, 3, 4, 5]
    product = functools.reduce(lambda x, y: x * y, listDemo)
    print(product)
    
    120
    ```

- 通常来说，当对集合中的元素进行一些操作时，如果操作非常简单，比如相加、累积这种，那么应该优先考虑使用 map()、filter()、reduce() 实现。另外，在数据量非常多的情况下（比如机器学习的应用），一般更倾向于函数式编程的表示，因为效率更高。

- 当然，在数据量不多的情况下，使用 for 循环等方式也可以。不过，如果要对集合中的元素做一些比较复杂的操作，考虑到代码的可读性，通常会使用 for 循环。

###### 函数注解

- 函数注解是 Python 3 最独特的功能之一，关于它的介绍，官方文档是这么说的，“函数注解是关于用户自定义函数使用类型的完全可选的元信息”。也就是说，官方将函数注解的用途归结为：为函数中的形参和返回值提供类型提示信息。

- 下面是对 Python 官方文档中的示例稍作修改后的程序，可以很好的展示如何定义并获取函数注解：

  ```
  def f(ham:str,egg:str='eggs')->str:
    pass
  print(f.__annotations__)
  
  {'ham': <class 'str'>, 'egg': <class 'str'>, 'return': <class 'str'>}
  ```

  - 如上所示，给函数中的参数做注解的方法是在形参后添加冒号“：”，后接需添加的注解（可以是类（如 str、int 等），也可以是字符串或者表示式）；给返回值做注解的方法是将注解添加到 def 语句结尾的冒号和 -> 之间。
  - 如果参数有默认值，参数注解位于冒号和等号之间。比如 eggs:str='eggs'，它表示 eggs 参数的默认值为 'eggs'，添加的注解为 str。

- 给函数定义好注解之后，可以通过函数对象的 __annotations__ 属性获取，它是一个字典，在应用运行期间可以获取

  ```
  def square(number:"一个数字")->"返回number的平方":
    return number**2
  print(square(10))
  print(square.__annotations__)
  
  100
  {'number': '一个数字', 'return': '返回number的平方'}
  ```

- 事实上，函数注解并不局限于类型提示，而且在 Python 及其标准库中也没有单个功能可以利用这种注解，这也是这个功能独特的原因。

- 函数注解没有任何语法上的意义，只是为函数参数和返回值做注解，并在运行获取这些注解，仅此而已。换句话说，为函数做的注解，Python不做检查，不做强制，不做验证，什么操作都不做，函数注解对Python解释器没任何意义。

- PEP 3107 作为提议函数注解的官方文档，其中列出了以下可能的使用场景：

  - 提供类型信息：包括类型检查、让 IDE 显示函数接受和返回的类型、适配、与其他语言的桥梁、数据库查询映射、RPC参数编组等；
  - 其他信息：函数参数和返回值的文档。

- 总之，虽然函数注解存在的时间和 Python 3 一样长，但目前仍未找到任一常见且积极维护的包，将函数注解用作类型检查之外的功能。Python 3 最初发布时包含函数注解的最初目的也仅是用于试验和玩耍。 

#### 类和对象

- Python 语言在设计之初，就定位为一门面向对象的编程语言，“Python 中一切皆对象”就是对 Python 这门编程语言的完美诠释。类和对象是 Python 的重要特征，相比其它面向对象语言，Python 很容易就可以创建出一个类和对象。同时，Python 也支持面向对象的三大特征：封装、继承和多态。

- 无论是类属性还是类方法，对于类来说，它们都不是必需的，可以有也可以没有。另外，Python 类中属性和方法所在的位置是任意的，即它们之间并没有固定的前后次序。

- 给类起好名字之后，其后要跟有冒号（：），表示告诉 Python 解释器，下面要开始设计类的内部功能了，也就是编写类属性和类方法。

- 其实，类属性指的就是包含在类中的变量；而类方法指的是包含类中的函数。换句话说，类属性和类方法其实分别是包含类中的变量和函数的别称。需要注意的一点是，同属一个类的所有类属性和类方法，要保持统一的缩进格式，通常统一缩进 4 个空格。

  ```
  class TheFirstDemo:
      '''这是一个学习Python定义的第一个类'''
      # 下面定义了一个类属性
      add = 'http://c.biancheng.net'
      # 下面定义了一个say方法
      def say(self, content):
          print(content)
  ```

  - 和函数一样，我们也可以为类定义说明文档，其要放到类头之后，类体之前的位置，如上面程序中第二行的字符串，就是 TheFirstDemo 这个类的说明文档。
  - 分析上面的代码可以看到，我们创建了一个名为 TheFirstDemo 的类，其包含了一个名为 add 的类属性。注意，根据定义属性位置的不同，在各个类方法之外定义的变量称为类属性或类变量（如 add 属性），而在类方法中定义的属性称为实例属性（或实例变量）
  - say() 是一个实例方法，除此之外，Python 类中还可以定义类方法和静态方法

###### \__init__()类构造方法

- 在创建类时，我们可以手动添加一个 __init__() 方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。

- 构造方法用于创建对象时使用，每当创建一个类的实例对象时，[Python](http://c.biancheng.net/python/) 解释器都会自动调用它。[Python](http://c.biancheng.net/python/) 类中，手动添加构造方法的语法格式如下：

  ```
  def __init__(self,...):
      代码块
  ```

  - 此方法的方法名中，开头和结尾各有 2 个下划线，且中间不能有空格。Python 中很多这种以双下划线开头、双下划线结尾的方法，都具有特殊的意义

- \__init__() 方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。也就是说，类的构造方法最少也要有一个 self 参数。例如，仍以 TheFirstDemo 类为例，添加构造方法的代码如下所示

  ```
  class TheFirstDemo:
      '''这是一个学习Python定义的第一个类'''
      #构造方法
      def __init__(self):
          print("调用构造方法")
      # 下面定义了一个类属性
      add = 'http://c.biancheng.net'
      # 下面定义了一个say方法
      def say(self, content):
          print(content)
  ```

  - 即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法。
  - 仅包含 self 参数的 \__init__() 构造方法，又称为类的默认构造方法。

- 在 \__init__() 构造方法中，除了 self 参数外，还可以自定义一些参数，参数之间使用逗号“,”进行分割

  ```
  class CLanguage:
      '''这是一个学习Python定义的一个类'''
      def __init__(self,name,add):
          print(name,"的网址为:",add)
  #创建 add 对象，并传递参数给构造函数
  add = CLanguage("C语言中文网","http://c.biancheng.net")
  ```

  - 由于创建对象时会调用类的构造方法，如果构造函数有多个参数时，需要手动传递参数
  - 虽然构造方法中有 self、name、add 3 个参数，但实际需要传参的仅有 name 和 add，也就是说，self 不需要手动传递参数。

###### 类对象的创建和使用

- 创建类对象的过程，又称为类的实例化。

- 对已定义好的类进行实例化

  ```
  类名(参数)
  ```

  - 定义类时，如果没有手动添加\__init\__() 构造方法，又或者添加的 \__init__() 中仅有一个 self 参数，则创建类对象时的参数可以省略不写。

- 如下代码创建了名为 CLanguage 的类，并对其进行了实例化：

  ```
  class CLanguage :
      # 下面定义了2个类变量
      name = "C语言中文网"
      add = "http://c.biancheng.net"
      def __init__(self,name,add):
          #下面定义 2 个实例变量
          self.name = name
          self.add = add
          print(name,"网址为：",add)
      # 下面定义了一个say实例方法
      def say(self, content):
          print(content)
  # 将该CLanguage对象赋给clanguage变量
  clanguage = CLanguage("C语言中文网","http://c.biancheng.net")
  ```

  - 在上面的程序中，由于构造方法除 self 参数外，还包含 2 个参数，且这 2 个参数没有设置默认参数，因此在实例化类对象时，需要传入相应的 name 值和 add 值（self 参数是特殊参数，不需要手动传值，Python 会自动传给它值）。
  - 类变量和实例变量，简单地理解，定义在各个类方法之外（包含在类中）的变量为类变量（或者类属性），定义在类方法中的变量为实例变量（或者实例属性）

- 定义的类只有进行实例化，也就是使用该类创建对象之后，才能得到利用。总的来说，实例化后的类对象可以执行以下操作：

  - 访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量；
  - 调用类对象的方法，包括调用现有的方法，以及给类对象动态添加方法。
  
- 使用已创建好的类对象访问类中实例变量的语法格式如下：

  ```
  类对象名.变量名
  ```

- 使用类对象调用类中方法的语法格式如下：

  ```
  对象名.方法名(参数)
  ```

- Python 支持为已创建好的对象动态增加实例变量，方法也很简单，这里的动态是对一个实例化对象添加，不是为定义的类添加

  ```
  # 为clanguage对象增加一个money实例变量
  clanguage.money= 159.9
  print(clanguage.money)
  
  159.9
  ```

  - 通过直接增加一个新的实例变量并为其赋值，就成功地为 clanguage 对象添加了 money 变量。

- 既然能动态添加，那么是否能动态删除呢？答案是肯定的，使用 del 语句即可实现

  ```
  #删除新添加的 money 实例变量
  del clanguage.money
  #再次尝试输出 money，此时会报错
  print(clanguage.money)
  ```

- 给类对象动态添加方法，为 clanguage 对象动态增加的方法，Python 不会自动将调用者自动绑定到第一个参数（即使将第一个参数命名为 self 也没用）

  ```
  # 先定义一个函数
  def info(self):
      print("---info函数---", self)
  # 使用info对clanguage的foo方法赋值（动态绑定方法）
  clanguage.foo = info
  # Python不会自动将调用者绑定到第一个参数，
  # 因此程序需要手动将调用者绑定为第一个参数
  clanguage.foo(clanguage)  # ①
  # 使用lambda表达式为clanguage对象的bar方法赋值（动态绑定方法）
  clanguage.bar = lambda self: print('--lambda表达式--', self)
  clanguage.bar(clanguage) # ②
  ```

  - 上面的第 5 行和第 11 行代码分别使用函数、lambda 表达式为 clanguage 对象动态增加了方法，但对于动态增加的方法，Python 不会自动将方法调用者绑定到它们的第一个参数，因此程序必须手动为第一个参数传入参数值，如上面程序中 ① 号、② 号代码所示。

- 有读者可能会问，有没有不用手动给 self 传值的方法呢？通过借助 types 模块下的 MethodType 可以实现，仍以上面的 info() 函数为例：

  ```
  def info(self,content):
      print("C语言中文网地址为：%s" % content)
  # 导入MethodType
  from types import MethodType
  clanguage.info = MethodType(info, clanguage)
  # 第一个参数已经绑定了，无需传入
  clanguage.info("http://c.biancheng.net")
  ```

  - 可以看到，由于使用 MethodType 包装 info() 函数时，已经将该函数的 self 参数绑定为 clanguage，因此后续再使用 info() 函数时，就不用再给 self 参数绑定值了。

###### self用法

- 在定义类的过程中，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将 self 参数作为方法的第一个参数。例如，定义一个 Person 类：

  ```
  class Person:
      def __init__(self):
          print("正在执行构造方法")
      # 定义一个study()实例方法
      def study(self,name):
          print(name,"正在学Python")
  ```

- 事实上，Python 只是规定，无论是构造方法还是实例方法，最少要包含一个参数，并没有规定该参数的具体名称。之所以将其命名为 self，只是程序员之间约定俗成的一种习惯，遵守这个约定，可以使我们编写的代码具有更好的可读性（大家一看到 self，就知道它的作用）。

- 那么，self 参数的具体作用是什么呢？打个比方，如果把类比作造房子的图纸，那么类实例化后的对象是真正可以住的房子。根据一张图纸（类），我们可以设计出成千上万的房子（类对象），每个房子长相都是类似的（都有相同的类变量和类方法），但它们都有各自的主人，那么如何对它们进行区分呢？当然是通过 self 参数，它就相当于每个房子的门钥匙，可以保证每个房子的主人仅能进入自己的房子（每个类对象只能调用自己的类变量和类方法）。其实 Python 类方法中的 self 参数就相当于 C++ 中的 this 指针。

- 也就是说，同一个类可以产生多个对象，当某个对象调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，换句话说，Python 会自动绑定类方法的第一个参数指向调用该方法的对象。如此，Python解释器就能知道到底要操作哪个对象的方法了。

- 因此，程序在调用实例方法和构造方法时，不需要手动为第一个参数传值。例如，更改前面的 Person 类

  ```
  class Person:
      def __init__(self):
          print("正在执行构造方法")
      # 定义一个study()实例方法
      def study(self):
          print(self,"正在学Python")
  zhangsan = Person()
  zhangsan.study()
  lisi = Person()
  lisi.study()
  ```

  - 上面代码中，study() 中的 self 代表该方法的调用者，即谁调用该方法，那么 self 就代表谁。因此，该程序的运行结果为：

    ```
    正在执行构造方法
    <__main__.Person object at 0x0000021ADD7D21D0> 正在学Python
    正在执行构造方法
    <__main__.Person object at 0x0000021ADD7D2E48> 正在学Python
    ```

- 另外，对于构造函数中的 self 参数，其代表的是当前正在初始化的类对象

  ```
  class Person:
      name = "xxx"
      def __init__(self,name):
          self.name=name
  zhangsan = Person("zhangsan")
  print(zhangsan.name)
  lisi = Person("lisi")
  print(lisi.name)
  
  zhangsan
  lisi
  ```

  - 可以看到，zhangsan 在进行初始化时，调用的构造函数中 self 代表的是 zhangsan；而 lisi 在进行初始化时，调用的构造函数中 self 代表的是 lisi。

- 值得一提的是，除了类对象可以直接调用类方法，还有一种函数调用的方式

  ```
  class Person:
      def who(self):
          print(self)
  zhangsan = Person()
  #第一种方式
  zhangsan.who()
  #第二种方式
  who = zhangsan.who   //相当于函数指针，将函数名给函数指针，然后通过函数指针调用，这样函数名代表地址就不用写()，但是下面要写
  who()#通过 who 变量调用zhangsan对象中的 who() 方法
  
  
  <__main__.Person object at 0x0000025C26F021D0>
  <__main__.Person object at 0x0000025C26F021D0>
  ```

  - 无论采用哪种方法，self 所表示的都是实际调用该方法的对象。

###### 类变量和实例变量

- 无论是类属性还是类方法，都无法像普通变量或者函数那样，在类的外部直接使用它们。我们可以将类看做一个独立的空间，则类属性其实就是在类体中定义的变量，类方法是在类体中定义的函数。

- 在类体中，根据变量定义的位置不同，以及定义的方式不同，类属性又可细分为以下 3 种类型：

  1. 类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；
  2. 类体中，所有函数内部：以“self.变量名”的方式定义的变量，称为实例属性或实例变量；
  3. 类体中，所有函数内部：以“变量名=变量值”的方式定义的变量，称为局部变量。

- 类变量指的是在类中，但在各个类方法外定义的变量

  ```
  class CLanguage :
      # 下面定义了2个类变量
      name = "C语言中文网"
      add = "http://c.biancheng.net"
      # 下面定义了一个say实例方法
      def say(self, content):
          print(content)
  ```

  - 类变量的特点是，所有类的实例化对象都同时共享类变量，也就是说，类变量在所有实例化对象中是作为公用资源存在的。类方法的调用方式有 2 种，既可以使用类名直接调用，也可以使用类的实例化对象调用。

    ```
    #使用类名直接调用
    print(CLanguage.name)
    print(CLanguage.add)
    #修改类变量的值
    CLanguage.name = "Python教程"
    CLanguage.add = "http://c.biancheng.net/python"
    print(CLanguage.name)
    print(CLanguage.add)
    
    C语言中文网
    http://c.biancheng.net
    Python教程
    http://c.biancheng.net/python
    ```

  - 也可以使用类对象来调用所属类中的类变量（此方式不推荐使用）

  - 因为类变量为所有实例化对象共有，通过类名修改类变量的值，会影响所有的实例化对象

  - 通过类对象是无法修改类变量的。通过类对象对类变量赋值，其本质将不再是修改类变量的值，而是在给该对象定义新的实例变量

  - 除了可以通过类名访问类变量之外，还可以动态地为类和对象添加类变量

    ```
    clang = CLanguage()
    CLanguage.catalog = 13
    print(clang.catalog)
    
    13
    ```

- 实例变量指的是在任意类方法内部，以“self.变量名”的方式定义的变量，其特点是只作用于调用方法的对象。另外，实例变量只能通过对象名访问，无法通过类名访问。

  ```
  class CLanguage :
      def __init__(self):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
      # 下面定义了一个say实例方法
      def say(self):
          self.catalog = 13
  ```

  - name、add 以及 catalog 都是实例变量。其中，由于 __init__() 函数在创建类对象时会自动调用，而 say() 方法需要类对象手动调用。因此，CLanguage 类的类对象都会包含 name 和 add 实例变量，而只有调用了 say() 方法的类对象，才包含 catalog 实例变量。

  - 通过类对象可以访问类变量，但无法修改类变量的值。这是因为，通过类对象修改类变量的值，不是在给“类变量赋值”，而是定义新的实例变量

    ```
    clang = CLanguage()
    #clang访问类变量
    print(clang.name)
    print(clang.add)
    clang.name = "Python教程"
    clang.add = "http://c.biancheng.net/python"
    #clang实例变量的值
    print(clang.name)
    print(clang.add)
    #类变量的值
    print(CLanguage.name)
    print(CLanguage.add)
    
    C语言中文网
    http://c.biancheng.net
    Python教程
    http://c.biancheng.net/python
    C语言中文网
    http://c.biancheng.net
    
    通过类对象是无法修改类变量的值的，本质其实是给 clang 对象新添加 name 和 add 这 2 个实例变量。
    ```

- 局部变量直接以“变量名=值”的方式进行定义

  ```
  class CLanguage :
      # 下面定义了一个say实例方法
      def count(self,money):
          sale = 0.8*money
          print("优惠后的价格为：",sale)
  clang = CLanguage()
  clang.count(100)
  ```

  - 定义局部变量是为了所在类方法功能的实现。需要注意的一点是，局部变量只能用于所在函数中，函数执行完成后，局部变量也会被销毁。

###### 实例方法、静态方法和类方法

- 和类属性一样，类方法也可以进行更细致的划分，具体可分为类方法、实例方法和静态方法。

- 和类属性的分类不同，对于初学者来说，区分这 3 种类方法是非常简单的，即采用 @classmethod 修饰的方法为类方法；采用 @staticmethod 修饰的方法为静态方法；不用任何修改的方法为实例方法。其中 @classmethod 和 @staticmethod 都是函数装饰器

- 通常情况下，在类中定义的方法默认都是实例方法。前面章节中，我们已经定义了不只一个实例方法。不仅如此，类的构造方法理论上也属于实例方法，只不过它比较特殊。

  - 实例方法最大的特点就是，它最少也要包含一个 self 参数，用于绑定调用此方法的实例对象（Python 会自动完成绑定）。实例方法通常会用类对象直接调用

  - Python 也支持使用类名调用实例方法，但此方式需要手动给 self 参数传值

    ```
    #类名调用实例方法，需手动给 self 参数传值
    clang = CLanguage()
    CLanguage.say(clang)
    ```

- 类方法和实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为 cls，Python 会自动将类本身绑定给 cls 参数（注意，绑定的不是类对象）。也就是说，我们在调用类方法时，无需显式为 cls 参数传参。和 self 一样，cls 参数的命名也不是规定的（可以随意命名），只是 Python 程序员约定俗称的习惯而已。和实例方法最大的不同在于，类方法需要使用`＠classmethod`修饰符进行修饰

  ```
  class CLanguage:
      #类构造方法，也属于实例方法
      def __init__(self):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
      #下面定义了一个类方法
      @classmethod
      def info(cls):
          print("正在调用类方法",cls)
  ```

  - 如果没有 ＠classmethod，则 Python 解释器会将 类方法认定为实例方法，而不是类方法。

  - 类方法推荐使用类名直接调用，当然也可以使用实例对象来调用（不推荐）

    ```
    #使用类名直接调用类方法
    CLanguage.info()
    #使用类对象调用类方法
    clang = CLanguage()
    clang.info()
    ```

- 静态方法其实就是我们学过的函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。静态方法没有类似 self、cls 这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。静态方法需要使用`＠staticmethod`修饰

  ```
  class CLanguage:
      @staticmethod
      def info(name,add):
          print(name,add)
  ```

  - 静态方法的调用，既可以使用类名，也可以使用类对象

    ```
    #使用类名直接调用静态方法
    CLanguage.info("C语言中文网","http://c.biancheng.net")
    #使用类对象调用静态方法
    clang = CLanguage()
    clang.info("Python教程","http://c.biancheng.net/python")
    ```

  - 在实际编程中，几乎不会用到类方法和静态方法，因为我们完全可以使用函数代替它们实现想要的功能，但在一些特殊的场景中（例如工厂模式中），使用类方法和静态方法也是很不错的选择。

###### 描述符

- [Python](http://c.biancheng.net/python/) 中，通过使用描述符，可以让程序员在引用一个对象属性时自定义要完成的工作。

- 本质上看，描述符就是一个类，只不过它定义了另一个类中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。

- 描述符是 Python 中复杂属性访问的基础，它在内部被用于实现 property、方法、类方法、静态方法和 super 类型。

- 描述符类基于以下 3 个特殊方法，换句话说，这 3 个方法组成了描述符协议：

  - \__set__(self, obj, type=None)：在设置属性时将调用这一方法（本节后续用 setter 表示）；
  - \__get__(self, obj, value)：在读取属性时将调用这一方法（本节后续用 getter 表示）；
  - \__delete__(self, obj)：对属性调用 del 时将调用这一方法。
  - 其中，实现了 setter 和 getter 方法的描述符类被称为数据描述符；反之，如果只实现了 getter 方法，则称为非数据描述符。

- 实际上，在每次查找属性时，描述符协议中的方法都由类对象的特殊方法 __getattribute__() 调用（注意不要和 __getattr__() 弄混）。也就是说，每次使用类对象.属性（或者 getattr(类对象，属性值)）的调用方式时，都会隐式地调用 __getattribute__()，它会按照下列顺序查找该属性：

  1. 验证该属性是否为类实例对象的数据描述符；
  2. 如果不是，就查看该属性是否能在类实例对象的 __dict__ 中找到；
  3. 最后，查看该属性是否为类实例对象的非数据描述符。

  ```
  #描述符类
  class revealAccess:
      def __init__(self, initval = None, name = 'var'):
          self.val = initval
          self.name = name
      def __get__(self, obj, objtype):
          print("Retrieving",self.name)
          return self.val
      def __set__(self, obj, val):
      
          print("updating",self.name)
          self.val = val
  class myClass:
      x = revealAccess(10,'var "x"')
      y = 5
  m = myClass()
  print(m.x)
  m.x = 20
  print(m.x)
  print(m.y)
  运行结果为：
  Retrieving var "x"
  10
  updating var "x"
  Retrieving var "x"
  20
  5
  ```

  - 从这个例子可以看到，如果一个类的某个属性有数据描述符，那么每次查找这个属性时，都会调用描述符的\\__get__() 方法，并返回它的值；同样，每次在对该属性赋值时，也会调用 \__set__() 方法。
  - 虽然上面例子中没有使用\__del__() 方法，但也很容易理解，当每次使用 del 类对象.属性（或者 delattr(类对象，属性)）语句时，都会调用该方法。

- 除了使用描述符类自定义类属性被调用时做的操作外，还可以使用 property() 函数或者 @property 装饰器

###### property()定义属性

- 前面章节中，我们一直在用“类对象.属性”的方式访问类中定义的属性，其实这种做法是欠妥的，因为它破坏了类的封装原则。正常情况下，类包含的属性应该是隐藏的，只允许通过类提供的方法来间接实现对类属性的访问和操作。

- 因此，在不破坏类封装原则的基础上，为了能够有效操作类中的属性，类中应包含读（或写）类属性的多个 getter（或 setter）方法，这样就可以通过“类对象.方法(参数)”的方式操作属性

  ```
  class CLanguage:
      #构造函数
      def __init__(self,name):
          self.name = name 
      #设置 name 属性值的函数 
      def setname(self,name):
          self.name = name
      #访问nema属性值的函数
      def getname(self):
          return self.name
      #删除name属性值的函数
      def delname(self):
          self.name="xxx"
  clang = CLanguage("C语言中文网")
  #获取name属性值
  print(clang.getname())
  #设置name属性值
  clang.setname("Python教程")
  print(clang.getname())
  #删除name属性值
  clang.delname()
  print(clang.getname())
  
  C语言中文网
  Python教程
  xxx
  ```

  - 可能有读者觉得，这种操作类属性的方式比较麻烦，更习惯使用“类对象.属性”这种方式。庆幸的是，Python 中提供了 property() 函数，可以实现在不破坏类封装原则的前提下，让开发者依旧使用“类对象.属性”的方式操作类中的属性。

- property() 函数的基本使用格式如下：

  ```
  属性名=property(fget=None, fset=None, fdel=None, doc=None)
  ```

  - fget 参数用于指定获取该属性值的类方法，fset 参数用于指定设置该属性值的方法，fdel 参数用于指定删除该属性值的方法，最后的 doc 是一个文档字符串，用于说明此函数的作用。

  - 在使用 property() 函数时，以上 4 个参数可以仅指定第 1 个、或者前 2 个、或者前 3 个，当前也可以全部指定。也就是说，property() 函数中参数的指定并不是完全随意的。

    ```
    修改上面的程序，为 name 属性配置 property() 函数
    
    class CLanguage:
        #构造函数
        def __init__(self,n):
            self.__name = n
        #设置 name 属性值的函数
        def setname(self,n):
            self.__name = n
        #访问nema属性值的函数
        def getname(self):
            return self.__name
        #删除name属性值的函数
        def delname(self):
            self.__name="xxx"
        #为name 属性配置 property() 函数
        name = property(getname, setname, delname, '指明出处')
    #调取说明文档的 2 种方式
    #print(CLanguage.name.__doc__)
    help(CLanguage.name)
    clang = CLanguage("C语言中文网")
    #调用 getname() 方法
    print(clang.name)
    #调用 setname() 方法
    clang.name="Python教程"
    print(clang.name)
    #调用 delname() 方法
    del clang.name
    print(clang.name)
    
    Help on property:
    
        指明出处
    
    C语言中文网
    Python教程
    xxx
    ```

  - 在此程序中，由于 getname() 方法中需要返回 name 属性，如果使用 self.name 的话，其本身又被调用 getname()，这将会先入无限死循环。为了避免这种情况的出现，程序中的 name 属性必须设置为私有属性，即使用 __name（前面有 2 个下划线）。有关类属性和类方法的属性设置（分为共有属性、保护属性、私有属性）

  - 当然，property() 函数也可以少传入几个参数。以上面的程序为例，我们可以修改 property() 函数如下所示

    ```
    name = property(getname, setname)
    ```

    - 这意味着，name 是一个可读写的属性，但不能删除，因为 property() 函数中并没有为 name 配置用于函数该属性的方法。也就是说，即便 CLanguage 类中设计有 delname() 函数，这种情况下也不能用来删除 name 属性。 

  - 同理，还可以像如下这样使用 property() 函数：

    ```
    name = property(getname)    # name 属性可读，不可写，也不能删除
    name = property(getname, setname,delname)    #name属性可读、可写、也可删除，就是没有说明文档
    ```

###### @property装饰器

- 既要保护类的封装特性，又要让开发者可以使用“对象.属性”的方式操作操作类属性，除了使用 property() 函数，Python 还提供了 @property 装饰器。通过 @property 装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对“（）”小括号。

- @property 的语法格式如下：

  ```
  @property
  def 方法名(self)
      代码块
  ```

- 例如，定义一个矩形类，并定义用 @property 修饰的方法操作类中的 area 私有属性

  ```
  class Rect:
      def __init__(self,area):
          self.__area = area
      @property
      def area(self):
          return self.__area
  rect = Rect(30)
  #直接通过方法名来访问 area 方法
  print("矩形的面积是：",rect.area)
  
  矩形的面积为： 30
  ```

  - 上面程序中，使用 ＠property 修饰了 area() 方法，这样就使得该方法变成了 area 属性的 getter 方法。需要注意的是，如果类中只包含该方法，那么 area 属性将是一个只读属性。
  - 也就是说，在使用 Rect 类时，无法对 area 属性重新赋值

- 而要想实现修改 area 属性的值，还需要为 area 属性添加 setter 方法，就需要用到 setter 装饰器

  ```
  @方法名.setter
  def 方法名(self, value):
      代码块
  ```

  - 为 Rect 类中的 area 方法添加 setter 方法

    ```
    @area.setter
    def area(self, value):
        self.__area = value
    ```

- 除此之外，还可以使用 deleter 装饰器来删除指定属性

  ```
  @方法名.deleter
  def 方法名(self):
      代码块
  ```

  - 在 Rect 类中，给 area() 方法添加 deleter 方法

    ```
    @area.deleter
    def area(self):
        self.__area = 0
    ```

    ```
    del rect.area
    print("删除后的area值为：",rect.area)
    
    删除后的area值为： 0
    ```

###### 封装

- 简单的理解封装（Encapsulation），即在设计类时，刻意地将一些属性和方法隐藏在类的内部，这样在使用此类时，将无法直接以“类对象.属性名”（或者“类对象.方法名(参数)”）的形式调用这些属性（或方法），而只能用未隐藏的类方法间接操作这些隐藏的属性和方法。
- 封装机制保证了类内部[数据结构](http://c.biancheng.net/data_structure/)的完整性，因为使用类的用户无法直接看到类中的数据结构，只能使用类允许公开的数据，很好地避免了外部对内部数据的影响，提高了程序的可维护性。除此之外，对一个类实现良好的封装，用户只能借助暴露出来的类方法来访问数据，我们只需要在这些暴露的方法中加入适当的控制逻辑，即可轻松实现用户对类中属性或方法的不合理操作。
- 和其它面向对象的编程语言（如 C++、Java）不同，Python 类中的变量和函数，不是公有的（类似 public 属性），就是私有的（类似 private），这 2 种属性的区别如下：
  - public：公有属性的类变量和类函数，在类的外部、类内部以及子类（后续讲继承特性时会做详细介绍）中，都可以正常访问；
  - private：私有属性的类变量和类函数，只能在本类内部使用，类的外部以及子类都无法使用。
- 但是，Python 并没有提供 public、private 这些修饰符。为了实现类的封装，Python 采取了下面的方法：
  - 默认情况下，Python 类中的变量和方法都是公有（public）的，它们的名称前都没有下划线（_）；这个是双下划线
  - 如果类中的变量和函数，其名称以双下划线“__”开头，则该变量（函数）为私有变量（私有函数），其属性等同于 private。

- 除此之外，还可以定义以单下划线“\_”开头的类属性或者类方法（例如 \_name、\_display(self)），这种类属性和类方法通常被视为私有属性和私有方法，虽然它们也能通过类对象正常访问，但这是一种约定俗称的用法，初学者一定要遵守。

- 注意，Python 类中还有以双下划线开头和结尾的类方法（例如类的构造函数\__init__(self)），这些都是 Python 内部定义的，用于 Python 内部调用。我们自己定义类属性或者类方法时，不要使用这种格式。

  ```
  class CLanguage :
      def setname(self, name):
          if len(name) < 3:
              raise ValueError('名称长度必须大于3！')
          self.__name = name
      def getname(self):
          return self.__name
      #为 name 配置 setter 和 getter 方法
      name = property(getname, setname)
      def setadd(self, add):
          if add.startswith("http://"):
              self.__add = add
          else:
              raise ValueError('地址必须以 http:// 开头') 
      def getadd(self):
          return self.__add
     
      #为 add 配置 setter 和 getter 方法
      add = property(getadd, setadd)
      #定义个私有方法
      def __display(self):
          print(self.__name,self.__add)
  clang = CLanguage()
  clang.name = "C语言中文网"
  clang.add = "http://c.biancheng.net"
  print(clang.name)
  print(clang.add)
  
  C语言中文网
  http://c.biancheng.net
  ```

  - 上面程序中，CLanguage 将 name 和 add 属性都隐藏了起来，但同时也提供了可操作它们的“窗口”，也就是各自的 setter 和 getter 方法，这些方法都是公有（public）的。

  - 不仅如此，以 add 属性的 setadd() 方法为例，通过在该方法内部添加控制逻辑，即通过调用 startswith() 方法，控制用户输入的地址必须以“http://”开头，否则程序将会执行 raise 语句抛出 ValueError 异常。

  - 通过此程序的运行逻辑不难看出，通过对 CLanguage 类进行良好的封装，使得用户仅能通过暴露的 setter() 和 getter() 方法操作 name 和 add 属性，而通过对 setname() 和 setadd() 方法进行适当的设计，可以避免用户对类中属性的不合理操作，从而提高了类的可维护性和安全性。

  - 细心的读者可能还发现，CLanguage 类中还有一个 \__display() 方法，由于该类方法为私有（private）方法，且该类没有提供操作该私有方法的“窗口”，因此我们无法在类的外部使用它。换句话说，如下调用 __display() 方法是不可行的：

    ```
    #尝试调用私有的 display() 方法
    clang.__display()
    
    Traceback (most recent call last):
      File "D:\python3.6\1.py", line 33, in <module>
        clang.__display()
    AttributeError: 'CLanguage' object has no attribute '__display'
    ```

- python封装底层原理
  - 事实上，Python 封装特性的实现纯属“投机取巧”，之所以类对象无法直接调用以双下划线开头命名的类属性和类方法，是因为其底层实现时，Python 偷偷改变了它们的名称。

  - 事实上，对于以双下划线开头命名的类属性或类方法，Python 在底层实现时，将它们的名称都偷偷改成了 "_类名__属性（方法）名" 的格式。

  - 就以 CLanguage 类中的\_\_display() 为例，Python 在底层将其方法名偷偷改成了“_CLanguage__display()”。例如，在 CLanguage 类的基础上，执行如下代码：

    ```
    clang = CLanguage()
    #调用name的setname()方法
    clang.name = "C语言中文网"
    #调用add的setadd()方法
    clang.add = "http://c.biancheng.net"
    #直接调用隐藏的display()方法
    clang._CLanguage__display()
    
    C语言中文网 http://c.biancheng.net
    ```

  - 不仅如此，那些原本我们认为是私有的类属性（例如 `__name` 和 `__add`），其底层的名称也改成了“_类名__属性名”的这种格式

  ```
  clang = CLanguage()
  clang.name = "C语言中文网"
  clang.add = "http://c.biancheng.net"
  #直接调用 name 和 add 私有属性
  print(clang._CLanguage__name,clang._CLanguage__add)
  
  C语言中文网 http://c.biancheng.net
  ```

  - 甚至于，我们还可以通过这种方式修改 clang 对象的私有属性

    ```
    clang._CLanguage__name = "Python教程"
    clang._CLanguage__add = "http://c.biancheng.net/python"
    print(clang._CLanguage__name,clang._CLanguage__add)
    
    Python教程 http://c.biancheng.net/python
    ```

  - Python 类中所有的属性和方法，都是公有（public）属性，如果希望 Python 底层修改类属性或者类方法的名称，以此将它们隐藏起来，只需将它们的名称前添加双下划线（“__”）即可。

###### 继承

- Python 中，实现继承的类称为子类，被继承的类称为父类（也可称为基类、超类）

- 子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。语法格式如下：

  ```
  class 类名(父类1, 父类2, ...)：
      #类定义部分
  ```

  - 如果该类没有显式指定继承自哪个类，则默认继承 object 类（object 类是 Python 中所有类的父类，即要么是直接父类，要么是间接父类）。另外，Python 的继承是多继承机制（和 [C++](http://c.biancheng.net/cplus/) 一样），即一个子类可以同时拥有多个直接父类。

  ```
  class People:
      def say(self):
          print("我是一个人，名字是：",self.name)
  class Animal:
      def display(self):
          print("人也是高级动物")
  #同时继承 People 和 Animal 类
  #其同时拥有 name 属性、say() 和 display() 方法
  class Person(People, Animal):
      pass
  zhangsan = Person()
  zhangsan.name = "张三"
  zhangsan.say()
  zhangsan.display()
  
  我是一个人，名字是： 张三
  人也是高级动物
  
  可以看到，虽然 Person 类为空类，但由于其继承自 People 和 Animal 这 2 个类，因此实际上 Person 并不空，它同时拥有这 2 个类所有的属性和方法。
  ```

  - 子类拥有父类所有的属性和方法，即便该属性或方法是私有（private）的，看封装的底层实现即可知道，python的封装只是投机取巧改了名字

- 事实上，大部分面向对象的编程语言，都只支持单继承，即子类有且只能有一个父类。而 Python 却支持多继承（C++也支持多继承）。和单继承相比，多继承容易让代码逻辑复杂、思路混乱，一直备受争议，中小型项目中较少使用，后来的 [Java](http://c.biancheng.net/java/)、[C#](http://c.biancheng.net/csharp/)、[PHP](http://c.biancheng.net/php/) 等干脆取消了多继承。

- 使用多继承经常需要面临的问题是，多个父类中包含同名的类方法。对于这种情况，Python 的处置措施是：根据子类继承多个父类时这些父类的前后次序决定，即排在前面父类中的类方法会覆盖排在后面父类中的同名类方法。

- 虽然 Python 在语法上支持多继承，但逼不得已，建议大家不要使用多继承。

###### 父类方法重写

- 前面讲过在 [Python](http://c.biancheng.net/python/) 中，子类继承了父类，那么子类就拥有了父类所有的类属性和类方法。通常情况下，子类会在此基础上，扩展一些新的类属性和类方法。但凡事都有例外，我们可能会遇到这样一种情况，即子类从父类继承得来的类方法中，大部分是适合子类使用的，但有个别的类方法，并不能直接照搬父类的，如果不对这部分类方法进行修改，子类对象无法使用。针对这种情况，我们就需要在子类中重复父类的方法。

- 重写，有时又称覆盖，是一个意思，指的是对类中已有方法的内部实现进行修改。

  ```
  class Bird:
      #鸟有翅膀
      def isWing(self):
          print("鸟有翅膀")
      #鸟会飞
      def fly(self):
          print("鸟会飞")
  class Ostrich(Bird):
      # 重写Bird类的fly()方法
      def fly(self):
          print("鸵鸟不会飞")
  # 创建Ostrich对象
  ostrich = Ostrich()
  #调用 Ostrich 类中重写的 fly() 类方法
  ostrich.fly()
  
  鸵鸟不会飞
  
  ostrich 调用的是重写之后的 fly() 类方法。
  ```

- 事实上，如果我们在子类中重写了从父类继承来的类方法，那么当在类的外部通过子类对象调用该方法时，Python 总是会执行子类中重写的方法。这就产生一个新的问题，即如果想调用父类中被重写的这个方法，很简单，前面讲过，Python 中的类可以看做是一个独立空间，而类方法其实就是出于该空间中的一个函数。而如果想要全局空间中，调用类空间中的函数，只需要在调用该函数是备注类名即可

  ```
  class Bird:
      #鸟有翅膀
      def isWing(self):
          print("鸟有翅膀")
      #鸟会飞
      def fly(self):
          print("鸟会飞")
  class Ostrich(Bird):
      # 重写Bird类的fly()方法
      def fly(self):
          print("鸵鸟不会飞")
  # 创建Ostrich对象
  ostrich = Ostrich()
  #调用 Bird 类中的 fly() 方法
  Bird.fly(ostrich)
  
  鸟会飞
  ```

  - 此程序中，需要大家注意的一点是，使用类名调用其类方法，Python 不会为该方法的第一个 self 参数自定绑定值，因此采用这种调用方法，需要手动为 self 参数赋值。

###### 子类化内置类型

- Python 中内置有一个 object 类，它是所有内置类型的共同祖先，也是所有没有显式指定父类的类（包括用户自定义的）的共同祖先。因此在实际编程过程中，如果想实现与某个内置类型具有类似行为的类时，最好的方法就是将这个内置类型子类化。

- 内置类型子类化，其实就是自定义一个新类，使其继承有类似行为的内置类，通过重定义这个新类实现指定的功能。

- 举个例子，如下所示创建了一个名为 newDict 的类，其中 newDictError 是自定义的异常类：

  ```
  class newDictError(ValueError):
    """如果向newDict 添加重复值，则引发此异常"""
  class newDict(dict):
    """不接受重复值的字典"""
    def __setitem__(self,key,value):
      if value in self.values():
        if ((key in self and self[key]!=value) or (key not in self)):
          raise newDictError("这个值已经存在，并对应不同的键")
      super().__setitem__(key,value)
  demoDict = newDict()
  demoDict['key']='value'
  demoDict['other_key']='value2'
  print(demoDict)
  demoDict['other_key']='value'
  print(demoDict)
  
  {'key': 'value', 'other_key': 'value2'}
  Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\demo.py", line 15, in <module>
      demoDict['other_key']='value'
    File "C:\Users\mengma\Desktop\demo.py", line 9, in __setitem__
      raise newDictError("这个值已经存在，并对应不同的键")
  newDictError: 这个值已经存在，并对应不同的键
  ```

  - 可以看到，newDict 是 Python 中 dict 类型的子类，所以其大部分行为都和 dict 内置类相同，唯一不同之处在于，newDict 不允许字典中多个键对应相同的值。如果用户试图添加具有相同值的新元素，则会引发 newDictError 异常，并给出提示信息。

  - 由于目前尚未学习如何处理异常，因此这里没有 newDictError 做任何处理，异常处理会在后续章节做详细讲解。

  - 另外，如果查看现有代码你会发现，其实很多类都是对 Python 内置类的部分实现，它们作为子类的速度更快，代码更整洁。比如，list 类型用来管理序列，如果一个类需要在内部处理序列，那么就可以对 list 进行子类化，示例代码如下：

    ```
    class myList(list):
      def __init__(self,name):
        self.name = name
      def dir(self,nesting = 0):
        offset = " " * nesting
        print("%s%s/" % (offset,self.name))
        for element in self:
          if hasattr(element , 'dir'):
            element.dir(nesting + 1)
          else:
            print("%s %s" % (offset,element))
    demoList = myList('C语言中文网')
    demoList.append('http://c.biancheng.net')
    print(demoList.dir())
    
    C语言中文网/
    http://c.biancheng.net
    None
    ```

  - 除了 Python 中常用的基本内置类型，collections 模块中还额外提供了很多有用的容器，这些容器可以满足大部分情况。

###### super()函数：调用父类的构造方法

- 前面不止一次讲过，[Python](http://c.biancheng.net/python/) 中子类会继承父类所有的类属性和类方法。严格来说，类的构造方法其实就是实例方法，因此毫无疑问，父类的构造方法，子类同样会继承。

- 但我们知道，Python 是一门支持多继承的面向对象编程语言，如果子类继承的多个父类中包含同名的类实例方法，则子类对象在调用该方法时，会优先选择排在最前面的父类中的实例方法。显然，构造方法也是如此。

  ```
  class People:
      def __init__(self,name):
          self.name = name
      def say(self):
          print("我是人，名字为：",self.name)
  class Animal:
      def __init__(self,food):
          self.food = food
      def display(self):
          print("我是动物,我吃",self.food)
  #People中的 name 属性和 say() 会遮蔽 Animal 类中的
  class Person(People, Animal):
      pass
  per = Person("zhangsan")
  per.say()
  #per.display()
  
  我是人，名字为： zhangsan
  ```

  - 上面程序中，Person 类同时继承 People 和 Animal，其中 People 在前。这意味着，在创建 per 对象时，其将会调用从 People 继承来的构造函数。因此我们看到，上面程序在创建 per 对象的同时，还要给 name 属性进行赋值。

  - 但如果去掉最后一行的注释，运行此行代码，Python 解释器会报如下错误：

    ```
    Traceback (most recent call last):
      File "D:\python3.6\Demo.py", line 18, in <module>
        per.display()
      File "D:\python3.6\Demo.py", line 11, in display
        print("我是动物,我吃",self.food)
    AttributeError: 'Person' object has no attribute 'food'
    ```

    - 这是因为，从 Animal 类中继承的 display() 方法中，需要用到 food 属性的值，但由于 People 类的构造方法“遮蔽”了Animal 类的构造方法，使得在创建 per 对象时，Animal 类的构造方法未得到执行，所以程序出错。

- 针对这种情况，正确的做法是定义 Person 类自己的构造方法（等同于重写第一个直接父类的构造方法）。但需要注意，如果在子类中定义构造方法，则必须在该方法中调用父类的构造方法。

- 在子类中的构造方法中，调用父类构造方法的方式有 2 种，分别是：

  1. 类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要额外备注类名（此方式又称为未绑定方法）；
  2. 使用 super() 函数。但如果涉及多继承，该函数只能调用第一个直接父类的构造方法。
  3. 也就是说，涉及到多继承时，在子类构造函数中，调用第一个父类构造方法的方式有以上 2 种，而调用其它父类构造方法的方式只能使用未绑定方法。

- Python 2.x 中，super() 函数的使用语法格式如下：

  ```
  super(Class, obj).__init__(self,...)
  ```

  - Class 值得是子类的类名，obj 通常指的就是 self。

- 但在 Python 3.x 中，super() 函数有一种更简单的语法格式，推荐大家使用这种格式

  ```
  super().__init__(self,...)
  ```

  ```
  class People:
      def __init__(self,name):
          self.name = name
      def say(self):
          print("我是人，名字为：",self.name)
  class Animal:
      def __init__(self,food):
          self.food = food
      def display(self):
          print("我是动物,我吃",self.food)
  class Person(People, Animal):
      #自定义构造方法
      def __init__(self,name,food):
          #调用 People 类的构造方法
          super().__init__(name)
          #super(Person,self).__init__(name) #执行效果和上一行相同
          #People.__init__(self,name)#使用未绑定方法调用 People 类构造方法
          #调用其它父类的构造方法，需手动给 self 传值
          Animal.__init__(self,food)    
  per = Person("zhangsan","熟食")
  per.say()
  per.display()
  
  我是人，名字为： zhangsan
  我是动物,我吃 熟食
  ```

  - 可以看到，Person 类自定义的构造方法中，调用 People 类构造方法，可以使用 super() 函数，也可以使用未绑定方法。但是调用 Animal 类的构造方法，只能使用未绑定方法。

- 前面已经讲解了 super() 函数的用法，值得一提的是，Python 2 中 super() 函数的用法和 Python 3 大致相同，唯一的区别在于，Python 2 中不能使用零参数形式的格式，必须提供至少一个参数。

- 对于想要编写跨版本兼容代码的程序员来说，还要注意一件事，即 Python 2 中的 super() 函数只适用于新式类，在旧式类中不能使用 super()。

- 那么，什么是旧式类和新式类呢？在早期版本的 Python 中，所有类并没有一个共同的祖先 object，如果定义一个类，但没有显式指定其祖先，那么就被解释为旧式类

- Python 2.x 版本中，为了向后兼容保留了旧式类。该版本中的新式类必须显式继承 object 或者其他新式类

- 而在 Python 3.x 版本中，不再保留旧式类的概念。因此，没有继承任何其他类的类都隐式地继承自 object。

- 可以说，在 Python 3.x 中，显式声明某个类继承自 object 似乎是冗余的。但如果考虑跨版本兼容，那么就必须将 object 作为所有基类的祖先，因为如果不这么做的话，这些类将被解释为旧式类，最终会导致难以诊断的问题。

###### super()使用注意事项

- 混用super与显示类调用，分析如下程序，C 类使用了 __init__() 方法调用它的基类，会造成 B 类被调用了 2 次：

  ```
  class A:
      def __init__(self):
          print("A",end=" ")
          super().__init__()
  class B:
      def __init__(self):
          print("B",end=" ")
          super().__init__()
  class C(A,B):
      def __init__(self):
          print("C",end=" ")
          A.__init__(self)
          B.__init__(self)
  print("MRO:",[x.__name__ for x in C.__mro__])
  C()
  
  MRO: ['C', 'A', 'B', 'object']
  C A B B
  ```

  - 出现以上这种情况的原因在于，C 的实例调用 A.__init__(self)，使得 super(A,self).__init__() 调用了 B.__init__() 方法。换句话说，super 应该被用到整个类的层次结构中。
  - 但是，有时这种层次结构的一部分位于第三方代码中，我们无法确定外部包的这些代码中是否使用 super()，因此，当需要对某个第三方类进行子类化时，最好查看其内部代码以及 MRO 中其他类的内部代码。

- 不同种类的参数，使用 super 的另一个问题是初始化过程中的参数传递。如果没有相同的签名，一个类怎么能调用其基类的 __init__() 代码呢？这会导致下列问题：

  ```
  class commonBase:
      def __init__(self):
          print("commonBase")
          super().__init__()
  class base1(commonBase):
      def __init__(self):
          print("base1")
          super().__init__()
  class base2(commonBase):
      def __init__(self):
          print("base2")
          super().__init__()
  class myClass(base1,base2):
      def __init__(self,arg):
          print("my base")
          super().__init__(arg)
  myClass(10)
  
  my base
  Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\demo.py", line 20, in <module>
      myClass(10)
    File "C:\Users\mengma\Desktop\demo.py", line 19, in __init__
      super().__init__(arg)
  TypeError: __init__() takes 1 positional argument but 2 were given
  ```

  - 一种解决方法是使用 *args 和 **kwargs 包装的参数和关键字参数，这样即使不使用它们，所有的构造函数也会传递所有参数

    ```
    class commonBase:
        def __init__(self,*args,**kwargs):
            print("commonBase")
            super().__init__()
    class base1(commonBase):
        def __init__(self,*args,**kwargs):
            print("base1")
            super().__init__(*args,**kwargs)
    class base2(commonBase):
        def __init__(self,*args,**kwargs):
            print("base2")
            super().__init__(*args,**kwargs)
    class myClass(base1,base2):
        def __init__(self,arg):
            print("my base")
            super().__init__(arg)
    myClass(10)
    
    my base
    base1
    base2
    commonBase
    ```

    - 不过，这是一种很糟糕的解决方法，由于任何参数都可以传入，所有构造函数都可以接受任何类型的参数，这会导致代码变得脆弱。另一种解决方法是在 MyClass 中显式地使用特定类的 __init__() 调用，但这无疑会导致第一种错误。

- 如果想要避免程序中出现以上的这些问题，这里给出几点建议：

  - 尽可能避免使用多继承，可以使用一些设计模式来替代它；
  - super 的使用必须一致，即在类的层次结构中，要么全部使用 super，要么全不用。混用 super 和传统调用是一种混乱的写法；
  - 如果代码需要兼容 Python 2.x，在 Python 3.x 中应该显式地继承自 object。在 Python 2.x 中，没有指定任何祖先地类都被认定为旧式类。
  - 调用父类时应提前查看类的层次结构，也就是使用类的 `__mro__` 属性或者 mro() 方法查看有关类的 MRO。

###### \__slots__:限制类实例动态添加属性和方法

- 通过学习《[Python类变量和实例变量](http://c.biancheng.net/view/2283.html)》一节，了解了如何动态的为单个实例对象添加属性，甚至如果必要的话，还可以为所有的类实例对象统一添加属性（通过给类添加属性）。

- 那么，[Python](http://c.biancheng.net/python/) 是否也允许动态地为类或实例对象添加方法呢？答案是肯定的。我们知道，类方法又可细分为实例方法、静态方法和类方法，Python 语言允许为类动态地添加这 3 种方法；但对于实例对象，则只允许动态地添加实例方法，不能添加类方法和静态方法。

- 为单个实例对象添加方法，不会影响该类的其它实例对象；而如果为类动态地添加方法，则所有的实例对象都可以使用。

  ```
  class CLanguage:
      pass
  #下面定义了一个实例方法
  def info(self):
      print("正在调用实例方法")
  #下面定义了一个类方法
  @classmethod
  def info2(cls):
      print("正在调用类方法")
  #下面定义个静态方法
  @staticmethod
  def info3():
      print("正在调用静态方法")
  #类可以动态添加以上 3 种方法，会影响所有实例对象
  CLanguage.info = info
  CLanguage.info2 = info2
  CLanguage.info3 = info3
  clang = CLanguage()
  #如今，clang 具有以上 3 种方法
  clang.info()
  clang.info2()
  clang.info3()
  #类实例对象只能动态添加实例方法，不会影响其它实例对象
  clang1 = CLanguage()
  clang1.info = info
  #必须手动为 self 传值
  clang1.info(clang1)
  
  正在调用实例方法
  正在调用类方法
  正在调用静态方法
  正在调用实例方法
  ```

- 显然，动态给类或者实例对象添加属性或方法，是非常灵活的。但与此同时，如果胡乱地使用，也会给程序带来一定的隐患，即程序中已经定义好的类，如果不做任何限制，是可以做动态的修改的。

- 庆幸的是，Python 提供了 `__slots__` 属性，通过它可以避免用户频繁的给实例对象动态地添加属性或方法。再次声明，`__slots__` 只能限制为实例对象动态添加属性和方法，而无法限制动态地为类添加属性和方法。

- `__slots__` 属性值其实就是一个元组，只有其中指定的元素，才可以作为动态添加的属性或者方法的名称。举个例子：

  ```
  class CLanguage:
      __slots__ = ('name','add','info')
  ```

  - 可以看到， CLanguage 类中指定了 `__slots__` 属性，这意味着，该类的实例对象仅限于动态添加 name、add、info 这 3 个属性以及 name()、add() 和 info() 这 3 个方法。注意，对于动态添加的方法，`__slots__` 限制的是其方法名，并不限制参数的个数。

- 比如，在 CLanguage 类的基础上，添加如下代码并运行：

  ```
  def info(self,name):
      print("正在调用实例方法",self.name)
  clang = CLanguage()
  clang.name = "C语言中文网"
  #为 clang 对象动态添加 info 实例方法
  clang.info = info
  clang.info(clang,"Python教程")
  
  正在调用实例方法 C语言中文网
  
  def info(self,name):
      print("正在调用实例方法",self.name)
  clang = CLanguage()
  clang.name = "C语言中文网"
  clang.say = info
  clang.say(clang,"Python教程")
  
  Traceback (most recent call last):
    File "D:\python3.6\1.py", line 9, in <module>
      clang.say = info
  AttributeError: 'CLanguage' object has no attribute 'say'
  ```

  - 显然，根据 `__slots__` 属性的设置，CLanguage 类的实例对象是不能动态添加以 say 为名称的方法的。

- 另外本节前面提到，`__slots__` 属性限制的对象是类的实例对象，而不是类，因此下面的代码是合法的：

  ```
  def info(self):
      print("正在调用实例方法")
  CLanguage.say = info
  clang = CLanguage()
  clang.say()
  
  正在调用实例方法
  ```

- 此外，`__slots__` 属性对由该类派生出来的子类，也是不起作用的

  ```
  class CLanguage:
      __slots__ = ('name','add','info')
  #Clanguage 的空子类
  class CLangs(CLanguage):
      pass
  #定义的实例方法
  def info(self):
      print("正在调用实例方法")
  clang = CLangs()
  #为子类对象动态添加 say() 方法
  clang.say = info
  clang.say(clang)
  
  正在调用实例方法
  ```

  - 显然，`__slots__` 属性只对当前所在的类起限制作用。
  - 因此，如果子类也要限制外界为其实例对象动态地添加属性和方法，必须在子类中设置 `__slots__` 属性。
- 注意，如果为子类也设置有 `__slots__` 属性，那么子类实例对象允许动态添加的属性和方法，是子类中 `__slots__` 属性和父类 `__slots__` 属性的和。

###### type():动态创建类

- type() 函数属于 [Python](http://c.biancheng.net/python/) 内置函数，通常用来查看某个变量的具体类型。其实，type() 函数还有一个更高级的用法，即创建一个自定义类型（也就是创建一个类）。

- type() 函数的语法格式有 2 种，分别如下：

  ```
  type(obj) 
  type(name, bases, dict)
  ```

  - 以上这 2 种语法格式，各参数的含义及功能分别是：
    - 第一种语法格式用来查看某个变量（类对象）的具体类型，obj 表示某个变量或者类对象。
    - 第二种语法格式用来创建类，其中 name 表示类的名称；bases 表示一个元组，其中存储的是该类的父类；dict 表示一个字典，用于表示类内定义的属性或者方法。

  ```
  #定义一个实例方法
  def say(self):
      print("我要学 Python！")
  #使用 type() 函数创建类
  CLanguage = type("CLanguage",(object,),dict(say = say, name = "C语言中文网"))
  #创建一个 CLanguage 实例对象
  clangs = CLanguage()
  #调用 say() 方法和 name 属性
  clangs.say()
  print(clangs.name)
  
  我要学 Python！
  C语言中文网
  ```

  - Python 元组语法规定，当 (object,) 元组中只有一个元素时，最后的逗号（,）不能省略。
  - 此程序中通过 type() 创建了类，其类名为 CLanguage，继承自 objects 类，且该类中还包含一个 say() 方法和一个 name 属性。
  - 有读者可能会问，如何判断 dict 字典中添加的是方法还是属性？很简单，如果该键值对中，值为普通变量（如 "C语言中文网"），则表示为类添加了一个类属性；反之，如果值为外部定义的函数（如 say() ），则表示为类添加了一个实例方法。
  - 可以看到，使用 type() 函数创建的类，和直接使用 class 定义的类并无差别。事实上，我们在使用 class 定义类时，Python 解释器底层依然是用 type() 来创建这个类。

###### MetaClass元类

- MetaClass元类，本质也是一个类，但和普通类的用法不同，它可以对类内部的定义（包括类属性和类方法）进行动态的修改。可以这么说，使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法。

- 举个例子，根据实际场景的需要，我们要为多个类添加一个 name 属性和一个 say() 方法。显然有多种方法可以实现，但其中一种方法就是使用 MetaClass 元类。

- 如果在创建类时，想用 MetaClass 元类动态地修改内部的属性或者方法，则类的创建过程将变得复杂：先创建 MetaClass 元类，然后用元类去创建类，最后使用该类的实例化对象实现功能。

- 和前面章节创建的类不同，如果想把一个类设计成 MetaClass 元类，其必须符合以下条件：

  1. 必须显式继承自 type 类；
  2. 类中需要定义并实现 `__new__`() 方法，该方法一定要返回该类的一个实例对象，因为在使用元类创建类时，该 `__new__`() 方法会自动被执行，用来修改新建的类。

  ```
  #定义一个元类
  class FirstMetaClass(type):
      # cls代表动态修改的类
      # name代表动态修改的类名
      # bases代表被动态修改的类的所有父类
      # attr代表被动态修改的类的所有属性、方法组成的字典
      def __new__(cls, name, bases, attrs):
          # 动态为该类添加一个name属性
          attrs['name'] = "C语言中文网"
          attrs['say'] = lambda self: print("调用 say() 实例方法")
          return super().__new__(cls,name,bases,attrs)
  ```

  - 此程序中，首先可以断定 FirstMetaClass 是一个类。其次，由于该类继承自 type 类，并且内部实现了 `__new__`() 方法，因此可以断定 FirstMetaCLass 是一个元类。

  - 可以看到，在这个元类的 `__new__`() 方法中，手动添加了一个 name 属性和 say() 方法。这意味着，通过 FirstMetaClass 元类创建的类，会额外添加 name 属性和 say() 方法

    ```
    #定义类时，指定元类
    class CLanguage(object,metaclass=FirstMetaClass):
        pass
    clangs = CLanguage()
    print(clangs.name)
    clangs.say()
    
    C语言中文网
    调用 say() 实例方法
    ```

    - 可以看到，在创建类时，通过在标注父类的同时指定元类（格式为`metaclass=元类名`），则当 [Python](http://c.biancheng.net/python/) 解释器在创建这该类时，FirstMetaClass 元类中的 `__new__` 方法就会被调用，从而实现动态修改类属性或者类方法的目的。
    - 显然，FirstMetaClass 元类的 `__new__`() 方法动态地为 Clanguage 类添加了 name 属性和 say() 方法，因此，即便该类在定义时是空类，它也依然有 name 属性和 say() 方法。
    - 对于 MetaClass 元类，它多用于创建 API，因此我们几乎不会使用到它。

- metaclass 这样“逆天”的存在，会"扭曲变形"正常的 Python 类型模型，所以，如果使用不慎，对于整个代码库造成的风险是不可估量的。换句话说，metaclass 仅仅是给小部分 Python 开发者，在开发框架层面的 Python 库时使用的。而在应用层，metaclass 往往不是很好的选择。

###### 多态

- 我们都知道，[Python](http://c.biancheng.net/python/) 是弱类型语言，其最明显的特征是在使用变量时，无需为其指定具体的数据类型。这会导致一种情况，即同一变量可能会被先后赋值不同的类对象，例如：

  ```
  class CLanguage:
      def say(self):
          print("赋值的是 CLanguage 类的实例对象")
  class CPython:
      def say(self):
          print("赋值的是 CPython 类的实例对象")
  a = CLanguage()
  a.say()
  a = CPython()
  a.say()
  
  赋值的是 CLanguage 类的实例对象
  赋值的是 CPython 类的实例对象
  ```

  - 可以看到，a 可以被先后赋值为 CLanguage 类和 CPython 类的对象，但这并不是多态。类的多态特性，还要满足以下 2 个前提条件：
    1. 继承：多态一定是发生在子类和父类之间；
    2. 重写：子类重写了父类的方法。

- 改写上面的代码

  ```
  class CLanguage:
      def say(self):
          print("调用的是 Clanguage 类的say方法")
  class CPython(CLanguage):
      def say(self):
          print("调用的是 CPython 类的say方法")
  class CLinux(CLanguage):
      def say(self):
          print("调用的是 CLinux 类的say方法")
  a = CLanguage()
  a.say()
  a = CPython()
  a.say()
  a = CLinux()
  a.say()
  
  调用的是 Clanguage 类的say方法
  调用的是 CPython 类的say方法
  调用的是 CLinux 类的say方法
  ```

  - 可以看到，CPython 和 CLinux 都继承自 CLanguage 类，且各自都重写了父类的 say() 方法。从运行结果可以看出，同一变量 a 在执行同一个 say() 方法时，由于 a 实际表示不同的类实例对象，因此 a.say() 调用的并不是同一个类中的 say() 方法，这就是多态。

- 但是，仅仅学到这里，读者还无法领略 Python 类使用多态特性的精髓。其实，Python 在多态的基础上，衍生出了一种更灵活的编程机制。

  ```
  class WhoSay:
      def say(self,who):
          who.say()
  class CLanguage:
      def say(self):
          print("调用的是 Clanguage 类的say方法")
  class CPython(CLanguage):
      def say(self):
          print("调用的是 CPython 类的say方法")
  class CLinux(CLanguage):
      def say(self):
          print("调用的是 CLinux 类的say方法")
  a = WhoSay()
  #调用 CLanguage 类的 say() 方法
  a.say(CLanguage())
  #调用 CPython 类的 say() 方法
  a.say(CPython())
  #调用 CLinux 类的 say() 方法
  a.say(CLinux())
  
  调用的是 Clanguage 类的say方法
  调用的是 CPython 类的say方法
  调用的是 CLinux 类的say方法
  ```

  - 此程序中，通过给 WhoSay 类中的 say() 函数添加一个 who 参数，其内部利用传入的 who 调用 say() 方法。这意味着，当调用 WhoSay 类中的 say() 方法时，我们传给 who 参数的是哪个类的实例对象，它就会调用那个类中的 say() 方法。

###### 枚举类

- 一些具有特殊含义的类，其实例化对象的个数往往是固定的，比如用一个类表示月份，则该类的实例对象最多有 12 个；再比如用一个类表示季节，则该类的实例化对象最多有 4 个。

- 针对这种特殊的类，[Python](http://c.biancheng.net/python/) 3.4 中新增加了 Enum 枚举类。也就是说，对于这些实例化对象个数固定的类，可以用枚举类来定义。

  ```
  from enum import Enum
  class Color(Enum):
      # 为序列值指定value值
      red = 1
      green = 2
      blue = 3
  ```

  - 如果想将一个类定义为枚举类，只需要令其继承自 enum 模块中的 Enum 类即可。例如在上面程序中，Color 类继承自 Enum 类，则证明这是一个枚举类。

- 在 Color 枚举类中，red、green、blue 都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为 name 和 value，其中 name 属性值为该枚举值的变量名（如 red），value 代表该枚举值的序号（序号通常从 1 开始）。

- 和普通类的用法不同，枚举类不能用来实例化对象，但这并不妨碍我们访问枚举类中的成员。访问枚举类成员的方式有多种，例如以 Color 枚举类为例，在其基础上添加如下代码：

  ```
  #调用枚举成员的 3 种方式
  print(Color.red)
  print(Color['red'])
  print(Color(1))
  #调取枚举成员中的 value 和 name
  print(Color.red.value)
  print(Color.red.name)
  #遍历枚举类中所有成员的 2 种方式
  for color in Color:
      print(color)
      
  Color.red
  Color.red
  Color.red
  1
  red
  Color.red
  Color.green
  Color.blue
  ```

- 枚举类成员之间不能比较大小，但可以用 == 或者 is 进行比较是否相等

  ```
  print(Color.red == Color.green)
  print(Color.red.name is Color.green.name)
  
  Flase
  Flase
  ```

- 需要注意的是，枚举类中各个成员的值，不能在类的外部做任何修改，也就是说，下面语法的做法是错误的：

  ```
  Color.red = 4
  ```

- 除此之外，该枚举类还提供了一个 `__members__` 属性，该属性是一个包含枚举类中所有成员的字典，通过遍历该属性，也可以访问枚举类中的各个成员。例如：

  ```
  for name,member in Color.__members__.items():
      print(name,"->",member)
      
  red -> Color.red
  green -> Color.green
  blue -> Color.blue
  ```

- 值得一提的是，Python 枚举类中各个成员必须保证 name 互不相同，但 value 可以相同

  ```
  from enum import Enum
  class Color(Enum):
      # 为序列值指定value值
      red = 1
      green = 1
      blue = 3
  print(Color['green'])
  
  Color.red
  ```

  - 可以看到，Color 枚举类中 red 和 green 具有相同的值（都是 1），Python 允许这种情况的发生，它会将 green 当做是 red 的别名，因此当访问 green 成员时，最终输出的是 red。

- 在实际编程过程中，如果想避免发生这种情况，可以借助 @unique 装饰器，这样当枚举类中出现相同值的成员时，程序会报 ValueError 错误。

  ```
  #引入 unique
  from enum import Enum,unique
  #添加 unique 装饰器
  @unique
  class Color(Enum):
      # 为序列值指定value值
      red = 1
      green = 1
      blue = 3
  print(Color['green'])
  
  Traceback (most recent call last):
    File "D:\python3.6\demo.py", line 3, in <module>
      class Color(Enum):
    File "D:\python3.6\lib\enum.py", line 834, in unique
      (enumeration, alias_details))
  ValueError: duplicate values found in <enum 'Color'>: green -> red
  ```

- 除了通过继承 Enum 类的方法创建枚举类，还可以使用 Enum() 函数创建枚举类

  ```
  from enum import Enum
  #创建一个枚举类
  Color = Enum("Color",('red','green','blue'))
  #调用枚举成员的 3 种方式
  print(Color.red)
  print(Color['red'])
  print(Color(1))
  #调取枚举成员中的 value 和 name
  print(Color.red.value)
  print(Color.red.name)
  #遍历枚举类中所有成员的 2 种方式
  for color in Color:
      print(color)
      
  Color.red
  Color.red
  Color.red
  1
  red
  Color.red
  Color.green
  Color.blue
  ```

  - Enum() 函数可接受 2 个参数，第一个用于指定枚举类的类名，第二个参数用于指定枚举类中的多个成员。

#### 类特殊成员

- Python 类中，凡是以双下划线 "\__" 开头和结尾命名的成员（属性和方法），都被称为类的特殊成员（特殊属性和特殊方法）。例如，类的 `__init__(self)` 构造方法就是典型的特殊方法。
- Python 类中的特殊成员，其特殊性类似 C++ 类的 private 私有成员，即不能在类的外部直接调用，但允许借助类中的普通方法调用甚至修改它们。如果需要，还可以对类的特殊方法进行重写，从而实现一些特殊的功能。

###### \__new__()

- `__new__()` 是一种负责创建类实例的静态方法，它无需使用 staticmethod 装饰器修饰，且该方法会优先 `__init__()` 初始化方法被调用。

- 一般情况下，覆写 `__new__()` 的实现将会使用合适的参数调用其超类的 `super().__new__()`，并在返回之前修改实例

```
class demoClass:
    instances_created = 0
    def __new__(cls,*args,**kwargs):
        print("__new__():",cls,args,kwargs)
        instance = super().__new__(cls)
        instance.number = cls.instances_created
        cls.instances_created += 1
        return instance
    def __init__(self,attribute):
        print("__init__():",self,attribute)
        self.attribute = attribute
test1 = demoClass("abc")
test2 = demoClass("xyz")
print(test1.number,test1.instances_created)
print(test2.number,test2.instances_created)

__new__(): <class '__main__.demoClass'> ('abc',) {}
__init__(): <__main__.demoClass object at 0x0000026FC0DF8080> abc
__new__(): <class '__main__.demoClass'> ('xyz',) {}
__init__(): <__main__.demoClass object at 0x0000026FC0DED358> xyz
0 2
1 2
```

- `__new__()` 通常会返回该类的一个实例，但有时也可能会返回其他类的实例，如果发生了这种情况，则会跳过对 `__init__()` 方法的调用。而在某些情况下（比如需要修改不可变类实例（[Python](http://c.biancheng.net/python/) 的某些内置类型）的创建行为），利用这一点会事半功倍

```
class nonZero(int):
    def __new__(cls,value):
        return super().__new__(cls,value) if value != 0 else None
    def __init__(self,skipped_value):
        #此例中会跳过此方法
        print("__init__()")
        super().__init__()
print(type(nonZero(-12)))
print(type(nonZero(0)))

__init__()
<class '__main__.nonZero'>
<class 'NoneType'>
```

- 那么，什么情况下使用 `__new__()` 呢？答案很简单，在 `__init__()` 不够用的时候。例如，前面例子中对 Python 不可变的内置类型（如 int、str、float 等）进行了子类化，这是因为一旦创建了这样不可变的对象实例，就无法在 `__init__`() 方法中对其进行修改。
- 有些读者可能会认为，`__new__()` 对执行重要的对象初始化很有用，如果用户忘记使用 super()，可能会漏掉这一初始化。虽然这听上去很合理，但有一个主要的缺点，即如果使用这样的方法，那么即便初始化过程已经是预期的行为，程序员明确跳过初始化步骤也会变得更加困难。不仅如此，它还破坏了“`__init__()` 中执行所有初始化工作”的潜规则。
- 注意，由于 `__new__()` 不限于返回同一个类的实例，所以很容易被滥用，不负责任地使用这种方法可能会对代码有害，所以要谨慎使用。一般来说，对于特定问题，最好搜索其他可用的解决方案，最好不要影响对象的创建过程，使其违背程序员的预期。比如说，前面提到的覆写不可变类型初始化的例子，完全可以用工厂方法（一种[设计模式](http://c.biancheng.net/design_pattern/)）来替代。
- Python中大量使用 `__new__()` 方法且合理的，就是 MetaClass 元类。

###### \__repr__():显示属性

- 前面章节中，我们经常会直接输出类的实例化对象，例如：

  ```
  class CLanguage:
      pass
  clangs = CLanguage()
  print(clangs)
  
  <__main__.CLanguage object at 0x000001A7275221D0>
  ```

  - 通常情况下，直接输出某个实例化对象，本意往往是想了解该对象的基本信息，例如该对象有哪些属性，它们的值各是多少等等。但默认情况下，我们得到的信息只会是“类名+object at+内存地址”，对我们了解该实例化对象帮助不大。

- 那么，有没有可能自定义输出实例化对象时的信息呢？答案是肯定，通过重写类的 `__repr__()` 方法即可。事实上，当我们输出某个实例化对象时，其调用的就是该对象的 `__repr__()` 方法，输出的是该方法的返回值。

  ```
  class CLanguage:
      def __init__(self):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
      def __repr__(self):
          return "CLanguage[name="+ self.name +",add=" + self.add +"]"
  clangs = CLanguage()
  print(clangs)
  
  CLanguage[name=C语言中文网,add=http://c.biancheng.net]
  ```

###### \__del__():销毁对象

- 
