#### python理解

- cpu执行的都是机器码，所以无论是编译型语言还是解释型语言最后都要编译为机器码来运行，不同的操作系统可执行文件的格式不同，例如linux下支持的是ELF格式，windows下使用的是PE格式，编译型语言例如c，要经历预处理、编译、汇编、链接四个过程，最后生成可执行文件，这个可执行文件操作系统是可以直接执行的，不用借助其他的中间件。可执行文件里面都是机器码。可执行文件放在虚拟内存里面，按照分页管理，用到哪部分机器码，就由操作系统按照内存映射将哪部分机器码放到物理内存中。每一个进程按照虚拟内存来说都有独立的内存区域，所以不用担心内存的问题。编译型语言例如python，其没有c语言的四个过程，但是如果想要运行就必须要有机器码，所以python在不同的平台上都实现了解释器，这个解释器是一个可执行程序，在linux下就是ELF文件，在windows下就是PE文件，在运行python程序的时候，由这个python解释器来将源代码编译为机器码来运行，这个过程不是说编译全部的，程序运行时需要哪部分代码就编译哪部分代码为机器码，将机器码放到内存中，这样就能直接运行。至于这个编译是如何控制的，也就是如何确定需要哪部分代码这是python解释器要实现的，使用者不需要管。所以python源文件是不能直接由操作系统执行的，必须借助python解释器。这也是python运行比较慢的原因

- python源码能跨平台运行，其中的差异都由不同平台上的python编译器隐藏了。例如不同的平台对于文件的管理是不同的，对于文件的底层实现是不同的。如果python源码中打开一个文件open(file)这个操作，不同的平台对于打开文件底层都是不同的，机器码也是不同的，但是这个机器码在相同的平台下是固定的，例如打开文件在linux下的机器码是固定的，这样python解释器就能将打开文件这个操作转换为机器码，然后将这个机器码放到内存中(内存中有代码段和数据段)，不同的解释器就是用来隐藏这个差异的，对我们用户来说打开文件都是一样的操作，其实底层都用解释器来隐藏了。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态。比如打开文件读写文件都在内核态，如果要用这些服务时，就会转到内存中的内核态里面去执行。python解释器应该也会实现这些转换，用户态到内核态，因为本身python解释器就是解释代码变成机器码来运行。操作系统只提供最基本的服务，具体的算法实现一般还是在用户态自己实现。

- python需要系统服务的一些会转到内核态，但是一些用户态的还是python本身自己就能实现，不用调用c和c++的库，例如数据计算时，数据计算主要是内存中的计算，定义变量时申请内存，计算时用机器码操作计算。这些python解释器就能转换为机器码来实现，不用先转换为c或者c++的库然后在转换为机器码，python解释器自己就能转换为机器码。所以一些numpy、pandas这些计算模块不用调用c或者c++的代码，用python的语法就能实现，剩下的交给python解释器就行。所以用pip下载的这些模块里面都没有动态库，只有py文件

- cpu指令是固定的，例如加减乘除移动访问，这些机器码对于cpu都是固定的，所有的语言最后都要生成cpu能执行的的这些固定的机器码。内存中有代码段和数据段。其实变量的定义和计算就是申请一个内存，然后计算，这个比较好说。如果涉及到操作系统提供的函数，就会涉及到一些底层的实现，这样生成的机器码比较复杂，放到内存中的也比较复杂，我们用户不用管这些，python解释器帮我们干了这些事情。其实操作系统提供的主要是一些文件操作以及网络服务之类的。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- 不同的编程语言对于操作系统提供的这些服务按照语法来说是不同的，但是最后生成的机器码都是一样的。不同的编程语言在一些功能上实现的方式不同，对于用户来说就是实现的简单与否。但是最后殊途同归，生成的机器码都是一样的。所以会有算法这种东西产生，不同的算法对于一个功能的实现可能是质的飞跃(不同的算法计算方式不一样)，这样生成的机器码就不会很啰嗦，生成的机器码就会很少，这样运算速度就会很快。所以算法对于运算的提升很大。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- python官网上的模块例如numpy，pandas官网上的都是.whl文件，whl文件本质上就是一个压缩文件，安装whl文件很简单，先手动下载文件然后手动安装时使用pip install xxx.whl，pip命令直接安装(不用先手动下载whl文件)也是命令自己下载whl文件，然后在解压安装，原理都是一样的。

- 查看可执行程序，windows下是where python， linux和mac下是which python

- pip安装包的路径查询，在pip install首次安装完成的时候会显示安装位置，如果已经安装使用pip install就会显示安装位置，windows下pip安装的模块一般都放在C:\Users\lylyx\AppData\Local\Programs\Python\Python39\Lib\site-packages里面

- mac下使用homebrew安装软件时使用brew info可以看到软件的依赖以及各种信息，如果直接安装例如brew install python3，里面的idle运行时就会提示Tkinter缺失(Tkinter模块("Tk 接口")是Python的标准Tk GUI工具包的接口。 作为 python 特定的GUI界面，是一个图像的窗口，tkinter是python 自带的，可以编辑的GUI界面)，这样就会出错。但是我们可以使用brew info python3，就是显示各种信息，包括依赖的tkinter问题，这样我们就能根据提示安装thinter，idle就能正常使用了

- pyc文件是py文件编译后生成的字节码文件(byte code)。pyc文件经过python解释器最终会生成机器码运行。为什么要手动提前生成pyc文件呢，主要是不想把源代码暴露出来。生成的pyc文件会放到当前目录下新创建的\__pycache__中

  ```
  命令生成pyc文件
  python -m foo.py
  代码来生成pyc文件
  import py_compile
  py_compile.compile('/path/to/foo.py')
  
  批量生成，针对一个目录下所有的py文件进行编译。python提供了一个模块叫compileall
  import compileall
  compileall.compile_dir(r'/path')
  ```

  - 生成的pyc文件使用python xxx.pyc来运行

#### 变量类型和运算符

- 变量在 Python 内部是有类型的，比如 int、float 等，但是我们在编程时无需关注变量类型，所有的变量都无需提前声明，赋值后就能使用。另外，可以将不同类型的数据赋值给同一个变量，所以变量的类型是可以改变的。

- Python 支持自增和自减运算符，但是它只支持一种形式，就是前自增和前自减，而取消了后自增和后自减，避免了给程序员造成混乱

- 变量（Variable）可以看成一个小箱子，专门用来“盛装”程序中的数据。每个变量都拥有独一无二的名字，通过变量的名字就能找到变量中的数据。

- 从底层看，程序中的数据最终都要放到内存（内存条）中，变量其实就是这块内存的名字。

- 和变量相对应的是常量（Constant），它们都是用来“盛装”数据的小箱子，不同的是：变量保存的数据可以被多次修改，而常量一旦保存某个数据之后就不能修改了。

- id() 内置函数，该函数的功能是获取变量（对象）所在的内存地址

- 在强类型的编程语言中，定义变量时要指明变量的类型，而且赋值的数据也必须是相同类型的，C语言、C++、[Java](http://c.biancheng.net/java/) 是强类型语言的代表。

- 和强类型语言相对应的是弱类型语言，Python、[JavaScript](http://c.biancheng.net/js/)、[PHP](http://c.biancheng.net/php/) 等脚本语言一般都是弱类型的。弱类型语言有两个特点：

  - 变量无须声明就可以直接赋值，对一个不存在的变量赋值就相当于定义了一个新变量。
  - 变量的数据类型可以随时改变，比如，同一个变量可以一会儿被赋值为整数，一会儿被赋值为字符串。

- 弱类型并不等于没有类型！弱类型是说在书写代码时不用刻意关注类型，但是在编程语言的内部仍然是有类型的。我们可以使用 type() 内置函数类检测某个变量或者表达式的类型，其类型的

  ```python
  >>>num = 10
  >>> type(num)
  <class 'int'>
  >>> num = 15.8
  >>> type(num)
  <class 'float'>
  >>> num = 20 + 15j
  >>> type(num)
  <class 'complex'>
  >>> type(3*15.6)
  <class 'float'>
  ```

- 弱类型语言的变量在内存中存储，每一种占据的字节数都是固定的，例如int占用四个字节，float占用8个字节一个。但是我们可以不用管，因为有python解释器，解释器就帮我们干了这个事，所以我们不用考虑变量的类型。

##### 整数

- Python 整数不分类型，或者说它只有一种类型的整数。Python 整数的取值范围是无限的，不管多大或者多小的数字，Python 都能轻松处理。当所用数值超过计算机自身的计算能力时，Python 会自动转用高精度计算（大数计算）。不管对于多大或者多小的整数，Python 只用一种类型存储，就是 int。无论对于多大的整数，type()的结果都为int

- 在 Python 中，可以使用多种进制来表示整数：

  1) 十进制形式

  我们平时常见的整数就是十进制形式，它由 0~9 共十个数字排列组合而成。

  注意，使用十进制形式的整数不能以 0 作为开头，除非这个数值本身就是 0。

  2) 二进制形式

  由 0 和 1 两个数字组成，书写时以`0b`或`0B`开头。例如，101 对应十进制数是 5。

  3) 八进制形式

  八进制整数由 0~7 共八个数字组成，以`0o`或`0O`开头。注意，第一个符号是数字 0，第二个符号是大写或小写的字母 O。

  在 Python 2.x 中，八进制数字还可以直接以`0`（数字零）开头。

  4) 十六进制形式

  由 0~9 十个数字以及 A~F（或 a~f）六个字母组成，书写时以`0x`或`0X`开头

- 为了提高数字的的可读性，Python 3.x 允许使用下划线`_`作为数字（包括整数和小数）的分隔符。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。下划线不会影响数字本身的值。

  ```python
  click = 1_301_547
  distance = 384_000_000
  print("Python教程阅读量：", click)
  print("地球和月球的距离：", distance)
  
  Python教程阅读量：1301547
  地球和月球的距离：384000000
  ```

##### 浮点数

- [Python](http://c.biancheng.net/python/) 中的小数有两种书写形式：

  1) 十进制形式

  这种就是我们平时看到的小数形式，例如 34.6、346.0、0.346。

  书写小数时必须包含一个小数点，否则会被 Python 当作整数处理。

  2) 指数形式

  Python 小数的指数形式的写法为：aEn 或 aen

  a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；`E`或`e`是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 a×10n。

- 只要写成指数形式就是小数，即使它的最终值看起来像一个整数。例如 14E3 等价于 14000，但 14E3 是一个小数。

- Python 只有一种小数类型，就是 float。C语言有两种小数类型，分别是 float 和 double：float 能容纳的小数范围比较小，double 能容纳的小数范围比较大。

- Python 能容纳极小和极大的浮点数。print 在输出浮点数时，会根据浮点数的长度和大小适当的舍去一部分数字，或者采用科学计数法。

  ```python
  f5 = 12e4
  print("f5Value: ", f5)
  print("f5Type: ", type(f5))
  f6 = 12.3 * 0.1
  print("f6Value: ", f6)
  print("f6Type: ", type(f6))
  
  f5Value:  120000.0
  f5Type:  <class 'float'>
  f6Value:  1.2300000000000002
  f6Type:  <class 'float'>
  ```

  - f5 的值是 120000，但是它依然是小数类型，而不是整数类型。

  -  f6中`12.3*0.1`的计算结果很明显是 1.23，但是 print 的输出却不精确。这是因为小数在内存中是以二进制形式存储的，小数点后面的部分在转换成二进制时很有可能是一串无限循环的数字，无论如何都不能精确表示，所以小数的计算结果一般都是不精确的

  - 为什么在计算这么简单的问题上，计算机会出现这样的低级错误呢？真正的原因在于十进制和数和二进制数的转换。计算机其实是不认识十进制数，它只认识二进制数，也就是说，当我们以十进制数进行运算的时候，计算机需要将各个十进制数转换成二进制数，然后进行二进制间的计算。以类似 0.1 这样的浮点数为例，如果手动将其转换成二进制，其结果为：

    ```
    0.1(10)=0.00011001100110011...(2)
    ```

    - 可以看到，结果是无限循环的，也就是说，0.1 转换成二进制数后，无法精确到等于十进制数的 0.1。同时，由于计算机存储的位数是有限制的，所以如果要存储的二进制位数超过了计算机存储位数的最大值，其后续位数会被舍弃（舍弃的原则是“0 舍 1 入”）。	

- 如果需要非常精确的结果，可以使用 decimal 模块（其实就是别人开发好的程序，我们可以直接拿来用），它实现的十进制数运算适合会计方面的应用和有高精度要求的应用

  ```python
  #使用模块前，需要使用 import 引入
  import decimal
  a = decimal.Decimal("10.0")
  b = decimal.Decimal("3")
  print(10.0/3)
  print(a/b)
  
  3.3333333333333335
  3.333333333333333333333333333
  ```

- 如果 decimal 模块还是无法满足需求，还可以使用 fractions 模块

  ```python
  #引入 decimal 模块
  from fractions import Fraction
  print(10/3)
  print(Fraction(10,3))
  
  3.3333333333333335
  10/3
  ```

  

##### 复数

- 复数（Complex）是 [Python](http://c.biancheng.net/python/) 的内置类型，直接书写即可。换句话说，Python 语言本身就支持复数，而不依赖于标准库或者第三方库。
- 复数由实部（real）和虚部（imag）构成，在 Python 中，复数的虚部以`j`或者`J`作为后缀，具体格式为：a + bj，a 表示实部，b 表示虚部。

```python
c1 = 12 + 0.2j
print("c1Value: ", c1)
print("c1Type", type(c1))
c2 = 6 - 1.2j
print("c2Value: ", c2)
#对复数进行简单计算
print("c1+c2: ", c1+c2)
print("c1*c2: ", c1*c2)

c1Value:  (12+0.2j)
c1Type <class 'complex'>
c2Value:  (6-1.2j)
c1+c2:  (18-1j)
c1*c2:  (72.24-13.2j)
```

- 复数在 Python 内部的类型是 complex，Python 默认支持对复数的简单计算。

##### 字符串

- Python中的字符串必须由双引号`" "`或者单引号`' '`包围

- Python 字符串中的双引号和单引号没有任何区别。而有些编程语言的双引号字符串可以解析变量，单引号字符串一律原样输出，例如 [PHP](http://c.biancheng.net/php/) 和 [JavaScript](http://c.biancheng.net/js/)。

- 字符串中对引号的处理有两种方案

  - 对引号进行转义，在引号前面添加反斜杠`\`就可以对引号进行转义，让 Python 把它作为普通文本对待
  - 使用不同的引号包围字符串。如果字符串内容中出现了单引号，那么我们可以使用双引号包围字符串，反之亦然

- 字符串的换行。Python 不是格式自由的语言，它对程序的换行、缩进都有严格的语法要求。要想换行书写一个比较长的字符串，必须在行尾添加反斜杠`\`

  ```
  s2 = 'It took me six months to write this Python tutorial. \
      Please give me more support. \
      I will keep it updated.'
  ```

  - 上面 s2 字符串的比较长，所以使用了转义字符`\`对字符串内容进行了换行，这样就可以把一个长字符串写成多行。

  - Python 也支持表达式的换行

    ```
    num = 20 + 3 / 4 + \
        2 * 3
    print(num)
    ```

- 长字符串。使用三个单引号或者双引号可以对多行内容进行注释，这其实是 Python 长字符串的写法。所谓长字符串，就是可以直接换行（不用加反斜杠`\`）书写的字符串。Python 长字符串由三个双引号`"""`或者三个单引号`'''`包围。在长字符串中放置单引号或者双引号不会导致解析错误。如果长字符串没有赋值给任何变量，那么这个长字符串就不会起到任何作用，和一段普通的文本无异，相当于被注释掉了。此时 Python 解释器并不会忽略长字符串，也会按照语法解析，只是长字符串起不到实际作用而已。当程序中有大段文本内容需要定义成字符串时，优先推荐使用长字符串形式，因为这种形式非常强大，可以在字符串中放置任何内容，包括单引号和双引号。长字符串中的换行、空格、缩进等空白符都会原样输出

  ```python
  longstr = '''
      It took me 6 months to write this Python tutorial.
      Please give me a to 'thumb' to keep it updated.
      The Python tutorial is available at http://c.biancheng.net/python/.
  '''
  print(longstr)
  
  
      It took me 6 months to write this Python tutorial.
      Please give me a to 'thumb' to keep it updated.
      The Python tutorial is available at http://c.biancheng.net/python/.
   
   字符串内容前后多出了两个空行，并且每一行的前面会多出四个空格。
  
  ```

- 原始字符串。Python 字符串中的反斜杠`\`有着特殊的作用，就是转义字符。转义字符有时候会带来一些麻烦，例如我要表示一个包含 Windows 路径`D:\Program Files\Python 3.8\python.exe`这样的字符串，在 Python 程序中直接这样写肯定是不行的，不管是普通字符串还是长字符串。因为`\`的特殊性，我们需要对字符串中的每个`\`都进行转义，也就是写成`D:\\Program Files\\Python 3.8\\python.exe\`这种形式才行。这种写法需要特别谨慎，稍有疏忽就会出错。为了解决转义字符的问题，Python 支持原始字符串。在原始字符串中，`\`不会被当作转义字符，所有的内容都保持“原汁原味”的样子。

  - 在普通字符串或者长字符串的开头加上`r`前缀，就变成了原始字符串

    ```
    str1 = r'原始字符串内容'
    str2 = r"""原始字符串内容"""
    
    rstr = r'D:\Program Files\Python 3.8\python.exe'
    print(rstr)
    ```

  - 如果普通格式的原始字符串中出现引号，程序同样需要对引号进行转义，否则 Python 照样无法对字符串的引号精确配对；但是和普通字符串不同的是，此时用于转义的反斜杠会变成字符串内容的一部分。

    ```
    str1 = r'I\'m a great coder!'
    print(str1)
    
    I\'m a great coder!
    ```

    - 需要注意的是，Python 原始字符串中的反斜杠仍然会对引号进行转义，因此原始字符串的结尾处不能是反斜杠，否则字符串结尾处的引号会被转义，导致字符串不能正确结束。

  - 在 Python 中有两种方式解决原始字符串中\这个问题：一种方式是改用长字符串的写法，不要使用原始字符串；另一种方式是单独书写反斜杠

    - 例如想表示`D:\Program Files\Python 3.8\`，可以这样写：

      ```
      str1 = r'D:\Program Files\Python 3.8' '\\'
      print(str1)
      
      我们先写了一个原始字符串r'D:\Program Files\Python 3.8'，紧接着又使用'\\'写了一个包含转义字符的普通字符串，Python 会自动将这两个字符串拼接在一起
      D:\Program Files\Python 3.8\
      ```

##### bytes

- bytes 类型用来表示一个字节串。“字节串“不是编程术语，是我自己“捏造”的一个词，用来和字符串相呼应。

- 字节串（bytes）和字符串（string）的对比：

  - 字符串由若干个字符组成，以字符为单位进行操作；字节串由若干个字节组成，以字节为单位进行操作。
  - 字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法都基本相同。
  - 字节串和字符串都是不可变序列，不能随意增加和删除数据。

- bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。说白了，bytes 只是简单地记录内存中的原始数据，至于如何使用这些数据，bytes 并不在意，你想怎么使用就怎么使用，bytes 并不约束你的行为。bytes 类型的数据非常适合在互联网上传输，可以用于网络通信编程；bytes 也可以用来存储图片、音频、视频等二进制格式的文件。

- 字符串和 bytes 存在着千丝万缕的联系，我们可以通过字符串来创建 bytes 对象，或者说将字符串转换成 bytes 对象。有以下三种方法可以达到这个目的：

  - 如果字符串的内容都是 ASCII 字符，那么直接在字符串前面添加`b`前缀就可以转换成 bytes。
  - bytes 是一个类，调用它的构造方法，也就是 bytes()，可以将字符串按照指定的字符集转换成 bytes；如果不指定字符集，那么默认采用 UTF-8。
  - 字符串本身有一个 encode() 方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8。

  ```
  #通过构造函数创建空 bytes
  b1 = bytes()
  #通过空字符串创建空 bytes
  b2 = b''
  #通过b前缀将字符串转换成 bytes
  b3 = b'http://c.biancheng.net/python/'
  print("b3: ", b3)
  print(b3[3])
  print(b3[7:22])
  #为 bytes() 方法指定字符集
  b4 = bytes('C语言中文网8岁了', encoding='UTF-8')
  print("b4: ", b4)
  #通过 encode() 方法将字符串转换成 bytes
  b5 = "C语言中文网8岁了".encode('UTF-8')
  print("b5: ", b5)
  
  
  b3:  b'http://c.biancheng.net/python/'
  112
  b'c.biancheng.net'
  b4:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
  b5:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
  ```

  - 从运行结果可以发现，对于非 ASCII 字符，print 输出的是它的字符编码值（十六进制形式），而不是字符本身。非 ASCII 字符一般占用两个字节以上的内存，而 bytes 是按照单个字节来处理数据的，所以不能一次处理多个字节。

- bytes 类也有一个 decode() 方法，通过该方法可以将 bytes 对象转换为字符串

  ```
  #通过 decode() 方法将 bytes 转换成字符串
  str1 = b5.decode('UTF-8')
  print("str1: ", str1)
  
  str1:  C语言中文网8岁了
  ```

##### bool

- True 和 False 是 Python 中的关键字，当作为 Python 代码输入时，一定要注意字母的大小写，否则解释器会报错。

- 布尔类型可以当做整数来对待，即 True 相当于整数值 1，False 相当于整数值 0。

  ```
  >>> False+1
  1
  >>> True+1
  2
  ```

- 在 Python 中，所有的对象都可以进行真假值的测试，包括字符串、元组、列表、字典、对象等

##### input()函数

- input() 是 [Python](http://c.biancheng.net/python/) 的内置函数，用于从控制台读取用户输入的内容。input() 函数总是以字符串的形式来处理用户输入的内容，所以用户输入的内容可以包含任何字符。

  ```
  str = input(tipmsg)
  ```

  - str 表示一个字符串类型的变量，input 会将读取到的字符串放入 str 中。
  - tipmsg 表示提示信息，它会显示在控制台上，告诉用户应该输入什么样的内容；如果不写 tipmsg，就不会有任何提示信息。

- 我们可以使用 Python 内置函数将字符串转换成想要的类型，比如：

  - int(string) 将字符串转换成 int 类型；
  - float(string) 将字符串转换成 float 类型；
  - bool(string) 将字符串转换成 bool 类型。

##### print

- print() 函数完全可以同时输出多个变量

- print() 函数的详细语法格式如下：

  ```
  print (value,...,sep='',end='\n',file=sys.stdout,flush=False)
  ```

  - value 参数可以接受任意多个变量或值，因此 print() 函数完全可以输出多个值

    ```
    user_name ＝ 'Charlie'
    user_age = 8
    #同时输出多个变量和字符串
    print("读者名：",user_name,"年龄：",user_age)
    
    读者名： Charlie 年龄： 8
    ```

  - 从输出结果来看，使用 print() 函数输出多个变量时，print() 函数默认以空格隔开多个变量，如果读者希望改变默认的分隔符，可通过 sep 参数进行设置。例如输出语句：

    ```
    #同时输出多个变量和字符串，指定分隔符
    print("读者名：" ,user_name,"年龄：",user_age,sep='|')
    
    读者名：|Charlie|年龄：|8
    ```

  - 在默认情况下，print() 函数输出之后总会换行，这是因为 print() 函数的 end 参数的默认值是“\n”，这个“\n”就代表了换行。如果希望 print() 函数输出之后不会换行，则重设 end 参数即可

    ```
    #设置end 参数，指定输出之后不再换行
    print(40,'\t',end＝"")
    print(5O,'\t',end＝"")
    print(60,'\t',end＝"")
    
    40    50    60
    ```

  - file 参数指定 print() 函数的输出目标，file 参数的默认值为 sys.stdout，该默认值代表了系统标准输出，也就是屏幕，因此 print() 函数默认输出到屏幕。实际上，完全可以通过改变该参数让 print() 函数输出到特定文件中

    ```
    f = open("demo.txt","w")#打开文件以便写入
    print('沧海月明珠有泪',file=f)
    print('蓝回日暖玉生烟',file=f)
    f.close()
    ```

  - print() 函数的 flush 参数用于控制输出缓存，该参数一般保持为 False 即可，这样可以获得较好的性能。
  
- print() 函数使用以`%`开头的转换说明符对各种类型的数据进行格式化输出

  | 转换说明符 | 解释                                   |
  | ---------- | -------------------------------------- |
  | %d、%i     | 转换为带符号的十进制整数               |
  | %o         | 转换为带符号的八进制整数               |
  | %x、%X     | 转换为带符号的十六进制整数             |
  | %e         | 转化为科学计数法表示的浮点数（e 小写） |
  | %E         | 转化为科学计数法表示的浮点数（E 大写） |
  | %f、%F     | 转化为十进制浮点数                     |
  | %g         | 智能选择使用 %f 或 %e 格式             |
  | %G         | 智能选择使用 %F 或 %E 格式             |
  | %c         | 格式化字符及其 ASCII 码                |
  | %r         | 使用 repr() 函数将表达式转换为字符串   |
  | %s         | 使用 str() 函数将表达式转换为字符串    |

  ```
  age = 8
  print("C语言中文网已经%d岁了！" % age)
  
  输出结果  C语言中文网已经8岁了！
  在 print() 函数中，由引号包围的是格式化字符串，它相当于一个字符串模板，可以放置一些转换说明符（占位符）。本例的格式化字符串中包含一个%d说明符，它最终会被后面的 age 变量的值所替代。中间的%是一个分隔符，它前面是格式化字符串，后面是要输出的表达式。
  
  格式化字符串中也可以包含多个转换说明符，这个时候也得提供多个表达式，用以替换对应的转换说明符；多个表达式必须使用小括号( )包围起来。
  name = "C语言中文网"
  age = 8
  url = "http://c.biancheng.net/"
  print("%s已经%d岁了，它的网址是%s。" % (name, age, url))
  
  C语言中文网已经8岁了，它的网址是http://c.biancheng.net/。
  
  如果没有中间的%分割就会出错，另外如果没有% ，两个中间有逗号分隔输出结果为  C语言中文网已经%d岁了！ 8
  ```

- 指定最小输出宽度

  - %10d 表示输出的整数宽度至少为 10；

  - %20s 表示输出的字符串宽度至少为 20。

    ```
    n = 1234567
    print("n(10):%10d." % n)
    print("n(5):%5d." % n)
    url = "http://c.biancheng.net/python/"
    print("url(35):%35s." % url)
    print("url(20):%20s." % url)
    
    n(10):   1234567.
    n(5):1234567.
    url(35):     http://c.biancheng.net/python/.
    url(20):http://c.biancheng.net/python/.
    ```

  - 从运行结果可以发现，对于整数和字符串，当数据的实际宽度小于指定宽度时，会在左侧以空格补齐；当数据的实际宽度大于指定宽度时，会按照数据的实际宽度输出。

- 指定对齐方式

  - 默认情况下，print() 输出的数据总是右对齐的。也就是说，当数据不够宽时，数据总是靠右边输出，而在左边补充空格以达到指定的宽度。Python 允许在最小宽度之前增加一个标志来改变对齐方式

    | 标志 | 说明                                               |
    | ---- | -------------------------------------------------- |
    | -    | 指定左对齐                                         |
    | +    | 表示输出的数字总要带着符号；正数带`+`，负数带`-`。 |
    | 0    | 表示宽度不足时补充 0，而不是补充空格。             |

    - 对于整数，指定左对齐时，在右边补 0 是没有效果的，因为这样会改变整数的值。
    - 对于小数，以上三个标志可以同时存在。
    - 对于字符串，只能使用`-`标志，因为符号对于字符串没有意义，而补 0 会改变字符串的值。

    ```
    n = 123456
    # %09d 表示最小宽度为9，左边补0
    print("n(09):%09d" % n)
    # %+9d 表示最小宽度为9，带上符号
    print("n(+9):%+9d" % n)
    f = 140.5
    # %-+010f 表示最小宽度为10，左对齐，带上符号
    print("f(-+0):%-+010f" % f)
    s = "Hello"
    # %-10s 表示最小宽度为10，左对齐
    print("s(-10):%-10s." % s)
    
    n(09):000123456
    n(+9):  +123456
    f(-+0):+140.500000
    s(-10):Hello     .
    ```

- 指定小数精度

  - 对于小数（浮点数），print() 还允许指定小数点后的数字位数，也即指定小数的输出精度。

  - 精度值需要放在最小宽度之后，中间用点号`.`隔开；也可以不写最小宽度，只写精度。具体格式如下：

    ```
    %m.nf
    %.nf
    
    m 表示最小宽度，n 表示输出精度，.是必须存在的。
    
    f = 3.141592653
    # 最小宽度为8，小数点后保留3位
    print("%8.3f" % f)
    # 最小宽度为8，小数点后保留3位，左边补0
    print("%08.3f" % f)
    # 最小宽度为8，小数点后保留3位，左边补0，带符号
    print("%+08.3f" % f)
    
       3.142
    0003.142
    +003.142
    ```

    

##### 转义字符

- 转义字符，就是那些以反斜杠`\`开头的字符。

- ASCII 编码为每个字符都分配了唯一的编号，称为编码值。在 [Python](http://c.biancheng.net/python/) 中，一个 ASCII 字符除了可以用它的实体（也就是真正的字符）表示，还可以用它的编码值表示。这种使用编码值来间接地表示字符的方式称为转义字符（Escape Character）。

- 转义字符以`\0`或者`\x`开头，以`\0`开头表示后跟八进制形式的编码值，以`\x`开头表示后跟十六进制形式的编码值，Python 中的转义字符只能使用八进制或者十六进制。

  ```
  \0dd
  \xhh
  ```

  - dd 表示八进制数字，hh 表示十六进制数字。

- ASCII 编码共收录了 128 个字符，`\0`和`\x`后面最多只能跟两位数字，所以八进制形式`\0`并不能表示所有的 ASCII 字符，只有十六进制形式`\x`才能表示所有 ASCII 字符。

- 字符 1、2、3、x、y、z 对应的 ASCII 码的八进制形式分别是 61、62、63、170、171、172，十六进制形式分别是 31、32、33、78、79、7A。下面的例子演示了转义字符的用法：使用八进制形式的转义字符没法表示 xyz，因为它们的编码值转换成八进制以后有三位。

  ```python
  str1 = "Oct: \061\062\063"
  str2 = "Hex: \x31\x32\x33\x78\x79\x7A"
  print(str1)
  print(str2)
  
  Oct: 123
  Hex: 123xyz
  ```

- 对于 ASCII 编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能用转义字符的形式来表示。不过，直接使用 ASCII 码记忆不方便，也不容易理解，所以，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下。

  | 转义字符 | 说明                                                         |
  | -------- | ------------------------------------------------------------ |
  | \n       | 换行符，将光标位置移到下一行开头。                           |
  | \r       | 回车符，将光标位置移到本行开头。                             |
  | \t       | 水平制表符，也即 Tab 键，一般相当于四个空格。                |
  | \a       | 蜂鸣器响铃。注意不是喇叭发声，现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效。 |
  | \b       | 退格（Backspace），将光标位置移到前一列。                    |
  | \\\      | 反斜线                                                       |
  | \\'      | 单引号                                                       |
  | \\"      | 双引号                                                       |
  | \\       | 在字符串行尾的续行符，即一行未完，转到下一行继续写。         |

```python
#使用\t排版
str1 = '网站\t\t域名\t\t\t年龄\t\t价值'
str2 = 'C语言中文网\tc.biancheng.net\t\t8\t\t500W'
str3 = '百度\t\twww.baidu.com\t\t20\t\t500000W'
print(str1)
print(str2)
print(str3)
print("--------------------")
# \n在输出时换行，\在书写字符串时换行
info = "Python教程：http://c.biancheng.net/python/\n\
C++教程：http://c.biancheng.net/cplus/\n\
Linux教程：http://c.biancheng.net/linux_tutorial/"
print(info)

网站        域名                年龄    价值
C语言中文网 c.biancheng.net     8       500W
百度        www.baidu.com       20      500000W
--------------------
Python教程：http://c.biancheng.net/python/
C++教程：http://c.biancheng.net/cplus/
Linux教程：http://c.biancheng.net/linux_tutorial/
```

##### 数据类型转换

- 虽然 [Python](http://c.biancheng.net/python/) 是弱类型编程语言，不需要像 [Java](http://c.biancheng.net/java/) 或 C 语言那样还要在使用变量前声明变量的类型，但在一些特定场景中，仍然需要用到类型转换。

  | 函 数                  | 作 用                                              |
  | ---------------------- | -------------------------------------------------- |
  | int(x)                 | 将 x 转换成整数类型                                |
  | float(x)               | 将 x 转换成浮点数类型                              |
  | complex(real，[,imag]) | 创建一个复数                                       |
  | str(x)                 | 将 x 转换为字符串                                  |
  | repr(x)                | 将 x 转换为表达式字符串                            |
  | eval(str)              | 计算在字符串中的有效 Python 表达式，并返回一个对象 |
  | chr(x)                 | 将整数 x 转换为一个字符                            |
  | ord(x)                 | 将一个字符 x 转换为它对应的整数值                  |
  | hex(x)                 | 将一个整数 x 转换为一个十六进制字符串              |
  | oct(x)                 | 将一个整数 x 转换为一个八进制的字符串              |

- 需要注意的是，在使用类型转换函数时，提供给它的数据必须是有意义的。例如，int() 函数无法将一个非数字字符串转换成整数

  ```
  >>> int("123") #转换成功
  123
  >>> int("123个") #转换失败
  Traceback (most recent call last):
    File "<pyshell#3>", line 1, in <module>
      int("123个")
  ValueError: invalid literal for int() with base 10: '123个'
  ```

##### 运算符

###### 算数运算符

| 运算符 | 说明                                | 实例        | 结果      |
| ------ | ----------------------------------- | ----------- | --------- |
| +      | 加                                  | 12.45 + 15  | 27.45     |
| -      | 减                                  | 4.56 - 0.26 | 4.3       |
| *      | 乘                                  | 5 * 3.6     | 18.0      |
| /      | 除法（和数学中的规则一样）          | 7 / 2       | 3.5       |
| //     | 整除（只保留商的整数部分）          | 7 // 2      | 3         |
| %      | 取余，即返回除法的余数              | 7 % 2       | 1         |
| **     | 幂运算/次方运算，即返回 x 的 y 次方 | 2 ** 4      | 16，即 24 |

- 当`+`用于数字时表示加法，但是当`+`用于字符串时，它还有拼接字符串（将两个字符串连接为一个）的作用

  ```
  name = "C语言中文网"
  url = "http://c.biancheng.net/"
  age = 8
  info = name + "的网址是" + url + "，它已经" + str(age) + "岁了。"
  print(info)
  ```

  - str() 函数用来将整数类型的 age 转换成字符串。

- `*`除了可以用作乘法运算，还可以用来重复字符串，也即将 n 个同样的字符串连接起来

  ```
  str1 = "hello "
  print(str1 * 4)
  
  hello hello hello hello 
  ```

- Python 支持`/`和`//`两个除法运算符，但它们之间是有区别的：

  - `/`表示普通除法，使用它计算出来的结果和数学中的计算结果相同。
  - `//`表示整除，只保留结果的整数部分，舍弃小数部分；注意是直接丢掉小数部分，而不是四舍五入。
  - `/`的计算结果总是小数，不管是否能除尽，也不管参与运算的是整数还是小数。
  - 当有小数参与运算时，`//`结果才是小数，否则就是整数。
  - 除数始终不能为 0，除以 0 是没有意义的，这将导致 ZeroDivisionError 错误

- Python ** 运算符用来求一个 x 的 y 次方，也即次方（乘方）运算符。由于开方是次方的逆运算，所以也可以使用 ** 运算符间接地实现开方运算。

  ```
  print('----次方运算----')
  print('3**4 =', 3**4)
  print('2**5 =', 2**5)
  print('----开方运算----')
  print('81**(1/4) =', 81**(1/4))
  print('32**(1/5) =', 32**(1/5))
  ```

###### 赋值运算符

- 连续赋值，Python 中的赋值表达式也是有值的，它的值就是被赋的那个值，或者说是左侧变量的值；如果将赋值表达式的值再赋值给另外一个变量，这就构成了连续赋值。

  ```
  a = b = c = 100
  ```

  - `=`具有右结合性，我们从右到左分析这个表达式：
    - c = 100 表示将 100 赋值给 c，所以 c 的值是 100；同时，c = 100 这个子表达式的值也是 100。
    - b = c = 100 表示将 c = 100 的值赋给 b，因此 b 的值也是 100。
    - 以此类推，a 的值也是 100。

  | 运算符 | 说 明            | 用法举例 | 等价形式                              |
  | ------ | ---------------- | -------- | ------------------------------------- |
  | =      | 最基本的赋值运算 | x = y    | x = y                                 |
  | +=     | 加赋值           | x += y   | x = x + y                             |
  | -=     | 减赋值           | x -= y   | x = x - y                             |
  | *=     | 乘赋值           | x *= y   | x = x * y                             |
  | /=     | 除赋值           | x /= y   | x = x / y                             |
  | %=     | 取余数赋值       | x %= y   | x = x % y                             |
  | **=    | 幂赋值           | x **= y  | x = x ** y                            |
  | //=    | 取整数赋值       | x //= y  | x = x // y                            |
  | &=     | 按位与赋值       | x &= y   | x = x & y                             |
  | \|=    | 按位或赋值       | x \|= y  | x = x \| y                            |
  | ^=     | 按位异或赋值     | x ^= y   | x = x ^ y                             |
  | <<=    | 左移赋值         | x <<= y  | x = x << y，这里的 y 指的是左移的位数 |
  | >>=    | 右移赋值         | x >>= y  | x = x >> y，这里的 y 指的是右移的位数 |

###### 位运算符

- [Python](http://c.biancheng.net/python/) 位运算按照数据在内存中的二进制位（Bit）进行操作，它一般用于底层开发（算法设计、驱动、图像处理、单片机等），在应用层开发（Web 开发、Linux 运维等）中并不常见。

  | 位运算符 | 说明     | 使用形式 | 举 例                            |
  | -------- | -------- | -------- | -------------------------------- |
  | &        | 按位与   | a & b    | 4 & 5                            |
  | \|       | 按位或   | a \| b   | 4 \| 5                           |
  | ^        | 按位异或 | a ^ b    | 4 ^ 5                            |
  | ~        | 按位取反 | ~a       | ~4                               |
  | <<       | 按位左移 | a << b   | 4 << 2，表示整数 4 按位左移 2 位 |
  | >>       | 按位右移 | a >> b   | 4 >> 2，表示整数 4 按位右移 2 位 |

- Python 左移运算符`<<`用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补 0。
- Python 右移运算符`>>`用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。

###### 比较运算符

| 比较运算符 | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| >          | 大于，如果`>`前面的值大于后面的值，则返回 True，否则返回 False。 |
| <          | 小于，如果`<`前面的值小于后面的值，则返回 True，否则返回 False。 |
| ==         | 等于，如果`==`两边的值相等，则返回 True，否则返回 False。    |
| >=         | 大于等于（等价于数学中的 ≥），如果`>=`前面的值大于或者等于后面的值，则返回 True，否则返回 False。 |
| <=         | 小于等于（等价于数学中的 ≤），如果`<=`前面的值小于或者等于后面的值，则返回 True，否则返回 False。 |
| !=         | 不等于（等价于数学中的 ≠），如果`!=`两边的值不相等，则返回 True，否则返回 False。 |
| is         | 判断两个变量所引用的对象是否相同，如果相同则返回 True，否则返回 False。 |
| is not     | 判断两个变量所引用的对象是否不相同，如果不相同则返回 True，否则返回 False。 |

- 初学 Python，大家可能对 is 比较陌生，很多人会误将它和 == 的功能混为一谈，但其实 is 与 == 有本质上的区别，完全不是一码事儿。== 用来比较两个变量的值是否相等，而 is 则用来比对两个变量引用的是否是同一个对象

  ```
  import time  #引入time模块
  t1 = time.gmtime() # gmtime()用来获取当前时间
  t2 =  time.gmtime()
  print(t1 == t2) #输出True
  print(t1 is t2) #输出False
  
  True
  False
  ```

  - time 模块的 gmtime() 方法用来获取当前的系统时间，精确到秒级，因为程序运行非常快，所以 t1 和 t1 得到的时间是一样的。== 用来判断 t1 和 t2 的值是否相等，所以返回 True。
  - 虽然 t1 和 t2 的值相等，但它们是两个不同的对象（每次调用 gmtime() 都返回不同的对象），所以`t1 is t2`返回 False。这就好像两个双胞胎姐妹，虽然她们的外貌是一样的，但它们是两个人。
  - 那么，如何判断两个对象是否相同呢？答案是判断两个对象的内存地址。如果内存地址相同，说明两个对象使用的是同一块内存，当然就是同一个对象了；这就像两个名字使用了同一个身体，当然就是同一个人了。

###### 逻辑运算符

| 逻辑运算符 | 含义                           | 基本格式 | 说明                                                         |
| ---------- | ------------------------------ | -------- | ------------------------------------------------------------ |
| and        | 逻辑与运算，等价于数学中的“且” | a and b  | 当 a 和 b 两个表达式都为真时，a and b 的结果才为真，否则为假。 |
| or         | 逻辑或运算，等价于数学中的“或” | a or b   | 当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。 |
| not        | 逻辑非运算，等价于数学中的“非” | not a    | 如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。 |

- 有些不负责任的 Python 教程说：Python 逻辑运算符用于操作 bool 类型的表达式，执行结果也是 bool 类型，这两点其实都是错误的！Python 逻辑运算符可以用来操作任何类型的表达式，不管表达式是不是 bool 类型；同时，逻辑运算的结果也不一定是 bool 类型，它也可以是任意类型。

  ```
  print(100 and 200)
  print(45 and 0)
  print("" or "http://c.biancheng.net/python/")
  print(18.5 or "http://c.biancheng.net/python/")
  
  200
  0
  http://c.biancheng.net/python/
  18.5
  ```

  - 在 Python 中，and 和 or 不一定会计算右边表达式的值，有时候只计算左边表达式的值就能得到最终结果。
  - 另外，and 和 or 运算符会将其中一个表达式的值作为最终结果，而不是将 True 或者 False 作为最终结果。

- 对于 and 运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 Python 按照下面的规则执行 and 运算：

  - 如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时 and 会把左边表达式的值作为最终结果。
  - 如果左边表达式的值为真，那么最终值是不能确定的，and 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

- 对于 or 运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以 Python 按照下面的规则执行 or 运算：

  - 如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时 or 会把左边表达式的值作为最终结果。
  - 如果左边表达式的值为假，那么最终值是不能确定的，or 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

###### 三目运算符

- 假设现在有两个数字，我们希望获得其中较大的一个，那么可以使用 if else 语句

  ```
  if a>b:
      max = a;
  else:
      max = b;
  
  但是 Python 提供了一种更加简洁的写法
  max = a if a>b else b
  ```

  - 这是一种类似于其它编程语言中三目运算符`? :`的写法。Python 是一种极简主义的编程语言，它没有引入`? :`这个新的运算符，而是使用已有的 if else 关键字来实现相同的功能。

- 使用 if else 实现三目运算符（条件运算符）的格式如下：

  ```
  exp1 if contion else exp2
  ```

  - condition 是判断条件，exp1 和 exp2 是两个表达式。如果 condition 成立（结果为真），就执行 exp1，并把 exp1 的结果作为整个表达式的结果；如果 condition 不成立（结果为假），就执行 exp2，并把 exp2 的结果作为整个表达式的结果。

- 前面的语句`max = a if a>b else b`的含义是：

  - 如果 a>b 成立，就把 a 作为整个表达式的值，并赋给变量 max；
  - 如果 a> b 不成立，就把 b 作为整个表达式的值，并赋给变量 max。

- Python 三目运算符支持嵌套，如此可以构成更加复杂的表达式。在嵌套时需要注意 if 和 else 的配对

  ```
  a if a>b else c if c>d else d
  应该理解为：
  a if a>b else ( c if c>d else d )
  ```

###### 运算符优先级和结合性

| 运算符说明 | Python运算符            | 优先级 | 结合性 | 优先级顺序 |
| ---------- | ----------------------- | ------ | ------ | ---------- |
| 小括号     | ( )                     | 19     | 无     | 最高       |
| 索引运算符 | x[i] 或 x[i1: i2 [:i3]] | 18     | 左     |            |
| 属性访问   | x.attribute             | 17     | 左     |            |
| 乘方       | **                      | 16     | 右     |            |
| 按位取反   | ~                       | 15     | 右     |            |
| 符号运算符 | +（正号）、-（负号）    | 14     | 右     |            |
| 乘除       | *、/、//、%             | 13     | 左     |            |
| 加减       | +、-                    | 12     | 左     |            |
| 位移       | >>、<<                  | 11     | 左     |            |
| 按位与     | &                       | 10     | 右     |            |
| 按位异或   | ^                       | 9      | 左     |            |
| 按位或     | \|                      | 8      | 左     |            |
| 比较运算符 | ==、!=、>、>=、<、<=    | 7      | 左     |            |
| is 运算符  | is、is not              | 6      | 左     |            |
| in 运算符  | in、not in              | 5      | 左     |            |
| 逻辑非     | not                     | 4      | 右     |            |
| 逻辑与     | and                     | 3      | 左     |            |
| 逻辑或     | or                      | 2      | 左     |            |
| 逗号运算符 | exp1, exp2              | 1      | 左     | 最低       |

- 所谓结合性，就是当一个表达式中出现多个优先级相同的运算符时，先执行哪个运算符：先执行左边的叫左结合性，先执行右边的叫右结合性。
- 例如对于表达式对于`100 / 25 * 16`，`/`和`*`的优先级相同，应该先执行哪一个呢？这个时候就不能只依赖运算符优先级决定了，还要参考运算符的结合性。`/`和`*`都具有左结合性，因此先执行左边的除法，再执行右边的乘法，最终结果是 64。
- Python 中大部分运算符都具有左结合性，也就是从左到右执行；只有 ** 乘方运算符、单目运算符（例如 not 逻辑非运算符）、赋值运算符和三目运算符例外，它们具有右结合性，也就是从右向左执行
- 当一个表达式中出现多个运算符时，Python 会先比较各个运算符的优先级，按照优先级从高到低的顺序依次执行；当遇到优先级相同的运算符时，再根据结合性决定先执行哪个运算符：如果是左结合性就先执行左边的运算符，如果是右结合性就先执行右边的运算符。

#### 列表、元组、字典、集合

- Python 序列（Sequence）是指按特定顺序依次排列的一组数据，它们可以占用一块连续的内存，也可以分散到多块内存中。Python 中的序列类型包括列表（list）、元组（tuple）、字典（dict）和集合（set）。
- 在 Python 编程中，我们既需要独立的变量来保存一份数据，也需要序列来保存大量数据。
- 列表（list）和元组（tuple）比较相似，它们都按顺序保存元素，所有的元素占用一块连续的内存，每个元素都有自己的索引，因此列表和元组的元素都可以通过索引（index）来访问。它们的区别在于：列表是可以修改的，而元组是不可修改的。
- 字典（dict）和集合（set）存储的数据都是无序的，每份元素占用不同的内存，其中字典元素以 `key-value` 的形式保存。

##### 序列

- 所谓序列，指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可通过每个值所在位置的编号（称为索引）访问它们。
- 在 [Python](http://c.biancheng.net/python/) 中，序列类型包括字符串、列表、元组、集合和字典，这些序列支持以下几种通用的操作，但比较特殊的是，集合和字典不支持索引、切片、相加和相乘操作。
- 字符串也是一种常见的序列，它也可以直接通过索引访问字符串内的字符。

###### 序列索引

- 序列中，每个元素都有属于自己的编号（索引）。从起始元素开始，索引值从 0 开始递增
- Python 还支持索引值是负数，此类索引是从右向左计数，换句话说，从最后一个元素开始计数，从索引值 -1 开始。在使用负值作为列序中各元素的索引值时，是从 -1 开始，而不是从 0 开始。

###### 序列切片

- 切片操作是访问序列中元素的另一种方法，它可以访问一定范围内的元素，通过切片操作，可以生成一个新的序列。

- 序列实现切片操作的语法格式如下：

  ```
  sname[start : end : step]
  ```

  - sname：表示序列的名称；

  - start：表示切片的开始索引位置（包括该位置），此参数也可以不指定，会默认为 0，也就是从序列的开头进行切片；

  - end：表示切片的结束索引位置（不包括该位置），如果不指定，则默认为序列的长度；

  - step：表示在切片过程中，隔几个存储位置（包含当前位置）取一次元素，也就是说，如果 step 的值大于 1，则在进行切片去序列元素时，会“跳跃式”的取元素。如果省略设置 step 的值，则最后一个冒号就可以省略。

    ```
    str="C语言中文网"
    #取索引区间为[0,2]之间（不包括索引2处的字符）的字符串
    print(str[:2])
    #隔 1 个字符取一个字符，区间是整个字符串
    print(str[::2])
    #取整个字符串，此时 [] 中只需一个冒号即可
    print(str[:])
    ```

###### 序列相加

- Python 中，支持两种类型相同的序列使用“+”运算符做相加操作，它会将两个序列进行连接，但不会去除重复的元素。这里所说的“类型相同”，指的是“+”运算符的两侧序列要么都是列表类型，要么都是元组类型，要么都是字符串。

###### 序列相乘

- Python 中，使用数字 n 乘以一个序列会生成新的序列，其内容为原来序列被重复 n 次的结果

- 比较特殊的是，列表类型在进行乘法运算时，还可以实现初始化指定长度列表的功能。例如如下的代码，将创建一个长度为 5 的列表，列表中的每个元素都是 None，表示什么都没有。

  ```
  #列表的创建用 []，后续讲解列表时会详细介绍
  list = [None]*5
  print(list)
  
  [None, None, None, None, None]
  ```

###### 检查元素是否包含在序列中

- Python 中，可以使用 in 关键字检查某元素是否为序列的成员

  ```
  value in sequence
  ```

  - value 表示要检查的元素，sequence 表示指定的序列。

  - 例如，检查字符‘c’是否包含在字符串“c.biancheng.net”中

    ```
    str="c.biancheng.net"
    print('c'in str)
    
    True
    ```

- 和 in 关键字用法相同，但功能恰好相反的，还有 not in 关键字，它用来检查某个元素是否不包含在指定的序列中

###### 内置函数

| 函数        | 功能                                                         |
| ----------- | ------------------------------------------------------------ |
| len()       | 计算序列的长度，即返回序列中包含多少个元素。                 |
| max()       | 找出序列中的最大元素。注意，对序列使用 sum() 函数时，做加和操作的必须都是数字，不能是字符或字符串，否则该函数将抛出异常，因为解释器无法判定是要做连接操作（+ 运算符可以连接两个序列），还是做加和操作。 |
| min()       | 找出序列中的最小元素。                                       |
| list()      | 将序列转换为列表。                                           |
| str()       | 将序列转换为字符串。                                         |
| sum()       | 计算元素和。                                                 |
| sorted()    | 对元素进行排序。                                             |
| reversed()  | 反向序列中的元素。                                           |
| enumerate() | 将序列组合为一个索引序列，多用在 for 循环中。                |

##### 列表

- [Python](http://c.biancheng.net/python/) 中没有数组，但是加入了更加强大的列表。如果把数组看做是一个集装箱，那么 Python 的列表就是一个工厂的仓库。

- 从形式上看，列表会将所有元素都放在一对中括号`[ ]`里面，相邻元素之间用逗号`,`分隔

- 从内容上看，列表可以存储整数、小数、字符串、列表、元组等任何类型的数据，并且同一个列表中元素的类型也可以不同

  ```
  ["http://c.biancheng.net/python/", 1, [2,3,4] , 3.0]
  ```

  - 列表中同时包含字符串、整数、列表、浮点数这些数据类型。

- 在使用列表时，虽然可以将不同类型的数据放入到同一个列表中，但通常情况下不这么做，同一列表中只放入同一类型的数据，这样可以提高程序的可读性。

- 在其它 Python 教程中，经常用 list 代指列表，这是因为列表的数据类型就是 list，通过 type() 函数就可以知道

###### 创建列表

- 使用[]直接创建列表

- 使用list()函数创建列表，内置的函数 list()，使用它可以将其它数据类型转换为列表类型

  ```python
  #将字符串转换成列表
  list1 = list("hello")
  print(list1)
  #将元组转换成列表
  tuple1 = ('Python', 'Java', 'C++', 'JavaScript')
  list2 = list(tuple1)
  print(list2)
  #将字典转换成列表
  dict1 = {'a':100, 'b':42, 'c':9}
  list3 = list(dict1)
  print(list3)
  #将区间转换成列表
  range1 = range(1, 6)
  list4 = list(range1)
  print(list4)
  #创建空列表
  print(list())
  
  ['h', 'e', 'l', 'l', 'o']
  ['Python', 'Java', 'C++', 'JavaScript']
  ['a', 'b', 'c']
  [1, 2, 3, 4, 5]
  []
  ```

- 访问列表元素使用索引或者切片
- 删除列表，对于已经创建的列表，如果不再使用，可以使用`del`关键字将其删除。实际开发中并不经常使用 del 来删除列表，因为 Python 自带的垃圾回收机制会自动销毁无用的列表，即使开发者不手动删除，Python 也会自动将其回收。

###### 列表添加元素

- 使用`+`运算符可以将多个序列连接起来；列表是序列的一种，所以也可以使用`+`进行连接，这样就相当于在第一个列表的末尾添加了另一个列表。`+`更多的是用来拼接列表，而且执行效率并不高

- append() 方法用于在列表的末尾追加元素

  ```
  listname.append(obj)
  ```

  - obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等

    ```
    l = ['Python', 'C++', 'Java']
    #追加元素
    l.append('PHP')
    print(l)
    #追加元组，整个元组被当成一个元素
    t = ('JavaScript', 'C#', 'Go')
    l.append(t)
    print(l)
    #追加列表，整个列表也被当成一个元素
    l.append(['Ruby', 'SQL'])
    print(l)
    
    ['Python', 'C++', 'Java', 'PHP']
    ['Python', 'C++', 'Java', 'PHP', ('JavaScript', 'C#', 'Go')]
    ['Python', 'C++', 'Java', 'PHP', ('JavaScript', 'C#', 'Go'), ['Ruby', 'SQL']]
    ```

  - 当给 append() 方法传递列表或者元组时，此方法会将它们视为一个整体，作为一个元素添加到列表中，从而形成包含列表和元组的新列表

- extend()方法添加元素。extend() 和 append() 的不同之处在于：extend() 不会把列表或者元祖视为一个整体，而是把它们包含的元素逐个添加到列表中。

  ```
  listname.extend(obj)
  ```

  - obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等，但不能是单个的数字

- insert()方法插入元素。append() 和 extend() 方法只能在列表末尾插入元素，如果希望在列表中间某个位置插入元素，那么可以使用 insert() 方法。

  ```
  listname.insert(index , obj)
  ```

  - index 表示指定位置的索引值。insert() 会将 obj 插入到 listname 列表第 index 个元素的位置。
  - 当插入列表或者元祖时，insert() 也会将它们视为一个整体，作为一个元素插入到列表中，这一点和 append() 是一样的。

###### 删除元素

- 在 [Python](http://c.biancheng.net/python/) 列表中删除元素主要分为以下 3 种场景：

  - 根据目标元素所在位置的索引进行删除，可以使用 del 关键字或者 pop() 方法；
  - 根据元素本身的值进行删除，可使用列表（list类型）提供的 remove() 方法；
  - 将列表中所有元素全部删除，可使用列表（list类型）提供的 clear() 方法。

- del根据索引值删除元素

  - del 是 Python 中的关键字，专门用来执行删除操作，它不仅可以删除整个列表，还可以删除列表中的某些元素

  - del 可以删除列表中的单个元素

    ```
    del listname[index]
    ```

  - del 也可以删除中间一段连续的元素

    ```
    del listname[start : end]
    del 会删除从索引 start 到 end 之间的元素，不包括 end 位置的元素。
    ```

- pop()根据索引值删除元素

  - pop() 方法用来删除列表中指定索引处的元素

    ```
    listname.pop(index)
    ```

    - index 表示索引值。如果不写 index 参数，默认会删除列表中的最后一个元素，类似于[数据结构](http://c.biancheng.net/data_structure/)中的“出栈”操作。

  - 大部分编程语言都会提供和 pop() 相对应的方法，就是 push()，该方法用来将元素添加到列表的尾部，类似于数据结构中的“入栈”操作。但是 Python 是个例外，Python 并没有提供 push() 方法，因为完全可以使用 append() 来代替 push() 的功能。

- remove()根据元素值进行删除

  - 除了 del 关键字，Python 还提供了 remove() 方法，该方法会根据元素本身的值来进行删除操作。
  - remove() 方法只会删除第一个和指定值相同的元素，而且必须保证该元素是存在的，否则会引发 ValueError 错误。所以我们在使用 remove() 删除元素时最好提前判断一下。

- clear()删除列表所有元素

###### 修改元素

- 提供了两种修改列表（list）元素的方法，你可以每次修改单个元素，也可以每次修改一组元素（多个）。

- 修改单个元素非常简单，直接对元素赋值即可

  ```
  nums = [40, 36, 89, 2, 36, 100, 7]
  nums[2] = -26  #使用正数索引
  nums[-3] = -66.2  #使用负数索引
  print(nums)
  
  [40, 36, -26, 2, -66.2, 100, 7]
  ```

  - 使用索引得到列表元素后，通过`=`赋值就改变了元素的值。

- Python 支持通过切片语法给一组元素赋值。在进行这种操作时，如果不指定步长（step 参数），Python 就不要求新赋值的元素个数与原来的元素个数相同；这意味，该操作既可以为列表添加元素，也可以为列表删除元素。

  ```
  修改一组元素的值
  nums = [40, 36, 89, 2, 36, 100, 7]
  #修改第 1~4 个元素的值（不包括第4个元素）
  nums[1: 4] = [45.25, -77, -52.5]
  print(nums)
  [40, 45.25, -77, -52.5, 36, 100, 7]
  
  
  如果对空切片（slice）赋值，就相当于插入一组新的元素：
  nums = [40, 36, 89, 2, 36, 100, 7]
  #在4个位置插入元素
  nums[4: 4] = [-77, -52.5, 999]
  print(nums)
  [40, 36, 89, 2, -77, -52.5, 999, 36, 100, 7]
  
  使用切片语法赋值时，Python 不支持单个值，例如下面的写法就是错误的：
  nums[4: 4] = -77
  
  但是如果使用字符串赋值，Python 会自动把字符串转换成序列，其中的每个字符都是一个元素
  s = list("Hello")
  s[2:4] = "XYZ"
  print(s)
  ['H', 'e', 'X', 'Y', 'Z', 'o']
  ```

- 使用切片语法时也可以指定步长（step 参数），但这个时候就要求所赋值的新元素的个数与原有元素的个数相同

  ```
  nums = [40, 36, 89, 2, 36, 100, 7]
  #步长为2，为第1、3、5个元素赋值
  nums[1: 6: 2] = [0.025, -99, 20.5]
  print(nums)
  [40, 0.025, 89, -99, 36, 20.5, 7]
  ```

###### 查找元素

- 提供了 index() 和 count() 方法，它们都可以用来查找元素。

- index() 方法用来查找某个元素在列表中出现的位置（也就是索引），如果该元素不存在，则会导致 ValueError 错误，所以在查找之前最好使用 count() 方法判断一下。

  ```
  listname.index(obj, start, end)
  ```

  - start 和 end 参数用来指定检索范围：
    - start 和 end 可以都不写，此时会检索整个列表；
    - 如果只写 start 不写 end，那么表示检索从 start 到末尾的元素；
    - 如果 start 和 end 都写，那么表示检索 start 和 end 之间的元素。
  - index() 方法会返回元素所在列表中的索引值。

- count() 方法用来统计某个元素在列表中出现的次数

  ```
  listname.count(obj)
  ```

  - 如果 count() 返回 0，就表示列表中不存在该元素，所以 count() 也可以用来判断列表中的某个元素是否存在。

###### range()快速初始化数字列表

- 列表非常适合用于存储数字集合，并且 Python 提供了 range() 函数，可帮助我们高效地处理数字列表，即便列表需要包含数百万个元素，也可以快速实现。

- Python range() 函数能够轻松地生成一系列的数字

  ```
  for value in range(1,5):
      print(value)
      
  1
  2
  3
  4
  ```

  - 在这个示例程序中，range() 只是打印数字 1~4，因为range() 函数的用法是：让 Python 从指定的第一个值开始，一直数到指定的第二个值停止，但不包含第二个值（这里为 5）。

- 另外需要指明的是，range() 函数的返回值并不直接是列表类型（list）

  ```
  >>> type([1,2,3,4,5])
  <class 'list'>
  >>> type(range(1,6))
  <class 'range'>
  ```

  - range() 函数的返回值类型为 range，而不是 list。而如果想要得到 range() 函数创建的数字列表，还需要借助 list() 函数

- 在使用 range() 函数时，还可以指定步长。例如，下面的代码打印 1~10 内的偶数：

  ```
  even_numbers = list(range(2,11,2))
  print(even_numbers)
  
  [2, 4, 6, 8, 10]
  ```

  - 函数 range() 从 2 开始数，然后不断地加 2，直到达到或超过终值

##### 元组

- 元组和列表（list）的不同之处在于：

  - 列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列；
  - 而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。

- 元组也可以看做是不可变的列表，通常情况下，元组用于保存无需修改的内容。

- 从形式上看，元组的所有元素都放在一对小括号`( )`中，相邻元素之间用逗号`,`分隔

- 从存储内容上看，元组可以存储整数、实数、字符串、列表、元组等任何类型的数据，并且在同一个元组中，元素的类型可以不同

- 元组的类型位tuple，可以使用type查看

- 在 Python 中，元组通常都是使用一对小括号将所有元素包围起来的，但小括号不是必须的，只要将各元素用逗号隔开，Python 就会将其视为元组

  ```
  course = "Python教程", "http://c.biancheng.net/python/"
  print(course)
  
  ('Python教程', 'http://c.biancheng.net/python/')
  ```

- 需要注意的一点是，当创建的元组中只有一个字符串类型的元素时，该元素后面必须要加一个逗号`,`，否则 Python 解释器会将它视为字符串

- 除了使用`( )`创建元组外，Python 还提供了一个内置的函数 tuple()，用来将其它数据类型转换为元组类型。

- 和列表一样，我们可以使用索引（Index）访问元组中的某个元素（得到的是一个元素的值），也可以使用切片访问元组中的一组元素（得到的是一个新的子元组）。

- 元组是不可变序列，元组中的元素不能被修改，所以我们只能创建一个新的元组去替代旧的元组。

- 还可以通过连接多个元组（使用`+`可以拼接元组）的方式向元组中添加新元素

- 当创建的元组不再使用时，可以通过 del 关键字将其删除。Python 自带垃圾回收功能，会自动销毁不用的元组，所以一般不需要通过 del 来手动删除。

- 总的来说，元组确实没有列表那么多功能，但是元组依旧是很重要的序列类型之一，元组的不可替代性体现在以下这些场景中：

  1. 元组作为很多内置函数和序列类型方法的返回值存在，也就是说，在使用某些函数或者方法时，它的返回值会元组类型，因此你必须对元组进行处理。
  2. 元组比列表的访问和处理速度更快，因此，当需要对指定元素进行访问，且不涉及修改元素的操作时，建议使用元组。
  3. 元组可以在映射（和集合的成员）中当做“键”使用，而列表不行。

##### 字典dict

| 主要特征                       | 解释                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 通过键而不是通过索引来读取元素 | 字典类型有时也称为关联数组或者散列表（hash）。它是通过键将一系列的值联系起来的，这样就可以通过键从字典中获取指定项，但不能通过索引来获取。 |
| 字典是任意数据类型的无序集合   | 和列表、元组不同，通常会将索引值 0 对应的元素称为第一个元素，而字典中的元素是无序的。 |
| 字典是可变的，并且可以任意嵌套 | 字典可以在原处增长或者缩短（无需生成一个副本），并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其它的字典。 |
| 字典中的键必须唯一             | 字典中，不支持同一个键出现多次，否则只会保留最后一个键值对。 |
| 字典中的键必须不可变           | 字典中每个键值对的键是不可变的，只能使用数字、字符串或者元组，不能使用列表。 |

###### 创建字典

- 使用{}创建字典，由于字典中每个元素都包含两部分，分别是键（key）和值（value），因此在创建字典时，键和值之间使用冒号`:`分隔，相邻元素之间使用逗号`,`分隔，所有元素放在大括号`{ }`中。需要注意的是，同一字典中的各个键必须唯一，不能重复。

- 通过fromkeys()创建字典，使用 dict 字典类型提供的 fromkeys() 方法创建带有默认值的字典

  ```
  dictname = dict.fromkeys(list，value=None)
  ```

  - list 参数表示字典中所有键的列表（list）；value 参数表示默认值，如果不写，则为空值 None。

    ```
    knowledge = ['语文', '数学', '英语']
    scores = dict.fromkeys(knowledge, 60)
    print(scores)
    
    {'语文': 60, '英语': 60, '数学': 60}
    ```

- 通过dict()映射函数创建字典

  | 创建格式                                                     | 注意事项                                                     |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | a = dict(str1=value1, str2=value2, str3=value3)              | str 表示字符串类型的键，value 表示键对应的值。使用此方式创建字典时，字符串不能带引号。 |
  | #方式1 demo = [('two',2), ('one',1), ('three',3)]                                                                          #方式2 demo = [['two',2], ['one',1], ['three',3]]                                                                               #方式3 demo = (('two',2), ('one',1), ('three',3))                                                                                 #方式4 demo = (['two',2], ['one',1], ['three',3]) a = dict(demo) | 向 dict() 函数传入列表或元组，而它们中的元素又各自是包含 2 个元素的列表或元组，其中第一个元素作为键，第二个元素作为值。 |
  | keys = ['one', 'two', 'three'] #还可以是字符串或元组 values = [1, 2, 3] #还可以是字符串或元组 a = dict( zip(keys, values) ) | 通过应用 dict() 函数和 zip() 函数，可将前两个列表转换为对应的字典。 |

- 访问字典

  - 列表和元组是通过下标来访问元素的，而字典不同，它通过键来访问对应的值。因为字典中的元素是无序的，每个元素的位置都不固定，所以字典也不能像列表和元组那样，采用切片的方式一次性访问多个元素。

    ```
    dictname[key]
    ```

    - dictname 表示字典变量的名字，key 表示键名。注意，键必须是存在的，否则会抛出异常。

    ```
    tup = (['two',26], ['one',88], ['three',100], ['four',-59])
    dic = dict(tup)
    print(dic['one'])  #键存在
    print(dic['five'])  #键不存在
    
    88
    Traceback (most recent call last):
        File "C:\Users\mozhiyan\Desktop\demo.py", line 4, in <module>
            print(dic['five'])  #键不存在
    KeyError: 'five'
    ```

  - 除了上面这种方式外，Python 更推荐使用 dict 类型提供的 get() 方法来获取指定键对应的值。当指定的键不存在时，get() 方法不会抛出异常。

    ```
    dictname.get(key[,default])
    ```

    - key 表示指定的键；default 用于指定要查询的键不存在时，此方法返回的默认值，如果不手动指定，会返回 None。

      ```
      a = dict(two=0.65, one=88, three=100, four=-59)
      print( a.get('one') )
      
      88
      ```

    - 当键不存在时，get() 返回空值 None，如果想明确地提示用户该键不存在，那么可以手动设置 get() 的第二个参数

      ```
      a = dict(two=0.65, one=88, three=100, four=-59)
      print( a.get('five', '该键不存在') )
      
      该键不存在
      ```

  - 和删除列表、元组一样，手动删除字典也可以使用 del 关键字

###### 字典基本操作

- 由于字典属于可变序列，所以我们可以任意操作字典中的键值对（key-value）。[Python](http://c.biancheng.net/python/) 中，常见的字典操作有以下几种：

  - 向现有字典中添加新的键值对。
  - 修改现有字典中的键值对。
  - 从现有字典中删除指定的键值对。
  - 判断现有字典中是否存在指定的键值对。

- 字典是由一个一个的 key-value 构成的，key 是找到数据的关键，Python 对字典的操作都是通过 key 来完成的。

- 为字典添加新的键值对很简单，直接给不存在的 key 赋值即可

  ```
  dictname[key] = value
  ```

- Python 字典中键（key）的名字不能被修改，我们只能修改值（value）。字典中各元素的键必须是唯一的，因此，如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的。

- 如果要删除字典中的键值对，还是可以使用 del 语句

  ```
  # 使用del语句删除键值对
  a = {'数学': 95, '语文': 89, '英语': 90}
  del a['语文']
  del a['数学']
  print(a)
  
  {'英语': 90}
  ```

- 如果要判断字典中是否存在指定键值对，首先应判断字典中是否有对应的键。判断字典是否包含指定键值对的键，可以使用 in 或 not in 运算符。对于 dict 而言，in 或 not in 运算符都是基于 key 来判断的。

  ```
  a = {'数学': 95, '语文': 89, '英语': 90}
  # 判断 a 中是否包含名为'数学'的key
  print('数学' in a) # True
  # 判断 a 是否包含名为'物理'的key
  print('物理' in a) # False
  
  True
  False
  ```

  - 通过 in（或 not in）运算符，我们可以很轻易地判断出现有字典中是否包含某个键，如果存在，由于通过键可以很轻易的获取对应的值，因此很容易就能判断出字典中是否有指定的键值对。

###### dict字典方法

- [Python](http://c.biancheng.net/python/) 字典的数据类型为 dict，我们可使用 `dir(dict)` 来查看该类型包含哪些方法

  ```
  >>> dir(dict)
  ['clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
  ```

- keys、values和items方法，将这三个方法放在一起介绍，是因为它们都用来获取字典中的特定数据：

  - keys() 方法用于返回字典中的所有键（key）；

  - values() 方法用于返回字典中所有键对应的值（value）；

  - items() 用于返回字典中所有的键值对（key-value）。

    ```
    scores = {'数学': 95, '语文': 89, '英语': 90}
    print(scores.keys())
    print(scores.values())
    print(scores.items())
    
    dict_keys(['数学', '语文', '英语'])
    dict_values([95, 89, 90])
    dict_items([('数学', 95), ('语文', 89), ('英语', 90)])
    ```

  - keys()、values() 和 items() 返回值的类型分别为 dict_keys、dict_values 和 dict_items。

- 在 Python 3.x 中如果想使用这三个方法返回的数据，一般有下面两种方案：

  - 使用 list() 函数，将它们返回的数据转换成列表

    ```
    a = {'数学': 95, '语文': 89, '英语': 90}
    b = list(a.keys())
    print(b)
    
    ['数学', '语文', '英语']
    ```

  - 使用 for in 循环遍历它们的返回值

    ```
    a = {'数学': 95, '语文': 89, '英语': 90}
    for k in a.keys():
        print(k,end=' ')
    print("\n---------------")
    for v in a.values():
        print(v,end=' ')
    print("\n---------------")
    for k,v in a.items():
        print("key:",k," value:",v)
        
    数学 语文 英语
    ---------------
    95 89 90
    ---------------
    key: 数学  value: 95
    key: 语文  value: 89
    key: 英语  value: 90
    ```

- copy()方法，copy() 方法返回一个字典的拷贝，也即返回一个具有相同键值对的新字典

  ```
  a = {'one': 1, 'two': 2, 'three': [1,2,3]}
  b = a.copy()
  print(b)
  
  {'one': 1, 'two': 2, 'three': [1, 2, 3]}
  ```

  - copy() 方法所遵循的拷贝原理，既有深拷贝，也有浅拷贝。拿拷贝字典 a 为例，copy() 方法只会对最表层的键值对进行深拷贝，也就是说，它会再申请一块内存用来存放 {'one': 1, 'two': 2, 'three': []}；而对于某些列表类型的值来说，此方法对其做的是浅拷贝，也就是说，b 中的 [1,2,3] 的值不是自己独有，而是和 a 共有。

- update() 方法可以使用一个字典所包含的键值对来更新己有的字典。在执行 update() 方法时，如果被更新的字典中己包含对应的键值对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的键值对，则该键值对被添加进去。

  ```
  a = {'one': 1, 'two': 2, 'three': 3}
  a.update({'one':4.5, 'four': 9.3})
  print(a)
  
  {'one': 4.5, 'two': 2, 'three': 3, 'four': 9.3}
  ```

- pop() 和 popitem() 都用来删除字典中的键值对，不同的是，pop() 用来删除指定的键值对，而 popitem() 用来随机删除一个键值对

  ```
  dictname.pop(key)
  dictname.popitem()
  ```

  - 说 popitem() 随机删除字典中的一个键值对是不准确的，虽然字典是一种无须的列表，但键值对在底层也是有存储顺序的，popitem() 总是弹出底层中的最后一个 key-value，这和列表的 pop() 方法类似，都实现了[数据结构](http://c.biancheng.net/data_structure/)中“出栈”的操作。

- setdefault() 方法用来返回某个 key 对应的 value。

  ```
  dictname.setdefault(key, defaultvalue)
  ```

  - dictname 表示字典名称，key 表示键，defaultvalue 表示默认值（可以不写，不写的话是 None）。
  - 当指定的 key 不存在时，setdefault() 会先为这个不存在的 key 设置一个默认的 defaultvalue，然后再返回 defaultvalue。
  - 也就是说，setdefault() 方法总能返回指定 key 对应的 value：
    - 如果该 key 存在，那么直接返回该 key 对应的 value；
    - 如果该 key 不存在，那么先为该 key 设置默认的 defaultvalue，然后再返回该 key 对应的 defaultvalue。

##### set集合

- [Python](http://c.biancheng.net/python/) 中的集合，和数学中的集合概念一样，用来保存不重复的元素，即集合中的元素都是唯一的，互不相同。

- 从形式上看，和字典类似，Python 集合会将所有元素放在一对大括号 {} 中，相邻元素之间用“,”分隔

- 从内容上看，同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型，否则 Python 解释器会抛出 TypeError 错误

- 由于 Python 中的 set 集合是无序的，所以每次输出时元素的排序顺序可能都不相同。

- Python 中有两种集合类型，一种是 set 类型的集合，另一种是 frozenset 类型的集合，它们唯一的区别是，set 类型集合可以做添加、删除元素的操作，而 forzenset 类型集合不行。

- Python 提供了 2 种创建 set 集合的方法，分别是使用 {} 创建和使用 set() 函数将列表、元组等类型数据转换为集合。

  - 创建 set 集合可以像列表、元素和字典一样，直接将集合赋值给变量，从而实现创建集合的目的

    ```
    a = {1,'c',1,(1,2,3),'c'}
    print(a)
    
    {1, 'c', (1, 2, 3)}
    ```

  - set() 函数为 Python 的内置函数，其功能是将字符串、列表、元组、range 对象等可迭代对象转换成集合

    ```
    setname = set(iteration)
    ```

    - iteration 就表示字符串、列表、元组、range 对象等数据。

  - 如果要创建空集合，只能使用 set() 函数实现。因为直接使用一对 {}，Python 解释器会将其视为一个空字典。

- 由于集合中的元素是无序的，因此无法向列表那样使用下标访问元素。Python 中，访问集合元素最常用的方法是使用循环结构，将集合中的数据逐一读取出来。

- 和其他序列类型一样，也可以使用 del() 语句来删除集合

- Python set 集合最常用的操作是向集合中添加、删除元素，以及集合之间做交集、并集、差集等运算

  - set 集合中添加元素，可以使用 set 类型提供的 add() 方法实现，使用 add() 方法添加的元素，只能是数字、字符串、元组或者布尔类型（True 和 False）值，不能添加列表、字典、集合这类可变的数据
  - 删除现有 set 集合中的指定元素，可以使用 remove() 方法，使用此方法删除集合中元素，需要注意的是，如果被删除元素本就不包含在集合中，则此方法会抛出 KeyError 错误。如果我们不想在删除失败时令解释器提示 KeyError 错误，还可以使用 discard() 方法，此方法和 remove() 方法的用法完全相同，唯一的区别就是，当删除集合中元素失败时，此方法不会抛出任何错误。

  | 运算操作 | Python运算符 | 含义                              | 例子                                        |
  | -------- | ------------ | --------------------------------- | ------------------------------------------- |
  | 交集     | &            | 取两集合公共的元素                | >>> set1 & set2 {3}                         |
  | 并集     | \|           | 取两集合全部的元素                | >>> set1 \| set2 {1,2,3,4,5}                |
  | 差集     | -            | 取一个集合中另一集合没有的元素    | >>> set1 - set2 {1,2} >>> set2 - set1 {4,5} |
  | 对称差集 | ^            | 取集合 A 和 B 中不属于 A&B 的元素 | >>> set1 ^ set2 {1,2,4,5}                   |

- 通过 dir(set) 命令可以查看它有哪些方法

- set 集合是可变序列，程序可以改变序列中的元素；frozenset 集合是不可变序列，程序不能改变序列中的元素。set 集合中所有能改变集合本身的方法，比如 remove()、discard()、add() 等，frozenset 都不支持；set 集合中不改变集合本身的方法，fronzenset 都支持。

  - 两种情况下可以使用 fronzenset：
    - 当集合的元素不需要改变时，我们可以使用 fronzenset 替代 set，这样更加安全。
    - 有时候程序要求必须是不可变对象，这个时候也要使用 fronzenset 替代 set。比如，字典（dict）的键（key）就要求是不可变对象。

  ```
  s = {'Python', 'C', 'C++'}
  fs = frozenset(['Java', 'Shell'])
  s_sub = {'PHP', 'C#'}
  #向set集合中添加frozenset
  s.add(fs)
  print('s =', s)
  #向为set集合添加子set集合
  s.add(s_sub)
  print('s =', s)
  ```

  - set 集合本身的元素必须是不可变的， 所以 set 的元素不能是 set，只能是 frozenset。第 6 行代码向 set 中添加 frozenset 是没问题的，因为 frozenset 是不可变的；但是，第 10 行代码中尝试向 set 中添加子 set，这是不允许的，因为 set 是可变的。

#### 字符串

###### 字符串拼接

- 在 [Python](http://c.biancheng.net/python/) 中拼接（连接）字符串很简单，可以直接将两个字符串紧挨着写在一起，这种写法只能拼接字符串常量。如果需要使用变量，就得借助`+`运算符来拼接，当然，`+`运算符也能拼接字符串常量。

  ```
  name = "C++教程"
  url = "http://c.biancheng.net/cplus/"
  info = name + "的网址是：" + url
  print(info)
  
  C++教程的网址是：http://c.biancheng.net/cplus/
  ```

- 在很多应用场景中，我们需要将字符串和数字拼接在一起，而 Python 不允许直接拼接数字和字符串，所以我们必须先将数字转换成字符串。可以借助 str() 和 repr() 函数将数字转换为字符串

  ```
  str(obj)
  repr(obj)
  ```

  - obj 表示要转换的对象，它可以是数字、列表、元组、字典等多种类型的数据。

  - str() 和 repr() 函数虽然都可以将数字转换成字符串，但它们之间是有区别的：

    - str() 用于将数据转换成适合人类阅读的字符串形式。
    - repr() 用于将数据转换成适合解释器阅读的字符串形式（Python 表达式的形式），适合在开发和调试阶段使用；如果没有等价的语法，则会发生 SyntaxError 异常。

    ```
    s = "http://c.biancheng.net/shell/"
    s_str = str(s)
    s_repr = repr(s)
    print( type(s_str) )
    print (s_str)
    print( type(s_repr) )
    print (s_repr)
    
    <class 'str'>
    http://c.biancheng.net/shell/
    <class 'str'>
    'http://c.biancheng.net/shell/'
    
    s 本身就是一个字符串，但是我们依然使用 str() 和 repr() 对它进行了转换。从运行结果可以看出，str() 保留了字符串最原始的样子，而 repr() 使用引号将字符串包围起来，这就是 Python 字符串的表达式形式。
    ```

    - 在 Python 交互式编程环境中输入一个表达式（变量、加减乘除、逻辑运算等）时，Python 会自动使用 repr() 函数处理该表达式。

###### 截取字符串

- 字符串是由多个字符构成的，字符之间是有顺序的，这个顺序号就称为索引（index）。[Python](http://c.biancheng.net/python/) 允许通过索引来操作字符串中的单个或者多个字符，比如获取指定索引处的字符，返回指定字符的索引值等。

- 获取单个字符，知道字符串名字以后，在方括号`[ ]`中使用索引即可访问对应的字符

  - Python 允许从字符串的两端使用索引：
    - 当以字符串的左端（字符串的开头）为起点时，索引是从 0 开始计数的；字符串的第一个字符的索引为 0，第二个字符的索引为 1，第三个字符串的索引为 2 ……
    - 当以字符串的右端（字符串的末尾）为起点时，索引是从 -1 开始计数的；字符串的倒数第一个字符的索引为 -1，倒数第二个字符的索引为 -2，倒数第三个字符的索引为 -3 ……

- 获取多个字符，使用`[ ]`除了可以获取单个字符外，还可以指定一个范围来获取多个字符，也就是一个子串或者片段

  ```
  strname[start : end : step]
  ```

  - start：表示要截取的第一个字符所在的索引（截取时包含该字符）。如果不指定，默认为 0，也就是从字符串的开头截取；
  - end：表示要截取的最后一个字符所在的索引（截取时不包含该字符）。如果不指定，默认为字符串的长度；
  - step：指的是从 start 索引处的字符开始，每 step 个距离获取一个字符，直至 end 索引出的字符。step 默认值为 1，当省略该值时，最后一个冒号也可以省略。

###### 获取字符串长度

- 要想知道一个字符串有多少个字符（获得字符串长度），或者一个字符串占用多少个字节，可以使用 len 函数。

- 在实际开发中，除了常常要获取字符串的长度外，有时还要获取字符串的字节数。在 Python 中，不同的字符所占的字节数不同，数字、英文字母、小数点、下划线以及空格，各占一个字节，而一个汉字可能占 2~4 个字节，具体占多少个，取决于采用的编码方式。例如，汉字在 GBK/GB2312 编码中占用 2 个字节，而在 UTF-8 编码中一般占用 3 个字节。以 UTF-8 编码为例，字符串“人生苦短，我用Python”所占用的字节数如图 1 所示。

  ![](http://c.biancheng.net/uploads/allimg/190701/2-1ZF1140302452.gif)

- 我们可以通过使用 encode() 方法，将字符串进行编码后再获取它的字节数。例如，采用 UTF-8 编码方式，计算“人生苦短，我用Python”的字节数，可以执行如下代码：

  ```
  >>> str1 = "人生苦短，我用Python"
  >>> len(str1.encode())
  27
  
  如果要获取采用 GBK 编码的字符串的长度
  >>> str1 = "人生苦短，我用Python"
  >>> len(str1.encode('gbk'))
  20
  ```

###### split()分隔字符串

- 除了可以使用一些内建函数获取字符串的相关信息外（例如 len() 函数获取字符串长度），字符串类型本身也拥有一些方法供我们使用。

- split() 方法可以实现将一个字符串按照指定的分隔符切分成多个子串，这些子串会被保存到列表中（不包含分隔符），作为方法的返回值反馈回来。

  ```
  str.split(sep,maxsplit)
  ```

  - str：表示要进行分割的字符串；
  - sep：用于指定分隔符，可以包含多个字符。此参数默认为 None，表示所有空字符，包括空格、换行符“\n”、制表符“\t”等。
  - maxsplit：可选参数，用于指定分割的次数，最后列表中子串的个数最多为 maxsplit+1。如果不指定或者指定为 -1，则表示分割次数没有限制。

- 在 split 方法中，如果不指定 sep 参数，那么也不能指定 maxsplit 参数。同内建函数（如 len）的使用方式不同，字符串变量所拥有的方法，只能采用“字符串.方法名()”的方式调用

- 需要注意的是，在未指定 sep 参数时，split() 方法默认采用空字符进行分割，但当字符串中有连续的空格或其他空字符时，都会被视为一个分隔符对字符串进行分割

###### join()合并字符串

- join() 方法也是非常重要的字符串方法，它是 split() 方法的逆方法，用来将列表（或元组）中包含的多个字符串连接成一个字符串。

- 使用 join() 方法合并字符串时，它会将列表（或元组）中多个字符串采用固定的分隔符连接在一起。例如，字符串“c.biancheng.net”就可以看做是通过分隔符“.”将 ['c','biancheng','net'] 列表合并为一个字符串的结果。

  ```
  newstr = str.join(iterable)
  ```

  - newstr：表示合并后生成的新字符串；
  - str：用于指定合并时的分隔符；
  - iterable：做合并操作的源字符串数据，允许以列表、元组等形式提供。

  ```
  将列表中的字符串合并成一个字符串。
  >>> list = ['c','biancheng','net']
  >>> '.'.join(list)
  'c.biancheng.net'
  
  将元组中的字符串合并成一个字符串。
  >>> dir = '','usr','bin','env'
  >>> type(dir)
  <class 'tuple'>
  >>> '/'.join(dir)
  '/usr/bin/env'
  ```

###### count()统计字符串出现的次数

- count 方法用于检索指定字符串在另一字符串中出现的次数，如果检索的字符串不存在，则返回 0，否则返回出现的次数。

  ```
  str.count(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：表示要检索的字符串；
  - start：指定检索的起始位置，也就是从什么位置开始检测。如果不指定，默认从头开始检索；
  - end：指定检索的终止位置，如果不指定，则表示一直检索到结尾。

  ```
  检索字符串“c.biancheng.net”中“.”出现的次数。
  >>> str = "c.biancheng.net"
  >>> str.count('.')
  2
  
  >>> str = "c.biancheng.net"
  >>> str.count('.',1)
  2
  >>> str.count('.',2)
  1
  字符串中各字符对应的检索值，从 0 开始，因此，本例中检索值 1 对应的是第 2 个字符‘.’，从输出结果可以分析出，从指定索引位置开始检索，其中也包含此索引位置。
  
  >>> str = "c.biancheng.net"
  >>> str.count('.',2,-3)
  1
  >>> str.count('.',2,-4)
  0
  ```

###### find()

- find() 方法用于检索字符串中是否包含目标字符串，如果包含，则返回第一次出现该字符串的索引；反之，则返回 -1。

  ```
  str.find(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：表示要检索的目标字符串；
  - start：表示开始检索的起始位置。如果不指定，则默认从头开始检索；
  - end：表示结束检索的结束位置。如果不指定，则默认一直检索到结尾。

- [Python](http://c.biancheng.net/python/) 还提供了 rfind() 方法，与 find() 方法最大的不同在于，rfind() 是从字符串右边开始检索

###### index()

- 同 find() 方法类似，index() 方法也可以用于检索是否包含指定的字符串，不同之处在于，当指定的字符串不存在时，index() 方法会抛出异常。

  ```
  str.index(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：表示要检索的子字符串；
  - start：表示检索开始的起始位置，如果不指定，默认从头开始检索；
  - end：表示检索的结束位置，如果不指定，默认一直检索到结尾。

- 同 find() 和 rfind() 一样，字符串变量还具有 rindex() 方法，其作用和 index() 方法类似，不同之处在于它是从右边开始检索

###### ljust()、rjust()、center()

- [Python](http://c.biancheng.net/python/) str 提供了 3 种可用来进行文本对齐的方法，分别是 ljust()、rjust() 和 center() 方法

- ljust() 方法的功能是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。

  ```
  S.ljust(width[, fillchar])
  ```

  - S：表示要进行填充的字符串；
  - width：表示包括 S 本身长度在内，字符串要占的总长度；
  - fillchar：作为可选参数，用来指定填充字符串时所用的字符，默认情况使用空格。

  ```
  S = 'http://c.biancheng.net/python/'
  addr = 'http://c.biancheng.net'
  print(S.ljust(35,'-'))
  print(addr.ljust(35,'-'))
  
  http://c.biancheng.net/python/-----
  http://c.biancheng.net-------------
  ```

- rjust() 和 ljust() 方法类似，唯一的不同在于，rjust() 方法是向字符串的左侧填充指定字符，从而达到右对齐文本的目的。

  ```
  S = 'http://c.biancheng.net/python/'
  addr = 'http://c.biancheng.net'
  print(S.rjust(35))
  print(addr.rjust(35))
  
       http://c.biancheng.net/python/
               http://c.biancheng.net   
  ```

  - 每行字符串都占用 35 个字节的位置，实现了整体的右对齐效果

- center() 字符串方法与 ljust() 和 rjust() 的用法类似，但它让文本居中，而不是左对齐或右对齐。

###### startswith() 和endswith() 

- startswith() 方法用于检索字符串是否以指定字符串开头，如果是返回 True；反之返回 False

  ```
  str.startswith(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：要检索的子串；
  - start：指定检索开始的起始位置索引，如果不指定，则默认从头开始检索；
  - end：指定检索的结束位置索引，如果不指定，则默认一直检索在结束。

  ```
  >>> str = "c.biancheng.net"
  >>> str.startswith("c")
  True
  
  >>> str = "c.biancheng.net"
  >>> str.startswith("http")
  False
  
  >>> str = "c.biancheng.net"
  >>> str.startswith("b",2)
  True
  ```

- endswith() 方法用于检索字符串是否以指定字符串结尾，如果是则返回 True；反之则返回 False

###### 大小写转换

- 为了方便对字符串中的字母进行大小写转换，字符串变量提供了 3 种方法，分别是 title()、lower() 和 upper()。

- title() 方法用于将字符串中每个单词的首字母转为大写，其他字母全部转为小写，转换完成后，此方法会返回转换得到的字符串。如果字符串中没有需要被转换的字符，此方法会将字符串原封不动地返回。

  ```
  >>> str = "c.biancheng.net"
  >>> str.title()
  'C.Biancheng.Net'
  >>> str = "I LIKE C"
  >>> str.title()
  'I Like C'
  ```

- lower() 方法用于将字符串中的所有大写字母转换为小写字母，转换完成后，该方法会返回新得到的字符串。如果字符串中原本就都是小写字母，则该方法会返回原字符串。

  ```
  >>> str = "I LIKE C"
  >>> str.lower()
  'i like c'
  ```

- upper() 的功能和 lower() 方法恰好相反，它用于将字符串中的所有小写字母转换为大写字母，和以上两种方法的返回方式相同，即如果转换成功，则返回新字符串；反之，则返回原字符串。

###### 去除空格

- 用户输入数据时，很有可能会无意中输入多余的空格，或者在一些场景中，字符串前后不允许出现空格和特殊字符，此时就需要去除字符串中的空格和特殊字符。这里的特殊字符，指的是制表符（\t）、回车符（\r）、换行符（\n）等。

- [Python](http://c.biancheng.net/python/) 中，字符串变量提供了 3 种方法来删除字符串中多余的空格和特殊字符，它们分别是：

  1. strip()：删除字符串前后（左右两侧）的空格或特殊字符。
  2. lstrip()：删除字符串前面（左边）的空格或特殊字符。
  3. rstrip()：删除字符串后面（右边）的空格或特殊字符。

- Python 的 str 是不可变的（不可变的意思是指，字符串一旦形成，它所包含的字符序列就不能发生任何改变），因此这三个方法只是返回字符串前面或后面空白被删除之后的副本，并不会改变字符串本身。

- strip() 方法用于删除字符串左右两个的空格和特殊字符

  ```
  str.strip([chars])
  ```

  - str 表示原字符串，[chars] 用来指定要删除的字符，可以同时指定多个，如果不手动指定，则默认会删除空格以及制表符、回车符、换行符等特殊字符。

  ```
  >>> str = "  c.biancheng.net \t\n\r"
  >>> str.strip()
  'c.biancheng.net'
  >>> str.strip(" ,\r")
  'c.biancheng.net \t\n'
  >>> str
  '  c.biancheng.net \t\n\r'
  
  通过 strip() 确实能够删除字符串左右两侧的空格和特殊字符，但并没有真正改变字符串本身。
  ```

- lstrip() 方法用于去掉字符串左侧的空格和特殊字符

- rstrip() 方法用于删除字符串右侧的空格和特殊字符

###### format()格式化

- 前面章节介绍了如何使用 % 操作符对各种类型的数据进行格式化输出，这是早期 [Python](http://c.biancheng.net/python/) 提供的方法。自 Python 2.6 版本开始，字符串类型（str）提供了 format() 方法对字符串进行格式化

  ```
  str.format(args)
  ```

  - str 用于指定字符串的显示样式；args 用于指定要进行格式转换的项，如果有多项，之间有逗号进行分割。

- 学习 format() 方法的难点，在于搞清楚 str 显示样式的书写格式。在创建显示样式模板时，需要使用`{}`和`：`来指定占位符，其完整的语法格式为：

  ```
  { [index][ : [ [fill] align] [sign] [#] [width] [.precision] [type] ] }
  ```

  - 格式中用 [] 括起来的参数都是可选参数，即可以使用，也可以不使用。各个参数的含义如下：

    - index：指定：后边设置的格式要作用到 args 中第几个数据，数据的索引值从 0 开始。如果省略此选项，则会根据 args 中数据的先后顺序自动分配。
    - fill：指定空白处填充的字符。注意，当填充字符为逗号(,)且作用于整数或浮点数时，该整数（或浮点数）会以逗号分隔的形式输出，例如（1000000会输出 1,000,000）。
    - align：指定数据的对齐方式

    | align | 含义                                                         |
    | ----- | ------------------------------------------------------------ |
    | <     | 数据左对齐。                                                 |
    | >     | 数据右对齐。                                                 |
    | =     | 数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对数字类型有效。 |
    | ^     | 数据居中，此选项需和 width 参数一起使用。                    |

    - sign：指定有无符号数

    | sign参数 | 含义                                                         |
    | -------- | ------------------------------------------------------------ |
    | +        | 正数前加正号，负数前加负号。                                 |
    | -        | 正数前不加正号，负数前加负号。                               |
    | 空格     | 正数前加空格，负数前加负号。                                 |
    | #        | 对于二进制数、八进制数和十六进制数，使用此参数，各进制数前会分别显示 0b、0o、0x前缀；反之则不显示前缀。 |

    - width：指定输出数据时所占的宽度。
    - .precision：指定保留的小数位数。
    - type：指定输出数据的具体类型

    | type类型值 | 含义                                                  |
    | ---------- | ----------------------------------------------------- |
    | s          | 对字符串类型格式化。                                  |
    | d          | 十进制整数。                                          |
    | c          | 将十进制整数自动转换成对应的 Unicode 字符。           |
    | e 或者 E   | 转换成科学计数法后，再格式化输出。                    |
    | g 或 G     | 自动在 e 和 f（或 E 和 F）中切换。                    |
    | b          | 将十进制数自动转换成二进制表示，再格式化输出。        |
    | o          | 将十进制数自动转换成八进制表示，再格式化输出。        |
    | x 或者 X   | 将十进制数自动转换成十六进制表示，再格式化输出。      |
    | f 或者 F   | 转换为浮点数（默认小数点后保留 6 位），再格式化输出。 |
    | %          | 显示百分比（默认显示小数点后 6 位）。                 |

```
str="网站名称：{:>9s}\t网址：{:s}"
print(str.format("C语言中文网","c.biancheng.net"))

Traceback (most recent call last):
  File "C:\Users\mengma\Desktop\1.py", line 2, in
    print(str.format("C语言中文网","c.biancheng.net"))
ValueError: cannot switch from automatic field numbering to manual field specification

在实际开发中，数值类型有多种显示需求，比如货币形式、百分比形式等，使用 format() 方法可以将数值格式化为不同的形式。
#以货币形式显示
print("货币形式：{:,d}".format(1000000))
#科学计数法表示
print("科学计数法：{:E}".format(1200.12))
#以十六进制表示
print("100的十六进制：{:#x}".format(100))
#输出百分比形式
print("0.01的百分比表示：{:.0%}".format(0.01))

货币形式：1,000,000
科学计数法：1.200120E+03
100的十六进制：0x64
0.01的百分比表示：1%
```

###### encode() 和 decode()

- 在 Python 中，有 2 种常用的字符串类型，分别为 str 和 bytes 类型，其中 str 用来表示 Unicode 字符，bytes 用来表示二进制数据。str 类型和 bytes 类型之间就需要使用 encode() 和 decode() 方法进行转换。

- encode() 方法为字符串类型（str）提供的方法，用于将 str 类型转换成 bytes 类型，这个过程也称为“编码”。

  ```
  str.encode([encoding="utf-8"][,errors="strict"])
  ```

| 参数               | 含义                                                         |
| ------------------ | ------------------------------------------------------------ |
| str                | 表示要进行转换的字符串。                                     |
| encoding = "utf-8" | 指定进行编码时采用的字符编码，该选项默认采用 utf-8 编码。例如，如果想使用简体中文，可以设置 gb2312。  当方法中只使用这一个参数时，可以省略前边的“encoding=”，直接写编码格式，例如 str.encode("UTF-8")。 |
| errors = "strict"  | 指定错误处理方式，其可选择值可以是：strict：遇到非法字符就抛出异常。ignore：忽略非法字符。replace：用“？”替换非法字符。xmlcharrefreplace：使用 xml 的字符引用。该参数的默认值为 strict。 |

```
>>> str = "C语言中文网"
>>> str.encode()
b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x91'
```

- 和 encode() 方法正好相反，decode() 方法用于将 bytes 类型的二进制数据转换为 str 类型，这个过程也称为“解码”。

  ```
  bytes.decode([encoding="utf-8"][,errors="strict"])
  ```

###### dir()和help()

- [Python](http://c.biancheng.net/python/) dir() 函数用来列出某个类或者某个模块中的全部内容，包括变量、方法、函数和类等

  ```
  dir(obj)
  ```

  - obj 表示要查看的对象。obj 可以不写，此时 dir() 会列出当前范围内的变量、方法和定义的类型。

- Python help() 函数用来查看某个函数或者模块的帮助文档

  ```
  help(obj)
  ```

- 在 Python 标准库中，以`__`开头和结尾的方法都是私有的，不能在类的外部调用。

  ```
  使用 help() 查看 str 类型中 lower() 函数的用法：
  >>> help(str.lower)
  Help on method_descriptor:
  
  lower(self, /)
      Return a copy of the string converted to lowercase.
  ```

  - 使用 help() 查看某个函数的用法时，函数名后边不能带括号，例如将上面的命令写作`help(str.lower())`就是错误的。

#### 流程控制

- 在其他语言中（如 C语言、[C++](http://c.biancheng.net/cplus/)、[Java](http://c.biancheng.net/java/) 等），选择结构还包括 switch 语句，也可以实现多重选择，但是在 Python 中没有 switch 语句，所以当要实现多重选择的功能时，只能使用 if else 分支语句。if   elif   else

- 布尔类型（bool）只有两个值，分别是 True 和 False，Python 会把 True 当做“真”，把 False 当做“假”。对于数字，Python 会把 0 和 0.0 当做“假”，把其它值当做“真”。对于其它类型，当对象为空或者为 None 时，Python 会把它们当做“假”，其它情况当做真。

  ```
  ""  #空字符串
  [ ]  #空列表
  ( )  #空元组
  { }  #空字典
  None  #空值
  ```

- 对于没有 return 语句的函数，返回值为空，也即 None。

###### Pass

- 在实际开发中，有时候我们会先搭建起程序的整体逻辑结构，但是暂时不去实现某些细节，而是在这些地方加一些注释，方面以后再添加代码

  ```
  age = int( input("请输入你的年龄：") )
  if age < 12 :
      print("婴幼儿")
  elif age >= 12 and age < 18:
      print("青少年")
  elif age >= 18 and age < 30:
      print("成年人")
  elif age >= 30 and age < 50:
      #TODO: 成年人
  else:
      print("老年人")
  ```

  - 当年龄大于等于 30 并且小于 50 时，我们没有使用 print() 语句，而是使用了一个注释，希望以后再处理成年人的情况。当 [Python](http://c.biancheng.net/python/) 执行到该 elif 分支时，会跳过注释，什么都不执行。

  - 但是 Python 提供了一种更加专业的做法，就是空语句 pass。**pass** 是 Python 中的关键字，用来让解释器跳过此处，什么都不做。

  - 就像上面的情况，有时候程序需要占一个位置，或者放一条语句，但又不希望这条语句做任何事情，此时就可以通过 pass 语句来实现。使用 pass 语句比使用注释更加优雅。

    ```
    age = int( input("请输入你的年龄：") )
    if age < 12 :
        print("婴幼儿")
    elif age >= 12 and age < 18:
        print("青少年")
    elif age >= 18 and age < 30:
        print("成年人")
    elif age >= 30 and age < 50:
        pass
    else:
        print("老年人")
    ```

###### Assert断言函数

- [Python](http://c.biancheng.net/python/) assert 语句，又称断言语句，可以看做是功能缩小版的 if 语句，它用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报 AssertionError 错误。

  ```
  assert 表达式
  
  assert 语句的执行流程可以用 if 判断语句表示
  if 表达式==True:
      程序继续执行
  else:
      程序报 AssertionError 错误
  ```

  - 有读者可能会问，明明 assert 会令程序崩溃，为什么还要使用它呢？这是因为，与其让程序在晚些时候崩溃，不如在错误条件出现时，就直接让程序崩溃，这有利于我们对程序排错，提高程序的健壮性。
  - 因此，assert 语句通常用于检查用户的输入是否符合规定，还经常用作程序初期测试和调试过程中的辅助工具。

  ```
  mathmark = int(input())
  #断言数学考试分数是否位于正常范围内
  assert 0 <= mathmark <= 100
  #只有当 mathmark 位于 [0,100]范围内，程序才会继续执行
  print("数学考试分数为：",mathmark)
  
  90
  数学考试分数为： 90
  再次运行
  159
  Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\file.py", line 3, in <module>
      assert 0 <= mathmark <= 100
  AssertionError
  ```

  - 当 assert 语句后的表达式值为真时，程序继续执行；反之，程序停止执行，并报 AssertionError 错误。

- 另外，在实际工作中，assert 还有一些很常见的用法

  ```
  def func(input):
      assert isinstance(input, list), '输入内容必须是列表'
      # 下面的操作都是基于前提：input 必须是 list
      if len(input) == 1:
          ...
      elif len(input) == 2:
          ...
      else:
          ...
  ```

  - 上面代码中，func() 函数中的所有操作都基于输入必须是列表这个前提。所以很有必要在开头加一句 assert 的检查，防止程序出错。

- assert 的检查是可以被关闭的，比如在命令行模式下运行 Python 程序时，加入 -O 选项就可以使程序中的 assert 失效。一旦 assert 失效，其包含的语句也就不会被执行。

###### 循环结构while

- 除了数字，while 循环还常用来遍历列表、元组和字符串，因为它们都支持通过下标索引获取指定位置的元素

  ```
  my_char="http://c.biancheng.net/python/"
  i = 0;
  while i<len(my_char):
      print(my_char[i],end="")
      i = i + 1
      
  http://c.biancheng.net/python/
  ```

###### for循环

- for 循环，它常用于遍历字符串、列表、元组、字典、集合等序列类型，逐个获取序列中的各个元素。

  ```
  for 迭代变量 in 字符串|列表|元组|字典|集合：
      代码块
  ```

  - 格式中，迭代变量用于存放从序列类型变量中读取出来的元素，所以一般不会在循环中对迭代变量手动赋值；代码块指的是具有相同缩进格式的多行代码（和 while 一样），由于和循环结构联用，因此代码块又称为循环体。

  ```
  add = "http://c.biancheng.net/python/"
  #for循环，遍历 add 字符串
  for ch in add:
      print(ch,end="")
      
  http://c.biancheng.net/python/
  ```

  - 使用 for 循环遍历 add 字符串的过程中，迭代变量 ch 会先后被赋值为 add 字符串中的每个字符，并代入循环体中使用。只不过例子中的循环体比较简单，只有一行输出语句。

- 在使用 for 循环时，最基本的应用就是进行数值循环。比如说，想要实现从 1 到 100 的累加

  ```
  print("计算 1+2+...+100 的结果为：")
  #保存累加结果的变量
  result = 0
  #逐个获取从 1 到 100 这些值，并做累加操作
  for i in range(101):
      result += i
  print(result)
  ```

  - 上面代码中，使用了 range() 函数，此函数是 Python 内置函数，用于生成一系列连续整数，多用于 for 循环中。

- 当用 for 循环遍历 list 列表或者 tuple 元组时，其迭代变量会先后被赋值为列表或元组中的每个元素并执行一次循环体。

  ```
  my_list = [1,2,3,4,5]
  for ele in my_list:
      print('ele =', ele)
      
  ele = 1
  ele = 2
  ele = 3
  ele = 4
  ele = 5
  ```

- 在使用 for 循环遍历字典时，经常会用到和字典相关的 3 个方法，即 items()、keys() 以及 values()，它们各自的用法已经在前面章节中讲过，这里不再赘述。当然，如果使用 for 循环直接遍历字典，则迭代变量会被先后赋值为每个键值对中的键。

  ```
  my_dic = {'python教程':"http://c.biancheng.net/python/",\
            'shell教程':"http://c.biancheng.net/shell/",\
            'java教程':"http://c.biancheng.net/java/"}
  for ele in my_dic.items():
      print('ele =', ele)
      
  ele = ('python教程', 'http://c.biancheng.net/python/')
  ele = ('shell教程', 'http://c.biancheng.net/shell/')
  ele = ('java教程', 'http://c.biancheng.net/java/')
  ```

- 使用 for 循环实现用冒泡排序算法对 [5,8,4,1] 进行排序：

  ```
  data = [5,8,4,1]
  #实现冒泡排序
  for i in range(len(data)-1):
      for j in range(len(data)-i-1):
          if(data[j]>data[j+1]):
              data[j],data[j+1] = data[j+1],data[j]
  print("排序后：",data)
  ```

###### 推导式快速初始化各种序列

- 推导式（又称解析器），是 Python 独有的一种特性。使用推导式可以快速生成列表、元组、字典以及集合类型的数据，因此推导式又可细分为列表推导式、元组推导式、字典推导式以及集合推导式。

- 列表推导式，列表推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的列表。

  ```
  [表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ]
  ```

  - [if 条件表达式] 不是必须的，可以使用，也可以省略。

  - 通过列表推导式的语法格式，明显会感觉到它和 for 循环存在某些关联。其实，除去 [if 条件表达式] 部分，其余各部分的含义以及执行顺序和 for 循环是完全一样的（表达式其实就是 for 循环中的循环体），即它的执行顺序如下所示：

    ```
    for 迭代变量 in 可迭代对象
        表达式
    ```

  - 初学者可以这样认为，它只是对 for 循环语句的格式做了一下简单的变形，并用 [] 括起来而已，只不过最大的不同之处在于，列表推导式最终会将循环过程中，计算表达式得到的一系列值组成一个列表。

    ```
    a_range = range(10)
    # 对a_range执行for表达式
    a_list = [x * x for x in a_range]
    # a_list集合包含10个元素
    print(a_list)
    
    [0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64, 81]
    
    我们还可以在列表推导式中添加 if 条件语句，这样列表推导式将只迭代那些符合条件的元素
    b_list = [x * x for x in a_range if x % 2 == 0]
    # a_list集合包含5个元素
    print(b_list)
    
    [0 ,4 , 16, 36, 64]
    ```

  - 以上所看到的列表推导式都只有一个循环，实际上它可使用多个循环，就像嵌套循环一样。

    ```
    d_list = [(x, y) for x in range(5) for y in range(4)]
    # d_list列表包含20个元素
    print(d_list)
    
    上面代码中，x 是遍历 range(5) 的迭代变量（计数器），因此该 x 可迭代 5 次；y 是遍历 range(4) 的计数器，因此该 y 可迭代 4 次。因此，该（x,y）表达式一共会迭代 20 次。上面的 for 表达式相当于如下嵌套循环：
    dd_list = []
    for x in range(5):
        for y in range(4):
            dd_list.append((x, y))
            
    [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3)]
    ```

  - 对于包含多个循环的 for 表达式，同样可指定 if 条件。假如我们有一个需求：程序要将两个列表中的数值按“能否整除”的关系配对在一起。比如 src_a 列表中包含 30，src_b 列表中包含 5，其中 30 可以整除 5，那么就将 30 和 5 配对在一起。对于上面的需求使用 for 表达式来实现非常简单，例如如下代码：

    ```
    src_a = [30, 12, 66, 34, 39, 78, 36, 57, 121]
    src_b = [3, 5, 7, 11]
    # 只要y能整除x，就将它们配对在一起
    result = [(x, y) for x in src_b for y in src_a if y % x == 0]
    print(result)
    
    [(3, 30), (3, 12), (3, 66), (3, 39), (3, 78), (3, 36), (3, 57), (5, 30), (11, 66), (11, 121)]
    ```

- 元组推导式，元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。通过和列表推导式做对比，你会发现，除了元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是 []，其它完全相同。不仅如此，元组推导式和列表推导式的用法也完全相同。

  ```
  a = (x for x in range(1,10))
  print(a)
  
  <generator object <genexpr> at 0x0000020BAD136620>
  从上面的执行结果可以看出，使用元组推导式生成的结果并不是一个元组，而是一个生成器对象（后续会介绍），这一点和列表推导式是不同的。
  ```

  - 如果我们想要使用元组推导式获得新元组或新元组中的元素，有以下三种方式：

    - 使用 tuple() 函数，可以直接将生成器对象转换成元组

      ```
      a = (x for x in range(1,10))
      print(tuple(a))
      运行结果为：
      (1, 2, 3, 4, 5, 6, 7, 8, 9)
      ```

    - 直接使用 for 循环遍历生成器对象，可以获得各个元素

      ```
      a = (x for x in range(1,10))
      for i in a:
          print(i,end=' ')
      print(tuple(a))
      
      1 2 3 4 5 6 7 8 9 ()
      ```

    - 使用 __next__() 方法遍历生成器对象，也可以获得各个元素

      ```
      a = (x for x in range(3))
      print(a.__next__())
      print(a.__next__())
      print(a.__next__())
      a = tuple(a)
      print("转换后的元组：",a)
      
      0
      1
      2
      转换后的元组： ()
      ```

  - 无论是使用 for 循环遍历生成器对象，还是使用 __next__() 方法遍历生成器对象，遍历后原生成器对象将不复存在，这就是遍历后转换原生成器对象却得到空元组的原因。

- 字典推导式

  ```
  {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}
  ```

  ```
  listdemo = ['C语言中文网','c.biancheng.net']
  #将列表中各字符串值为键，各字符串的长度为值，组成键值对
  newdict = {key:len(key) for key in listdemo}
  print(newdict)
  
  {'C语言中文网': 6, 'c.biancheng.net': 15}
  
  交换现有字典中各键值对的键和值。
  olddict={'C语言中文网': 6, 'c.biancheng.net': 15}
  newdict = {v: k for k, v in olddict.items()}
  print(newdict)
  {6: 'C语言中文网', 15: 'c.biancheng.net'}
  ```

- 集合推导式

  ```
  { 表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] }
  ```

  - 有读者可能会问，集合推导式和字典推导式的格式完全相同，那么给定一个类似的推导式，如何判断是哪种推导式呢？最简单直接的方式，就是根据表达式进行判断，如果表达式以键值对（key：value）的形式，则证明此推导式是字典推导式；反之，则是集合推导式。
  - 既然生成的是集合，那么其保存的元素必须是唯一的。

###### zip函数

- zip() 函数是 [Python](http://c.biancheng.net/python/) 内置函数之一，它可以将多个序列（列表、元组、字典、集合、字符串以及 range() 区间构成的列表）“压缩”成一个 zip 对象。所谓“压缩”，其实就是将这些序列中对应位置的元素重新组合，生成一个个新的元组。

  ```
  zip(iterable, ...)
  ```

  - 其中 iterable,... 表示多个列表、元组、字典、集合、字符串，甚至还可以为 range() 区间。

    ```
    my_list = [11,12,13]
    my_tuple = (21,22,23)
    print([x for x in zip(my_list,my_tuple)])
    my_dic = {31:2,32:4,33:5}
    my_set = {41,42,43,44}
    print([x for x in zip(my_dic)])
    my_pychar = "python"
    my_shechar = "shell"
    print([x for x in zip(my_pychar,my_shechar)])
    
    [(11, 21), (12, 22), (13, 23)]
    [(31,), (32,), (33,)]
    [('p', 's'), ('y', 'h'), ('t', 'e'), ('h', 'l'), ('o', 'l')]
    ```

    - 读者分析以上的程序和相应的输出结果不难发现，在使用 zip() 函数“压缩”多个序列时，它会分别取各序列中第 1 个元素、第 2 个元素、... 第 n 个元素，各自组成新的元组。需要注意的是，当多个序列中元素个数不一致时，会以最短的序列为准进行压缩。

  - 对于 zip() 函数返回的 zip 对象，既可以像上面程序那样，通过遍历提取其存储的元组，也可以向下面程序这样，通过调用 list() 函数将 zip() 对象强制转换成列表：

    ```
    my_list = [11,12,13]
    my_tuple = (21,22,23)
    print(list(zip(my_list,my_tuple)))
    ```

###### reversed函数

- reserved() 是 Pyton 内置函数之一，其功能是对于给定的序列（包括列表、元组、字符串以及 range(n) 区间），该函数可以返回一个逆序序列的迭代器（用于遍历该逆序序列）。

  ```
  reversed(seq)
  ```

  - seq 可以是列表，元素，字符串以及 range() 生成的区间列表。

  ```
  #将列表进行逆序
  print([x for x in reversed([1,2,3,4,5])])
  #将元组进行逆序
  print([x for x in reversed((1,2,3,4,5))])
  #将字符串进行逆序
  print([x for x in reversed("abcdefg")])
  #将 range() 生成的区间列表进行逆序
  print([x for x in reversed(range(10))])
  
  [5, 4, 3, 2, 1]
  [5, 4, 3, 2, 1]
  ['g', 'f', 'e', 'd', 'c', 'b', 'a']
  [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
  ```

- 除了使用列表推导式的方式，还可以使用 list() 函数，将 reversed() 函数逆序返回的迭代器，直接转换成列表

  ```
  #将列表进行逆序
  print(list(reversed([1,2,3,4,5])))
  
  [5, 4, 3, 2, 1]
  ```

- 再次强调，使用 reversed() 函数进行逆序操作，并不会修改原来序列中元素的顺序

###### sorted函数

- sorted() 作为 [Python](http://c.biancheng.net/python/) 内置函数之一，其功能是对序列（列表、元组、字典、集合、还包括字符串）进行排序。

  ```
  list = sorted(iterable, key=None, reverse=False)  
  ```

  - iterable 表示指定的序列，key 参数可以自定义排序规则；reverse 参数指定以升序（False，默认）还是降序（True）进行排序。sorted() 函数会返回一个排好序的列表。

    ```
    #对列表进行排序
    a = [5,3,4,2,1]
    print(sorted(a))
    #对元组进行排序
    a = (5,4,3,1,2)
    print(sorted(a))
    #字典默认按照key进行排序
    a = {4:1,\
         5:2,\
         3:3,\
         2:6,\
         1:8}
    print(sorted(a.items()))
    #对集合进行排序
    a = {1,5,3,2,4}
    print(sorted(a))
    #对字符串进行排序
    a = "51423"
    print(sorted(a))
    
    [1, 2, 3, 4, 5]
    [1, 2, 3, 4, 5]
    [(1, 8), (2, 6), (3, 3), (4, 1), (5, 2)]
    [1, 2, 3, 4, 5]
    ['1', '2', '3', '4', '5']
    ```

- 使用 sorted() 函数对序列进行排序， 并不会在原序列的基础进行修改，而是会重新生成一个排好序的列表。

- sorted(）函数默认对序列中元素进行升序排序，通过手动将其 reverse 参数值改为 True，可实现降序排序

- 另外在调用 sorted() 函数时，还可传入一个 key 参数，它可以接受一个函数，该函数的功能是指定 sorted() 函数按照什么标准进行排序

  ```
  chars=['http://c.biancheng.net',\
         'http://c.biancheng.net/python/',\
         'http://c.biancheng.net/shell/',\
         'http://c.biancheng.net/java/',\
         'http://c.biancheng.net/golang/']
  #默认排序
  print(sorted(chars))
  #自定义按照字符串长度排序
  print(sorted(chars,key=lambda x:len(x)))
  ```

  
