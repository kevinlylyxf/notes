#### python理解

- cpu执行的都是机器码，所以无论是编译型语言还是解释型语言最后都要编译为机器码来运行，不同的操作系统可执行文件的格式不同，例如linux下支持的是ELF格式，windows下使用的是PE格式，编译型语言例如c，要经历预处理、编译、汇编、链接四个过程，最后生成可执行文件，这个可执行文件操作系统是可以直接执行的，不用借助其他的中间件。可执行文件里面都是机器码。可执行文件放在虚拟内存里面，按照分页管理，用到哪部分机器码，就由操作系统按照内存映射将哪部分机器码放到物理内存中。每一个进程按照虚拟内存来说都有独立的内存区域，所以不用担心内存的问题。编译型语言例如python，其没有c语言的四个过程，但是如果想要运行就必须要有机器码，所以python在不同的平台上都实现了解释器，这个解释器是一个可执行程序，在linux下就是ELF文件，在windows下就是PE文件，在运行python程序的时候，由这个python解释器来将源代码编译为机器码来运行，这个过程不是说编译全部的，程序运行时需要哪部分代码就编译哪部分代码为机器码，将机器码放到内存中，这样就能直接运行。至于这个编译是如何控制的，也就是如何确定需要哪部分代码这是python解释器要实现的，使用者不需要管。所以python源文件是不能直接由操作系统执行的，必须借助python解释器。这也是python运行比较慢的原因

- python源码能跨平台运行，其中的差异都由不同平台上的python编译器隐藏了。例如不同的平台对于文件的管理是不同的，对于文件的底层实现是不同的。如果python源码中打开一个文件open(file)这个操作，不同的平台对于打开文件底层都是不同的，机器码也是不同的，但是这个机器码在相同的平台下是固定的，例如打开文件在linux下的机器码是固定的，这样python解释器就能将打开文件这个操作转换为机器码，然后将这个机器码放到内存中(内存中有代码段和数据段)，不同的解释器就是用来隐藏这个差异的，对我们用户来说打开文件都是一样的操作，其实底层都用解释器来隐藏了。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态。比如打开文件读写文件都在内核态，如果要用这些服务时，就会转到内存中的内核态里面去执行。python解释器应该也会实现这些转换，用户态到内核态，因为本身python解释器就是解释代码变成机器码来运行。操作系统只提供最基本的服务，具体的算法实现一般还是在用户态自己实现。

- python需要系统服务的一些会转到内核态，但是一些用户态的还是python本身自己就能实现，不用调用c和c++的库，例如数据计算时，数据计算主要是内存中的计算，定义变量时申请内存，计算时用机器码操作计算。这些python解释器就能转换为机器码来实现，不用先转换为c或者c++的库然后在转换为机器码，python解释器自己就能转换为机器码。所以一些numpy、pandas这些计算模块不用调用c或者c++的代码，用python的语法就能实现，剩下的交给python解释器就行。所以用pip下载的这些模块里面都没有动态库，只有py文件

- cpu指令是固定的，例如加减乘除移动访问，这些机器码对于cpu都是固定的，所有的语言最后都要生成cpu能执行的的这些固定的机器码。内存中有代码段和数据段。其实变量的定义和计算就是申请一个内存，然后计算，这个比较好说。如果涉及到操作系统提供的函数，就会涉及到一些底层的实现，这样生成的机器码比较复杂，放到内存中的也比较复杂，我们用户不用管这些，python解释器帮我们干了这些事情。其实操作系统提供的主要是一些文件操作以及网络服务之类的。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- 不同的编程语言对于操作系统提供的这些服务按照语法来说是不同的，但是最后生成的机器码都是一样的。不同的编程语言在一些功能上实现的方式不同，对于用户来说就是实现的简单与否。但是最后殊途同归，生成的机器码都是一样的。所以会有算法这种东西产生，不同的算法对于一个功能的实现可能是质的飞跃(不同的算法计算方式不一样)，这样生成的机器码就不会很啰嗦，生成的机器码就会很少，这样运算速度就会很快。所以算法对于运算的提升很大。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- python官网上的模块例如numpy，pandas官网上的都是.whl文件，whl文件本质上就是一个压缩文件，安装whl文件很简单，先手动下载文件然后手动安装时使用pip install xxx.whl，pip命令直接安装(不用先手动下载whl文件)也是命令自己下载whl文件，然后在解压安装，原理都是一样的。

- 查看可执行程序，windows下是where python， linux和mac下是which python

- pip安装包的路径查询，在pip install首次安装完成的时候会显示安装位置，如果已经安装使用pip install就会显示安装位置，windows下pip安装的模块一般都放在C:\Users\lylyx\AppData\Local\Programs\Python\Python39\Lib\site-packages里面

- mac下使用homebrew安装软件时使用brew info可以看到软件的依赖以及各种信息，如果直接安装例如brew install python3，里面的idle运行时就会提示Tkinter缺失(Tkinter模块("Tk 接口")是Python的标准Tk GUI工具包的接口。 作为 python 特定的GUI界面，是一个图像的窗口，tkinter是python 自带的，可以编辑的GUI界面)，这样就会出错。但是我们可以使用brew info python3，就是显示各种信息，包括依赖的tkinter问题，这样我们就能根据提示安装thinter，idle就能正常使用了

- pyc文件是py文件编译后生成的字节码文件(byte code)。pyc文件经过python解释器最终会生成机器码运行。为什么要手动提前生成pyc文件呢，主要是不想把源代码暴露出来。生成的pyc文件会放到当前目录下新创建的\__pycache__中

  ```
  命令生成pyc文件
  python -m foo.py
  代码来生成pyc文件
  import py_compile
  py_compile.compile('/path/to/foo.py')
  
  批量生成，针对一个目录下所有的py文件进行编译。python提供了一个模块叫compileall
  import compileall
  compileall.compile_dir(r'/path')
  ```

  - 生成的pyc文件使用python xxx.pyc来运行

#### 变量类型和运算符

- 变量在 Python 内部是有类型的，比如 int、float 等，但是我们在编程时无需关注变量类型，所有的变量都无需提前声明，赋值后就能使用。另外，可以将不同类型的数据赋值给同一个变量，所以变量的类型是可以改变的。

- Python 支持自增和自减运算符，但是它只支持一种形式，就是前自增和前自减，而取消了后自增和后自减，避免了给程序员造成混乱

- 变量（Variable）可以看成一个小箱子，专门用来“盛装”程序中的数据。每个变量都拥有独一无二的名字，通过变量的名字就能找到变量中的数据。

- 从底层看，程序中的数据最终都要放到内存（内存条）中，变量其实就是这块内存的名字。

- 和变量相对应的是常量（Constant），它们都是用来“盛装”数据的小箱子，不同的是：变量保存的数据可以被多次修改，而常量一旦保存某个数据之后就不能修改了。

- id() 内置函数，该函数的功能是获取变量（对象）所在的内存地址

- 在强类型的编程语言中，定义变量时要指明变量的类型，而且赋值的数据也必须是相同类型的，C语言、C++、[Java](http://c.biancheng.net/java/) 是强类型语言的代表。

- 和强类型语言相对应的是弱类型语言，Python、[JavaScript](http://c.biancheng.net/js/)、[PHP](http://c.biancheng.net/php/) 等脚本语言一般都是弱类型的。弱类型语言有两个特点：

  - 变量无须声明就可以直接赋值，对一个不存在的变量赋值就相当于定义了一个新变量。
  - 变量的数据类型可以随时改变，比如，同一个变量可以一会儿被赋值为整数，一会儿被赋值为字符串。

- 弱类型并不等于没有类型！弱类型是说在书写代码时不用刻意关注类型，但是在编程语言的内部仍然是有类型的。我们可以使用 type() 内置函数类检测某个变量或者表达式的类型，其类型的

  ```python
  >>>num = 10
  >>> type(num)
  <class 'int'>
  >>> num = 15.8
  >>> type(num)
  <class 'float'>
  >>> num = 20 + 15j
  >>> type(num)
  <class 'complex'>
  >>> type(3*15.6)
  <class 'float'>
  ```

- 弱类型语言的变量在内存中存储，每一种占据的字节数都是固定的，例如int占用四个字节，float占用8个字节一个。但是我们可以不用管，因为有python解释器，解释器就帮我们干了这个事，所以我们不用考虑变量的类型。

##### 整数

- Python 整数不分类型，或者说它只有一种类型的整数。Python 整数的取值范围是无限的，不管多大或者多小的数字，Python 都能轻松处理。当所用数值超过计算机自身的计算能力时，Python 会自动转用高精度计算（大数计算）。不管对于多大或者多小的整数，Python 只用一种类型存储，就是 int。无论对于多大的整数，type()的结果都为int

- 在 Python 中，可以使用多种进制来表示整数：

  1) 十进制形式

  我们平时常见的整数就是十进制形式，它由 0~9 共十个数字排列组合而成。

  注意，使用十进制形式的整数不能以 0 作为开头，除非这个数值本身就是 0。

  2) 二进制形式

  由 0 和 1 两个数字组成，书写时以`0b`或`0B`开头。例如，101 对应十进制数是 5。

  3) 八进制形式

  八进制整数由 0~7 共八个数字组成，以`0o`或`0O`开头。注意，第一个符号是数字 0，第二个符号是大写或小写的字母 O。

  在 Python 2.x 中，八进制数字还可以直接以`0`（数字零）开头。

  4) 十六进制形式

  由 0~9 十个数字以及 A~F（或 a~f）六个字母组成，书写时以`0x`或`0X`开头

- 为了提高数字的的可读性，Python 3.x 允许使用下划线`_`作为数字（包括整数和小数）的分隔符。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。下划线不会影响数字本身的值。

  ```python
  click = 1_301_547
  distance = 384_000_000
  print("Python教程阅读量：", click)
  print("地球和月球的距离：", distance)
  
  Python教程阅读量：1301547
  地球和月球的距离：384000000
  ```

##### 浮点数

- [Python](http://c.biancheng.net/python/) 中的小数有两种书写形式：

  1) 十进制形式

  这种就是我们平时看到的小数形式，例如 34.6、346.0、0.346。

  书写小数时必须包含一个小数点，否则会被 Python 当作整数处理。

  2) 指数形式

  Python 小数的指数形式的写法为：aEn 或 aen

  a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；`E`或`e`是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 a×10n。

- 只要写成指数形式就是小数，即使它的最终值看起来像一个整数。例如 14E3 等价于 14000，但 14E3 是一个小数。

- Python 只有一种小数类型，就是 float。C语言有两种小数类型，分别是 float 和 double：float 能容纳的小数范围比较小，double 能容纳的小数范围比较大。

- Python 能容纳极小和极大的浮点数。print 在输出浮点数时，会根据浮点数的长度和大小适当的舍去一部分数字，或者采用科学计数法。

  ```python
  f5 = 12e4
  print("f5Value: ", f5)
  print("f5Type: ", type(f5))
  f6 = 12.3 * 0.1
  print("f6Value: ", f6)
  print("f6Type: ", type(f6))
  
  f5Value:  120000.0
  f5Type:  <class 'float'>
  f6Value:  1.2300000000000002
  f6Type:  <class 'float'>
  ```

  - f5 的值是 120000，但是它依然是小数类型，而不是整数类型。

  -  f6中`12.3*0.1`的计算结果很明显是 1.23，但是 print 的输出却不精确。这是因为小数在内存中是以二进制形式存储的，小数点后面的部分在转换成二进制时很有可能是一串无限循环的数字，无论如何都不能精确表示，所以小数的计算结果一般都是不精确的

  - 为什么在计算这么简单的问题上，计算机会出现这样的低级错误呢？真正的原因在于十进制和数和二进制数的转换。计算机其实是不认识十进制数，它只认识二进制数，也就是说，当我们以十进制数进行运算的时候，计算机需要将各个十进制数转换成二进制数，然后进行二进制间的计算。以类似 0.1 这样的浮点数为例，如果手动将其转换成二进制，其结果为：

    ```
    0.1(10)=0.00011001100110011...(2)
    ```

    - 可以看到，结果是无限循环的，也就是说，0.1 转换成二进制数后，无法精确到等于十进制数的 0.1。同时，由于计算机存储的位数是有限制的，所以如果要存储的二进制位数超过了计算机存储位数的最大值，其后续位数会被舍弃（舍弃的原则是“0 舍 1 入”）。	

- 如果需要非常精确的结果，可以使用 decimal 模块（其实就是别人开发好的程序，我们可以直接拿来用），它实现的十进制数运算适合会计方面的应用和有高精度要求的应用

  ```python
  #使用模块前，需要使用 import 引入
  import decimal
  a = decimal.Decimal("10.0")
  b = decimal.Decimal("3")
  print(10.0/3)
  print(a/b)
  
  3.3333333333333335
  3.333333333333333333333333333
  ```

- 如果 decimal 模块还是无法满足需求，还可以使用 fractions 模块

  ```python
  #引入 decimal 模块
  from fractions import Fraction
  print(10/3)
  print(Fraction(10,3))
  
  3.3333333333333335
  10/3
  ```

  

##### 复数

- 复数（Complex）是 [Python](http://c.biancheng.net/python/) 的内置类型，直接书写即可。换句话说，Python 语言本身就支持复数，而不依赖于标准库或者第三方库。
- 复数由实部（real）和虚部（imag）构成，在 Python 中，复数的虚部以`j`或者`J`作为后缀，具体格式为：a + bj，a 表示实部，b 表示虚部。

```python
c1 = 12 + 0.2j
print("c1Value: ", c1)
print("c1Type", type(c1))
c2 = 6 - 1.2j
print("c2Value: ", c2)
#对复数进行简单计算
print("c1+c2: ", c1+c2)
print("c1*c2: ", c1*c2)

c1Value:  (12+0.2j)
c1Type <class 'complex'>
c2Value:  (6-1.2j)
c1+c2:  (18-1j)
c1*c2:  (72.24-13.2j)
```

- 复数在 Python 内部的类型是 complex，Python 默认支持对复数的简单计算。

##### 字符串

- Python中的字符串必须由双引号`" "`或者单引号`' '`包围

- Python 字符串中的双引号和单引号没有任何区别。而有些编程语言的双引号字符串可以解析变量，单引号字符串一律原样输出，例如 [PHP](http://c.biancheng.net/php/) 和 [JavaScript](http://c.biancheng.net/js/)。

- 字符串中对引号的处理有两种方案

  - 对引号进行转义，在引号前面添加反斜杠`\`就可以对引号进行转义，让 Python 把它作为普通文本对待
  - 使用不同的引号包围字符串。如果字符串内容中出现了单引号，那么我们可以使用双引号包围字符串，反之亦然

- 字符串的换行。Python 不是格式自由的语言，它对程序的换行、缩进都有严格的语法要求。要想换行书写一个比较长的字符串，必须在行尾添加反斜杠`\`

  ```
  s2 = 'It took me six months to write this Python tutorial. \
      Please give me more support. \
      I will keep it updated.'
  ```

  - 上面 s2 字符串的比较长，所以使用了转义字符`\`对字符串内容进行了换行，这样就可以把一个长字符串写成多行。

  - Python 也支持表达式的换行

    ```
    num = 20 + 3 / 4 + \
        2 * 3
    print(num)
    ```

- 长字符串。使用三个单引号或者双引号可以对多行内容进行注释，这其实是 Python 长字符串的写法。所谓长字符串，就是可以直接换行（不用加反斜杠`\`）书写的字符串。Python 长字符串由三个双引号`"""`或者三个单引号`'''`包围。在长字符串中放置单引号或者双引号不会导致解析错误。如果长字符串没有赋值给任何变量，那么这个长字符串就不会起到任何作用，和一段普通的文本无异，相当于被注释掉了。此时 Python 解释器并不会忽略长字符串，也会按照语法解析，只是长字符串起不到实际作用而已。当程序中有大段文本内容需要定义成字符串时，优先推荐使用长字符串形式，因为这种形式非常强大，可以在字符串中放置任何内容，包括单引号和双引号。长字符串中的换行、空格、缩进等空白符都会原样输出

  ```python
  longstr = '''
      It took me 6 months to write this Python tutorial.
      Please give me a to 'thumb' to keep it updated.
      The Python tutorial is available at http://c.biancheng.net/python/.
  '''
  print(longstr)
  
  
      It took me 6 months to write this Python tutorial.
      Please give me a to 'thumb' to keep it updated.
      The Python tutorial is available at http://c.biancheng.net/python/.
   
   字符串内容前后多出了两个空行，并且每一行的前面会多出四个空格。
  
  ```

- 原始字符串。Python 字符串中的反斜杠`\`有着特殊的作用，就是转义字符。转义字符有时候会带来一些麻烦，例如我要表示一个包含 Windows 路径`D:\Program Files\Python 3.8\python.exe`这样的字符串，在 Python 程序中直接这样写肯定是不行的，不管是普通字符串还是长字符串。因为`\`的特殊性，我们需要对字符串中的每个`\`都进行转义，也就是写成`D:\\Program Files\\Python 3.8\\python.exe\`这种形式才行。这种写法需要特别谨慎，稍有疏忽就会出错。为了解决转义字符的问题，Python 支持原始字符串。在原始字符串中，`\`不会被当作转义字符，所有的内容都保持“原汁原味”的样子。

  - 在普通字符串或者长字符串的开头加上`r`前缀，就变成了原始字符串

    ```
    str1 = r'原始字符串内容'
    str2 = r"""原始字符串内容"""
    
    rstr = r'D:\Program Files\Python 3.8\python.exe'
    print(rstr)
    ```

  - 如果普通格式的原始字符串中出现引号，程序同样需要对引号进行转义，否则 Python 照样无法对字符串的引号精确配对；但是和普通字符串不同的是，此时用于转义的反斜杠会变成字符串内容的一部分。

    ```
    str1 = r'I\'m a great coder!'
    print(str1)
    
    I\'m a great coder!
    ```

    - 需要注意的是，Python 原始字符串中的反斜杠仍然会对引号进行转义，因此原始字符串的结尾处不能是反斜杠，否则字符串结尾处的引号会被转义，导致字符串不能正确结束。

  - 在 Python 中有两种方式解决原始字符串中\这个问题：一种方式是改用长字符串的写法，不要使用原始字符串；另一种方式是单独书写反斜杠

    - 例如想表示`D:\Program Files\Python 3.8\`，可以这样写：

      ```
      str1 = r'D:\Program Files\Python 3.8' '\\'
      print(str1)
      
      我们先写了一个原始字符串r'D:\Program Files\Python 3.8'，紧接着又使用'\\'写了一个包含转义字符的普通字符串，Python 会自动将这两个字符串拼接在一起
      D:\Program Files\Python 3.8\
      ```

##### bytes

- bytes 类型用来表示一个字节串。“字节串“不是编程术语，是我自己“捏造”的一个词，用来和字符串相呼应。

- 字节串（bytes）和字符串（string）的对比：

  - 字符串由若干个字符组成，以字符为单位进行操作；字节串由若干个字节组成，以字节为单位进行操作。
  - 字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法都基本相同。
  - 字节串和字符串都是不可变序列，不能随意增加和删除数据。

- bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。说白了，bytes 只是简单地记录内存中的原始数据，至于如何使用这些数据，bytes 并不在意，你想怎么使用就怎么使用，bytes 并不约束你的行为。bytes 类型的数据非常适合在互联网上传输，可以用于网络通信编程；bytes 也可以用来存储图片、音频、视频等二进制格式的文件。

- 字符串和 bytes 存在着千丝万缕的联系，我们可以通过字符串来创建 bytes 对象，或者说将字符串转换成 bytes 对象。有以下三种方法可以达到这个目的：

  - 如果字符串的内容都是 ASCII 字符，那么直接在字符串前面添加`b`前缀就可以转换成 bytes。
  - bytes 是一个类，调用它的构造方法，也就是 bytes()，可以将字符串按照指定的字符集转换成 bytes；如果不指定字符集，那么默认采用 UTF-8。
  - 字符串本身有一个 encode() 方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8。

  ```
  #通过构造函数创建空 bytes
  b1 = bytes()
  #通过空字符串创建空 bytes
  b2 = b''
  #通过b前缀将字符串转换成 bytes
  b3 = b'http://c.biancheng.net/python/'
  print("b3: ", b3)
  print(b3[3])
  print(b3[7:22])
  #为 bytes() 方法指定字符集
  b4 = bytes('C语言中文网8岁了', encoding='UTF-8')
  print("b4: ", b4)
  #通过 encode() 方法将字符串转换成 bytes
  b5 = "C语言中文网8岁了".encode('UTF-8')
  print("b5: ", b5)
  
  
  b3:  b'http://c.biancheng.net/python/'
  112
  b'c.biancheng.net'
  b4:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
  b5:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
  ```

  - 从运行结果可以发现，对于非 ASCII 字符，print 输出的是它的字符编码值（十六进制形式），而不是字符本身。非 ASCII 字符一般占用两个字节以上的内存，而 bytes 是按照单个字节来处理数据的，所以不能一次处理多个字节。

- bytes 类也有一个 decode() 方法，通过该方法可以将 bytes 对象转换为字符串

  ```
  #通过 decode() 方法将 bytes 转换成字符串
  str1 = b5.decode('UTF-8')
  print("str1: ", str1)
  
  str1:  C语言中文网8岁了
  ```

##### bool

- True 和 False 是 Python 中的关键字，当作为 Python 代码输入时，一定要注意字母的大小写，否则解释器会报错。

- 布尔类型可以当做整数来对待，即 True 相当于整数值 1，False 相当于整数值 0。

  ```
  >>> False+1
  1
  >>> True+1
  2
  ```

- 在 Python 中，所有的对象都可以进行真假值的测试，包括字符串、元组、列表、字典、对象等

##### input()函数

- input() 是 [Python](http://c.biancheng.net/python/) 的内置函数，用于从控制台读取用户输入的内容。input() 函数总是以字符串的形式来处理用户输入的内容，所以用户输入的内容可以包含任何字符。

  ```
  str = input(tipmsg)
  ```

  - str 表示一个字符串类型的变量，input 会将读取到的字符串放入 str 中。
  - tipmsg 表示提示信息，它会显示在控制台上，告诉用户应该输入什么样的内容；如果不写 tipmsg，就不会有任何提示信息。

- 我们可以使用 Python 内置函数将字符串转换成想要的类型，比如：

  - int(string) 将字符串转换成 int 类型；
  - float(string) 将字符串转换成 float 类型；
  - bool(string) 将字符串转换成 bool 类型。

##### print

- print() 函数完全可以同时输出多个变量

- print() 函数的详细语法格式如下：

  ```
  print (value,...,sep='',end='\n',file=sys.stdout,flush=False)
  ```

  - value 参数可以接受任意多个变量或值，因此 print() 函数完全可以输出多个值

    ```
    user_name ＝ 'Charlie'
    user_age = 8
    #同时输出多个变量和字符串
    print("读者名：",user_name,"年龄：",user_age)
    
    读者名： Charlie 年龄： 8
    ```

  - 从输出结果来看，使用 print() 函数输出多个变量时，print() 函数默认以空格隔开多个变量，如果读者希望改变默认的分隔符，可通过 sep 参数进行设置。例如输出语句：

    ```
    #同时输出多个变量和字符串，指定分隔符
    print("读者名：" ,user_name,"年龄：",user_age,sep='|')
    
    读者名：|Charlie|年龄：|8
    ```

  - 在默认情况下，print() 函数输出之后总会换行，这是因为 print() 函数的 end 参数的默认值是“\n”，这个“\n”就代表了换行。如果希望 print() 函数输出之后不会换行，则重设 end 参数即可

    ```
    #设置end 参数，指定输出之后不再换行
    print(40,'\t',end＝"")
    print(5O,'\t',end＝"")
    print(60,'\t',end＝"")
    
    40    50    60
    ```

  - file 参数指定 print() 函数的输出目标，file 参数的默认值为 sys.stdout，该默认值代表了系统标准输出，也就是屏幕，因此 print() 函数默认输出到屏幕。实际上，完全可以通过改变该参数让 print() 函数输出到特定文件中

    ```
    f = open("demo.txt","w")#打开文件以便写入
    print('沧海月明珠有泪',file=f)
    print('蓝回日暖玉生烟',file=f)
    f.close()
    ```

  - print() 函数的 flush 参数用于控制输出缓存，该参数一般保持为 False 即可，这样可以获得较好的性能。

##### 转义字符

- 转义字符，就是那些以反斜杠`\`开头的字符。

- ASCII 编码为每个字符都分配了唯一的编号，称为编码值。在 [Python](http://c.biancheng.net/python/) 中，一个 ASCII 字符除了可以用它的实体（也就是真正的字符）表示，还可以用它的编码值表示。这种使用编码值来间接地表示字符的方式称为转义字符（Escape Character）。

- 转义字符以`\0`或者`\x`开头，以`\0`开头表示后跟八进制形式的编码值，以`\x`开头表示后跟十六进制形式的编码值，Python 中的转义字符只能使用八进制或者十六进制。

  ```
  \0dd
  \xhh
  ```

  - dd 表示八进制数字，hh 表示十六进制数字。

- ASCII 编码共收录了 128 个字符，`\0`和`\x`后面最多只能跟两位数字，所以八进制形式`\0`并不能表示所有的 ASCII 字符，只有十六进制形式`\x`才能表示所有 ASCII 字符。

- 字符 1、2、3、x、y、z 对应的 ASCII 码的八进制形式分别是 61、62、63、170、171、172，十六进制形式分别是 31、32、33、78、79、7A。下面的例子演示了转义字符的用法：使用八进制形式的转义字符没法表示 xyz，因为它们的编码值转换成八进制以后有三位。

  ```python
  str1 = "Oct: \061\062\063"
  str2 = "Hex: \x31\x32\x33\x78\x79\x7A"
  print(str1)
  print(str2)
  
  Oct: 123
  Hex: 123xyz
  ```

- 对于 ASCII 编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能用转义字符的形式来表示。不过，直接使用 ASCII 码记忆不方便，也不容易理解，所以，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下。

  | 转义字符 | 说明                                                         |
  | -------- | ------------------------------------------------------------ |
  | \n       | 换行符，将光标位置移到下一行开头。                           |
  | \r       | 回车符，将光标位置移到本行开头。                             |
  | \t       | 水平制表符，也即 Tab 键，一般相当于四个空格。                |
  | \a       | 蜂鸣器响铃。注意不是喇叭发声，现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效。 |
  | \b       | 退格（Backspace），将光标位置移到前一列。                    |
  | \\\      | 反斜线                                                       |
  | \\'      | 单引号                                                       |
  | \\"      | 双引号                                                       |
  | \\       | 在字符串行尾的续行符，即一行未完，转到下一行继续写。         |

```python
#使用\t排版
str1 = '网站\t\t域名\t\t\t年龄\t\t价值'
str2 = 'C语言中文网\tc.biancheng.net\t\t8\t\t500W'
str3 = '百度\t\twww.baidu.com\t\t20\t\t500000W'
print(str1)
print(str2)
print(str3)
print("--------------------")
# \n在输出时换行，\在书写字符串时换行
info = "Python教程：http://c.biancheng.net/python/\n\
C++教程：http://c.biancheng.net/cplus/\n\
Linux教程：http://c.biancheng.net/linux_tutorial/"
print(info)

网站        域名                年龄    价值
C语言中文网 c.biancheng.net     8       500W
百度        www.baidu.com       20      500000W
--------------------
Python教程：http://c.biancheng.net/python/
C++教程：http://c.biancheng.net/cplus/
Linux教程：http://c.biancheng.net/linux_tutorial/
```

