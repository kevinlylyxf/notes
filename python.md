#### python理解

- cpu执行的都是机器码，所以无论是编译型语言还是解释型语言最后都要编译为机器码来运行，不同的操作系统可执行文件的格式不同，例如linux下支持的是ELF格式，windows下使用的是PE格式，编译型语言例如c，要经历预处理、编译、汇编、链接四个过程，最后生成可执行文件，这个可执行文件操作系统是可以直接执行的，不用借助其他的中间件。可执行文件里面都是机器码。可执行文件放在虚拟内存里面，按照分页管理，用到哪部分机器码，就由操作系统按照内存映射将哪部分机器码放到物理内存中。每一个进程按照虚拟内存来说都有独立的内存区域，所以不用担心内存的问题。编译型语言例如python，其没有c语言的四个过程，但是如果想要运行就必须要有机器码，所以python在不同的平台上都实现了解释器，这个解释器是一个可执行程序，在linux下就是ELF文件，在windows下就是PE文件，在运行python程序的时候，由这个python解释器来将源代码编译为机器码来运行，这个过程不是说编译全部的，程序运行时需要哪部分代码就编译哪部分代码为机器码，将机器码放到内存中，这样就能直接运行。至于这个编译是如何控制的，也就是如何确定需要哪部分代码这是python解释器要实现的，使用者不需要管。所以python源文件是不能直接由操作系统执行的，必须借助python解释器。这也是python运行比较慢的原因

- python源码能跨平台运行，其中的差异都由不同平台上的python编译器隐藏了。例如不同的平台对于文件的管理是不同的，对于文件的底层实现是不同的。如果python源码中打开一个文件open(file)这个操作，不同的平台对于打开文件底层都是不同的，机器码也是不同的，但是这个机器码在相同的平台下是固定的，例如打开文件在linux下的机器码是固定的，这样python解释器就能将打开文件这个操作转换为机器码，然后将这个机器码放到内存中(内存中有代码段和数据段)，不同的解释器就是用来隐藏这个差异的，对我们用户来说打开文件都是一样的操作，其实底层都用解释器来隐藏了。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态。比如打开文件读写文件都在内核态，如果要用这些服务时，就会转到内存中的内核态里面去执行。python解释器应该也会实现这些转换，用户态到内核态，因为本身python解释器就是解释代码变成机器码来运行。操作系统只提供最基本的服务，具体的算法实现一般还是在用户态自己实现。

- python需要系统服务的一些会转到内核态，但是一些用户态的还是python本身自己就能实现，不用调用c和c++的库，例如数据计算时，数据计算主要是内存中的计算，定义变量时申请内存，计算时用机器码操作计算。这些python解释器就能转换为机器码来实现，不用先转换为c或者c++的库然后在转换为机器码，python解释器自己就能转换为机器码。所以一些numpy、pandas这些计算模块不用调用c或者c++的代码，用python的语法就能实现，剩下的交给python解释器就行。所以用pip下载的这些模块里面都没有动态库，只有py文件

- cpu指令是固定的，例如加减乘除移动访问，这些机器码对于cpu都是固定的，所有的语言最后都要生成cpu能执行的的这些固定的机器码。内存中有代码段和数据段。其实变量的定义和计算就是申请一个内存，然后计算，这个比较好说。如果涉及到操作系统提供的函数，就会涉及到一些底层的实现，这样生成的机器码比较复杂，放到内存中的也比较复杂，我们用户不用管这些，python解释器帮我们干了这些事情。其实操作系统提供的主要是一些文件操作以及网络服务之类的。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- 不同的编程语言对于操作系统提供的这些服务按照语法来说是不同的，但是最后生成的机器码都是一样的。不同的编程语言在一些功能上实现的方式不同，对于用户来说就是实现的简单与否。但是最后殊途同归，生成的机器码都是一样的。所以会有算法这种东西产生，不同的算法对于一个功能的实现可能是质的飞跃(不同的算法计算方式不一样)，这样生成的机器码就不会很啰嗦，生成的机器码就会很少，这样运算速度就会很快。所以算法对于运算的提升很大。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- python官网上的模块例如numpy，pandas官网上的都是.whl文件，whl文件本质上就是一个压缩文件，安装whl文件很简单，先手动下载文件然后手动安装时使用pip install xxx.whl，pip命令直接安装(不用先手动下载whl文件)也是命令自己下载whl文件，然后在解压安装，原理都是一样的。

- 查看可执行程序，windows下是where python， linux和mac下是which python

- pip安装包的路径查询，在pip install首次安装完成的时候会显示安装位置，如果已经安装使用pip install就会显示安装位置，windows下pip安装的模块一般都放在C:\Users\lylyx\AppData\Local\Programs\Python\Python39\Lib\site-packages里面

- mac下使用homebrew安装软件时使用brew info可以看到软件的依赖以及各种信息，如果直接安装例如brew install python3，里面的idle运行时就会提示Tkinter缺失(Tkinter模块("Tk 接口")是Python的标准Tk GUI工具包的接口。 作为 python 特定的GUI界面，是一个图像的窗口，tkinter是python 自带的，可以编辑的GUI界面)，这样就会出错。但是我们可以使用brew info python3，就是显示各种信息，包括依赖的tkinter问题，这样我们就能根据提示安装thinter，idle就能正常使用了

- pyc文件是py文件编译后生成的字节码文件(byte code)。pyc文件经过python解释器最终会生成机器码运行。为什么要手动提前生成pyc文件呢，主要是不想把源代码暴露出来。生成的pyc文件会放到当前目录下新创建的\__pycache__中

  ```
  命令生成pyc文件
  python -m foo.py
  代码来生成pyc文件
  import py_compile
  py_compile.compile('/path/to/foo.py')
  
  批量生成，针对一个目录下所有的py文件进行编译。python提供了一个模块叫compileall
  import compileall
  compileall.compile_dir(r'/path')
  ```

  - 生成的pyc文件使用python xxx.pyc来运行

#### 变量类型和运算符

- 变量在 Python 内部是有类型的，比如 int、float 等，但是我们在编程时无需关注变量类型，所有的变量都无需提前声明，赋值后就能使用。另外，可以将不同类型的数据赋值给同一个变量，所以变量的类型是可以改变的。

- Python 支持自增和自减运算符，但是它只支持一种形式，就是前自增和前自减，而取消了后自增和后自减，避免了给程序员造成混乱

- 变量（Variable）可以看成一个小箱子，专门用来“盛装”程序中的数据。每个变量都拥有独一无二的名字，通过变量的名字就能找到变量中的数据。

- 从底层看，程序中的数据最终都要放到内存（内存条）中，变量其实就是这块内存的名字。

- 和变量相对应的是常量（Constant），它们都是用来“盛装”数据的小箱子，不同的是：变量保存的数据可以被多次修改，而常量一旦保存某个数据之后就不能修改了。

- id() 内置函数，该函数的功能是获取变量（对象）所在的内存地址

- 在强类型的编程语言中，定义变量时要指明变量的类型，而且赋值的数据也必须是相同类型的，C语言、C++、[Java](http://c.biancheng.net/java/) 是强类型语言的代表。

- 和强类型语言相对应的是弱类型语言，Python、[JavaScript](http://c.biancheng.net/js/)、[PHP](http://c.biancheng.net/php/) 等脚本语言一般都是弱类型的。弱类型语言有两个特点：

  - 变量无须声明就可以直接赋值，对一个不存在的变量赋值就相当于定义了一个新变量。
  - 变量的数据类型可以随时改变，比如，同一个变量可以一会儿被赋值为整数，一会儿被赋值为字符串。

- 弱类型并不等于没有类型！弱类型是说在书写代码时不用刻意关注类型，但是在编程语言的内部仍然是有类型的。我们可以使用 type() 内置函数类检测某个变量或者表达式的类型，其类型的

  ```python
  >>>num = 10
  >>> type(num)
  <class 'int'>
  >>> num = 15.8
  >>> type(num)
  <class 'float'>
  >>> num = 20 + 15j
  >>> type(num)
  <class 'complex'>
  >>> type(3*15.6)
  <class 'float'>
  ```

- 弱类型语言的变量在内存中存储，每一种占据的字节数都是固定的，例如int占用四个字节，float占用8个字节一个。但是我们可以不用管，因为有python解释器，解释器就帮我们干了这个事，所以我们不用考虑变量的类型。

##### 整数

- Python 整数不分类型，或者说它只有一种类型的整数。Python 整数的取值范围是无限的，不管多大或者多小的数字，Python 都能轻松处理。当所用数值超过计算机自身的计算能力时，Python 会自动转用高精度计算（大数计算）。不管对于多大或者多小的整数，Python 只用一种类型存储，就是 int。无论对于多大的整数，type()的结果都为int

- 在 Python 中，可以使用多种进制来表示整数：

  1) 十进制形式

  我们平时常见的整数就是十进制形式，它由 0~9 共十个数字排列组合而成。

  注意，使用十进制形式的整数不能以 0 作为开头，除非这个数值本身就是 0。

  2) 二进制形式

  由 0 和 1 两个数字组成，书写时以`0b`或`0B`开头。例如，101 对应十进制数是 5。

  3) 八进制形式

  八进制整数由 0~7 共八个数字组成，以`0o`或`0O`开头。注意，第一个符号是数字 0，第二个符号是大写或小写的字母 O。

  在 Python 2.x 中，八进制数字还可以直接以`0`（数字零）开头。

  4) 十六进制形式

  由 0~9 十个数字以及 A~F（或 a~f）六个字母组成，书写时以`0x`或`0X`开头

- 为了提高数字的的可读性，Python 3.x 允许使用下划线`_`作为数字（包括整数和小数）的分隔符。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。下划线不会影响数字本身的值。

  ```python
  click = 1_301_547
  distance = 384_000_000
  print("Python教程阅读量：", click)
  print("地球和月球的距离：", distance)
  
  Python教程阅读量：1301547
  地球和月球的距离：384000000
  ```

##### 浮点数

- [Python](http://c.biancheng.net/python/) 中的小数有两种书写形式：

  1) 十进制形式

  这种就是我们平时看到的小数形式，例如 34.6、346.0、0.346。

  书写小数时必须包含一个小数点，否则会被 Python 当作整数处理。

  2) 指数形式

  Python 小数的指数形式的写法为：aEn 或 aen

  a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；`E`或`e`是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 a×10n。

- 只要写成指数形式就是小数，即使它的最终值看起来像一个整数。例如 14E3 等价于 14000，但 14E3 是一个小数。

- Python 只有一种小数类型，就是 float。C语言有两种小数类型，分别是 float 和 double：float 能容纳的小数范围比较小，double 能容纳的小数范围比较大。

- Python 能容纳极小和极大的浮点数。print 在输出浮点数时，会根据浮点数的长度和大小适当的舍去一部分数字，或者采用科学计数法。

  ```python
  f5 = 12e4
  print("f5Value: ", f5)
  print("f5Type: ", type(f5))
  f6 = 12.3 * 0.1
  print("f6Value: ", f6)
  print("f6Type: ", type(f6))
  
  f5Value:  120000.0
  f5Type:  <class 'float'>
  f6Value:  1.2300000000000002
  f6Type:  <class 'float'>
  ```

  - f5 的值是 120000，但是它依然是小数类型，而不是整数类型。

  - f6中`12.3*0.1`的计算结果很明显是 1.23，但是 print 的输出却不精确。这是因为小数在内存中是以二进制形式存储的，小数点后面的部分在转换成二进制时很有可能是一串无限循环的数字，无论如何都不能精确表示，所以小数的计算结果一般都是不精确的

  - 为什么在计算这么简单的问题上，计算机会出现这样的低级错误呢？真正的原因在于十进制数和二进制数的转换。计算机其实是不认识十进制数，它只认识二进制数，也就是说，当我们以十进制数进行运算的时候，计算机需要将各个十进制数转换成二进制数，然后进行二进制间的计算。以类似 0.1 这样的浮点数为例，如果手动将其转换成二进制，其结果为：

    ```
    0.1(10)=0.00011001100110011...(2)
    ```

    - 可以看到，结果是无限循环的，也就是说，0.1 转换成二进制数后，无法精确到等于十进制数的 0.1。同时，由于计算机存储的位数是有限制的，所以如果要存储的二进制位数超过了计算机存储位数的最大值，其后续位数会被舍弃（舍弃的原则是“0 舍 1 入”）。	

- 如果需要非常精确的结果，可以使用 decimal 模块，它实现的十进制数运算适合会计方面的应用和有高精度要求的应用

  ```python
  #使用模块前，需要使用 import 引入
  import decimal
  a = decimal.Decimal("10.0")
  b = decimal.Decimal("3")
  print(10.0/3)
  print(a/b)
  
  3.3333333333333335
  3.333333333333333333333333333
  ```

- 如果 decimal 模块还是无法满足需求，还可以使用 fractions 模块

  ```python
  #引入 decimal 模块
  from fractions import Fraction
  print(10/3)
  print(Fraction(10,3))
  
  3.3333333333333335
  10/3
  ```

  

##### 复数

- 复数（Complex）是 [Python](http://c.biancheng.net/python/) 的内置类型，直接书写即可。换句话说，Python 语言本身就支持复数，而不依赖于标准库或者第三方库。
- 复数由实部（real）和虚部（imag）构成，在 Python 中，复数的虚部以`j`或者`J`作为后缀，具体格式为：a + bj，a 表示实部，b 表示虚部。

```python
c1 = 12 + 0.2j
print("c1Value: ", c1)
print("c1Type", type(c1))
c2 = 6 - 1.2j
print("c2Value: ", c2)
#对复数进行简单计算
print("c1+c2: ", c1+c2)
print("c1*c2: ", c1*c2)

c1Value:  (12+0.2j)
c1Type <class 'complex'>
c2Value:  (6-1.2j)
c1+c2:  (18-1j)
c1*c2:  (72.24-13.2j)
```

- 复数在 Python 内部的类型是 complex，Python 默认支持对复数的简单计算。

##### 字符串

- Python中的字符串必须由双引号`" "`或者单引号`' '`包围

- Python 字符串中的双引号和单引号没有任何区别。而有些编程语言的双引号字符串可以解析变量，单引号字符串一律原样输出，例如 [PHP](http://c.biancheng.net/php/) 和 [JavaScript](http://c.biancheng.net/js/)。

- 字符串中对引号的处理有两种方案

  - 对引号进行转义，在引号前面添加反斜杠`\`就可以对引号进行转义，让 Python 把它作为普通文本对待
  - 使用不同的引号包围字符串。如果字符串内容中出现了单引号，那么我们可以使用双引号包围字符串，反之亦然

- 字符串的换行。Python 不是格式自由的语言，它对程序的换行、缩进都有严格的语法要求。要想换行书写一个比较长的字符串，必须在行尾添加反斜杠`\`

  ```
  s2 = 'It took me six months to write this Python tutorial. \
      Please give me more support. \
      I will keep it updated.'
  ```

  - 上面 s2 字符串的比较长，所以使用了转义字符`\`对字符串内容进行了换行，这样就可以把一个长字符串写成多行。

  - Python 也支持表达式的换行

    ```python
    num = 20 + 3 / 4 + \    2 * 3print(num)
    ```

- 长字符串。使用三个单引号或者双引号可以对多行内容进行注释，这其实是 Python 长字符串的写法。所谓长字符串，就是可以直接换行（不用加反斜杠`\`）书写的字符串。Python 长字符串由三个双引号`"""`或者三个单引号`'''`包围。在长字符串中放置单引号或者双引号不会导致解析错误。如果长字符串没有赋值给任何变量，那么这个长字符串就不会起到任何作用，和一段普通的文本无异，相当于被注释掉了。此时 Python 解释器并不会忽略长字符串，也会按照语法解析，只是长字符串起不到实际作用而已。当程序中有大段文本内容需要定义成字符串时，优先推荐使用长字符串形式，因为这种形式非常强大，可以在字符串中放置任何内容，包括单引号和双引号。长字符串中的换行、空格、缩进等空白符都会原样输出

  ```python
  longstr = '''    It took me 6 months to write this Python tutorial.    Please give me a to 'thumb' to keep it updated.    The Python tutorial is available at http://c.biancheng.net/python/.'''print(longstr)    It took me 6 months to write this Python tutorial.    Please give me a to 'thumb' to keep it updated.    The Python tutorial is available at http://c.biancheng.net/python/.  字符串内容前后多出了两个空行，并且每一行的前面会多出四个空格。
  ```

- 原始字符串。Python 字符串中的反斜杠`\`有着特殊的作用，就是转义字符。转义字符有时候会带来一些麻烦，例如我要表示一个包含 Windows 路径`D:\Program Files\Python 3.8\python.exe`这样的字符串，在 Python 程序中直接这样写肯定是不行的，不管是普通字符串还是长字符串。因为`\`的特殊性，我们需要对字符串中的每个`\`都进行转义，也就是写成`D:\\Program Files\\Python 3.8\\python.exe\`这种形式才行。这种写法需要特别谨慎，稍有疏忽就会出错。为了解决转义字符的问题，Python 支持原始字符串。在原始字符串中，`\`不会被当作转义字符，所有的内容都保持“原汁原味”的样子。

  - 在普通字符串或者长字符串的开头加上`r`前缀，就变成了原始字符串

    ```python
    str1 = r'原始字符串内容'
    str2 = r"""原始字符串内容"""
    rstr = r'D:\Program Files\Python 3.8\python.exe'
    print(rstr)
    ```
  
  - 如果普通格式的原始字符串中出现引号，程序同样需要对引号进行转义，否则 Python 照样无法对字符串的引号精确配对；但是和普通字符串不同的是，此时用于转义的反斜杠会变成字符串内容的一部分。
  
    ```python
    str1 = r'I\'m a great coder!'
    print(str1)
    I\'m a great coder!
    ```
  
    - 需要注意的是，Python 原始字符串中的反斜杠仍然会对引号进行转义，因此原始字符串的结尾处不能是反斜杠，否则字符串结尾处的引号会被转义，导致字符串不能正确结束。
  
  - 在 Python 中有两种方式解决原始字符串中\这个问题：一种方式是改用长字符串的写法，不要使用原始字符串；另一种方式是单独书写反斜杠
  
    - 例如想表示`D:\Program Files\Python 3.8\`，可以这样写：
  
      ```python
      str1 = r'D:\Program Files\Python 3.8' '\\'
      print(str1)
      我们先写了一个原始字符串r'D:\Program Files\Python 3.8'，紧接着又使用'\\'写了一个包含转义字符的普通字符串，Python 会自动将这两个字符串拼接在一起D:\Program Files\Python 3.8\
      ```

##### bytes

- bytes 类型用来表示一个字节串。“字节串“不是编程术语，是我自己“捏造”的一个词，用来和字符串相呼应。

- 字节串（bytes）和字符串（string）的对比：

  - 字符串由若干个字符组成，以字符为单位进行操作；字节串由若干个字节组成，以字节为单位进行操作。
  - 字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法都基本相同。
  - 字节串和字符串都是不可变序列，不能随意增加和删除数据。

- bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。说白了，bytes 只是简单地记录内存中的原始数据，至于如何使用这些数据，bytes 并不在意，你想怎么使用就怎么使用，bytes 并不约束你的行为。bytes 类型的数据非常适合在互联网上传输，可以用于网络通信编程；bytes 也可以用来存储图片、音频、视频等二进制格式的文件。

- 字符串和 bytes 存在着千丝万缕的联系，我们可以通过字符串来创建 bytes 对象，或者说将字符串转换成 bytes 对象。有以下三种方法可以达到这个目的：

  - 如果字符串的内容都是 ASCII 字符，那么直接在字符串前面添加`b`前缀就可以转换成 bytes。
  - bytes 是一个类，调用它的构造方法，也就是 bytes()，可以将字符串按照指定的字符集转换成 bytes；如果不指定字符集，那么默认采用 UTF-8。
  - 字符串本身有一个 encode() 方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8。

  ```python
  #通过构造函数创建空 bytesb1 = bytes()
  #通过空字符串创建空 bytesb2 = b''
  #通过b前缀将字符串转换成 bytesb3 = b'http://c.biancheng.net/python/'
  print("b3: ", b3)
  print(b3[3])
  print(b3[7:22])
  #为 bytes() 方法指定字符集
  b4 = bytes('C语言中文网8岁了', encoding='UTF-8')
  print("b4: ", b4)
  #通过 encode() 方法将字符串转换成 
  bytesb5 = "C语言中文网8岁了".encode('UTF-8')
  print("b5: ", b5)
  b3:  b'http://c.biancheng.net/python/'112b'c.biancheng.net'
  b4:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
  b5:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
  ```

  - 从运行结果可以发现，对于非 ASCII 字符，print 输出的是它的字符编码值（十六进制形式），而不是字符本身。非 ASCII 字符一般占用两个字节以上的内存，而 bytes 是按照单个字节来处理数据的，所以不能一次处理多个字节。

- bytes 类也有一个 decode() 方法，通过该方法可以将 bytes 对象转换为字符串

  ```
  #通过 decode() 方法将 bytes 转换成字符串str1 = b5.decode('UTF-8')print("str1: ", str1)str1:  C语言中文网8岁了
  ```

##### bool

- True 和 False 是 Python 中的关键字，当作为 Python 代码输入时，一定要注意字母的大小写，否则解释器会报错。

- 布尔类型可以当做整数来对待，即 True 相当于整数值 1，False 相当于整数值 0。

  ```
  >>> False+11>>> True+12
  ```

- 在 Python 中，所有的对象都可以进行真假值的测试，包括字符串、元组、列表、字典、对象等

##### input()函数

- input() 是 [Python](http://c.biancheng.net/python/) 的内置函数，用于从控制台读取用户输入的内容。input() 函数总是以字符串的形式来处理用户输入的内容，所以用户输入的内容可以包含任何字符。

  ```
  str = input(tipmsg)
  ```

  - str 表示一个字符串类型的变量，input 会将读取到的字符串放入 str 中。
  - tipmsg 表示提示信息，它会显示在控制台上，告诉用户应该输入什么样的内容；如果不写 tipmsg，就不会有任何提示信息。

- 我们可以使用 Python 内置函数将字符串转换成想要的类型，比如：

  - int(string) 将字符串转换成 int 类型；
  - float(string) 将字符串转换成 float 类型；
  - bool(string) 将字符串转换成 bool 类型。

##### print

- print() 函数完全可以同时输出多个变量

- print() 函数的详细语法格式如下：

  ```
  print (value,...,sep='',end='\n',file=sys.stdout,flush=False)
  ```

  - value 参数可以接受任意多个变量或值，因此 print() 函数完全可以输出多个值

    ```
    user_name ＝ 'Charlie'    user_age = 8
    #同时输出多个变量和字符串print("读者名：",user_name,"年龄：",user_age)读者名： Charlie 年龄： 8
    ```

  - 从输出结果来看，使用 print() 函数输出多个变量时，print() 函数默认以空格隔开多个变量，如果读者希望改变默认的分隔符，可通过 sep 参数进行设置。例如输出语句：

    ```
    #同时输出多个变量和字符串，指定分隔符print("读者名：" ,user_name,"年龄：",user_age,sep='|')读者名：|Charlie|年龄：|8
    ```

  - 在默认情况下，print() 函数输出之后总会换行，这是因为 print() 函数的 end 参数的默认值是“\n”，这个“\n”就代表了换行。如果希望 print() 函数输出之后不会换行，则重设 end 参数即可

    ```python
    #设置end 参数，指定输出之后不再换行print(40,'\t',end＝"")print(5O,'\t',end＝"")print(60,'\t',end＝"")40    50    60
    ```

  - file 参数指定 print() 函数的输出目标，file 参数的默认值为 sys.stdout，该默认值代表了系统标准输出，也就是屏幕，因此 print() 函数默认输出到屏幕。实际上，完全可以通过改变该参数让 print() 函数输出到特定文件中

    ```python
    f = open("demo.txt","w")
    #打开文件以便写入
    print('沧海月明珠有泪',file=f)print('蓝回日暖玉生烟',file=f)f.close()
    ```

  - print() 函数的 flush 参数用于控制输出缓存，该参数一般保持为 False 即可，这样可以获得较好的性能。

- print() 函数使用以`%`开头的转换说明符对各种类型的数据进行格式化输出

  | 转换说明符 | 解释                                   |
  | ---------- | -------------------------------------- |
  | %d、%i     | 转换为带符号的十进制整数               |
  | %o         | 转换为带符号的八进制整数               |
  | %x、%X     | 转换为带符号的十六进制整数             |
  | %e         | 转化为科学计数法表示的浮点数（e 小写） |
  | %E         | 转化为科学计数法表示的浮点数（E 大写） |
  | %f、%F     | 转化为十进制浮点数                     |
  | %g         | 智能选择使用 %f 或 %e 格式             |
  | %G         | 智能选择使用 %F 或 %E 格式             |
  | %c         | 格式化字符及其 ASCII 码                |
  | %r         | 使用 repr() 函数将表达式转换为字符串   |
  | %s         | 使用 str() 函数将表达式转换为字符串    |

  ```python
  age = 8
  print("C语言中文网已经%d岁了！" % age)
  输出结果  C语言中文网已经8岁了！
  在 print() 函数中，由引号包围的是格式化字符串，它相当于一个字符串模板，可以放置一些转换说明符（占位符）。本例的格式化字符串中包含一个%d说明符，它最终会被后面的 age 变量的值所替代。中间的%是一个分隔符，它前面是格式化字符串，后面是要输出的表达式。格式化字符串中也可以包含多个转换说明符，这个时候也得提供多个表达式，用以替换对应的转换说明符；多个表达式必须使用小括号( )包围起来。
  name = "C语言中文网"
  age = 8
  url = "http://c.biancheng.net/"
  print("%s已经%d岁了，它的网址是%s。" % (name, age, url))C语言中文网已经8岁了，它的网址是http://c.biancheng.net/。如果没有中间的%分割就会出错，另外如果没有% ，两个中间有逗号分隔输出结果为  C语言中文网已经%d岁了！ 8
  ```

- 指定最小输出宽度

  - %10d 表示输出的整数宽度至少为 10；

  - %20s 表示输出的字符串宽度至少为 20。

    ```python
    n = 1234567
    print("n(10):%10d." % n)
    print("n(5):%5d." % n)
    url = "http://c.biancheng.net/python/"
    print("url(35):%35s." % url)
    print("url(20):%20s." % url)
    
    n(10):   1234567.
    n(5):1234567.
    url(35):     http://c.biancheng.net/python/.
    url(20):http://c.biancheng.net/python/.
    ```

  - 从运行结果可以发现，对于整数和字符串，当数据的实际宽度小于指定宽度时，会在左侧以空格补齐；当数据的实际宽度大于指定宽度时，会按照数据的实际宽度输出。

- 指定对齐方式

  - 默认情况下，print() 输出的数据总是右对齐的。也就是说，当数据不够宽时，数据总是靠右边输出，而在左边补充空格以达到指定的宽度。Python 允许在最小宽度之前增加一个标志来改变对齐方式

    | 标志 | 说明                                               |
    | ---- | -------------------------------------------------- |
    | -    | 指定左对齐                                         |
    | +    | 表示输出的数字总要带着符号；正数带`+`，负数带`-`。 |
    | 0    | 表示宽度不足时补充 0，而不是补充空格。             |

    - 对于整数，指定左对齐时，在右边补 0 是没有效果的，因为这样会改变整数的值。
    - 对于小数，以上三个标志可以同时存在。
    - 对于字符串，只能使用`-`标志，因为符号对于字符串没有意义，而补 0 会改变字符串的值。

    ```python
    n = 123456
    # %09d 表示最小宽度为9，左边补0
    print("n(09):%09d" % n)
    # %+9d 表示最小宽度为9，带上符号
    print("n(+9):%+9d" % n)
    f = 140.5
    # %-+010f 表示最小宽度为10，左对齐，带上符号
    print("f(-+0):%-+010f" % f)
    s = "Hello"
    # %-10s 表示最小宽度为10，左对齐
    print("s(-10):%-10s." % s)
    
    n(09):000123456
    n(+9):  +123456
    f(-+0):+140.500000
    s(-10):Hello     .
    ```

- 指定小数精度

  - 对于小数（浮点数），print() 还允许指定小数点后的数字位数，也即指定小数的输出精度。

  - 精度值需要放在最小宽度之后，中间用点号`.`隔开；也可以不写最小宽度，只写精度。具体格式如下：

    ```python
    %m.nf%.nfm 表示最小宽度，n 表示输出精度，.是必须存在的。f = 3.141592653
    # 最小宽度为8，小数点后保留3位print("%8.3f" % f)
    # 最小宽度为8，小数点后保留3位，左边补0print("%08.3f" % f)
    # 最小宽度为8，小数点后保留3位，左边补0，带符号print("%+08.3f" % f)   3.1420003.142+003.142
    ```


##### 转义字符

- 转义字符，就是那些以反斜杠`\`开头的字符。

- ASCII 编码为每个字符都分配了唯一的编号，称为编码值。在 [Python](http://c.biancheng.net/python/) 中，一个 ASCII 字符除了可以用它的实体（也就是真正的字符）表示，还可以用它的编码值表示。这种使用编码值来间接地表示字符的方式称为转义字符（Escape Character）。

- 转义字符以`\0`或者`\x`开头，以`\0`开头表示后跟八进制形式的编码值，以`\x`开头表示后跟十六进制形式的编码值，Python 中的转义字符只能使用八进制或者十六进制。

  ```
  \0dd\xhh
  ```

  - dd 表示八进制数字，hh 表示十六进制数字。

- ASCII 编码共收录了 128 个字符，`\0`和`\x`后面最多只能跟两位数字，所以八进制形式`\0`并不能表示所有的 ASCII 字符，只有十六进制形式`\x`才能表示所有 ASCII 字符。

- 字符 1、2、3、x、y、z 对应的 ASCII 码的八进制形式分别是 61、62、63、170、171、172，十六进制形式分别是 31、32、33、78、79、7A。下面的例子演示了转义字符的用法：使用八进制形式的转义字符没法表示 xyz，因为它们的编码值转换成八进制以后有三位。

  ```python
  str1 = "Oct: \061\062\063"
  str2 = "Hex: \x31\x32\x33\x78\x79\x7A"
  print(str1)
  print(str2)
  Oct: 123
  Hex: 123xyz
  ```

- 对于 ASCII 编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能用转义字符的形式来表示。不过，直接使用 ASCII 码记忆不方便，也不容易理解，所以，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下。

  | 转义字符 | 说明                                                         |
  | -------- | ------------------------------------------------------------ |
  | \n       | 换行符，将光标位置移到下一行开头。                           |
  | \r       | 回车符，将光标位置移到本行开头。                             |
  | \t       | 水平制表符，也即 Tab 键，一般相当于四个空格。                |
  | \a       | 蜂鸣器响铃。注意不是喇叭发声，现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效。 |
  | \b       | 退格（Backspace），将光标位置移到前一列。                    |
  | \\\      | 反斜线                                                       |
  | \\'      | 单引号                                                       |
  | \\"      | 双引号                                                       |
  | \\       | 在字符串行尾的续行符，即一行未完，转到下一行继续写。         |

```python
#使用\t排版str1 = '网站\t\t域名\t\t\t年龄\t\t价值'str2 = 'C语言中文网\tc.biancheng.net\t\t8\t\t500W'str3 = '百度\t\twww.baidu.com\t\t20\t\t500000W'print(str1)print(str2)print(str3)print("--------------------")# \n在输出时换行，\在书写字符串时换行info = "Python教程：http://c.biancheng.net/python/\n\C++教程：http://c.biancheng.net/cplus/\n\Linux教程：http://c.biancheng.net/linux_tutorial/"print(info)网站        域名                年龄    价值C语言中文网 c.biancheng.net     8       500W百度        www.baidu.com       20      500000W--------------------Python教程：http://c.biancheng.net/python/C++教程：http://c.biancheng.net/cplus/Linux教程：http://c.biancheng.net/linux_tutorial/
```

##### 数据类型转换

- 虽然 [Python](http://c.biancheng.net/python/) 是弱类型编程语言，不需要像 [Java](http://c.biancheng.net/java/) 或 C 语言那样还要在使用变量前声明变量的类型，但在一些特定场景中，仍然需要用到类型转换。

  | 函 数                  | 作 用                                              |
  | ---------------------- | -------------------------------------------------- |
  | int(x)                 | 将 x 转换成整数类型                                |
  | float(x)               | 将 x 转换成浮点数类型                              |
  | complex(real，[,imag]) | 创建一个复数                                       |
  | str(x)                 | 将 x 转换为字符串                                  |
  | repr(x)                | 将 x 转换为表达式字符串                            |
  | eval(str)              | 计算在字符串中的有效 Python 表达式，并返回一个对象 |
  | chr(x)                 | 将整数 x 转换为一个字符                            |
  | ord(x)                 | 将一个字符 x 转换为它对应的整数值                  |
  | hex(x)                 | 将一个整数 x 转换为一个十六进制字符串              |
  | oct(x)                 | 将一个整数 x 转换为一个八进制的字符串              |

- 需要注意的是，在使用类型转换函数时，提供给它的数据必须是有意义的。例如，int() 函数无法将一个非数字字符串转换成整数

  ```python
  >>> int("123") 
  #转换成功123
  >>> int("123个") 
  #转换失败Traceback (most recent call last):  File "<pyshell#3>", line 1, in <module>    int("123个")ValueError: invalid literal for int() with base 10: '123个'
  ```

##### 运算符

###### 算数运算符

| 运算符 | 说明                                | 实例        | 结果      |
| ------ | ----------------------------------- | ----------- | --------- |
| +      | 加                                  | 12.45 + 15  | 27.45     |
| -      | 减                                  | 4.56 - 0.26 | 4.3       |
| *      | 乘                                  | 5 * 3.6     | 18.0      |
| /      | 除法（和数学中的规则一样）          | 7 / 2       | 3.5       |
| //     | 整除（只保留商的整数部分）          | 7 // 2      | 3         |
| %      | 取余，即返回除法的余数              | 7 % 2       | 1         |
| **     | 幂运算/次方运算，即返回 x 的 y 次方 | 2 ** 4      | 16，即 24 |

- 当`+`用于数字时表示加法，但是当`+`用于字符串时，它还有拼接字符串（将两个字符串连接为一个）的作用

  ```python
  name = "C语言中文网"    url = "http://c.biancheng.net/"    age = 8
  info = name + "的网址是" + url + "，它已经" + str(age) + "岁了。"
  print(info)
  ```

  - str() 函数用来将整数类型的 age 转换成字符串。

- `*`除了可以用作乘法运算，还可以用来重复字符串，也即将 n 个同样的字符串连接起来

  ```python
  str1 = "hello "
  print(str1 * 4)
  hello hello hello hello 
  ```

- Python 支持`/`和`//`两个除法运算符，但它们之间是有区别的：

  - `/`表示普通除法，使用它计算出来的结果和数学中的计算结果相同。
  - `//`表示整除，只保留结果的整数部分，舍弃小数部分；注意是直接丢掉小数部分，而不是四舍五入。
  - `/`的计算结果总是小数，不管是否能除尽，也不管参与运算的是整数还是小数。
  - 当有小数参与运算时，`//`结果才是小数，否则就是整数。
  - 除数始终不能为 0，除以 0 是没有意义的，这将导致 ZeroDivisionError 错误

- Python ** 运算符用来求一个 x 的 y 次方，也即次方（乘方）运算符。由于开方是次方的逆运算，所以也可以使用 ** 运算符间接地实现开方运算。

  ```
  print('----次方运算----')
  print('3**4 =', 3**4)
  print('2**5 =', 2**5)print('----开方运算----')
  print('81**(1/4) =', 81**(1/4))
  print('32**(1/5) =', 32**(1/5))
  ```

###### 赋值运算符

- 连续赋值，Python 中的赋值表达式也是有值的，它的值就是被赋的那个值，或者说是左侧变量的值；如果将赋值表达式的值再赋值给另外一个变量，这就构成了连续赋值。

  ```
  a = b = c = 100
  ```

  - `=`具有右结合性，我们从右到左分析这个表达式：
    - c = 100 表示将 100 赋值给 c，所以 c 的值是 100；同时，c = 100 这个子表达式的值也是 100。
    - b = c = 100 表示将 c = 100 的值赋给 b，因此 b 的值也是 100。
    - 以此类推，a 的值也是 100。

  | 运算符 | 说 明            | 用法举例 | 等价形式                              |
  | ------ | ---------------- | -------- | ------------------------------------- |
  | =      | 最基本的赋值运算 | x = y    | x = y                                 |
  | +=     | 加赋值           | x += y   | x = x + y                             |
  | -=     | 减赋值           | x -= y   | x = x - y                             |
  | *=     | 乘赋值           | x *= y   | x = x * y                             |
  | /=     | 除赋值           | x /= y   | x = x / y                             |
  | %=     | 取余数赋值       | x %= y   | x = x % y                             |
  | **=    | 幂赋值           | x **= y  | x = x ** y                            |
  | //=    | 取整数赋值       | x //= y  | x = x // y                            |
  | &=     | 按位与赋值       | x &= y   | x = x & y                             |
  | \|=    | 按位或赋值       | x \|= y  | x = x \| y                            |
  | ^=     | 按位异或赋值     | x ^= y   | x = x ^ y                             |
  | <<=    | 左移赋值         | x <<= y  | x = x << y，这里的 y 指的是左移的位数 |
  | >>=    | 右移赋值         | x >>= y  | x = x >> y，这里的 y 指的是右移的位数 |

###### 位运算符

- [Python](http://c.biancheng.net/python/) 位运算按照数据在内存中的二进制位（Bit）进行操作，它一般用于底层开发（算法设计、驱动、图像处理、单片机等），在应用层开发（Web 开发、Linux 运维等）中并不常见。

  | 位运算符 | 说明     | 使用形式 | 举 例                            |
  | -------- | -------- | -------- | -------------------------------- |
  | &        | 按位与   | a & b    | 4 & 5                            |
  | \|       | 按位或   | a \| b   | 4 \| 5                           |
  | ^        | 按位异或 | a ^ b    | 4 ^ 5                            |
  | ~        | 按位取反 | ~a       | ~4                               |
  | <<       | 按位左移 | a << b   | 4 << 2，表示整数 4 按位左移 2 位 |
  | >>       | 按位右移 | a >> b   | 4 >> 2，表示整数 4 按位右移 2 位 |

- Python 左移运算符`<<`用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补 0。

- Python 右移运算符`>>`用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。

###### 比较运算符

| 比较运算符 | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| >          | 大于，如果`>`前面的值大于后面的值，则返回 True，否则返回 False。 |
| <          | 小于，如果`<`前面的值小于后面的值，则返回 True，否则返回 False。 |
| ==         | 等于，如果`==`两边的值相等，则返回 True，否则返回 False。    |
| >=         | 大于等于（等价于数学中的 ≥），如果`>=`前面的值大于或者等于后面的值，则返回 True，否则返回 False。 |
| <=         | 小于等于（等价于数学中的 ≤），如果`<=`前面的值小于或者等于后面的值，则返回 True，否则返回 False。 |
| !=         | 不等于（等价于数学中的 ≠），如果`!=`两边的值不相等，则返回 True，否则返回 False。 |
| is         | 判断两个变量所引用的对象是否相同，如果相同则返回 True，否则返回 False。 |
| is not     | 判断两个变量所引用的对象是否不相同，如果不相同则返回 True，否则返回 False。 |

- 初学 Python，大家可能对 is 比较陌生，很多人会误将它和 == 的功能混为一谈，但其实 is 与 == 有本质上的区别，完全不是一码事儿。== 用来比较两个变量的值是否相等，而 is 则用来比对两个变量引用的是否是同一个对象

  ```
  import time  
  #引入time模块
  t1 = time.gmtime() 
  # gmtime()
  用来获取当前时间t2 =  time.gmtime()
  print(t1 == t2) #输出True
  print(t1 is t2) #输出False
  True
  False
  ```
  
  - time 模块的 gmtime() 方法用来获取当前的系统时间，精确到秒级，因为程序运行非常快，所以 t1 和 t1 得到的时间是一样的。== 用来判断 t1 和 t2 的值是否相等，所以返回 True。
  - 虽然 t1 和 t2 的值相等，但它们是两个不同的对象（每次调用 gmtime() 都返回不同的对象），所以`t1 is t2`返回 False。这就好像两个双胞胎姐妹，虽然她们的外貌是一样的，但它们是两个人。
  - 那么，如何判断两个对象是否相同呢？答案是判断两个对象的内存地址。如果内存地址相同，说明两个对象使用的是同一块内存，当然就是同一个对象了；这就像两个名字使用了同一个身体，当然就是同一个人了。

###### 逻辑运算符

| 逻辑运算符 | 含义                           | 基本格式 | 说明                                                         |
| ---------- | ------------------------------ | -------- | ------------------------------------------------------------ |
| and        | 逻辑与运算，等价于数学中的“且” | a and b  | 当 a 和 b 两个表达式都为真时，a and b 的结果才为真，否则为假。 |
| or         | 逻辑或运算，等价于数学中的“或” | a or b   | 当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。 |
| not        | 逻辑非运算，等价于数学中的“非” | not a    | 如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。 |

- 有些不负责任的 Python 教程说：Python 逻辑运算符用于操作 bool 类型的表达式，执行结果也是 bool 类型，这两点其实都是错误的！Python 逻辑运算符可以用来操作任何类型的表达式，不管表达式是不是 bool 类型；同时，逻辑运算的结果也不一定是 bool 类型，它也可以是任意类型。

  ```python
  print(100 and 200)
  print(45 and 0)
  print("" or "http://c.biancheng.net/python/")
  print(18.5 or "http://c.biancheng.net/python/")
  2000
  http://c.biancheng.net/python/
  18.5
  ```

  - 在 Python 中，and 和 or 不一定会计算右边表达式的值，有时候只计算左边表达式的值就能得到最终结果。
  - 另外，and 和 or 运算符会将其中一个表达式的值作为最终结果，而不是将 True 或者 False 作为最终结果。

- 对于 and 运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 Python 按照下面的规则执行 and 运算：

  - 如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时 and 会把左边表达式的值作为最终结果。
  - 如果左边表达式的值为真，那么最终值是不能确定的，and 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

- 对于 or 运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以 Python 按照下面的规则执行 or 运算：

  - 如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时 or 会把左边表达式的值作为最终结果。
  - 如果左边表达式的值为假，那么最终值是不能确定的，or 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

###### 三目运算符

- 假设现在有两个数字，我们希望获得其中较大的一个，那么可以使用 if else 语句

  ```
  if a>b:    
  	max = a;
  else:    
  	max = b;
  但是 Python 提供了一种更加简洁的写法max = a if a>b else b
  ```

  - 这是一种类似于其它编程语言中三目运算符`? :`的写法。Python 是一种极简主义的编程语言，它没有引入`? :`这个新的运算符，而是使用已有的 if else 关键字来实现相同的功能。

- 使用 if else 实现三目运算符（条件运算符）的格式如下：

  ```
  exp1 if contion else exp2
  ```

  - condition 是判断条件，exp1 和 exp2 是两个表达式。如果 condition 成立（结果为真），就执行 exp1，并把 exp1 的结果作为整个表达式的结果；如果 condition 不成立（结果为假），就执行 exp2，并把 exp2 的结果作为整个表达式的结果。

- 前面的语句`max = a if a>b else b`的含义是：

  - 如果 a>b 成立，就把 a 作为整个表达式的值，并赋给变量 max；
  - 如果 a> b 不成立，就把 b 作为整个表达式的值，并赋给变量 max。

- Python 三目运算符支持嵌套，如此可以构成更加复杂的表达式。在嵌套时需要注意 if 和 else 的配对

  ```
  a if a>b else c if c>d else d应该理解为：a if a>b else ( c if c>d else d )
  ```

###### 运算符优先级和结合性

| 运算符说明 | Python运算符            | 优先级 | 结合性 | 优先级顺序 |
| ---------- | ----------------------- | ------ | ------ | ---------- |
| 小括号     | ( )                     | 19     | 无     | 最高       |
| 索引运算符 | x[i] 或 x[i1: i2 [:i3]] | 18     | 左     |            |
| 属性访问   | x.attribute             | 17     | 左     |            |
| 乘方       | **                      | 16     | 右     |            |
| 按位取反   | ~                       | 15     | 右     |            |
| 符号运算符 | +（正号）、-（负号）    | 14     | 右     |            |
| 乘除       | *、/、//、%             | 13     | 左     |            |
| 加减       | +、-                    | 12     | 左     |            |
| 位移       | >>、<<                  | 11     | 左     |            |
| 按位与     | &                       | 10     | 右     |            |
| 按位异或   | ^                       | 9      | 左     |            |
| 按位或     | \|                      | 8      | 左     |            |
| 比较运算符 | ==、!=、>、>=、<、<=    | 7      | 左     |            |
| is 运算符  | is、is not              | 6      | 左     |            |
| in 运算符  | in、not in              | 5      | 左     |            |
| 逻辑非     | not                     | 4      | 右     |            |
| 逻辑与     | and                     | 3      | 左     |            |
| 逻辑或     | or                      | 2      | 左     |            |
| 逗号运算符 | exp1, exp2              | 1      | 左     | 最低       |

- 所谓结合性，就是当一个表达式中出现多个优先级相同的运算符时，先执行哪个运算符：先执行左边的叫左结合性，先执行右边的叫右结合性。
- 例如对于表达式对于`100 / 25 * 16`，`/`和`*`的优先级相同，应该先执行哪一个呢？这个时候就不能只依赖运算符优先级决定了，还要参考运算符的结合性。`/`和`*`都具有左结合性，因此先执行左边的除法，再执行右边的乘法，最终结果是 64。
- Python 中大部分运算符都具有左结合性，也就是从左到右执行；只有 ** 乘方运算符、单目运算符（例如 not 逻辑非运算符）、赋值运算符和三目运算符例外，它们具有右结合性，也就是从右向左执行
- 当一个表达式中出现多个运算符时，Python 会先比较各个运算符的优先级，按照优先级从高到低的顺序依次执行；当遇到优先级相同的运算符时，再根据结合性决定先执行哪个运算符：如果是左结合性就先执行左边的运算符，如果是右结合性就先执行右边的运算符。

#### 列表、元组、字典、集合

- Python 序列（Sequence）是指按特定顺序依次排列的一组数据，它们可以占用一块连续的内存，也可以分散到多块内存中。Python 中的序列类型包括列表（list）、元组（tuple）、字典（dict）和集合（set）。
- 在 Python 编程中，我们既需要独立的变量来保存一份数据，也需要序列来保存大量数据。
- 列表（list）和元组（tuple）比较相似，它们都按顺序保存元素，所有的元素占用一块连续的内存，每个元素都有自己的索引，因此列表和元组的元素都可以通过索引（index）来访问。它们的区别在于：列表是可以修改的，而元组是不可修改的。
- 字典（dict）和集合（set）存储的数据都是无序的，每份元素占用不同的内存，其中字典元素以 `key-value` 的形式保存。

##### 序列

- 所谓序列，指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可通过每个值所在位置的编号（称为索引）访问它们。
- 在 [Python](http://c.biancheng.net/python/) 中，序列类型包括字符串、列表、元组、集合和字典，这些序列支持以下几种通用的操作，但比较特殊的是，集合和字典不支持索引、切片、相加和相乘操作。
- 字符串也是一种常见的序列，它也可以直接通过索引访问字符串内的字符。

###### 序列索引

- 序列中，每个元素都有属于自己的编号（索引）。从起始元素开始，索引值从 0 开始递增
- Python 还支持索引值是负数，此类索引是从右向左计数，换句话说，从最后一个元素开始计数，从索引值 -1 开始。在使用负值作为列序中各元素的索引值时，是从 -1 开始，而不是从 0 开始。

###### 序列切片

- 切片操作是访问序列中元素的另一种方法，它可以访问一定范围内的元素，通过切片操作，可以生成一个新的序列。

- 序列实现切片操作的语法格式如下：

  ```
  sname[start : end : step]
  ```

  - sname：表示序列的名称；

  - start：表示切片的开始索引位置（包括该位置），此参数也可以不指定，会默认为 0，也就是从序列的开头进行切片；

  - end：表示切片的结束索引位置（不包括该位置），如果不指定，则默认为序列的长度；

  - step：表示在切片过程中，隔几个存储位置（包含当前位置）取一次元素，也就是说，如果 step 的值大于 1，则在进行切片去序列元素时，会“跳跃式”的取元素。如果省略设置 step 的值，则最后一个冒号就可以省略。

    ```python
    str="C语言中文网"
    #取索引区间为[0,2]之间（不包括索引2处的字符）的字符串
    print(str[:2])
    #隔 1 个字符取一个字符，区间是整个字符串print(str[::2])
    #取整个字符串，此时 [] 中只需一个冒号即可print(str[:])
    ```

###### 序列相加

- Python 中，支持两种类型相同的序列使用“+”运算符做相加操作，它会将两个序列进行连接，但不会去除重复的元素。这里所说的“类型相同”，指的是“+”运算符的两侧序列要么都是列表类型，要么都是元组类型，要么都是字符串。

###### 序列相乘

- Python 中，使用数字 n 乘以一个序列会生成新的序列，其内容为原来序列被重复 n 次的结果

- 比较特殊的是，列表类型在进行乘法运算时，还可以实现初始化指定长度列表的功能。例如如下的代码，将创建一个长度为 5 的列表，列表中的每个元素都是 None，表示什么都没有。

  ```
  #列表的创建用 []，后续讲解列表时会详细介绍
  list = [None]*5
  print(list)
  [None, None, None, None, None]
  ```

###### 检查元素是否包含在序列中

- Python 中，可以使用 in 关键字检查某元素是否为序列的成员

  ```
  value in sequence
  ```

  - value 表示要检查的元素，sequence 表示指定的序列。

  - 例如，检查字符‘c’是否包含在字符串“c.biancheng.net”中

    ```
    str="c.biancheng.net"
    print('c'in str)
    True
    ```

- 和 in 关键字用法相同，但功能恰好相反的，还有 not in 关键字，它用来检查某个元素是否不包含在指定的序列中

###### 内置函数

| 函数        | 功能                                                         |
| ----------- | ------------------------------------------------------------ |
| len()       | 计算序列的长度，即返回序列中包含多少个元素。                 |
| max()       | 找出序列中的最大元素。注意，对序列使用 sum() 函数时，做加和操作的必须都是数字，不能是字符或字符串，否则该函数将抛出异常，因为解释器无法判定是要做连接操作（+ 运算符可以连接两个序列），还是做加和操作。 |
| min()       | 找出序列中的最小元素。                                       |
| list()      | 将序列转换为列表。                                           |
| str()       | 将序列转换为字符串。                                         |
| sum()       | 计算元素和。                                                 |
| sorted()    | 对元素进行排序。                                             |
| reversed()  | 反向序列中的元素。                                           |
| enumerate() | 将序列组合为一个索引序列，多用在 for 循环中。                |

##### 列表

- [Python](http://c.biancheng.net/python/) 中没有数组，但是加入了更加强大的列表。如果把数组看做是一个集装箱，那么 Python 的列表就是一个工厂的仓库。

- 从形式上看，列表会将所有元素都放在一对中括号`[ ]`里面，相邻元素之间用逗号`,`分隔

- 从内容上看，列表可以存储整数、小数、字符串、列表、元组等任何类型的数据，并且同一个列表中元素的类型也可以不同

  ```
  ["http://c.biancheng.net/python/", 1, [2,3,4] , 3.0]
  ```

  - 列表中同时包含字符串、整数、列表、浮点数这些数据类型。

- 在使用列表时，虽然可以将不同类型的数据放入到同一个列表中，但通常情况下不这么做，同一列表中只放入同一类型的数据，这样可以提高程序的可读性。

- 在其它 Python 教程中，经常用 list 代指列表，这是因为列表的数据类型就是 list，通过 type() 函数就可以知道

###### 创建列表

- 使用[]直接创建列表

- 使用list()函数创建列表，内置的函数 list()，使用它可以将其它数据类型转换为列表类型

  ```python
  #将字符串转换成列表list1 = list("hello")
  print(list1)
  #将元组转换成列表
  tuple1 = ('Python', 'Java', 'C++', 'JavaScript')
  list2 = list(tuple1)
  print(list2)
  #将字典转换成列表
  dict1 = {'a':100, 'b':42, 'c':9}
  list3 = list(dict1)
  print(list3)
  #将区间转换成列表
  range1 = range(1, 6)
  list4 = list(range1)
  print(list4)
  #创建空列表
  print(list())
  ['h', 'e', 'l', 'l', 'o']
  ['Python', 'Java', 'C++', 'JavaScript']
  ['a', 'b', 'c']
  [1, 2, 3, 4, 5]
  []
  ```

- 访问列表元素使用索引或者切片

- 删除列表，对于已经创建的列表，如果不再使用，可以使用`del`关键字将其删除。实际开发中并不经常使用 del 来删除列表，因为 Python 自带的垃圾回收机制会自动销毁无用的列表，即使开发者不手动删除，Python 也会自动将其回收。

###### 列表添加元素

- 使用`+`运算符可以将多个序列连接起来；列表是序列的一种，所以也可以使用`+`进行连接，这样就相当于在第一个列表的末尾添加了另一个列表。`+`更多的是用来拼接列表，而且执行效率并不高

- append() 方法用于在列表的末尾追加元素

  ```
  listname.append(obj)
  ```

  - obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等

    ```python
    l = ['Python', 'C++', 'Java']
    #追加元素
    l.append('PHP')
    print(l)
    #追加元组，整个元组被当成一个元素
    t = ('JavaScript', 'C#', 'Go')
    l.append(t)print(l)
    #追加列表，整个列表也被当成一个元素
    l.append(['Ruby', 'SQL'])
    print(l)
    ['Python', 'C++', 'Java', 'PHP']
    ['Python', 'C++', 'Java', 'PHP', ('JavaScript', 'C#', 'Go')]
    ['Python', 'C++', 'Java', 'PHP', ('JavaScript', 'C#', 'Go'), ['Ruby', 'SQL']]
    ```

  - 当给 append() 方法传递列表或者元组时，此方法会将它们视为一个整体，作为一个元素添加到列表中，从而形成包含列表和元组的新列表

- extend()方法添加元素。extend() 和 append() 的不同之处在于：extend() 不会把列表或者元祖视为一个整体，而是把它们包含的元素逐个添加到列表中。

  ```
  listname.extend(obj)
  ```

  - obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等，但不能是单个的数字

- insert()方法插入元素。append() 和 extend() 方法只能在列表末尾插入元素，如果希望在列表中间某个位置插入元素，那么可以使用 insert() 方法。

  ```
  listname.insert(index , obj)
  ```

  - index 表示指定位置的索引值。insert() 会将 obj 插入到 listname 列表第 index 个元素的位置。
  - 当插入列表或者元祖时，insert() 也会将它们视为一个整体，作为一个元素插入到列表中，这一点和 append() 是一样的。

###### 删除元素

- 在 [Python](http://c.biancheng.net/python/) 列表中删除元素主要分为以下 3 种场景：

  - 根据目标元素所在位置的索引进行删除，可以使用 del 关键字或者 pop() 方法；
  - 根据元素本身的值进行删除，可使用列表（list类型）提供的 remove() 方法；
  - 将列表中所有元素全部删除，可使用列表（list类型）提供的 clear() 方法。

- del根据索引值删除元素

  - del 是 Python 中的关键字，专门用来执行删除操作，它不仅可以删除整个列表，还可以删除列表中的某些元素

  - del 可以删除列表中的单个元素

    ```
    del listname[index]
    ```

  - del 也可以删除中间一段连续的元素

    ```
    del listname[start : end]del 会删除从索引 start 到 end 之间的元素，不包括 end 位置的元素。
    ```

- pop()根据索引值删除元素

  - pop() 方法用来删除列表中指定索引处的元素

    ```
    listname.pop(index)
    ```

    - index 表示索引值。如果不写 index 参数，默认会删除列表中的最后一个元素，类似于[数据结构](http://c.biancheng.net/data_structure/)中的“出栈”操作。

  - 大部分编程语言都会提供和 pop() 相对应的方法，就是 push()，该方法用来将元素添加到列表的尾部，类似于数据结构中的“入栈”操作。但是 Python 是个例外，Python 并没有提供 push() 方法，因为完全可以使用 append() 来代替 push() 的功能。

- remove()根据元素值进行删除

  - 除了 del 关键字，Python 还提供了 remove() 方法，该方法会根据元素本身的值来进行删除操作。
  - remove() 方法只会删除第一个和指定值相同的元素，而且必须保证该元素是存在的，否则会引发 ValueError 错误。所以我们在使用 remove() 删除元素时最好提前判断一下。

- clear()删除列表所有元素

###### 修改元素

- 提供了两种修改列表（list）元素的方法，你可以每次修改单个元素，也可以每次修改一组元素（多个）。

- 修改单个元素非常简单，直接对元素赋值即可

  ```python
  nums = [40, 36, 89, 2, 36, 100, 7]
  nums[2] = -26  
  #使用正数索引
  nums[-3] = -66.2  
  #使用负数索引
  print(nums)
  [40, 36, -26, 2, -66.2, 100, 7]
  ```

  - 使用索引得到列表元素后，通过`=`赋值就改变了元素的值。

- Python 支持通过切片语法给一组元素赋值。在进行这种操作时，如果不指定步长（step 参数），Python 就不要求新赋值的元素个数与原来的元素个数相同；这意味，该操作既可以为列表添加元素，也可以为列表删除元素。

  ```python
  修改一组元素的值
  nums = [40, 36, 89, 2, 36, 100, 7]
  #修改第 1~4 个元素的值（不包括第4个元素）
  nums[1: 4] = [45.25, -77, -52.5]
  print(nums)
  [40, 45.25, -77, -52.5, 36, 100, 7]
  如果对空切片（slice）赋值，就相当于插入一组新的元素：
  nums = [40, 36, 89, 2, 36, 100, 7]
  #在4个位置插入元素
  nums[4: 4] = [-77, -52.5, 999]
  print(nums)
  [40, 36, 89, 2, -77, -52.5, 999, 36, 100, 7]
  使用切片语法赋值时，Python 不支持单个值，例如下面的写法就是错误的：
  nums[4: 4] = -77
  但是如果使用字符串赋值，Python 会自动把字符串转换成序列，其中的每个字符都是一个元素
  s = list("Hello")
  s[2:4] = "XYZ"
  print(s)
  ['H', 'e', 'X', 'Y', 'Z', 'o']
  ```

- 使用切片语法时也可以指定步长（step 参数），但这个时候就要求所赋值的新元素的个数与原有元素的个数相同

  ```python
  nums = [40, 36, 89, 2, 36, 100, 7]
  #步长为2，为第1、3、5个元素赋值
  nums[1: 6: 2] = [0.025, -99, 20.5]
  print(nums)
  [40, 0.025, 89, -99, 36, 20.5, 7]
  ```

###### 查找元素

- 提供了 index() 和 count() 方法，它们都可以用来查找元素。

- index() 方法用来查找某个元素在列表中出现的位置（也就是索引），如果该元素不存在，则会导致 ValueError 错误，所以在查找之前最好使用 count() 方法判断一下。

  ```
  listname.index(obj, start, end)
  ```

  - start 和 end 参数用来指定检索范围：
    - start 和 end 可以都不写，此时会检索整个列表；
    - 如果只写 start 不写 end，那么表示检索从 start 到末尾的元素；
    - 如果 start 和 end 都写，那么表示检索 start 和 end 之间的元素。
  - index() 方法会返回元素所在列表中的索引值。

- count() 方法用来统计某个元素在列表中出现的次数

  ```
  listname.count(obj)
  ```

  - 如果 count() 返回 0，就表示列表中不存在该元素，所以 count() 也可以用来判断列表中的某个元素是否存在。

###### range()快速初始化数字列表

- 列表非常适合用于存储数字集合，并且 Python 提供了 range() 函数，可帮助我们高效地处理数字列表，即便列表需要包含数百万个元素，也可以快速实现。

- Python range() 函数能够轻松地生成一系列的数字

  ```python
  for value in range(1,5):
      print(value)
      
  1
  2
  3
  4
  ```

  - 在这个示例程序中，range() 只是打印数字 1~4，因为range() 函数的用法是：让 Python 从指定的第一个值开始，一直数到指定的第二个值停止，但不包含第二个值（这里为 5）。

- 另外需要指明的是，range() 函数的返回值并不直接是列表类型（list）

  ```python
  >>> type([1,2,3,4,5])
  <class 'list'>
  >>> type(range(1,6))
  <class 'range'>
  ```

  - range() 函数的返回值类型为 range，而不是 list。而如果想要得到 range() 函数创建的数字列表，还需要借助 list() 函数

- 在使用 range() 函数时，还可以指定步长。例如，下面的代码打印 1~10 内的偶数：

  ```python
  even_numbers = list(range(2,11,2))
  print(even_numbers)
  
  [2, 4, 6, 8, 10]
  ```

  - 函数 range() 从 2 开始数，然后不断地加 2，直到达到或超过终值

##### 元组

- 元组和列表（list）的不同之处在于：

  - 列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列；
  - 而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。

- 元组也可以看做是不可变的列表，通常情况下，元组用于保存无需修改的内容。

- 从形式上看，元组的所有元素都放在一对小括号`( )`中，相邻元素之间用逗号`,`分隔

- 从存储内容上看，元组可以存储整数、实数、字符串、列表、元组等任何类型的数据，并且在同一个元组中，元素的类型可以不同

- 元组的类型位tuple，可以使用type查看

- 在 Python 中，元组通常都是使用一对小括号将所有元素包围起来的，但小括号不是必须的，只要将各元素用逗号隔开，Python 就会将其视为元组

  ```python
  course = "Python教程", "http://c.biancheng.net/python/"
  print(course)
  ('Python教程', 'http://c.biancheng.net/python/')
  ```

- 需要注意的一点是，当创建的元组中只有一个字符串类型的元素时，该元素后面必须要加一个逗号`,`，否则 Python 解释器会将它视为字符串

- 除了使用`( )`创建元组外，Python 还提供了一个内置的函数 tuple()，用来将其它数据类型转换为元组类型。

- 和列表一样，我们可以使用索引（Index）访问元组中的某个元素（得到的是一个元素的值），也可以使用切片访问元组中的一组元素（得到的是一个新的子元组）。

- 元组是不可变序列，元组中的元素不能被修改，所以我们只能创建一个新的元组去替代旧的元组。

- 还可以通过连接多个元组（使用`+`可以拼接元组）的方式向元组中添加新元素

- 当创建的元组不再使用时，可以通过 del 关键字将其删除。Python 自带垃圾回收功能，会自动销毁不用的元组，所以一般不需要通过 del 来手动删除。

- 总的来说，元组确实没有列表那么多功能，但是元组依旧是很重要的序列类型之一，元组的不可替代性体现在以下这些场景中：

  1. 元组作为很多内置函数和序列类型方法的返回值存在，也就是说，在使用某些函数或者方法时，它的返回值会元组类型，因此你必须对元组进行处理。
  2. 元组比列表的访问和处理速度更快，因此，当需要对指定元素进行访问，且不涉及修改元素的操作时，建议使用元组。
  3. 元组可以在映射（和集合的成员）中当做“键”使用，而列表不行。

###### 元组解包

- 赋值给多个变量的元组解包，一对一解包

  ```python
  temp = ("hi","yuan","wai") 
  first,second,third = temp
  等同于temp = ("hi","yuan","wai") 
  first = temp[0] second = temp[1] third = temp[2]
  ```

- 元组的每个元素作为位置参数的元组解包

  ```python
  temp = (1,2,3) 
  def hello(first,second,third):    
  	print(first)    
  	print(second)    
  	print(third)    
  hello(*temp)
  等同于hello(1,2,3)
  ```

- 遍历的元素为元组对象时，同时赋值给对应的变量，自动完成元组解包

  ```py
  temp_list = [('测试人员', self.tester),('开始时间', start_time),('合计耗时', duration),('测试结果', status + "，通过率= " + self.pass_rate)] 
  for first, second in temp_list:   
  	print(first)    
  	print(second)
  ```

  - temp_list是一个list，每个元素为tuple，遍历temp_list时，将每次的获取到tuple对象，自动解包到2个变量first和second

- *的使用

  ```python
  >>> first, *new, last = [94, 85, 73, 46]
  >>> new[85, 73]
  ```

  - *在函数里面表示可变参数，在这里面也表示解包获取多个值，将多个值拼成一个列表返回到new，说明现在new是一个list类型，如果后面是元组，返回的也是list类型

- 压包过程，压包是解包的逆过程，用zip函数实现

  ```python
  >>> a = ['a', 'b', 'c']
  >>> b = [1, 2, 3]
  >>> for i in zip(a, b):...
  		print(i)...('a', 1)('b', 2)('c', 3)
  ```

- 压包与解包混合

  ```python
  >>> a = [0, 1, 2]
  >>> b = [1, 2, 3]
  >>> for i, j in zip(a, b):...     
  		print(i+j)...135
  ```

  - 先是`zip`函数将`a b`压包成为一个可迭代对象
  - 对可迭代对象的每一个元素（`('a', 1)`）进行解包（`i, j = ('a', 1)`）
  - 此时就可以分别调用`i j`变量进行计算
  - 加入星号如下

  ```python
  >>> l = [('Bob', '1990-1-1', 60),...     ('Mary', '1996-1-4', 50),...     ('Nancy', '1993-3-1', 55),]
  >>> for name, *args in l:...    
  		print(name, args)...Bob ['1990-1-1', 60]Mary ['1996-1-4', 50]Nancy ['1993-3-1', 55]
  ```

  - 解包与压包结合可以实现类似矩阵转置的操作

  ```
  a = [[1, 2, 3], [4, 5, 6]]for x, y in zip(*a):    print(x, y)# 1 4# 2 5# 3 6
  ```

- _的用法，当一些元素不用时，用`_`表示是更好的写法，可以让读代码的人知道这个元素是不要的

  ```python
  >>> person = ('Bob', 20, 50, (11, 20, 2000))
  >>> name, *_, (*_, year) = person
  >>> name'Bob'
  >>> year2000
  ```

- 多变量同时赋值，之前赋值符号右侧都是可迭代对象，其实左侧也可以是多个变量

  ```python
  >>> a, b = 1, 2
  >>> a1
  >>> b2
  >>> a = 1, 2
  >>> a(1, 2)下面的语法是错误的*a = 1, 2  //如果只有一个参数，编译器会当作字符串，不能作为元组处理，可以在后面加一个逗号来表示元组a, b, c = 1, 2  可以这样写*a, = 1, 2
  ```

- *之可变参数，函数定义时，我们使用`*`的可变参数，其实也是压包解包过程

  ```
  >>> def myfun(*num):...     print(num)...
  >>> myfun(1,2,5,6)(1, 2, 5, 6)
  ```

  - 参数用`*num`表示，`num`变量就可以当成元组调用了。其实这个过程相当于`*num, = 1,2,5,6`

- *之关键字参数

  ```
  >>> def myfun(**kw):...     print(kw)...
  >>> myfun(name = "Bob", age = 20, weight = 50){'weight': 50, 'name': 'Bob', 'age': 20}
  ```

  - 键值对传入`**kw`，`kw`就可以表示相应字典。`**`的用法只在函数定义中使用，不能这样使用

    ```
    a, **b = {'weight': 50, 'name': 'Bob', 'age': 20}
    ```

- 可变参数与关键字参数的细节问题

  - 函数传入实参时，可变参数(`*`)之前的参数不能指定参数名

    ```
    >>> def myfun(a, *b):...     print(a)...     print(b)...
    >>> myfun(a=1, 2,3,4)  File "<stdin>", line 1SyntaxError: positional argument follows keyword argument>>> myfun(1, 2,3,4)1(2, 3, 4)
    ```

  - 函数传入实参时，可变参数(`*`)之后的参数必须指定参数名，否则就会被归到可变参数之中

    ```
    >>> def myfun(a, *b, c=None):...     print(a)...     print(b)...     print(c)...
    >>> myfun(1, 2,3,4)1(2, 3, 4)None>>> myfun(1, 2,3,c=4)1(2, 3)4
    ```

  - 关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以

    ```
    >>> def myfun(a, *b, c, **d):...     print(a)...     print(b)...     print(c)...     print(d)...
    >>> myfun(1, 2, 3, c= 4, m = 5, n = 6)1(2, 3)4{'n': 6, 'm': 5}
    ```

  - 可变参数与关键词参数共同使用以表示任意参数，下面是这一点在装饰器当中的使用

    ```
    >>> def mydecorator(func):...     def wrapper(*args, **kw):...         print('I am using a decorator.')...         return func(*args, **kw)...     return wrapper...>>> @mydecorator... def myfun(a, b):...     print(a)...     print(b)...>>> myfun(1, b = 2)I am using a decorator.12
    ```

    - (如果有的读者不熟悉装饰器，只需要知道，使用`@`定义`myfun`相当于`myfun = mydecorator(myfun)`，定义出来的`myfun`其实是返回结果`wrapper`函数)
    - `wrapper`函数使用`*args, **kw`作为参数，则被修饰的`myfun`函数需要的参数无论是什么样的，传入`wrapper`都不会报错，这保证了装饰器可以修饰各种各样函数的灵活性。毕竟我们一般在函数中传入参数时，要么所有参数名都写，要么前面几个不写，后面的会写，这样使用`*args, **kw`完全没有问题。

- 解包作为参数传入函数中

  ```python
  def myfun(a, b):    print(a + b)列表元组的解包   
  >>> n = [1, 2]
  >>> myfun(*n)3
  >>> m = (1, 2)
  >>> myfun(*m)3字典的解包
  >>> mydict = {'a':1, 'b': 2}
  >>> myfun(**mydict)3
  >>> myfun(*mydict)ba应用
  >>> bob = {'name': 'Bob', 'age': 30}
  >>> "{name}'s age is {age}".format(**bob)"Bob's age is 30"
  ```

- 多返回值函数

  ```python
  def myfun(a, b):    return a + 1, b + 2
  >>> m, n = myfun(1, 2)
  >>> m2
  >>> n4
  >>> p = myfun(1, 2)
  >>> p(2, 4)
  ```

- 其实在python中元组解包不仅仅只限于元组，只要是可迭代的如列表、元组、字典、字符串、range()等，都是可以的

##### 字典dict

| 主要特征                       | 解释                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 通过键而不是通过索引来读取元素 | 字典类型有时也称为关联数组或者散列表（hash）。它是通过键将一系列的值联系起来的，这样就可以通过键从字典中获取指定项，但不能通过索引来获取。 |
| 字典是任意数据类型的无序集合   | 和列表、元组不同，通常会将索引值 0 对应的元素称为第一个元素，而字典中的元素是无序的。 |
| 字典是可变的，并且可以任意嵌套 | 字典可以在原处增长或者缩短（无需生成一个副本），并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其它的字典。 |
| 字典中的键必须唯一             | 字典中，不支持同一个键出现多次，否则只会保留最后一个键值对。 |
| 字典中的键必须不可变           | 字典中每个键值对的键是不可变的，只能使用数字、字符串或者元组，不能使用列表。 |

###### 创建字典

- 使用{}创建字典，由于字典中每个元素都包含两部分，分别是键（key）和值（value），因此在创建字典时，键和值之间使用冒号`:`分隔，相邻元素之间使用逗号`,`分隔，所有元素放在大括号`{ }`中。需要注意的是，同一字典中的各个键必须唯一，不能重复。

- 通过fromkeys()创建字典，使用 dict 字典类型提供的 fromkeys() 方法创建带有默认值的字典

  ```
  dictname = dict.fromkeys(list，value=None)
  ```

  - list 参数表示字典中所有键的列表（list）；value 参数表示默认值，如果不写，则为空值 None。

    ```python
    knowledge = ['语文', '数学', '英语']
    scores = dict.fromkeys(knowledge, 60)
    print(scores)
    {'语文': 60, '英语': 60, '数学': 60}
    ```

- 通过dict()映射函数创建字典

  | 创建格式                                                     | 注意事项                                                     |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | a = dict(str1=value1, str2=value2, str3=value3)              | str 表示字符串类型的键，value 表示键对应的值。使用此方式创建字典时，字符串不能带引号。 |
  | #方式1 demo = [('two',2), ('one',1), ('three',3)]                                                                          #方式2 demo = [['two',2], ['one',1], ['three',3]]                                                                               #方式3 demo = (('two',2), ('one',1), ('three',3))                                                                                 #方式4 demo = (['two',2], ['one',1], ['three',3]) a = dict(demo) | 向 dict() 函数传入列表或元组，而它们中的元素又各自是包含 2 个元素的列表或元组，其中第一个元素作为键，第二个元素作为值。 |
  | keys = ['one', 'two', 'three'] #还可以是字符串或元组 values = [1, 2, 3] #还可以是字符串或元组 a = dict( zip(keys, values) ) | 通过应用 dict() 函数和 zip() 函数，可将前两个列表转换为对应的字典。 |

- 访问字典

  - 列表和元组是通过下标来访问元素的，而字典不同，它通过键来访问对应的值。因为字典中的元素是无序的，每个元素的位置都不固定，所以字典也不能像列表和元组那样，采用切片的方式一次性访问多个元素。

    ```
    dictname[key]
    ```

    - dictname 表示字典变量的名字，key 表示键名。注意，键必须是存在的，否则会抛出异常。

    ```python
    tup = (['two',26], ['one',88], ['three',100], ['four',-59])
    dic = dict(tup)
    print(dic['one'])  
    #键存在
    print(dic['five'])  
    #键不存在
    88
    Traceback (most recent call last):    File "C:\Users\mozhiyan\Desktop\demo.py", line 4, in <module>        print(dic['five'])  
    #键不存在
    KeyError: 'five'
    ```
  
  - 除了上面这种方式外，Python 更推荐使用 dict 类型提供的 get() 方法来获取指定键对应的值。当指定的键不存在时，get() 方法不会抛出异常。
  
    ```
    dictname.get(key[,default])
    ```
  
    - key 表示指定的键；default 用于指定要查询的键不存在时，此方法返回的默认值，如果不手动指定，会返回 None。
  
      ```python
      a = dict(two=0.65, one=88, three=100, four=-59)
      print( a.get('one') )
      88
      ```
  
    - 当键不存在时，get() 返回空值 None，如果想明确地提示用户该键不存在，那么可以手动设置 get() 的第二个参数
  
      ```
      a = dict(two=0.65, one=88, three=100, four=-59)print( a.get('five', '该键不存在') )该键不存在
      ```
  
  - 和删除列表、元组一样，手动删除字典也可以使用 del 关键字

###### 字典基本操作

- 由于字典属于可变序列，所以我们可以任意操作字典中的键值对（key-value）。[Python](http://c.biancheng.net/python/) 中，常见的字典操作有以下几种：

  - 向现有字典中添加新的键值对。
  - 修改现有字典中的键值对。
  - 从现有字典中删除指定的键值对。
  - 判断现有字典中是否存在指定的键值对。

- 字典是由一个一个的 key-value 构成的，key 是找到数据的关键，Python 对字典的操作都是通过 key 来完成的。

- 为字典添加新的键值对很简单，直接给不存在的 key 赋值即可

  ```
  dictname[key] = value
  ```

- Python 字典中键（key）的名字不能被修改，我们只能修改值（value）。字典中各元素的键必须是唯一的，因此，如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的。

- 如果要删除字典中的键值对，还是可以使用 del 语句

  ```python
  # 使用del语句删除键值对
  a = {'数学': 95, '语文': 89, '英语': 90}
  del a['语文']
  del a['数学']
  print(a)
  {'英语': 90}
  ```

- 如果要判断字典中是否存在指定键值对，首先应判断字典中是否有对应的键。判断字典是否包含指定键值对的键，可以使用 in 或 not in 运算符。对于 dict 而言，in 或 not in 运算符都是基于 key 来判断的。

  ```python
  a = {'数学': 95, '语文': 89, '英语': 90}
  # 判断 a 中是否包含名为'数学'的key
  print('数学' in a) 
  # True
  # 判断 a 是否包含名为'物理'的key
  print('物理' in a) 
  # False
  True
  False
  ```
  
  - 通过 in（或 not in）运算符，我们可以很轻易地判断出现有字典中是否包含某个键，如果存在，由于通过键可以很轻易的获取对应的值，因此很容易就能判断出字典中是否有指定的键值对。

###### dict字典方法

- [Python](http://c.biancheng.net/python/) 字典的数据类型为 dict，我们可使用 `dir(dict)` 来查看该类型包含哪些方法

  ```
  >>> dir(dict)
  ['clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
  ```

- keys、values和items方法，将这三个方法放在一起介绍，是因为它们都用来获取字典中的特定数据：

  - keys() 方法用于返回字典中的所有键（key）；

  - values() 方法用于返回字典中所有键对应的值（value）；

  - items() 用于返回字典中所有的键值对（key-value）。

    ```python
    scores = {'数学': 95, '语文': 89, '英语': 90}
    print(scores.keys())
    print(scores.values())
    print(scores.items())
    dict_keys(['数学', '语文', '英语'])
    dict_values([95, 89, 90])
    dict_items([('数学', 95), ('语文', 89), ('英语', 90)])
    ```

  - keys()、values() 和 items() 返回值的类型分别为 dict_keys、dict_values 和 dict_items。

- 在 Python 3.x 中如果想使用这三个方法返回的数据，一般有下面两种方案：

  - 使用 list() 函数，将它们返回的数据转换成列表

    ```python
    a = {'数学': 95, '语文': 89, '英语': 90}
    b = list(a.keys())
    print(b)
    ['数学', '语文', '英语']
    ```

  - 使用 for in 循环遍历它们的返回值

    ```python
    a = {'数学': 95, '语文': 89, '英语': 90}
    for k in a.keys():
        print(k,end=' ')
    print("\n---------------")
    for v in a.values():
        print(v,end=' ')
    print("\n---------------")
    for k,v in a.items():
        print("key:",k," value:",v)
        
    数学 语文 英语
    ---------------
    95 89 90
    ---------------
    key: 数学  value: 95
    key: 语文  value: 89
    key: 英语  value: 90
    ```

- copy()方法，copy() 方法返回一个字典的拷贝，也即返回一个具有相同键值对的新字典

  ```python
  a = {'one': 1, 'two': 2, 'three': [1,2,3]}
  b = a.copy()
  print(b)
  
  {'one': 1, 'two': 2, 'three': [1, 2, 3]}
  ```

  - copy() 方法所遵循的拷贝原理，既有深拷贝，也有浅拷贝。拿拷贝字典 a 为例，copy() 方法只会对最表层的键值对进行深拷贝，也就是说，它会再申请一块内存用来存放 {'one': 1, 'two': 2, 'three': []}；而对于某些列表类型的值来说，此方法对其做的是浅拷贝，也就是说，b 中的 [1,2,3] 的值不是自己独有，而是和 a 共有。

- update() 方法可以使用一个字典所包含的键值对来更新己有的字典。在执行 update() 方法时，如果被更新的字典中己包含对应的键值对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的键值对，则该键值对被添加进去。

  ```
  a = {'one': 1, 'two': 2, 'three': 3}
  a.update({'one':4.5, 'four': 9.3})
  print(a)
  
  {'one': 4.5, 'two': 2, 'three': 3, 'four': 9.3}
  ```

- pop() 和 popitem() 都用来删除字典中的键值对，不同的是，pop() 用来删除指定的键值对，而 popitem() 用来随机删除一个键值对

  ```
  dictname.pop(key)
  dictname.popitem()
  ```

  - 说 popitem() 随机删除字典中的一个键值对是不准确的，虽然字典是一种无须的列表，但键值对在底层也是有存储顺序的，popitem() 总是弹出底层中的最后一个 key-value，这和列表的 pop() 方法类似，都实现了[数据结构](http://c.biancheng.net/data_structure/)中“出栈”的操作。

- setdefault() 方法用来返回某个 key 对应的 value。

  ```
  dictname.setdefault(key, defaultvalue)
  ```

  - dictname 表示字典名称，key 表示键，defaultvalue 表示默认值（可以不写，不写的话是 None）。
  - 当指定的 key 不存在时，setdefault() 会先为这个不存在的 key 设置一个默认的 defaultvalue，然后再返回 defaultvalue。
  - 也就是说，setdefault() 方法总能返回指定 key 对应的 value：
    - 如果该 key 存在，那么直接返回该 key 对应的 value；
    - 如果该 key 不存在，那么先为该 key 设置默认的 defaultvalue，然后再返回该 key 对应的 defaultvalue。

##### set集合

- [Python](http://c.biancheng.net/python/) 中的集合，和数学中的集合概念一样，用来保存不重复的元素，即集合中的元素都是唯一的，互不相同。

- 从形式上看，和字典类似，Python 集合会将所有元素放在一对大括号 {} 中，相邻元素之间用“,”分隔

- 从内容上看，同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型，否则 Python 解释器会抛出 TypeError 错误

- 由于 Python 中的 set 集合是无序的，所以每次输出时元素的排序顺序可能都不相同。

- Python 中有两种集合类型，一种是 set 类型的集合，另一种是 frozenset 类型的集合，它们唯一的区别是，set 类型集合可以做添加、删除元素的操作，而 forzenset 类型集合不行。

- Python 提供了 2 种创建 set 集合的方法，分别是使用 {} 创建和使用 set() 函数将列表、元组等类型数据转换为集合。

  - 创建 set 集合可以像列表、元素和字典一样，直接将集合赋值给变量，从而实现创建集合的目的

    ```
    a = {1,'c',1,(1,2,3),'c'}
    print(a)
    {1, 'c', (1, 2, 3)}
    ```

  - set() 函数为 Python 的内置函数，其功能是将字符串、列表、元组、range 对象等可迭代对象转换成集合

    ```
    setname = set(iteration)
    ```

    - iteration 就表示字符串、列表、元组、range 对象等数据。

  - 如果要创建空集合，只能使用 set() 函数实现。因为直接使用一对 {}，Python 解释器会将其视为一个空字典。

- 由于集合中的元素是无序的，因此无法向列表那样使用下标访问元素。Python 中，访问集合元素最常用的方法是使用循环结构，将集合中的数据逐一读取出来。

- 和其他序列类型一样，也可以使用 del() 语句来删除集合

- Python set 集合最常用的操作是向集合中添加、删除元素，以及集合之间做交集、并集、差集等运算

  - set 集合中添加元素，可以使用 set 类型提供的 add() 方法实现，使用 add() 方法添加的元素，只能是数字、字符串、元组或者布尔类型（True 和 False）值，不能添加列表、字典、集合这类可变的数据
  - 删除现有 set 集合中的指定元素，可以使用 remove() 方法，使用此方法删除集合中元素，需要注意的是，如果被删除元素本就不包含在集合中，则此方法会抛出 KeyError 错误。如果我们不想在删除失败时令解释器提示 KeyError 错误，还可以使用 discard() 方法，此方法和 remove() 方法的用法完全相同，唯一的区别就是，当删除集合中元素失败时，此方法不会抛出任何错误。

  | 运算操作 | Python运算符 | 含义                              | 例子                                        |
  | -------- | ------------ | --------------------------------- | ------------------------------------------- |
  | 交集     | &            | 取两集合公共的元素                | >>> set1 & set2 {3}                         |
  | 并集     | \|           | 取两集合全部的元素                | >>> set1 \| set2 {1,2,3,4,5}                |
  | 差集     | -            | 取一个集合中另一集合没有的元素    | >>> set1 - set2 {1,2} >>> set2 - set1 {4,5} |
  | 对称差集 | ^            | 取集合 A 和 B 中不属于 A&B 的元素 | >>> set1 ^ set2 {1,2,4,5}                   |

- 通过 dir(set) 命令可以查看它有哪些方法

- set 集合是可变序列，程序可以改变序列中的元素；frozenset 集合是不可变序列，程序不能改变序列中的元素。set 集合中所有能改变集合本身的方法，比如 remove()、discard()、add() 等，frozenset 都不支持；set 集合中不改变集合本身的方法，fronzenset 都支持。

  - 两种情况下可以使用 fronzenset：
    - 当集合的元素不需要改变时，我们可以使用 fronzenset 替代 set，这样更加安全。
    - 有时候程序要求必须是不可变对象，这个时候也要使用 fronzenset 替代 set。比如，字典（dict）的键（key）就要求是不可变对象。

  ```
  s = {'Python', 'C', 'C++'}
  fs = frozenset(['Java', 'Shell'])
  s_sub = {'PHP', 'C#'}
  #向set集合中添加
  frozensets.add(fs)
  print('s =', s)
  #向为set集合添加子set集合
  s.add(s_sub)
  print('s =', s)
  ```
  
  - set 集合本身的元素必须是不可变的， 所以 set 的元素不能是 set，只能是 frozenset。第 6 行代码向 set 中添加 frozenset 是没问题的，因为 frozenset 是不可变的；但是，第 10 行代码中尝试向 set 中添加子 set，这是不允许的，因为 set 是可变的。

#### 字符串

###### 字符串拼接

- 在 [Python](http://c.biancheng.net/python/) 中拼接（连接）字符串很简单，可以直接将两个字符串紧挨着写在一起，这种写法只能拼接字符串常量。如果需要使用变量，就得借助`+`运算符来拼接，当然，`+`运算符也能拼接字符串常量。

  ```
  name = "C++教程"
  url = "http://c.biancheng.net/cplus/"
  info = name + "的网址是：" + url
  print(info)
  C++教程的网址是：http://c.biancheng.net/cplus/
  ```

- 在很多应用场景中，我们需要将字符串和数字拼接在一起，而 Python 不允许直接拼接数字和字符串，所以我们必须先将数字转换成字符串。可以借助 str() 和 repr() 函数将数字转换为字符串

  ```
  str(obj)
  repr(obj)
  ```
  
  - obj 表示要转换的对象，它可以是数字、列表、元组、字典等多种类型的数据。
  
  - str() 和 repr() 函数虽然都可以将数字转换成字符串，但它们之间是有区别的：
  
    - str() 用于将数据转换成适合人类阅读的字符串形式。
    - repr() 用于将数据转换成适合解释器阅读的字符串形式（Python 表达式的形式），适合在开发和调试阶段使用；如果没有等价的语法，则会发生 SyntaxError 异常。
  
    ```python
    s = "http://c.biancheng.net/shell/"
    s_str = str(s)
    s_repr = repr(s)
    print( type(s_str) )
    print (s_str)
    print( type(s_repr) )
    print (s_repr)
    <class 'str'>
    http://c.biancheng.net/shell/
    <class 'str'>
    'http://c.biancheng.net/shell/'
    s 本身就是一个字符串，但是我们依然使用 str() 和 repr() 对它进行了转换。从运行结果可以看出，str() 保留了字符串最原始的样子，而 repr() 使用引号将字符串包围起来，这就是 Python 字符串的表达式形式。
    ```
    
    - 在 Python 交互式编程环境中输入一个表达式（变量、加减乘除、逻辑运算等）时，Python 会自动使用 repr() 函数处理该表达式。

###### 截取字符串

- 字符串是由多个字符构成的，字符之间是有顺序的，这个顺序号就称为索引（index）。[Python](http://c.biancheng.net/python/) 允许通过索引来操作字符串中的单个或者多个字符，比如获取指定索引处的字符，返回指定字符的索引值等。

- 获取单个字符，知道字符串名字以后，在方括号`[ ]`中使用索引即可访问对应的字符

  - Python 允许从字符串的两端使用索引：
    - 当以字符串的左端（字符串的开头）为起点时，索引是从 0 开始计数的；字符串的第一个字符的索引为 0，第二个字符的索引为 1，第三个字符串的索引为 2 ……
    - 当以字符串的右端（字符串的末尾）为起点时，索引是从 -1 开始计数的；字符串的倒数第一个字符的索引为 -1，倒数第二个字符的索引为 -2，倒数第三个字符的索引为 -3 ……

- 获取多个字符，使用`[ ]`除了可以获取单个字符外，还可以指定一个范围来获取多个字符，也就是一个子串或者片段

  ```
  strname[start : end : step]
  ```

  - start：表示要截取的第一个字符所在的索引（截取时包含该字符）。如果不指定，默认为 0，也就是从字符串的开头截取；
  - end：表示要截取的最后一个字符所在的索引（截取时不包含该字符）。如果不指定，默认为字符串的长度；
  - step：指的是从 start 索引处的字符开始，每 step 个距离获取一个字符，直至 end 索引出的字符。step 默认值为 1，当省略该值时，最后一个冒号也可以省略。

###### 获取字符串长度

- 要想知道一个字符串有多少个字符（获得字符串长度），或者一个字符串占用多少个字节，可以使用 len 函数。

- 在实际开发中，除了常常要获取字符串的长度外，有时还要获取字符串的字节数。在 Python 中，不同的字符所占的字节数不同，数字、英文字母、小数点、下划线以及空格，各占一个字节，而一个汉字可能占 2~4 个字节，具体占多少个，取决于采用的编码方式。例如，汉字在 GBK/GB2312 编码中占用 2 个字节，而在 UTF-8 编码中一般占用 3 个字节。以 UTF-8 编码为例，字符串“人生苦短，我用Python”所占用的字节数如图 1 所示。

  ![](http://c.biancheng.net/uploads/allimg/190701/2-1ZF1140302452.gif)

- 我们可以通过使用 encode() 方法，将字符串进行编码后再获取它的字节数。例如，采用 UTF-8 编码方式，计算“人生苦短，我用Python”的字节数，可以执行如下代码：

  ```
  >>> str1 = "人生苦短，我用Python"
  >>> len(str1.encode())
  27
  如果要获取采用 GBK 编码的字符串的长度
  >>> str1 = "人生苦短，我用Python"
  >>> len(str1.encode('gbk'))20
  ```

###### split()分隔字符串

- 除了可以使用一些内建函数获取字符串的相关信息外（例如 len() 函数获取字符串长度），字符串类型本身也拥有一些方法供我们使用。

- split() 方法可以实现将一个字符串按照指定的分隔符切分成多个子串，这些子串会被保存到列表中（不包含分隔符），作为方法的返回值反馈回来。

  ```
  str.split(sep,maxsplit)
  ```

  - str：表示要进行分割的字符串；
  - sep：用于指定分隔符，可以包含多个字符。此参数默认为 None，表示所有空字符，包括空格、换行符“\n”、制表符“\t”等。
  - maxsplit：可选参数，用于指定分割的次数，最后列表中子串的个数最多为 maxsplit+1。如果不指定或者指定为 -1，则表示分割次数没有限制。

- 在 split 方法中，如果不指定 sep 参数，那么也不能指定 maxsplit 参数。同内建函数（如 len）的使用方式不同，字符串变量所拥有的方法，只能采用“字符串.方法名()”的方式调用

- 需要注意的是，在未指定 sep 参数时，split() 方法默认采用空字符进行分割，但当字符串中有连续的空格或其他空字符时，都会被视为一个分隔符对字符串进行分割

###### join()合并字符串

- join() 方法也是非常重要的字符串方法，它是 split() 方法的逆方法，用来将列表（或元组）中包含的多个字符串连接成一个字符串。

- 使用 join() 方法合并字符串时，它会将列表（或元组）中多个字符串采用固定的分隔符连接在一起。例如，字符串“c.biancheng.net”就可以看做是通过分隔符“.”将 ['c','biancheng','net'] 列表合并为一个字符串的结果。

  ```
  newstr = str.join(iterable)
  ```

  - newstr：表示合并后生成的新字符串；
  - str：用于指定合并时的分隔符；
  - iterable：做合并操作的源字符串数据，允许以列表、元组等形式提供。

  ```python
  将列表中的字符串合并成一个字符串。
  >>> list = ['c','biancheng','net']
  >>> '.'.join(list)
  'c.biancheng.net'将元组中的字符串合并成一个字符串。
  >>> dir = '','usr','bin','env'
  >>> type(dir)
  <class 'tuple'
  >>>> '/'.join(dir)'/usr/bin/env'
  ```

###### count()统计字符串出现的次数

- count 方法用于检索指定字符串在另一字符串中出现的次数，如果检索的字符串不存在，则返回 0，否则返回出现的次数。

  ```
  str.count(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：表示要检索的字符串；
  - start：指定检索的起始位置，也就是从什么位置开始检测。如果不指定，默认从头开始检索；
  - end：指定检索的终止位置，如果不指定，则表示一直检索到结尾。

  ```python
  检索字符串“c.biancheng.net”中“.”出现的次数。
  >>> str = "c.biancheng.net"
  >>> str.count('.')
  2
  >>> str = "c.biancheng.net"
  >>> str.count('.',1)2
  >>> str.count('.',2)1字符串中各字符对应的检索值，从 0 开始，因此，本例中检索值 1 对应的是第 2 个字符‘.’，从输出结果可以分析出，从指定索引位置开始检索，其中也包含此索引位置。
  >>> str = "c.biancheng.net"
  >>> str.count('.',2,-3)
  1
  >>> str.count('.',2,-4)
  0
  ```

###### find()

- find() 方法用于检索字符串中是否包含目标字符串，如果包含，则返回第一次出现该字符串的索引；反之，则返回 -1。

  ```
  str.find(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：表示要检索的目标字符串；
  - start：表示开始检索的起始位置。如果不指定，则默认从头开始检索；
  - end：表示结束检索的结束位置。如果不指定，则默认一直检索到结尾。

- [Python](http://c.biancheng.net/python/) 还提供了 rfind() 方法，与 find() 方法最大的不同在于，rfind() 是从字符串右边开始检索

###### index()

- 同 find() 方法类似，index() 方法也可以用于检索是否包含指定的字符串，不同之处在于，当指定的字符串不存在时，index() 方法会抛出异常。

  ```
  str.index(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：表示要检索的子字符串；
  - start：表示检索开始的起始位置，如果不指定，默认从头开始检索；
  - end：表示检索的结束位置，如果不指定，默认一直检索到结尾。

- 同 find() 和 rfind() 一样，字符串变量还具有 rindex() 方法，其作用和 index() 方法类似，不同之处在于它是从右边开始检索

###### ljust()、rjust()、center()

- [Python](http://c.biancheng.net/python/) str 提供了 3 种可用来进行文本对齐的方法，分别是 ljust()、rjust() 和 center() 方法

- ljust() 方法的功能是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。

  ```
  S.ljust(width[, fillchar])
  ```

  - S：表示要进行填充的字符串；
  - width：表示包括 S 本身长度在内，字符串要占的总长度；
  - fillchar：作为可选参数，用来指定填充字符串时所用的字符，默认情况使用空格。

  ```
  S = 'http://c.biancheng.net/python/'
  addr = 'http://c.biancheng.net'
  print(S.ljust(35,'-'))
  print(addr.ljust(35,'-'))
  http://c.biancheng.net/python/
  -----http://c.biancheng.net-------------
  ```

- rjust() 和 ljust() 方法类似，唯一的不同在于，rjust() 方法是向字符串的左侧填充指定字符，从而达到右对齐文本的目的。

  ```
  S = 'http://c.biancheng.net/python/'
  addr = 'http://c.biancheng.net'
  print(S.rjust(35))
  print(addr.rjust(35))
  http://c.biancheng.net/python/             
  http://c.biancheng.net   
  ```

  - 每行字符串都占用 35 个字节的位置，实现了整体的右对齐效果

- center() 字符串方法与 ljust() 和 rjust() 的用法类似，但它让文本居中，而不是左对齐或右对齐。

###### startswith() 和endswith() 

- startswith() 方法用于检索字符串是否以指定字符串开头，如果是返回 True；反之返回 False

  ```
  str.startswith(sub[,start[,end]])
  ```

  - str：表示原字符串；
  - sub：要检索的子串；
  - start：指定检索开始的起始位置索引，如果不指定，则默认从头开始检索；
  - end：指定检索的结束位置索引，如果不指定，则默认一直检索在结束。

  ```python
  >>> str = "c.biancheng.net"
  >>> str.startswith("c")True
  >>> str = "c.biancheng.net"
  >>> str.startswith("http")
  False
  >>> str = "c.biancheng.net"
  >>> str.startswith("b",2)
  True
  ```

- endswith() 方法用于检索字符串是否以指定字符串结尾，如果是则返回 True；反之则返回 False

###### 大小写转换

- 为了方便对字符串中的字母进行大小写转换，字符串变量提供了 3 种方法，分别是 title()、lower() 和 upper()。

- title() 方法用于将字符串中每个单词的首字母转为大写，其他字母全部转为小写，转换完成后，此方法会返回转换得到的字符串。如果字符串中没有需要被转换的字符，此方法会将字符串原封不动地返回。

  ```
  >>> str = "c.biancheng.net"
  >>> str.title()'C.Biancheng.Net'
  >>> str = "I LIKE C"
  >>> str.title()
  'I Like C'
  ```

- lower() 方法用于将字符串中的所有大写字母转换为小写字母，转换完成后，该方法会返回新得到的字符串。如果字符串中原本就都是小写字母，则该方法会返回原字符串。

  ```
  >>> str = "I LIKE C"
  >>> str.lower()'i like c'
  ```

- upper() 的功能和 lower() 方法恰好相反，它用于将字符串中的所有小写字母转换为大写字母，和以上两种方法的返回方式相同，即如果转换成功，则返回新字符串；反之，则返回原字符串。

###### 去除空格

- 用户输入数据时，很有可能会无意中输入多余的空格，或者在一些场景中，字符串前后不允许出现空格和特殊字符，此时就需要去除字符串中的空格和特殊字符。这里的特殊字符，指的是制表符（\t）、回车符（\r）、换行符（\n）等。

- [Python](http://c.biancheng.net/python/) 中，字符串变量提供了 3 种方法来删除字符串中多余的空格和特殊字符，它们分别是：

  1. strip()：删除字符串前后（左右两侧）的空格或特殊字符。
  2. lstrip()：删除字符串前面（左边）的空格或特殊字符。
  3. rstrip()：删除字符串后面（右边）的空格或特殊字符。

- Python 的 str 是不可变的（不可变的意思是指，字符串一旦形成，它所包含的字符序列就不能发生任何改变），因此这三个方法只是返回字符串前面或后面空白被删除之后的副本，并不会改变字符串本身。

- strip() 方法用于删除字符串左右两个的空格和特殊字符

  ```
  str.strip([chars])
  ```

  - str 表示原字符串，[chars] 用来指定要删除的字符，可以同时指定多个，如果不手动指定，则默认会删除空格以及制表符、回车符、换行符等特殊字符。

  ```
  >>> str = "  c.biancheng.net \t\n\r"
  >>> str.strip()'c.biancheng.net'
  >>> str.strip(" ,\r")
  'c.biancheng.net \t\n'
  >>> str'  c.biancheng.net \t\n\r'通过 strip() 确实能够删除字符串左右两侧的空格和特殊字符，但并没有真正改变字符串本身。
  ```

- lstrip() 方法用于去掉字符串左侧的空格和特殊字符

- rstrip() 方法用于删除字符串右侧的空格和特殊字符

###### format()格式化

- 前面章节介绍了如何使用 % 操作符对各种类型的数据进行格式化输出，这是早期 [Python](http://c.biancheng.net/python/) 提供的方法。自 Python 2.6 版本开始，字符串类型（str）提供了 format() 方法对字符串进行格式化

  ```
  str.format(args)
  ```

  - str 用于指定字符串的显示样式；args 用于指定要进行格式转换的项，如果有多项，之间有逗号进行分割。

- 学习 format() 方法的难点，在于搞清楚 str 显示样式的书写格式。在创建显示样式模板时，需要使用`{}`和`：`来指定占位符，其完整的语法格式为：

  ```
  { [index][ : [ [fill] align] [sign] [#] [width] [.precision] [type] ] }
  ```

  - 格式中用 [] 括起来的参数都是可选参数，即可以使用，也可以不使用。各个参数的含义如下：

    - index：指定：后边设置的格式要作用到 args 中第几个数据，数据的索引值从 0 开始。如果省略此选项，则会根据 args 中数据的先后顺序自动分配。
    - fill：指定空白处填充的字符。注意，当填充字符为逗号(,)且作用于整数或浮点数时，该整数（或浮点数）会以逗号分隔的形式输出，例如（1000000会输出 1,000,000）。
    - align：指定数据的对齐方式

    | align | 含义                                                         |
    | ----- | ------------------------------------------------------------ |
    | <     | 数据左对齐。                                                 |
    | >     | 数据右对齐。                                                 |
    | =     | 数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对数字类型有效。 |
    | ^     | 数据居中，此选项需和 width 参数一起使用。                    |

    - sign：指定有无符号数

    | sign参数 | 含义                                                         |
    | -------- | ------------------------------------------------------------ |
    | +        | 正数前加正号，负数前加负号。                                 |
    | -        | 正数前不加正号，负数前加负号。                               |
    | 空格     | 正数前加空格，负数前加负号。                                 |
    | #        | 对于二进制数、八进制数和十六进制数，使用此参数，各进制数前会分别显示 0b、0o、0x前缀；反之则不显示前缀。 |

    - width：指定输出数据时所占的宽度。
    - .precision：指定保留的小数位数。
    - type：指定输出数据的具体类型

    | type类型值 | 含义                                                  |
    | ---------- | ----------------------------------------------------- |
    | s          | 对字符串类型格式化。                                  |
    | d          | 十进制整数。                                          |
    | c          | 将十进制整数自动转换成对应的 Unicode 字符。           |
    | e 或者 E   | 转换成科学计数法后，再格式化输出。                    |
    | g 或 G     | 自动在 e 和 f（或 E 和 F）中切换。                    |
    | b          | 将十进制数自动转换成二进制表示，再格式化输出。        |
    | o          | 将十进制数自动转换成八进制表示，再格式化输出。        |
    | x 或者 X   | 将十进制数自动转换成十六进制表示，再格式化输出。      |
    | f 或者 F   | 转换为浮点数（默认小数点后保留 6 位），再格式化输出。 |
    | %          | 显示百分比（默认显示小数点后 6 位）。                 |

```
str="网站名称：{:>9s}\t网址：{:s}"
print(str.format("C语言中文网","c.biancheng.net"))
Traceback (most recent call last):  File "C:\Users\mengma\Desktop\1.py", line 2, in    print(str.format("C语言中文网","c.biancheng.net"))ValueError: cannot switch from automatic field numbering to manual field specification
在实际开发中，数值类型有多种显示需求，比如货币形式、百分比形式等，使用 format() 方法可以将数值格式化为不同的形式。
#以货币形式显示
print("货币形式：{:,d}".format(1000000))#科学计数法表示print("科学计数法：{:E}".format(1200.12))#以十六进制表示print("100的十六进制：{:#x}".format(100))#输出百分比形式print("0.01的百分比表示：{:.0%}".format(0.01))货币形式：1,000,000科学计数法：1.200120E+03100的十六进制：0x640.01的百分比表示：1%
```

###### encode() 和 decode()

- 在 Python 中，有 2 种常用的字符串类型，分别为 str 和 bytes 类型，其中 str 用来表示 Unicode 字符，bytes 用来表示二进制数据。str 类型和 bytes 类型之间就需要使用 encode() 和 decode() 方法进行转换。

- encode() 方法为字符串类型（str）提供的方法，用于将 str 类型转换成 bytes 类型，这个过程也称为“编码”。

  ```
  str.encode([encoding="utf-8"][,errors="strict"])
  ```

| 参数               | 含义                                                         |
| ------------------ | ------------------------------------------------------------ |
| str                | 表示要进行转换的字符串。                                     |
| encoding = "utf-8" | 指定进行编码时采用的字符编码，该选项默认采用 utf-8 编码。例如，如果想使用简体中文，可以设置 gb2312。  当方法中只使用这一个参数时，可以省略前边的“encoding=”，直接写编码格式，例如 str.encode("UTF-8")。 |
| errors = "strict"  | 指定错误处理方式，其可选择值可以是：strict：遇到非法字符就抛出异常。ignore：忽略非法字符。replace：用“？”替换非法字符。xmlcharrefreplace：使用 xml 的字符引用。该参数的默认值为 strict。 |

```
>>> str = "C语言中文网">>> str.encode()b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x91'
```

- 和 encode() 方法正好相反，decode() 方法用于将 bytes 类型的二进制数据转换为 str 类型，这个过程也称为“解码”。

  ```
  bytes.decode([encoding="utf-8"][,errors="strict"])
  ```

###### dir()和help()

- [Python](http://c.biancheng.net/python/) dir() 函数用来列出某个类或者某个模块中的全部内容，包括变量、方法、函数和类等

  ```
  dir(obj)
  ```

  - obj 表示要查看的对象。obj 可以不写，此时 dir() 会列出当前范围内的变量、方法和定义的类型。

- Python help() 函数用来查看某个函数或者模块的帮助文档

  ```
  help(obj)
  ```

- 在 Python 标准库中，以`__`开头和结尾的方法都是私有的，不能在类的外部调用。

  ```
  使用 help() 查看 str 类型中 lower() 函数的用法：
  >>> help(str.lower)
  Help on method_descriptor:lower(self, /)    Return a copy of the string converted to lowercase.
  ```
  
  - 使用 help() 查看某个函数的用法时，函数名后边不能带括号，例如将上面的命令写作`help(str.lower())`就是错误的。

#### 流程控制

- 在其他语言中（如 C语言、[C++](http://c.biancheng.net/cplus/)、[Java](http://c.biancheng.net/java/) 等），选择结构还包括 switch 语句，也可以实现多重选择，但是在 Python 中没有 switch 语句，所以当要实现多重选择的功能时，只能使用 if else 分支语句。if   elif   else

- 布尔类型（bool）只有两个值，分别是 True 和 False，Python 会把 True 当做“真”，把 False 当做“假”。对于数字，Python 会把 0 和 0.0 当做“假”，把其它值当做“真”。对于其它类型，当对象为空或者为 None 时，Python 会把它们当做“假”，其它情况当做真。

  ```
  ""  #空字符串[ ]  #空列表( )  #空元组{ }  #空字典None  #空值
  ```

- 对于没有 return 语句的函数，返回值为空，也即 None。

###### Pass

- 在实际开发中，有时候我们会先搭建起程序的整体逻辑结构，但是暂时不去实现某些细节，而是在这些地方加一些注释，方面以后再添加代码

  ```
  age = int( input("请输入你的年龄：") )
  if age < 12 :
  	print("婴幼儿")
  elif age >= 12 and age < 18:
  	print("青少年")
  elif age >= 18 and age < 30:
  	print("成年人")
  elif age >= 30 and age < 50:
  	#TODO: 成年人
  else:    
  	print("老年人")
  ```
  
  - 当年龄大于等于 30 并且小于 50 时，我们没有使用 print() 语句，而是使用了一个注释，希望以后再处理成年人的情况。当 [Python](http://c.biancheng.net/python/) 执行到该 elif 分支时，会跳过注释，什么都不执行。
  
  - 但是 Python 提供了一种更加专业的做法，就是空语句 pass。**pass** 是 Python 中的关键字，用来让解释器跳过此处，什么都不做。
  
  - 就像上面的情况，有时候程序需要占一个位置，或者放一条语句，但又不希望这条语句做任何事情，此时就可以通过 pass 语句来实现。使用 pass 语句比使用注释更加优雅。
  
    ```
    age = int( input("请输入你的年龄：") )if age < 12 :    print("婴幼儿")elif age >= 12 and age < 18:    print("青少年")elif age >= 18 and age < 30:    print("成年人")elif age >= 30 and age < 50:    passelse:    print("老年人")
    ```

###### Assert断言函数

- [Python](http://c.biancheng.net/python/) assert 语句，又称断言语句，可以看做是功能缩小版的 if 语句，它用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报 AssertionError 错误。

  ```
  assert 表达式
  assert 语句的执行流程可以用 if 判断语句表示
  if 表达式==True:    程序继续执行else:    程序报 AssertionError 错误
  ```

  - 有读者可能会问，明明 assert 会令程序崩溃，为什么还要使用它呢？这是因为，与其让程序在晚些时候崩溃，不如在错误条件出现时，就直接让程序崩溃，这有利于我们对程序排错，提高程序的健壮性。
  - 因此，assert 语句通常用于检查用户的输入是否符合规定，还经常用作程序初期测试和调试过程中的辅助工具。

  ```
  mathmark = int(input())#断言数学考试分数是否位于正常范围内
  assert 0 <= mathmark <= 100#只有当 mathmark 位于 [0,100]范围内，程序才会继续执行
  print("数学考试分数为：",mathmark)
  90
  数学考试分数为： 90
  再次运行
  159
  Traceback (most recent call last):  File "C:\Users\mengma\Desktop\file.py", line 3, in <module>    assert 0 <= mathmark <= 100AssertionError
  ```

  - 当 assert 语句后的表达式值为真时，程序继续执行；反之，程序停止执行，并报 AssertionError 错误。

- 另外，在实际工作中，assert 还有一些很常见的用法

  ```
  def func(input):
  	assert isinstance(input, list), '输入内容必须是列表'    # 下面的操作都是基于前提：input 必须是 list    if len(input) == 1:        ...    elif len(input) == 2:        ...    else:        ...
  ```

  - 上面代码中，func() 函数中的所有操作都基于输入必须是列表这个前提。所以很有必要在开头加一句 assert 的检查，防止程序出错。

- assert 的检查是可以被关闭的，比如在命令行模式下运行 Python 程序时，加入 -O 选项就可以使程序中的 assert 失效。一旦 assert 失效，其包含的语句也就不会被执行。

###### 循环结构while

- 除了数字，while 循环还常用来遍历列表、元组和字符串，因为它们都支持通过下标索引获取指定位置的元素

  ```
  my_char="http://c.biancheng.net/python/"
  i = 0;
  while i<len(my_char):
      print(my_char[i],end="")
      i = i + 1
      
  http://c.biancheng.net/python/
  ```

###### for循环

- for 循环，它常用于遍历字符串、列表、元组、字典、集合等序列类型，逐个获取序列中的各个元素。

  ```
  for 迭代变量 in 字符串|列表|元组|字典|集合：
      代码块
  ```

  - 格式中，迭代变量用于存放从序列类型变量中读取出来的元素，所以一般不会在循环中对迭代变量手动赋值；代码块指的是具有相同缩进格式的多行代码（和 while 一样），由于和循环结构联用，因此代码块又称为循环体。

  ```
  add = "http://c.biancheng.net/python/"
  #for循环，遍历 add 字符串
  for ch in add:
      print(ch,end="")
      
  http://c.biancheng.net/python/
  ```

  - 使用 for 循环遍历 add 字符串的过程中，迭代变量 ch 会先后被赋值为 add 字符串中的每个字符，并代入循环体中使用。只不过例子中的循环体比较简单，只有一行输出语句。

- 在使用 for 循环时，最基本的应用就是进行数值循环。比如说，想要实现从 1 到 100 的累加

  ```
  print("计算 1+2+...+100 的结果为：")
  #保存累加结果的变量
  result = 0
  #逐个获取从 1 到 100 这些值，并做累加操作
  for i in range(101):
      result += i
  print(result)
  ```

  - 上面代码中，使用了 range() 函数，此函数是 Python 内置函数，用于生成一系列连续整数，多用于 for 循环中。

- 当用 for 循环遍历 list 列表或者 tuple 元组时，其迭代变量会先后被赋值为列表或元组中的每个元素并执行一次循环体。

  ```
  my_list = [1,2,3,4,5]
  for ele in my_list:
  	print('ele =', ele)    
  ele = 1
  ele = 2
  ele = 3
  ele = 4
  ele = 5
  ```

- 在使用 for 循环遍历字典时，经常会用到和字典相关的 3 个方法，即 items()、keys() 以及 values()，它们各自的用法已经在前面章节中讲过，这里不再赘述。当然，如果使用 for 循环直接遍历字典，则迭代变量会被先后赋值为每个键值对中的键。

  ```
  my_dic = {'python教程':"http://c.biancheng.net/python/",\          'shell教程':"http://c.biancheng.net/shell/",\          'java教程':"http://c.biancheng.net/java/"}
  for ele in my_dic.items():
  	print('ele =', ele)    
  ele = ('python教程', 'http://c.biancheng.net/python/')
  ele = ('shell教程', 'http://c.biancheng.net/shell/')
  ele = ('java教程', 'http://c.biancheng.net/java/')
  ```

- 使用 for 循环实现用冒泡排序算法对 [5,8,4,1] 进行排序：

  ```
  data = [5,8,4,1]#实现冒泡排序
  for i in range(len(data)-1):
  	for j in range(len(data)-i-1):
      	if(data[j]>data[j+1]): 
          	data[j],data[j+1] = data[j+1],data[j]
  print("排序后：",data)
  ```

###### 推导式快速初始化各种序列

- 推导式（又称解析器），是 Python 独有的一种特性。使用推导式可以快速生成列表、元组、字典以及集合类型的数据，因此推导式又可细分为列表推导式、元组推导式、字典推导式以及集合推导式。

- 列表推导式，列表推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的列表。

  ```
  [表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ]
  ```

  - [if 条件表达式] 不是必须的，可以使用，也可以省略。

  - 通过列表推导式的语法格式，明显会感觉到它和 for 循环存在某些关联。其实，除去 [if 条件表达式] 部分，其余各部分的含义以及执行顺序和 for 循环是完全一样的（表达式其实就是 for 循环中的循环体），即它的执行顺序如下所示：

    ```
    for 迭代变量 in 可迭代对象    表达式
    ```

  - 初学者可以这样认为，它只是对 for 循环语句的格式做了一下简单的变形，并用 [] 括起来而已，只不过最大的不同之处在于，列表推导式最终会将循环过程中，计算表达式得到的一系列值组成一个列表。

    ```
    a_range = range(10)
    # 对a_range执行for表达式
    a_list = [x * x for x in a_range]# a_list集合包含10个元素print(a_list)[0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64, 81]我们还可以在列表推导式中添加 if 条件语句，这样列表推导式将只迭代那些符合条件的元素b_list = [x * x for x in a_range if x % 2 == 0]# a_list集合包含5个元素print(b_list)[0 ,4 , 16, 36, 64]
    ```

  - 以上所看到的列表推导式都只有一个循环，实际上它可使用多个循环，就像嵌套循环一样。

    ```
    d_list = [(x, y) for x in range(5) for y in range(4)]# d_list列表包含20个元素print(d_list)上面代码中，x 是遍历 range(5) 的迭代变量（计数器），因此该 x 可迭代 5 次；y 是遍历 range(4) 的计数器，因此该 y 可迭代 4 次。因此，该（x,y）表达式一共会迭代 20 次。上面的 for 表达式相当于如下嵌套循环：dd_list = []for x in range(5):    for y in range(4):        dd_list.append((x, y))        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3)]
    ```

  - 对于包含多个循环的 for 表达式，同样可指定 if 条件。假如我们有一个需求：程序要将两个列表中的数值按“能否整除”的关系配对在一起。比如 src_a 列表中包含 30，src_b 列表中包含 5，其中 30 可以整除 5，那么就将 30 和 5 配对在一起。对于上面的需求使用 for 表达式来实现非常简单，例如如下代码：

    ```
    src_a = [30, 12, 66, 34, 39, 78, 36, 57, 121]src_b = [3, 5, 7, 11]# 只要y能整除x，就将它们配对在一起result = [(x, y) for x in src_b for y in src_a if y % x == 0]print(result)[(3, 30), (3, 12), (3, 66), (3, 39), (3, 78), (3, 36), (3, 57), (5, 30), (11, 66), (11, 121)]
    ```

- 元组推导式，元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。通过和列表推导式做对比，你会发现，除了元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是 []，其它完全相同。不仅如此，元组推导式和列表推导式的用法也完全相同。

  ```
  a = (x for x in range(1,10))print(a)<generator object <genexpr> at 0x0000020BAD136620>从上面的执行结果可以看出，使用元组推导式生成的结果并不是一个元组，而是一个生成器对象（后续会介绍），这一点和列表推导式是不同的。
  ```

  - 如果我们想要使用元组推导式获得新元组或新元组中的元素，有以下三种方式：

    - 使用 tuple() 函数，可以直接将生成器对象转换成元组

      ```
      a = (x for x in range(1,10))print(tuple(a))运行结果为：(1, 2, 3, 4, 5, 6, 7, 8, 9)
      ```

    - 直接使用 for 循环遍历生成器对象，可以获得各个元素

      ```
      a = (x for x in range(1,10))for i in a:    print(i,end=' ')print(tuple(a))1 2 3 4 5 6 7 8 9 ()
      ```

    - 使用 `__next__()` 方法遍历生成器对象，也可以获得各个元素

      ```
      a = (x for x in range(3))print(a.__next__())print(a.__next__())print(a.__next__())a = tuple(a)print("转换后的元组：",a)012转换后的元组： ()
      ```

  - 无论是使用 for 循环遍历生成器对象，还是使用 __next__() 方法遍历生成器对象，遍历后原生成器对象将不复存在，这就是遍历后转换原生成器对象却得到空元组的原因。

- 字典推导式

  ```
  {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}
  ```

  ```
  listdemo = ['C语言中文网','c.biancheng.net']
  #将列表中各字符串值为键，各字符串的长度为值，组成键值对
  newdict = {key:len(key) for key in listdemo}
  print(newdict)
  {'C语言中文网': 6, 'c.biancheng.net': 15}
  交换现有字典中各键值对的键和值。
  olddict={'C语言中文网': 6, 'c.biancheng.net': 15}
  newdict = {v: k for k, v in olddict.items()}
  print(newdict)
  {6: 'C语言中文网', 15: 'c.biancheng.net'}
  ```

- 集合推导式

  ```
  { 表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] }
  ```

  - 有读者可能会问，集合推导式和字典推导式的格式完全相同，那么给定一个类似的推导式，如何判断是哪种推导式呢？最简单直接的方式，就是根据表达式进行判断，如果表达式以键值对（key：value）的形式，则证明此推导式是字典推导式；反之，则是集合推导式。
  - 既然生成的是集合，那么其保存的元素必须是唯一的。

###### zip函数

- zip() 函数是 [Python](http://c.biancheng.net/python/) 内置函数之一，它可以将多个序列（列表、元组、字典、集合、字符串以及 range() 区间构成的列表）“压缩”成一个 zip 对象。所谓“压缩”，其实就是将这些序列中对应位置的元素重新组合，生成一个个新的元组。

  ```
  zip(iterable, ...)
  ```

  - 其中 iterable,... 表示多个列表、元组、字典、集合、字符串，甚至还可以为 range() 区间。

    ```
    my_list = [11,12,13]
    my_tuple = (21,22,23)
    print([x for x in zip(my_list,my_tuple)])
    my_dic = {31:2,32:4,33:5}
    my_set = {41,42,43,44}
    print([x for x in zip(my_dic)])
    my_pychar = "python"
    my_shechar = "shell"
    print([x for x in zip(my_pychar,my_shechar)])
    [(11, 21), (12, 22), (13, 23)]
    [(31,), (32,), (33,)]
    [('p', 's'), ('y', 'h'), ('t', 'e'), ('h', 'l'), ('o', 'l')]
    ```
  
    - 读者分析以上的程序和相应的输出结果不难发现，在使用 zip() 函数“压缩”多个序列时，它会分别取各序列中第 1 个元素、第 2 个元素、... 第 n 个元素，各自组成新的元组。需要注意的是，当多个序列中元素个数不一致时，会以最短的序列为准进行压缩。
  
  - 对于 zip() 函数返回的 zip 对象，既可以像上面程序那样，通过遍历提取其存储的元组，也可以向下面程序这样，通过调用 list() 函数将 zip() 对象强制转换成列表：
  
    ```
    my_list = [11,12,13]my_tuple = (21,22,23)print(list(zip(my_list,my_tuple)))
    ```

###### reversed函数

- reserved() 是 Pyton 内置函数之一，其功能是对于给定的序列（包括列表、元组、字符串以及 range(n) 区间），该函数可以返回一个逆序序列的迭代器（用于遍历该逆序序列）。

  ```
  reversed(seq)
  ```

  - seq 可以是列表，元素，字符串以及 range() 生成的区间列表。

  ```
  #将列表进行逆序print([x for x in reversed([1,2,3,4,5])])#将元组进行逆序print([x for x in reversed((1,2,3,4,5))])#将字符串进行逆序print([x for x in reversed("abcdefg")])#将 range() 生成的区间列表进行逆序print([x for x in reversed(range(10))])[5, 4, 3, 2, 1][5, 4, 3, 2, 1]['g', 'f', 'e', 'd', 'c', 'b', 'a'][9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
  ```

- 除了使用列表推导式的方式，还可以使用 list() 函数，将 reversed() 函数逆序返回的迭代器，直接转换成列表

  ```
  #将列表进行逆序print(list(reversed([1,2,3,4,5])))[5, 4, 3, 2, 1]
  ```

- 再次强调，使用 reversed() 函数进行逆序操作，并不会修改原来序列中元素的顺序

###### sorted函数

- sorted() 作为 [Python](http://c.biancheng.net/python/) 内置函数之一，其功能是对序列（列表、元组、字典、集合、还包括字符串）进行排序。

  ```
  list = sorted(iterable, key=None, reverse=False)  
  ```

  - iterable 表示指定的序列，key 参数可以自定义排序规则；reverse 参数指定以升序（False，默认）还是降序（True）进行排序。sorted() 函数会返回一个排好序的列表。

    ```
    #对列表进行排序a = [5,3,4,2,1]print(sorted(a))#对元组进行排序a = (5,4,3,1,2)print(sorted(a))#字典默认按照key进行排序a = {4:1,\     5:2,\     3:3,\     2:6,\     1:8}print(sorted(a.items()))#对集合进行排序a = {1,5,3,2,4}print(sorted(a))#对字符串进行排序a = "51423"print(sorted(a))[1, 2, 3, 4, 5][1, 2, 3, 4, 5][(1, 8), (2, 6), (3, 3), (4, 1), (5, 2)][1, 2, 3, 4, 5]['1', '2', '3', '4', '5']
    ```

- 使用 sorted() 函数对序列进行排序， 并不会在原序列的基础进行修改，而是会重新生成一个排好序的列表。

- sorted(）函数默认对序列中元素进行升序排序，通过手动将其 reverse 参数值改为 True，可实现降序排序

- 另外在调用 sorted() 函数时，还可传入一个 key 参数，它可以接受一个函数，该函数的功能是指定 sorted() 函数按照什么标准进行排序

  ```
  chars=['http://c.biancheng.net',\       'http://c.biancheng.net/python/',\       'http://c.biancheng.net/shell/',\       'http://c.biancheng.net/java/',\       'http://c.biancheng.net/golang/']#默认排序print(sorted(chars))#自定义按照字符串长度排序print(sorted(chars,key=lambda x:len(x)))
  ```

#### 函数和lambda表达式

- 在创建函数时，即使函数不需要参数，也必须保留一对空的“()”，否则 Python 解释器将提示“invaild syntax”错误。另外，如果想定义一个没有任何功能的空函数，可以使用 pass 语句作为占位符。

- 通过调用 Python 的 help() 内置函数或者 `__doc__` 属性，我们可以查看某个函数的使用说明文档。事实上，无论是 Python 提供给我们的函数，还是自定义的函数，其说明文档都需要设计该函数的程序员自己编写。其实，函数的说明文档，本质就是一段字符串，只不过作为说明文档，字符串的放置位置是有讲究的，函数的说明文档通常位于函数内部、所有代码的最前面。

  ```
  #定义一个比较字符串大小的函数
  def str_max(str1,str2):
  	'''    比较 2 个字符串的大小    '''    
  	str = str1 if str1 > str2 else str2    return strhelp(str_max)
  #print(str_max.__doc__)
  Help on function str_max in module __main__:str_max(str1, str2)    比较 2 个字符串的大小
  ```

  - 上面程序中，还可以使用 `__doc__` 属性来获取 str_max() 函数的说明文档，即使用最后一行的输出语句，其输出结果为

    ```
      比较 2 个字符串的大小
    ```

- [Python](http://c.biancheng.net/python/) 中，根据实际参数的类型不同，函数参数的传递方式可分为 2 种，分别为值传递和引用（地址）传递：

  1. 值传递：适用于实参类型为不可变类型（字符串、数字、元组）；
  2. 引用（地址）传递：适用于实参类型为可变类型（列表，字典）；
  3. 值传递和引用传递的区别是，函数参数进行值传递后，若形参的值发生改变，不会影响实参的值；而函数参数继续引用传递后，改变形参的值，实参的值也会一同改变。

- 位置参数，有时也称必备参数，指的是必须按照正确的顺序将实际参数传到函数中，换句话说，调用函数时传入实际参数的数量和位置都必须和定义函数时保持一致。

- 关键字参数，关键字参数是指使用形式参数的名字来确定输入的参数值。通过此方式指定函数实参时，不再需要与形参的位置完全一致，只要将参数名写正确即可。因此，[Python](http://c.biancheng.net/python/) 函数的参数名应该具有更好的语义，这样程序可以立刻明确传入函数的每个参数的含义。

  ```python
  def dis_str(str1,str2):
  	print("str1:",str1)
      print("str2:",str2)
  #位置参数
  dis_str("http://c.biancheng.net/python/","http://c.biancheng.net/shell/")
  #关键字参数dis_str("http://c.biancheng.net/python/",str2="http://c.biancheng.net/shell/")
  dis_str(str2="http://c.biancheng.net/python/",str1="http://c.biancheng.net/shell/")
  ```

  - 在调用有参函数时，既可以根据位置参数来调用，也可以使用关键字参数（程序中第 8 行）来调用。在使用关键字参数调用时，可以任意调换参数传参的位置。
  - 使用位置参数和关键字参数混合传参的方式。但需要注意，混合传参时关键字参数必须位于所有的位置参数之后。

- 默认参数

  ```
  def 函数名(...，形参名，形参名=默认值)：    代码块
  ```

  - 在使用此格式定义函数时，指定有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误。

###### 可变参数

- Python 在定义函数时也可以使用可变参数，即允许定义参数个数可变的函数。这样当调用该函数时，可以向其传入任意多个参数。可变参数，又称不定长参数，即传入函数中的实际参数可以是任意多个。Python 定义可变参数，主要有以下 2 种形式。

  - 形参前面加一个*

    ```
    *args
    ```

    - args 表示创建一个名为 args 的空元组，该元组可接受任意多个外界传入的非关键字实参。

    ```python
    # 定义了支持参数收集的函数
    def dis_str(home, *str) :
    	print(home)    
    	# 输出str元组中的元素    
    	print("str=",str)    
    	for s in str :
        	print(s)#可传入任何多个参数dis_str("http://c.biancheng.net","http://c.biancheng.net/python/","http://c.biancheng.net/shell/")
    dis_str() 函数的最后一个参数就是 str 元组，这样在调用该函数时，除了前面位置参数接收对应位置的实参外，其它非关键字参数都会由 str 元组接收。
    ```
  
    - 可变参数并不一定必须为最后一个函数参数，例如修改 dis_str() 函数为：
  
    ```python
    # 定义了支持参数收集的函数
    def dis_str(*str,home) :
    	print(home)    
    	# 输出str元组中的元素
        print("str=",str)
        for s in str :
        print(s)
        dis_str("http://c.biancheng.net","http://c.biancheng.net/python/",home="http://c.biancheng.net/shell/")str 可变参数作为 dis_str() 函数的第一个参数。但需要注意的是，在调用该函数时，必须以关键字参数的形式给普通参数传值，否则 Python 解释器会把所有参数都优先传给可变参数，如果普通参数没有默认值，就会报错。
    ```
  
  - 形参前面加两个*
  
    ```
    **kwargs
    ```
  
    - **kwargs 表示创建一个名为 kwargs 的空字典，该字典可以接收任意多个以关键字参数赋值的实际参数。
  
    ```python
    # 定义了支持参数收集的函数
    def dis_str(home,*str,**course) :
    	print(home)
        print(str)
        print(course)
        #调用函数
        
    dis_str("C语言中文网",\
    	"http://c.biancheng.net",\
        "http://c.biancheng.net/python/",\
        shell教程="http://c.biancheng.net/shell/",\
        go教程="http://c.biancheng.net/golang/",\
        java教程="http://c.biancheng.net/java/")
    
    C语言中文网('http://c.biancheng.net', 'http://c.biancheng.net/python/'){'shell教程': 'http://c.biancheng.net/shell/', 'go教程': 'http://c.biancheng.net/golang/', 'java教程': 'http://c.biancheng.net/java/'}
    ```
    
    - 第 1 个参数传递给 home 参数，第 2、3 个非关键字参数传递给 str 元组，最后 2 个关键字参数将由 course 字典接收。
    - *args 可变参数的值默认是空元组，**kwargs 可变参数的值默认是空字典。因此，在调用具有可变参数的函数时，不一定非要给它们传值

###### 逆向参数收集

- Python 支持定义具有可变参数的函数，即该函数可以接收任意多个参数，其中非关键字参数会集中存储到元组参数（*args）中，而关键字参数则集中存储到字典参数（**kwargs）中，这个过程可称为参数收集。

- 不仅如此，Python 还支持逆向参数收集，即直接将列表、元组、字典作为函数参数，Python 会将其进行拆分，把其中存储的元素按照次序分给函数中的各个形参。

- 在以逆向参数收集的方式向函数参数传值时，Pyhon 语法规定，当传入列表或元组时，其名称前要带一个 * 号，当传入字典时，其名称前要带有 2 个 * 号。

  ```python
  def dis_str(name,add) :
      print("name:",name)
      print("add",add)
  data = ["Python教程","http://c.biancheng.net/python/"]
  #使用逆向参数收集方式传值
  dis_str(*data)
  
  name: Python教程
  add http://c.biancheng.net/python/
  
  def dis_str(name,add) :
      print("name:",name)
      print("add:",add)
  data = {'name':"Python教程",'add':"http://c.biancheng.net/python/"}
  #使用逆向参数收集方式传值
  dis_str(**data)
  
  name: Python教程
  add: http://c.biancheng.net/python/
  
  以逆向参数收集的方式，还可以给拥有可变参数的函数传参
  def dis_str(name,*add) :
      print("name:",name)
      print("add:",add)
  data = ["http://c.biancheng.net/python/",\
          "http://c.biancheng.net/shell/",\
          "http://c.biancheng.net/golang/"]
  #使用逆向参数收集方式传值
  dis_str("Python教程",*data)
  
  name: Python教程
  add: ('http://c.biancheng.net/python/', 'http://c.biancheng.net/shell/', 'http://c.biancheng.net/golang/')
  ```

- None(空值)，在 [Python](http://c.biancheng.net/python/) 中，有一个特殊的常量 None（N 必须大写）。和 False 不同，它不表示 0，也不表示空字符串，而表示没有值，也就是空值。

  - 这里的空值并不代表空对象，即 None 和 []、“” 不同：

    ```python
    >>> None is []
    False
    >>> None is ""
    False
    ```

  - None 有自己的数据类型，我们可以在 IDLE 中使用 type() 函数查看它的类型

    ```python
    >>> type(None)
    <class 'NoneType'>
    ```
  
  - None 是 NoneType 数据类型的唯一值（其他编程语言可能称这个值为 null、nil 或 undefined），也就是说，我们不能再创建其它 NoneType 类型的变量，但是可以将 None 赋值给任何变量。如果希望变量中存储的东西不与任何其它值混淆，就可以使用 None。
  
  - 除此之外，None 常用于 assert、判断以及函数无返回值的情况。举个例子，在前面章节中我们一直使用 print() 函数输出数据，其实该函数的返回值就是 None。因为它的功能是在屏幕上显示文本，根本不需要返回任何值，所以 print() 就返回 None。
  
    ```python
    >>> spam = print('Hello!')
    Hello!
    >>> None == spam
    True
    ```
  
  - 对于所有没有 return 语句的函数定义，Python 都会在末尾加上 return None，使用不带值的 return 语句（也就是只有 return 关键字本身），那么就返回 None。

###### 函数返回多个值

- 通常情况下，一个函数只有一个返回值，实际上 Python 也是如此，只不过 Python 函数能以返回列表或者元组的方式，将要返回的多个值保存到序列中，从而间接实现返回多个值的目的。

- 因此，实现 Python 函数返回多个值，有以下 2 种方式：

  1. 在函数中，提前将要返回的多个值存储到一个列表或元组中，然后函数返回该列表或元组；
  2. 函数直接返回多个值，之间用逗号（ , ）分隔，Python 会自动将多个值封装到一个元组中，其返回值仍是一个元组。

  ```python
  def retu_list() :
  	add = ["http://c.biancheng.net/python/",\
      "http://c.biancheng.net/shell/",\
      "http://c.biancheng.net/golang/"]
      return add
  def retu_tuple() :    
      return "http://c.biancheng.net/python/",\
      "http://c.biancheng.net/golang/",\
      "http://c.biancheng.net/golang/"
  print("retu_list = ",retu_list())
  print("retu_tuple = ",retu_tuple())
  retu_list =  ['http://c.biancheng.net/python/', 'http://c.biancheng.net/shell/', 'http://c.biancheng.net/golang/']
  retu_tuple =  ('http://c.biancheng.net/python/', 'http://c.biancheng.net/golang/', 'http://c.biancheng.net/golang/')
  ```
  
  ```python
  在此基础上，我们可以利用 Python 提供的序列解包功能，之间使用对应数量的变量，直接接收函数返回列表或元组中的多个值。这里以 retu_list() 为例：
  def retu_list() :
  	add = ["http://c.biancheng.net/python/",\
      "http://c.biancheng.net/shell/",\
      "http://c.biancheng.net/golang/"]
      return add
  pythonadd,shelladd,golangadd =retu_list()
  print("pythonadd=",pythonadd)
  print("shelladd=",shelladd)
  print("golangadd=",golangadd)
  pythonadd= http://c.biancheng.net/python/
  shelladd= http://c.biancheng.net/shell/
  golangadd= http://c.biancheng.net/golang/
  ```

###### partial偏函数

- 简单的理解偏函数，它是对原始函数的二次封装，是将现有函数的部分参数预先绑定为指定值，从而得到一个新的函数，该函数就称为偏函数。相比原函数，偏函数具有较少的可变参数，从而降低了函数调用的难度。

- 定义偏函数，需使用 partial 关键字（位于 functools 模块中），其语法格式如下：

  ```
  偏函数名 = partial(func, *args, **kwargs)
  ```

  - func 指的是要封装的原函数，*args 和 **kwargs 分别用于接收无关键字实参和关键字实参。

  ```python
  from functools import partial
  #定义个原函数
  def display(name,age):
  	print("name:",name,"age:",age)
  #定义偏函数，其封装了 display() 函数，并为 name 参数设置了默认参数
  GaryFun = partial(display,name = 'Gary')#由于 name 参数已经有默认值，因此调用偏函数时，可以不指定
  GaryFun(age = 13)name: Gary age: 13
  ```

  - 此程序的第 8 行代码中，必须采用关键字参数的形式给 age 形参传参，因为如果以无关键字参数的方式，该实参将试图传递给 name 形参，Python解释器会报 TypeError 错误。

  ```python
  from functools import partial
  def mod( n, m ):
    return n % m
  #定义偏函数，并设置参数 n 对应的实参值为 100
  mod_by_100 = partial( mod, 100 )
  print(mod( 100, 7 ))
  print(mod_by_100( 7 ))
  
  2
  2
  ```

- 结合以上示例不难分析出，偏函数的本质是将函数式编程、默认参数和冗余参数结合在一起，通过偏函数传入的参数调用关系，与正常函数的参数调用关系是一致的。

- 偏函数通过将任意数量（顺序）的参数，转化为另一个带有剩余参数的函数对象，从而实现了截取函数功能（偏向）的效果。在实际应用中，可以使用一个原函数，然后将其封装多个偏函数，在调用函数时全部调用偏函数，一定程序上可以提高程序的可读性。

###### 函数递归

- 一个函数在它的函数体内调用它自身称为递归调用，这种函数称为递归函数。执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。

- 有这样一个数学题。己知有一个数列：f(0) = 1，f(1) = 4，f(n + 2) = 2*f(n+ 1) +f(n)，其中 n 是大于 0 的整数，求 f(10) 的值。这道题可以使用递归来求得。下面程序将定义一个 fn() 函数，用于计算 f(10) 的值。

  ```
  def fn(n) :
      if n == 0 :
          return 1
      elif n == 1 :
          return 4
      else :
          # 函数中调用它自身，就是函数递归
          return 2 * fn(n - 1) + fn(n - 2)
  # 输出fn(10)的结果
  print("fn(10)的结果是:", fn(10))
  ```

- 仔细看上面递归的过程，当一个函数不断地调用它自身时，必须在某个时刻函数的返回值是确定的，即不再调用它自身：否则，这种递归就变成了无穷递归，类似于死循环。因此，在定义递归函数时有一条最重要的规定： 递归一定要向已知方向进行。

- 递归是非常有用的，例如程序希望遍历某个路径下的所有文件，但这个路径下的文件夹的深度是未知的，那么就可以使用递归来实现这个需求。系统可定义一个函数，该函数接收一个文件路径作为参数，该函数可遍历出当前路径下的所有文件和文件路径，即在该函数的函数体中再次调用函数自身来处理该路径下的所有文件路径。

###### 变量作用域

- 定义全局变量的方式有以下 2 种：

  - 在函数体外定义的变量，一定是全局变量

  - 在函数体内定义全局变量。即使用 global 关键字对变量进行修饰后，该变量就会变为全局变量。

    ```python
    def text():
        global add
        add= "http://c.biancheng.net/java/"
        print("函数体内访问：",add)
    text()
    print('函数体外访问：',add)
    ```

- 在一些特定场景中，我们可能需要获取某个作用域内（全局范围内或者局部范围内）所有的变量，Python 提供了以下 3 种方式：

  - globals() 函数为 Python 的内置函数，它可以返回一个包含全局范围内所有变量的字典，该字典中的每个键值对，键为变量名，值为该变量的值。

    ```python
    #全局变量
    Pyname = "Python教程"
    Pyadd = "http://c.biancheng.net/python/"
    def text():
        #局部变量
        Shename = "shell教程"
        Sheadd= "http://c.biancheng.net/shell/"
    print(globals())
    
    { ...... , 'Pyname': 'Python教程', 'Pyadd': 'http://c.biancheng.net/python/', ......}
    
    globals() 函数返回的字典中，会默认包含有很多变量，这些都是 Python 主程序内置的，读者暂时不用理会它们。
    ```

    - 通过调用 globals() 函数，我们可以得到一个包含所有全局变量的字典。并且，通过该字典，我们还可以访问指定变量，甚至如果需要，还可以修改它的值。

      ```python
      print(globals()['Pyname'])
      globals()['Pyname'] = "Python入门教程"
      print(Pyname)
      
      Python教程
      Python入门教程
      ```

  - locals() 函数也是 Python 内置函数之一，通过调用该函数，我们可以得到一个包含当前作用域内所有变量的字典。这里所谓的“当前作用域”指的是，在函数内部调用 locals() 函数，会获得包含所有局部变量的字典；而在全局范文内调用 locals() 函数，其功能和 globals() 函数相同。

    ```python
    #全局变量
    Pyname = "Python教程"
    Pyadd = "http://c.biancheng.net/python/"
    def text():
        #局部变量
        Shename = "shell教程"
        Sheadd= "http://c.biancheng.net/shell/"
        print("函数内部的 locals:")
        print(locals())
    text()
    print("函数外部的 locals:")
    print(locals())
    
    函数内部的 locals:
    {'Sheadd': 'http://c.biancheng.net/shell/', 'Shename': 'shell教程'}
    函数外部的 locals:
    {...... , 'Pyname': 'Python教程', 'Pyadd': 'http://c.biancheng.net/python/', ...... }
    
    当使用 locals() 函数获取所有全局变量时，和 globals() 函数一样，其返回的字典中会默认包含有很多变量，这些都是 Python 主程序内置的，
    ```

    - 当使用 locals() 函数获得所有局部变量组成的字典时，可以向 globals() 函数那样，通过指定键访问对应的变量值，但无法对变量值做修改。

  - vars() 函数也是 Python 内置函数，其功能是返回一个指定 object 对象范围内所有变量组成的字典。如果不传入object 参数，vars() 和 locals() 的作用完全相同。

    ```
    #全局变量
    Pyname = "Python教程"
    Pyadd = "http://c.biancheng.net/python/"
    class Demo:
        name = "Python 教程"
        add = "http://c.biancheng.net/python/"
    print("有 object：")
    print(vars(Demo))
    print("无 object：")
    print(vars())
    
    有 object：
    {...... , 'name': 'Python 教程', 'add': 'http://c.biancheng.net/python/', ......}
    无 object：
    {...... , 'Pyname': 'Python教程', 'Pyadd': 'http://c.biancheng.net/python/', ...... }
    ```

- 全局变量可以在程序中任何位置被访问甚至修改，但是，当函数中定义了和全局变量同名的局部变量时，那么在当前函数中，无论是访问还是修改该同名变量，操作的都是局部变量，而不再是全局变量。

  ```python
  name = "Python教程"
  def demo ():
      #访问全局变量
      print(name)
      name = "shell教程"
  demo()
  
  UnboundLocalError: local variable 'name' referenced before assignment
  ```

  - 该错误直译过来的意思是：所访问的 name 变量还未定义。这是什么原因呢？就是我们添加第 5 行代码导致的。
  - Python 语法规定，在函数内部对不存在的变量赋值时，默认就是重新定义新的局部变量。上面程序中，第 5 行就定义了一个新的 name 局部变量，由于该局部变量名和全局变量名 name 同名，局部 name 变量就会“遮蔽”全局 name 变量，再加上局部变量 name 在 print(name) 后才被初始化，违反了“先定义后使用”的原则，因此程序会报错。

- 那么，如果就是想在函数中访问甚至修改被“遮蔽”的变量，怎么办呢？可以采取以下 2 中方法：

  - 直接访问被遮蔽的全局变量。如果希望程序依然能访问 name 全局变量，且在函数中可重新定义 name 局部变量，也就是在函数中可以访问被遮蔽的全局变量，此时可通过 globals() 函数来实现

    ```python
    name = "Python教程"
    def demo ():
        #通过 globals() 函数访问甚至修改全局变量
        print(globals()['name'])
        globals()['name']="Java教程"
        #定义局部变量
        name = "shell教程"
    demo()
    print(name)
    
    Python教程
    Java教程
    ```

  - 在函数中声明全局变量。为了避免在函数中对全局变量赋值（不是重新定义局部变量），可使用 global 语句来声明全局变量。

    ```python
    name = "Python教程"
    def demo ():
        global name
        #访问全局name变量
        print(name)
        #修改全局name变量的值
        name = "shell教程"
    demo()
    print(name)
    
    Python教程
    shell教程
    ```

    - 增加了“global name”声明之后，程序会把 name 变量当成全局变量，这意味着 demo() 函数后面对 name 赋值的语句只是对全局变量赋值，而不是重新定义局部变量。

###### 局部函数

- Python 支持在函数内部定义函数，此类函数又称为局部函数。

- 和局部变量一样，默认情况下局部函数只能在其所在函数的作用域内使用

  ```python
  #全局函数
  def outdef ():
  	#局部函数    
  	def indef():
      	print("http://c.biancheng.net/python/")    
      	#调用局部函数    
      indef()#调用全局函数
  outdef()
  http://c.biancheng.net/python/
  ```

- 就如同全局函数返回其局部变量，就可以扩大该变量的作用域一样，通过将局部函数作为所在函数的返回值，也可以扩大局部函数的使用范围。

  ```python
  #全局函数
  def outdef ():
  	#局部函数    
  	def indef():
  		print("调用局部函数")
  	#调用局部函数 
  	return indef
  #调用全局函数
  new_indef = outdef()
  调用全局函数中的局部函数
  new_indef()调用局部函数
  ```

  - 以上面程序中的 outdef() 和 indef() 为例，如果 outdef() 不将 indef 作为返回值，则 indef() 只能在 outdef() 函数内部使用；反之，则 indef() 函数既可以在 outdef() 函数内部使用，也可以在 outdef() 函数的作用域，也就是全局范围内使用。

- 如果局部函数中定义有和所在函数中变量同名的变量，也会发生“遮蔽”的问题

  ```python
  #全局函数
  def outdef ():
      name = "所在函数中定义的 name 变量"
      #局部函数
      def indef():
          print(name)
          name = "局部函数中定义的 name 变量"
      indef()
  #调用全局函数
  outdef()
  
  UnboundLocalError: local variable 'name' referenced before assignment
  ```

  - 由于这里的 name 变量也是局部变量，因此前面章节讲解的 globals() 函数或者 globals 关键字，并不适用于解决此问题。这里可以使用 Python 提供的 nonlocal 关键字。

    ```python
    #全局函数
    def outdef ():
        name = "所在函数中定义的 name 变量"
        #局部函数
        def indef():
            nonlocal name
            print(name)
            #修改name变量的值
            name = "局部函数中定义的 name 变量"
        indef()
    #调用全局函数
    outdef()
    
    所在函数中定义的 name 变量
    ```

###### 函数指针

- Python 函数还支持赋值、作为其他函数的参数以及作为其他函数的返回值。

- Python 允许直接将函数赋值给其它变量，这样做的效果是，程序中也可以用其他变量来调用该函数，更加灵活

  ```python
  def my_def ():
      print("正在执行 my_def 函数")
  #将函数赋值给其他变量   
  other = my_def
  #间接调用 my_def() 函数
  other()
  
  正在执行 my_def 函数
  ```

- Python 还支持将函数以参数的形式传入其他函数中

  ```python
  def add (a,b):
      return a+b
  def multi(a,b):
      return a*b
  def my_def(a,b,dis):
      return dis(a,b)
     
  #求 2 个数的和
  print(my_def(3,4,add))
  #求 2 个数的乘积
  print(my_def(3,4,multi))
  
  7
  12
  ```

  - 通过使用函数作为参数，可以在调用函数时动态传入函数，从而实现动态改变函数中的部分实现代码，在不同场景中赋予函数不同的作用。

- Python 还支持函数的返回值也为函数。

  ```python
  def my_def ():
      #局部函数
      def indef():
          print("调用局部函数")
      #调用局部函数
      return indef
  other_def = my_def()
  #调用局部的 indef() 函数
  other_def()
  
  调用局部函数
  ```

  - 通过返回值为函数的形式，可以扩大局部函数的作用域。

###### 闭包函数

- 闭包，又称闭包函数或者闭合函数，其实和前面讲的嵌套函数类似，不同之处在于，闭包中外部函数返回的不是一个具体的值，而是一个函数。一般情况下，返回的函数会赋值给一个变量，这个变量可以在后面被继续执行调用。

- 计算一个数的 n 次幂，用闭包可以写成下面的代码

  ```
  #闭包函数，其中 exponent 称为自由变量
  def nth_power(exponent):
      def exponent_of(base):
          return base ** exponent
      return exponent_of # 返回值是 exponent_of 函数
  square = nth_power(2) # 计算一个数的平方
  cube = nth_power(3) # 计算一个数的立方
  print(square(2))  # 计算 2 的平方
  print(cube(2)) # 计算 2 的立方
  
  4
  8
  ```

  - 外部函数 nth_power() 的返回值是函数 exponent_of()，而不是一个具体的数值。

  - 在执行完 square = nth_power(2) 和 cube = nth_power(3) 后，外部函数 nth_power() 的参数 exponent 会和内部函数 exponent_of 一起赋值给 squre 和 cube，这样在之后调用 square(2) 或者 cube(2) 时，程序就能顺利地输出结果，而不会报错说参数 exponent 没有定义。

  - 读者可能会问，为什么要闭包呢？上面的程序，完全可以写成下面的形式：

    ```
    def nth_power_rewrite(base, exponent):
        return base ** exponent
    ```

  - 上面程序确实可以实现相同的功能，不过使用闭包，可以让程序变得更简洁易读。设想一下，比如需要计算很多个数的平方

    ```python
    # 不使用闭包
    res1 = nth_power_rewrite(base1, 2)
    res2 = nth_power_rewrite(base2, 2)
    res3 = nth_power_rewrite(base3, 2)
    # 使用闭包
    square = nth_power(2)
    res1 = square(base1)
    res2 = square(base2)
    res3 = square(base3)
    ```

  - 和缩减嵌套函数的优点类似，函数开头需要做一些额外工作，当需要多次调用该函数时，如果将那些额外工作的代码放在外部函数，就可以减少多次调用导致的不必要开销，提高程序的运行效率。

- 闭包比普通的函数多了一个 `__closure__` 属性，该属性记录着自由变量的地址。当闭包被调用时，系统就会根据该地址找到对应的自由变量，完成整体的函数调用。

  - 以 nth_power() 为例，当其被调用时，可以通过 `__closure__` 属性获取自由变量（也就是程序中的 exponent 参数）存储的地址，

    ```
    def nth_power(exponent):
        def exponent_of(base):
            return base ** exponent
        return exponent_of
    square = nth_power(2)
    #查看 __closure__ 的值
    print(square.__closure__)
    
    (<cell at 0x0000014454DFA948: int object at 0x00000000513CC6D0>,)
    ```

    - 可以看到，显示的内容是一个 int 整数类型，这就是 square 中自由变量 exponent 的初始值。还可以看到，`__closure__` 属性的类型是一个元组，这表明闭包可以支持多个自由变量的形式。

###### lambda函数

- lambda 表达式，又称匿名函数，常用来表示内部仅包含 1 行表达式的函数。如果一个函数的函数体仅有 1 行表达式，则该函数就可以用 lambda 表达式来代替。

  ```
  name = lambda [list] : 表达式
  ```

  - 定义 lambda 表达式，必须使用 lambda 关键字；[list] 作为可选参数，等同于定义函数是指定的参数列表；value 为该表达式的名称。

- 举个例子，如果设计一个求 2 个数之和的函数，使用普通函数的方式

  ```
  def add(x, y):
      return x+ y
  print(add(3,4))
  
  7
  
  add = lambda x,y:x+y
  print(add(3,4))
  
  7
  ```

- 可以这样理解 lambda 表达式，其就是简单函数（函数体仅是单行的表达式）的简写版本。相比函数，lamba 表达式具有以下 2 个优势：

  - 对于单行函数，使用 lambda 表达式可以省去定义函数的过程，让代码更加简洁；
  - 对于不需要多次复用的函数，使用 lambda 表达式可以在用完之后立即释放，提高程序执行的性能。

###### eval()和exec()

- eval() 和 exec() 函数的功能是相似的，都可以执行一个字符串形式的 Python 代码（代码以字符串的形式提供），相当于一个 Python 的解释器。二者不同之处在于，eval() 执行完要返回结果，而 exec() 执行完不返回结果

  ```
  eval(source, globals=None, locals=None, /)
  
  exec(source, globals=None, locals=None, /)
  ```

  - 二者的语法格式除了函数名，其他都相同，其中各个参数的具体含义如下：

    - expression：这个参数是一个字符串，代表要执行的语句 。该语句受后面两个字典类型参数 globals 和 locals 的限制，只有在 globals 字典和 locals 字典作用域内的函数和变量才能被执行。
    - globals：这个参数管控的是一个全局的命名空间，即 expression 可以使用全局命名空间中的函数。如果只是提供了 globals 参数，而没有提供自定义的 `__builtins__`，则系统会将当前环境中的 `__builtins__` 复制到自己提供的 globals 中，然后才会进行计算；如果连 globals 这个参数都没有被提供，则使用 Python 的全局命名空间。
    - locals：这个参数管控的是一个局部的命名空间，和 globals 类似，当它和 globals 中有重复或冲突时，以 locals 的为准。如果 locals 没有被提供，则默认为 globals。
    - `__builtins__` 是 Python 的内建模块，平时使用的 int、str、abs 都在这个模块中。通过 print(dic["`__builtins__`"]) 语句可以查看 `__builtins__` 所对应的 value。

    ```
    通过如下的例子来演示参数 globals 作用域的作用，注意观察它是何时将 __builtins__ 复制 globals 字典中去的
    dic={} #定义一个字
    dic['b'] = 3 #在 dic 中加一条元素，key 为 b
    print (dic.keys()) #先将 dic 的 key 打印出来，有一个元素 b
    exec("a = 4", dic) #在 exec 执行的语句后面跟一个作用域 dic
    print(dic.keys()) #exec 后，dic 的 key 多了一个
    
    dict_keys(['b'])
    dict_keys(['b', '__builtins__', 'a'])
    ```

    - 上面的代码是在作用域 dic 下执行了一句 a = 4 的代码。可以看出，exec() 之前 dic 中的 key 只有一个 b。执行完 exec() 之后，系统在 dic 中生成了两个新的 key，分别是 a 和 `__builtins__`。其中，a 为执行语句生成的变量，系统将其放到指定的作用域字典里；`__builtins__` 是系统加入的内置 key。

    - locals参数的用法就很简单了

      ```
      a=10
      b=20
      c=30
      g={'a':6, 'b':8} #定义一个字典
      t={'b':100, 'c':10} #定义一个字典
      print(eval('a+b+c', g, t)) #定义一个字典 116
      
      116
      ```

- exe()和eval()的区别

  - 它们的区别在于，eval() 执行完会返回结果，而 exec() 执行完不返回结果。

    ```
    a = 1
    exec("a = 2") #相当于直接执行 a=2
    print(a)
    a = exec("2+3") #相当于直接执行 2+3，但是并没有返回值，a 应为 None
    print(a)
    a = eval('2+3') #执行 2+3，并把结果返回给 a
    print(a)
    
    2
    None
    5
    ```

    - exec() 中最适合放置运行后没有结果的语句，而 eval() 中适合放置有结果返回的语句。

    - 如果 eval() 里放置一个没有结果返回的语句

      ```
      a= eval("a = 2")
      ```

    - 这时 Python 解释器会报 SyntaxError 错误，提示 eval() 中不识别等号语法。

- 应用场景

  - 在使用 Python 开发服务端程序时，这两个函数应用得非常广泛。例如，客户端向服务端发送一段字符串代码，服务端无需关心具体的内容，直接跳过 eval() 或 exec() 来执行，这样的设计会使服务端与客户端的耦合度更低，系统更易扩展。
  - 另外，如果读者以后接触 [TensorFlow](http://c.biancheng.net/tensorflow/) 框架，就会发现该框架中的静态图就是类似这个原理实现的：
    - TensorFlow 中先将张量定义在一个静态图里，这就相当将键值对添加到字典里一样；
    - TensorFlow 中通过 session 和张量的 eval() 函数来进行具体值的运算，就当于使用 eval() 函数进行具体值的运算一样。
  - 需要注意的是，在使用 eval() 或是 exec() 来处理请求代码时，函数 eval() 和 exec() 常常会被黑客利用，成为可以执行系统级命令的入口点，进而来攻击网站。解决方法是：通过设置其命名空间里的可执行函数，来限制 eval() 和 exec() 的执行范围。

- 使用 exec() 和 eval() 函数时，一定要记住，它们的第一个参数是字符串，而字符串的内容一定要是可执行的代码。

- 以 eval() 函数为例，用代码演示常犯的错误

  ```
  s="hello"
  print(eval(s))
  
  Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\demo.py", line 2, in <module>
      print(eval(s))
    File "<string>", line 1, in <module>
  NameError: name 'hello' is not defined
  ```

  - 上面例子出错的地方在于，字符串的内容是 hello，而 hello 并不是可执行的代码（除非定义了一个变量叫作 hello）。

  - 如果要将字符串 hello 通过 print 函数打印出来

    ```
    s="hello"
    print(eval('s'))
    
    hello
    ```

    - 这种写法是要 eval() 执行 "hello" 这句代码。这个 hello 是有引号的，在代码中代表字符串的意思，所以可以执行。

  - 同理，也可以写成这样：

    ```
    s='"hello"' #s 是个字符串，字符串的内容是带引号的 hello
    print(eval(s))
    
    hello
    ```

    - 这种写法的意思是 s 是个字符串，并且其内容是个带引号的 hello。所以直接将 s 放入到函数 eval() 中也可以执行。

  - 除了以上这种方式，还可以不去改变原有字符串 s 的写法，直接使用 repr() 函数来进行转化，也可以得到同样的效果

    ```
    s="hello"
    print(eval(repr(s))) #使用函数 repr() 进行转化
    
    hello
    ```

  - 注意，虽然函数 eval() 与 str() 的返回值都是字符串。但是使用 str() 函数对 s 进行转化，程序同样会报错

    ```
    s="hello"
    print(eval(str(s)))
    
    Traceback (most recent call last):
      File "C:\Users\mengma\Desktop\demo.py", line 2, in <module>
        print(eval(str(s)))
      File "<string>", line 1, in <module>
    NameError: name 'hello' is not defined
    ```

  - 为什么会有这个区别呢？同样对带字符串 s 的转化，使用 repr() 与 str() 得到的结果是有差别的，直接将二者的结果打印出来，就可以很明显地看出不同。见下面代码：

    ```
    s="hello"
    print(repr(s))
    print(str(s))
    
    'hello'
    hello
    ```

    - 可见使用 repr() 返回的内容，输出后会在两边多一个单引号。

  - 在编写代码时，一般会使 repr() 函数来生成动态的字符串，再传入到 eval() 或 exec() 函数内，实现动态执行代码的功能。

###### 函数式编程

- 所谓函数式编程，是指代码中每一块都是不可变的，都由纯函数的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出。

- 除此之外，函数式编程还具有一个特点，即允许把函数本身作为参数传入另一个函数，还允许返回一个函数。

- 例如，想让列表中的元素值都变为原来的两倍，可以使用如下函数实现：

  ```
  def multiply_2(list):
      for index in range(0, len(list)):
          list[index] *= 2
      return list
  ```

  - 需要注意的是，这段代码不是一个纯函数的形式，因为列表中元素的值被改变了，如果多次调用 multiply_2() 函数，那么每次得到的结果都不一样。

  - 而要想让 multiply_2() 成为一个纯函数的形式，就得重新创建一个新的列表并返回

    ```
    def multiply_2_pure(list):
        new_list = []
        for item in list:
            new_list.append(item * 2)
        return new_list
    ```

- 函数式编程的优点，主要在于其纯函数和不可变的特性使程序更加健壮，易于调试和测试；缺点主要在于限制多，难写。

- Python 允许使用变量，所以它并不是一门纯函数式编程语言。Python 仅对函数式编程提供了部分支持，主要包括 map()、filter() 和 reduce() 这 3 个函数，它们通常都结合 lambda 匿名函数一起使用。接下来就对这 3 个函数的用法做逐一介绍。

- map() 函数的基本语法格式

  ```
  map(function, iterable)
  ```

  - function 参数表示要传入一个函数，其可以是内置函数、自定义函数或者 lambda 匿名函数；iterable 表示一个或多个可迭代对象，可以是列表、字符串等。

  - map() 函数的功能是对可迭代对象中的每个元素，都调用指定的函数，并返回一个 map 对象。

  - 该函数返回的是一个 map 对象，不能直接输出，可以通过 for 循环或者 list() 函数来显示。

    ```
    listDemo = [1, 2, 3, 4, 5]
    new_list = map(lambda x: x * 2, listDemo)
    print(list(new_list))
    
    [2， 4， 6， 8， 10]
    
    map() 函数可传入多个可迭代对象作为参数。
    listDemo1 = [1, 2, 3, 4, 5]
    listDemo2 = [3, 4, 5, 6, 7]
    new_list = map(lambda x,y: x + y, listDemo1,listDemo2)
    print(list(new_list))
    
    [4, 6, 8, 10, 12]
    ```

  - 由于 map() 函数是直接由用 C 语言写的，运行时不需要通过 Python 解释器间接调用，并且内部做了诸多优化，所以相比其他方法，此方法的运行效率最高。

- filter()函数的基本语法格式

  ```
  filter(function, iterable)
  ```

  - 此格式中，funcition 参数表示要传入一个函数，iterable 表示一个可迭代对象。

  - filter() 函数的功能是对 iterable 中的每个元素，都使用 function 函数判断，并返回 True 或者 False，最后将返回 True 的元素组成一个新的可遍历的集合。

    ```
    返回一个列表中的所有偶数。
    listDemo = [1, 2, 3, 4, 5]
    new_list = filter(lambda x: x % 2 == 0, listDemo)
    print(list(new_list))
    
    [2, 4]
    
    filter() 函数可以接受多个可迭代对象。
    listDemo = [1, 2, 3, 4, 5]
    new_list = map(lambda x,y: x-y>0,[3,5,6],[1,5,8] )
    print(list(new_list))
    
    [True, False, False]
    ```

- reduce() 函数通常用来对一个集合做一些累积操作

  ```
  reduce(function, iterable)
  ```

  - function 规定必须是一个包含 2 个参数的函数；iterable 表示可迭代对象。

  - 由于 reduce() 函数在 Python 3.x 中已经被移除，放入了 functools 模块，因此在使用该函数之前，需先导入 functools 模块。

  - 计算某个列表元素的乘积。

    ```
    import functools
    listDemo = [1, 2, 3, 4, 5]
    product = functools.reduce(lambda x, y: x * y, listDemo)
    print(product)
    
    120
    ```

- 通常来说，当对集合中的元素进行一些操作时，如果操作非常简单，比如相加、累积这种，那么应该优先考虑使用 map()、filter()、reduce() 实现。另外，在数据量非常多的情况下（比如机器学习的应用），一般更倾向于函数式编程的表示，因为效率更高。

- 当然，在数据量不多的情况下，使用 for 循环等方式也可以。不过，如果要对集合中的元素做一些比较复杂的操作，考虑到代码的可读性，通常会使用 for 循环。

###### 函数注解

- 函数注解是 Python 3 最独特的功能之一，关于它的介绍，官方文档是这么说的，“函数注解是关于用户自定义函数使用类型的完全可选的元信息”。也就是说，官方将函数注解的用途归结为：为函数中的形参和返回值提供类型提示信息。

- 下面是对 Python 官方文档中的示例稍作修改后的程序，可以很好的展示如何定义并获取函数注解：

  ```
  def f(ham:str,egg:str='eggs')->str:
    pass
  print(f.__annotations__)
  
  {'ham': <class 'str'>, 'egg': <class 'str'>, 'return': <class 'str'>}
  ```

  - 如上所示，给函数中的参数做注解的方法是在形参后添加冒号“：”，后接需添加的注解（可以是类（如 str、int 等），也可以是字符串或者表示式）；给返回值做注解的方法是将注解添加到 def 语句结尾的冒号和 -> 之间。
  - 如果参数有默认值，参数注解位于冒号和等号之间。比如 eggs:str='eggs'，它表示 eggs 参数的默认值为 'eggs'，添加的注解为 str。

- 给函数定义好注解之后，可以通过函数对象的 __annotations__ 属性获取，它是一个字典，在应用运行期间可以获取

  ```
  def square(number:"一个数字")->"返回number的平方":
    return number**2
  print(square(10))
  print(square.__annotations__)
  
  100
  {'number': '一个数字', 'return': '返回number的平方'}
  ```

- 事实上，函数注解并不局限于类型提示，而且在 Python 及其标准库中也没有单个功能可以利用这种注解，这也是这个功能独特的原因。

- 函数注解没有任何语法上的意义，只是为函数参数和返回值做注解，并在运行获取这些注解，仅此而已。换句话说，为函数做的注解，Python不做检查，不做强制，不做验证，什么操作都不做，函数注解对Python解释器没任何意义。

- PEP 3107 作为提议函数注解的官方文档，其中列出了以下可能的使用场景：

  - 提供类型信息：包括类型检查、让 IDE 显示函数接受和返回的类型、适配、与其他语言的桥梁、数据库查询映射、RPC参数编组等；
  - 其他信息：函数参数和返回值的文档。

- 总之，虽然函数注解存在的时间和 Python 3 一样长，但目前仍未找到任一常见且积极维护的包，将函数注解用作类型检查之外的功能。Python 3 最初发布时包含函数注解的最初目的也仅是用于试验和玩耍。 

#### 类和对象

- Python 语言在设计之初，就定位为一门面向对象的编程语言，“Python 中一切皆对象”就是对 Python 这门编程语言的完美诠释。类和对象是 Python 的重要特征，相比其它面向对象语言，Python 很容易就可以创建出一个类和对象。同时，Python 也支持面向对象的三大特征：封装、继承和多态。

- 无论是类属性还是类方法，对于类来说，它们都不是必需的，可以有也可以没有。另外，Python 类中属性和方法所在的位置是任意的，即它们之间并没有固定的前后次序。

- 给类起好名字之后，其后要跟有冒号（：），表示告诉 Python 解释器，下面要开始设计类的内部功能了，也就是编写类属性和类方法。

- 其实，类属性指的就是包含在类中的变量；而类方法指的是包含类中的函数。换句话说，类属性和类方法其实分别是包含类中的变量和函数的别称。需要注意的一点是，同属一个类的所有类属性和类方法，要保持统一的缩进格式，通常统一缩进 4 个空格。

  ```
  class TheFirstDemo:
      '''这是一个学习Python定义的第一个类'''
      # 下面定义了一个类属性
      add = 'http://c.biancheng.net'
      # 下面定义了一个say方法
      def say(self, content):
          print(content)
  ```

  - 和函数一样，我们也可以为类定义说明文档，其要放到类头之后，类体之前的位置，如上面程序中第二行的字符串，就是 TheFirstDemo 这个类的说明文档。
  - 分析上面的代码可以看到，我们创建了一个名为 TheFirstDemo 的类，其包含了一个名为 add 的类属性。注意，根据定义属性位置的不同，在各个类方法之外定义的变量称为类属性或类变量（如 add 属性），而在类方法中定义的属性称为实例属性（或实例变量）
  - say() 是一个实例方法，除此之外，Python 类中还可以定义类方法和静态方法

###### \__init__()类构造方法

- 在创建类时，我们可以手动添加一个 `__init__()` 方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。

- 构造方法用于创建对象时使用，每当创建一个类的实例对象时，[Python](http://c.biancheng.net/python/) 解释器都会自动调用它。[Python](http://c.biancheng.net/python/) 类中，手动添加构造方法的语法格式如下：

  ```
  def __init__(self,...):
      代码块
  ```

  - 此方法的方法名中，开头和结尾各有 2 个下划线，且中间不能有空格。Python 中很多这种以双下划线开头、双下划线结尾的方法，都具有特殊的意义

- \__init__() 方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。也就是说，类的构造方法最少也要有一个 self 参数。例如，仍以 TheFirstDemo 类为例，添加构造方法的代码如下所示

  ```python
  class TheFirstDemo:
      '''这是一个学习Python定义的第一个类'''
      #构造方法
      def __init__(self):
          print("调用构造方法")
      # 下面定义了一个类属性
      add = 'http://c.biancheng.net'
      # 下面定义了一个say方法
      def say(self, content):
          print(content)
  ```

  - 即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法。
  - 仅包含 self 参数的 \__init__() 构造方法，又称为类的默认构造方法。

- 在 \__init__() 构造方法中，除了 self 参数外，还可以自定义一些参数，参数之间使用逗号“,”进行分割

  ```python
  class CLanguage:
      '''这是一个学习Python定义的一个类'''
      def __init__(self,name,add):
          print(name,"的网址为:",add)
  #创建 add 对象，并传递参数给构造函数
  add = CLanguage("C语言中文网","http://c.biancheng.net")
  ```

  - 由于创建对象时会调用类的构造方法，如果构造函数有多个参数时，需要手动传递参数
  - 虽然构造方法中有 self、name、add 3 个参数，但实际需要传参的仅有 name 和 add，也就是说，self 不需要手动传递参数。

###### 类对象的创建和使用

- 创建类对象的过程，又称为类的实例化。

- 对已定义好的类进行实例化

  ```
  类名(参数)
  ```

  - 定义类时，如果没有手动添加\__init\__() 构造方法，又或者添加的 \__init__() 中仅有一个 self 参数，则创建类对象时的参数可以省略不写。

- 如下代码创建了名为 CLanguage 的类，并对其进行了实例化：

  ```
  class CLanguage :
      # 下面定义了2个类变量
      name = "C语言中文网"
      add = "http://c.biancheng.net"
      def __init__(self,name,add):
          #下面定义 2 个实例变量
          self.name = name
          self.add = add
          print(name,"网址为：",add)
      # 下面定义了一个say实例方法
      def say(self, content):
          print(content)
  # 将该CLanguage对象赋给clanguage变量
  clanguage = CLanguage("C语言中文网","http://c.biancheng.net")
  ```

  - 在上面的程序中，由于构造方法除 self 参数外，还包含 2 个参数，且这 2 个参数没有设置默认参数，因此在实例化类对象时，需要传入相应的 name 值和 add 值（self 参数是特殊参数，不需要手动传值，Python 会自动传给它值）。
  - 类变量和实例变量，简单地理解，定义在各个类方法之外（包含在类中）的变量为类变量（或者类属性），定义在类方法中的变量为实例变量（或者实例属性）

- 定义的类只有进行实例化，也就是使用该类创建对象之后，才能得到利用。总的来说，实例化后的类对象可以执行以下操作：

  - 访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量；
  - 调用类对象的方法，包括调用现有的方法，以及给类对象动态添加方法。
  
- 使用已创建好的类对象访问类中实例变量的语法格式如下：

  ```
  类对象名.变量名
  ```

- 使用类对象调用类中方法的语法格式如下：

  ```
  对象名.方法名(参数)
  ```

- Python 支持为已创建好的对象动态增加实例变量，方法也很简单，这里的动态是对一个实例化对象添加，不是为定义的类添加

  ```
  # 为clanguage对象增加一个money实例变量
  clanguage.money= 159.9
  print(clanguage.money)
  
  159.9
  ```

  - 通过直接增加一个新的实例变量并为其赋值，就成功地为 clanguage 对象添加了 money 变量。

- 既然能动态添加，那么是否能动态删除呢？答案是肯定的，使用 del 语句即可实现

  ```
  #删除新添加的 money 实例变量
  del clanguage.money
  #再次尝试输出 money，此时会报错
  print(clanguage.money)
  ```

- 给类对象动态添加方法，为 clanguage 对象动态增加的方法，Python 不会自动将调用者自动绑定到第一个参数（即使将第一个参数命名为 self 也没用）

  ```
  # 先定义一个函数
  def info(self):
      print("---info函数---", self)
  # 使用info对clanguage的foo方法赋值（动态绑定方法）
  clanguage.foo = info
  # Python不会自动将调用者绑定到第一个参数，
  # 因此程序需要手动将调用者绑定为第一个参数
  clanguage.foo(clanguage)  # ①
  # 使用lambda表达式为clanguage对象的bar方法赋值（动态绑定方法）
  clanguage.bar = lambda self: print('--lambda表达式--', self)
  clanguage.bar(clanguage) # ②
  ```

  - 上面的第 5 行和第 11 行代码分别使用函数、lambda 表达式为 clanguage 对象动态增加了方法，但对于动态增加的方法，Python 不会自动将方法调用者绑定到它们的第一个参数，因此程序必须手动为第一个参数传入参数值，如上面程序中 ① 号、② 号代码所示。

- 有读者可能会问，有没有不用手动给 self 传值的方法呢？通过借助 types 模块下的 MethodType 可以实现，仍以上面的 info() 函数为例：

  ```
  def info(self,content):
      print("C语言中文网地址为：%s" % content)
  # 导入MethodType
  from types import MethodType
  clanguage.info = MethodType(info, clanguage)
  # 第一个参数已经绑定了，无需传入
  clanguage.info("http://c.biancheng.net")
  ```

  - 可以看到，由于使用 MethodType 包装 info() 函数时，已经将该函数的 self 参数绑定为 clanguage，因此后续再使用 info() 函数时，就不用再给 self 参数绑定值了。

###### self用法

- 在定义类的过程中，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将 self 参数作为方法的第一个参数。例如，定义一个 Person 类：

  ```
  class Person:
      def __init__(self):
          print("正在执行构造方法")
      # 定义一个study()实例方法
      def study(self,name):
          print(name,"正在学Python")
  ```

- 事实上，Python 只是规定，无论是构造方法还是实例方法，最少要包含一个参数，并没有规定该参数的具体名称。之所以将其命名为 self，只是程序员之间约定俗成的一种习惯，遵守这个约定，可以使我们编写的代码具有更好的可读性（大家一看到 self，就知道它的作用）。

- 那么，self 参数的具体作用是什么呢？打个比方，如果把类比作造房子的图纸，那么类实例化后的对象是真正可以住的房子。根据一张图纸（类），我们可以设计出成千上万的房子（类对象），每个房子长相都是类似的（都有相同的类变量和类方法），但它们都有各自的主人，那么如何对它们进行区分呢？当然是通过 self 参数，它就相当于每个房子的门钥匙，可以保证每个房子的主人仅能进入自己的房子（每个类对象只能调用自己的类变量和类方法）。其实 Python 类方法中的 self 参数就相当于 C++ 中的 this 指针。

- 也就是说，同一个类可以产生多个对象，当某个对象调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，换句话说，Python 会自动绑定类方法的第一个参数指向调用该方法的对象。如此，Python解释器就能知道到底要操作哪个对象的方法了。

- 因此，程序在调用实例方法和构造方法时，不需要手动为第一个参数传值。例如，更改前面的 Person 类

  ```
  class Person:
      def __init__(self):
          print("正在执行构造方法")
      # 定义一个study()实例方法
      def study(self):
          print(self,"正在学Python")
  zhangsan = Person()
  zhangsan.study()
  lisi = Person()
  lisi.study()
  ```

  - 上面代码中，study() 中的 self 代表该方法的调用者，即谁调用该方法，那么 self 就代表谁。因此，该程序的运行结果为：

    ```
    正在执行构造方法
    <__main__.Person object at 0x0000021ADD7D21D0> 正在学Python
    正在执行构造方法
    <__main__.Person object at 0x0000021ADD7D2E48> 正在学Python
    ```

- 另外，对于构造函数中的 self 参数，其代表的是当前正在初始化的类对象

  ```
  class Person:
      name = "xxx"
      def __init__(self,name):
          self.name=name
  zhangsan = Person("zhangsan")
  print(zhangsan.name)
  lisi = Person("lisi")
  print(lisi.name)
  
  zhangsan
  lisi
  ```

  - 可以看到，zhangsan 在进行初始化时，调用的构造函数中 self 代表的是 zhangsan；而 lisi 在进行初始化时，调用的构造函数中 self 代表的是 lisi。

- 值得一提的是，除了类对象可以直接调用类方法，还有一种函数调用的方式

  ```
  class Person:
      def who(self):
          print(self)
  zhangsan = Person()
  #第一种方式
  zhangsan.who()
  #第二种方式
  who = zhangsan.who   //相当于函数指针，将函数名给函数指针，然后通过函数指针调用，这样函数名代表地址就不用写()，但是下面要写
  who()#通过 who 变量调用zhangsan对象中的 who() 方法
  
  
  <__main__.Person object at 0x0000025C26F021D0>
  <__main__.Person object at 0x0000025C26F021D0>
  ```

  - 无论采用哪种方法，self 所表示的都是实际调用该方法的对象。

###### 类变量和实例变量

- 无论是类属性还是类方法，都无法像普通变量或者函数那样，在类的外部直接使用它们。我们可以将类看做一个独立的空间，则类属性其实就是在类体中定义的变量，类方法是在类体中定义的函数。

- 在类体中，根据变量定义的位置不同，以及定义的方式不同，类属性又可细分为以下 3 种类型：

  1. 类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；
  2. 类体中，所有函数内部：以“self.变量名”的方式定义的变量，称为实例属性或实例变量；
  3. 类体中，所有函数内部：以“变量名=变量值”的方式定义的变量，称为局部变量。

- 类变量指的是在类中，但在各个类方法外定义的变量

  ```
  class CLanguage :
      # 下面定义了2个类变量
      name = "C语言中文网"
      add = "http://c.biancheng.net"
      # 下面定义了一个say实例方法
      def say(self, content):
          print(content)
  ```

  - 类变量的特点是，所有类的实例化对象都同时共享类变量，也就是说，类变量在所有实例化对象中是作为公用资源存在的。类方法的调用方式有 2 种，既可以使用类名直接调用，也可以使用类的实例化对象调用。

    ```
    #使用类名直接调用
    print(CLanguage.name)
    print(CLanguage.add)
    #修改类变量的值
    CLanguage.name = "Python教程"
    CLanguage.add = "http://c.biancheng.net/python"
    print(CLanguage.name)
    print(CLanguage.add)
    
    C语言中文网
    http://c.biancheng.net
    Python教程
    http://c.biancheng.net/python
    ```

  - 也可以使用类对象来调用所属类中的类变量（此方式不推荐使用）

  - 因为类变量为所有实例化对象共有，通过类名修改类变量的值，会影响所有的实例化对象

  - 通过类对象是无法修改类变量的。通过类对象对类变量赋值，其本质将不再是修改类变量的值，而是在给该对象定义新的实例变量

  - 除了可以通过类名访问类变量之外，还可以动态地为类和对象添加类变量

    ```
    clang = CLanguage()
    CLanguage.catalog = 13
    print(clang.catalog)
    
    13
    ```

- 实例变量指的是在任意类方法内部，以“self.变量名”的方式定义的变量，其特点是只作用于调用方法的对象。另外，实例变量只能通过对象名访问，无法通过类名访问。

  ```
  class CLanguage :
      def __init__(self):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
      # 下面定义了一个say实例方法
      def say(self):
          self.catalog = 13
  ```

  - name、add 以及 catalog 都是实例变量。其中，由于 `__init__()` 函数在创建类对象时会自动调用，而 say() 方法需要类对象手动调用。因此，CLanguage 类的类对象都会包含 name 和 add 实例变量，而只有调用了 say() 方法的类对象，才包含 catalog 实例变量。

  - 通过类对象可以访问类变量，但无法修改类变量的值。这是因为，通过类对象修改类变量的值，不是在给“类变量赋值”，而是定义新的实例变量

    ```
    clang = CLanguage()
    #clang访问类变量
    print(clang.name)
    print(clang.add)
    clang.name = "Python教程"
    clang.add = "http://c.biancheng.net/python"
    #clang实例变量的值
    print(clang.name)
    print(clang.add)
    #类变量的值
    print(CLanguage.name)
    print(CLanguage.add)
    
    C语言中文网
    http://c.biancheng.net
    Python教程
    http://c.biancheng.net/python
    C语言中文网
    http://c.biancheng.net
    
    通过类对象是无法修改类变量的值的，本质其实是给 clang 对象新添加 name 和 add 这 2 个实例变量。
    ```

- 局部变量直接以“变量名=值”的方式进行定义

  ```
  class CLanguage :
      # 下面定义了一个say实例方法
      def count(self,money):
          sale = 0.8*money
          print("优惠后的价格为：",sale)
  clang = CLanguage()
  clang.count(100)
  ```

  - 定义局部变量是为了所在类方法功能的实现。需要注意的一点是，局部变量只能用于所在函数中，函数执行完成后，局部变量也会被销毁。

###### 实例方法、静态方法和类方法

- 和类属性一样，类方法也可以进行更细致的划分，具体可分为类方法、实例方法和静态方法。

- 和类属性的分类不同，对于初学者来说，区分这 3 种类方法是非常简单的，即采用 @classmethod 修饰的方法为类方法；采用 @staticmethod 修饰的方法为静态方法；不用任何修改的方法为实例方法。其中 @classmethod 和 @staticmethod 都是函数装饰器

- 通常情况下，在类中定义的方法默认都是实例方法。前面章节中，我们已经定义了不只一个实例方法。不仅如此，类的构造方法理论上也属于实例方法，只不过它比较特殊。

  - 实例方法最大的特点就是，它最少也要包含一个 self 参数，用于绑定调用此方法的实例对象（Python 会自动完成绑定）。实例方法通常会用类对象直接调用

  - Python 也支持使用类名调用实例方法，但此方式需要手动给 self 参数传值

    ```
    #类名调用实例方法，需手动给 self 参数传值
    clang = CLanguage()
    CLanguage.say(clang)
    ```

- 类方法和实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为 cls，Python 会自动将类本身绑定给 cls 参数（注意，绑定的不是类对象）。也就是说，我们在调用类方法时，无需显式为 cls 参数传参。和 self 一样，cls 参数的命名也不是规定的（可以随意命名），只是 Python 程序员约定俗称的习惯而已。和实例方法最大的不同在于，类方法需要使用`＠classmethod`修饰符进行修饰

  ```
  class CLanguage:
      #类构造方法，也属于实例方法
      def __init__(self):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
      #下面定义了一个类方法
      @classmethod
      def info(cls):
          print("正在调用类方法",cls)
          
  正在调用类方法 <class '__main__.CLanguage'>
  ```

  如果没有 ＠classmethod，则 Python 解释器会将 类方法认定为实例方法，而不是类方法。

  类方法推荐使用类名直接调用，当然也可以使用实例对象来调用（不推荐）

  ```
  #使用类名直接调用类方法
  CLanguage.info()
  #使用类对象调用类方法
  clang = CLanguage()
  clang.info()
  ```

  网上的例子

  ```
  class Kls(object):
      num_inst = 0
  
      def __init__(self):
          Kls.num_inst = Kls.num_inst + 1
  
      @classmethod
      def get_no_of_instance(cls):
          return cls.num_inst
  
  
  ik1 = Kls()
  ik2 = Kls()
  
  print ik1.get_no_of_instance()
  print Kls.get_no_of_instance()
  
  在上述例子中，我们需要统计类Kls实例的个数，因此定义了一个类变量num_inst来存放实例个数。通过装饰器@classmethod的使用，方法get_no_of_instance被定义成一个类方法。在调用类方法时，Python 会将类（class Kls）传递给cls，这样在get_no_of_instance内部就可以引用类变量num_inst。
  ```

  - 类方法用于当您需要不特定于任何特定实例，但仍然以某种方式涉及类的方法时。它们最有趣的地方是可以被子类覆盖

  - 如果您有一个类MyClass和一个在MyClass(工厂、依赖注入存根等)上操作的模块级函数，那么将它设置为classmethod。然后它将对子类可用。

  - 工厂方法(可选构造函数)确实是类方法的一个经典例子。

  - 基本上，只要您希望有一个方法自然地适合于类的名称空间，但又不与类的特定实例关联，那么类方法就非常适合。

  - 因为类方法传入的参数是类，并不是类的实例，所以我们可以在类方法里面通过这个类声明一个类实例对象然后返回去，相当于这个类方法返回了一个类实例对象。

    ```
    class Data(object):
    		def __init__(self, year = 2022, month = 1, day = 14)
    				self.year = year
    				self.month = month
    				self.day = day
    
    @staticmethod
    def as_str(cls, s):
    		month, day, year = s.split("/")
    		d1 = cls(year, month, day)
    		return d1;
    ```

    

- 静态方法其实就是我们学过的函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。静态方法没有类似 self、cls 这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。静态方法需要使用`＠staticmethod`修饰

  - 在开发中，我们常常需要定义一些方法，这些方法跟类有关，但在实现时并不需要引用类或者实例，例如，设置环境变量，修改另一个类的变量，等。这个时候，我们可以使用静态方法。

    ```
    IND = 'ON'
    
    
    class Kls(object):
        def __init__(self, data):
            self.data = data
    
        @staticmethod
        def checkind():
            return IND == 'ON'
    
        def do_reset(self):
            if self.checkind():
                print('Reset done for: %s' % self.data)
    
        def set_db(self):
            if self.checkind():
                print('DB connection made for: %s' % self.data)
                
    在代码中，我们定义了一个全局变量IND，由于IND跟类Kls相关，所以我们将方法checkind放置在类Kls中定义。方法checkind只需检查IND的值，而不需要引用类或者实例，因此，我们将方法checkind定义为静态方法。
    ```

    

  ```
  class CLanguage:
      @staticmethod
      def info(name,add):
          print(name,add)
  ```

  - 静态方法的调用，既可以使用类名，也可以使用类对象

    ```
    #使用类名直接调用静态方法
    CLanguage.info("C语言中文网","http://c.biancheng.net")
    #使用类对象调用静态方法
    clang = CLanguage()
    clang.info("Python教程","http://c.biancheng.net/python")
    ```

  - 在实际编程中，几乎不会用到类方法和静态方法，因为我们完全可以使用函数代替它们实现想要的功能，但在一些特殊的场景中（例如工厂模式中），使用类方法和静态方法也是很不错的选择。


###### 描述符

- [Python](http://c.biancheng.net/python/) 中，通过使用描述符，可以让程序员在引用一个对象属性时自定义要完成的工作。

- 本质上看，描述符就是一个类，只不过它定义了另一个类中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。

- 描述符是 Python 中复杂属性访问的基础，它在内部被用于实现 property、方法、类方法、静态方法和 super 类型。

- 描述符类基于以下 3 个特殊方法，换句话说，这 3 个方法组成了描述符协议：

  - \__set__(self, obj, type=None)：在设置属性时将调用这一方法（本节后续用 setter 表示）；
  - \__get__(self, obj, value)：在读取属性时将调用这一方法（本节后续用 getter 表示）；
  - \__delete__(self, obj)：对属性调用 del 时将调用这一方法。
  - 其中，实现了 setter 和 getter 方法的描述符类被称为数据描述符；反之，如果只实现了 getter 方法，则称为非数据描述符。

- 实际上，在每次查找属性时，描述符协议中的方法都由类对象的特殊方法 `__getattribute__()` 调用（注意不要和 `__getattr__()` 弄混）。也就是说，每次使用类对象.属性（或者 getattr(类对象，属性值)）的调用方式时，都会隐式地调用 `__getattribute__()`，它会按照下列顺序查找该属性：

  1. 验证该属性是否为类实例对象的数据描述符；
  2. 如果不是，就查看该属性是否能在类实例对象的 __dict__ 中找到；
  3. 最后，查看该属性是否为类实例对象的非数据描述符。

  ```
  #描述符类
  class revealAccess:
      def __init__(self, initval = None, name = 'var'):
          self.val = initval
          self.name = name
      def __get__(self, obj, objtype):
          print("Retrieving",self.name)
          return self.val
      def __set__(self, obj, val):
      
          print("updating",self.name)
          self.val = val
  class myClass:
      x = revealAccess(10,'var "x"')
      y = 5
  m = myClass()
  print(m.x)
  m.x = 20
  print(m.x)
  print(m.y)
  运行结果为：
  Retrieving var "x"
  10
  updating var "x"
  Retrieving var "x"
  20
  5
  ```

  - 从这个例子可以看到，如果一个类的某个属性有数据描述符，那么每次查找这个属性时，都会调用描述符的\\__get__() 方法，并返回它的值；同样，每次在对该属性赋值时，也会调用 \__set__() 方法。
  - 虽然上面例子中没有使用\__del__() 方法，但也很容易理解，当每次使用 del 类对象.属性（或者 delattr(类对象，属性)）语句时，都会调用该方法。

- 除了使用描述符类自定义类属性被调用时做的操作外，还可以使用 property() 函数或者 @property 装饰器

###### property()定义属性

- 前面章节中，我们一直在用“类对象.属性”的方式访问类中定义的属性，其实这种做法是欠妥的，因为它破坏了类的封装原则。正常情况下，类包含的属性应该是隐藏的，只允许通过类提供的方法来间接实现对类属性的访问和操作。

- 因此，在不破坏类封装原则的基础上，为了能够有效操作类中的属性，类中应包含读（或写）类属性的多个 getter（或 setter）方法，这样就可以通过“类对象.方法(参数)”的方式操作属性

  ```
  class CLanguage:
      #构造函数
      def __init__(self,name):
          self.name = name 
      #设置 name 属性值的函数 
      def setname(self,name):
          self.name = name
      #访问nema属性值的函数
      def getname(self):
          return self.name
      #删除name属性值的函数
      def delname(self):
          self.name="xxx"
  clang = CLanguage("C语言中文网")
  #获取name属性值
  print(clang.getname())
  #设置name属性值
  clang.setname("Python教程")
  print(clang.getname())
  #删除name属性值
  clang.delname()
  print(clang.getname())
  
  C语言中文网
  Python教程
  xxx
  ```

  - 可能有读者觉得，这种操作类属性的方式比较麻烦，更习惯使用“类对象.属性”这种方式。庆幸的是，Python 中提供了 property() 函数，可以实现在不破坏类封装原则的前提下，让开发者依旧使用“类对象.属性”的方式操作类中的属性。

- property() 函数的基本使用格式如下：

  ```
  属性名=property(fget=None, fset=None, fdel=None, doc=None)
  ```

  - fget 参数用于指定获取该属性值的类方法，fset 参数用于指定设置该属性值的方法，fdel 参数用于指定删除该属性值的方法，最后的 doc 是一个文档字符串，用于说明此函数的作用。

  - 在使用 property() 函数时，以上 4 个参数可以仅指定第 1 个、或者前 2 个、或者前 3 个，当前也可以全部指定。也就是说，property() 函数中参数的指定并不是完全随意的。

    ```
    修改上面的程序，为 name 属性配置 property() 函数
    
    class CLanguage:
        #构造函数
        def __init__(self,n):
            self.__name = n
        #设置 name 属性值的函数
        def setname(self,n):
            self.__name = n
        #访问nema属性值的函数
        def getname(self):
            return self.__name
        #删除name属性值的函数
        def delname(self):
            self.__name="xxx"
        #为name 属性配置 property() 函数
        name = property(getname, setname, delname, '指明出处')
    #调取说明文档的 2 种方式
    #print(CLanguage.name.__doc__)
    help(CLanguage.name)
    clang = CLanguage("C语言中文网")
    #调用 getname() 方法
    print(clang.name)
    #调用 setname() 方法
    clang.name="Python教程"
    print(clang.name)
    #调用 delname() 方法
    del clang.name
    print(clang.name)
    
    Help on property:
    
        指明出处
    
    C语言中文网
    Python教程
    xxx
    ```

  - 在此程序中，由于 getname() 方法中需要返回 name 属性，如果使用 self.name 的话，其本身又被调用 getname()，这将会先入无限死循环。为了避免这种情况的出现，程序中的 name 属性必须设置为私有属性，即使用 __name（前面有 2 个下划线）。有关类属性和类方法的属性设置（分为共有属性、保护属性、私有属性）

  - 当然，property() 函数也可以少传入几个参数。以上面的程序为例，我们可以修改 property() 函数如下所示

    ```
    name = property(getname, setname)
    ```

    - 这意味着，name 是一个可读写的属性，但不能删除，因为 property() 函数中并没有为 name 配置用于函数该属性的方法。也就是说，即便 CLanguage 类中设计有 delname() 函数，这种情况下也不能用来删除 name 属性。 

  - 同理，还可以像如下这样使用 property() 函数：

    ```
    name = property(getname)    # name 属性可读，不可写，也不能删除
    name = property(getname, setname,delname)    #name属性可读、可写、也可删除，就是没有说明文档
    ```

###### @property装饰器

- 既要保护类的封装特性，又要让开发者可以使用“对象.属性”的方式操作操作类属性，除了使用 property() 函数，Python 还提供了 @property 装饰器。通过 @property 装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对“（）”小括号。

- @property 的语法格式如下：

  ```
  @property
  def 方法名(self)
      代码块
  ```

- 例如，定义一个矩形类，并定义用 @property 修饰的方法操作类中的 area 私有属性

  ```
  class Rect:
      def __init__(self,area):
          self.__area = area
      @property
      def area(self):
          return self.__area
  rect = Rect(30)
  #直接通过方法名来访问 area 方法
  print("矩形的面积是：",rect.area)
  
  矩形的面积为： 30
  ```

  - 上面程序中，使用 ＠property 修饰了 area() 方法，这样就使得该方法变成了 area 属性的 getter 方法。需要注意的是，如果类中只包含该方法，那么 area 属性将是一个只读属性。
  - 也就是说，在使用 Rect 类时，无法对 area 属性重新赋值

- 而要想实现修改 area 属性的值，还需要为 area 属性添加 setter 方法，就需要用到 setter 装饰器

  ```
  @方法名.setter
  def 方法名(self, value):
      代码块
  ```

  - 为 Rect 类中的 area 方法添加 setter 方法

    ```
    @area.setter
    def area(self, value):
        self.__area = value
    ```

- 除此之外，还可以使用 deleter 装饰器来删除指定属性

  ```
  @方法名.deleter
  def 方法名(self):
      代码块
  ```

  - 在 Rect 类中，给 area() 方法添加 deleter 方法

    ```
    @area.deleter
    def area(self):
        self.__area = 0
    ```

    ```
    del rect.area
    print("删除后的area值为：",rect.area)
    
    删除后的area值为： 0
    ```

###### 封装

- 简单的理解封装（Encapsulation），即在设计类时，刻意地将一些属性和方法隐藏在类的内部，这样在使用此类时，将无法直接以“类对象.属性名”（或者“类对象.方法名(参数)”）的形式调用这些属性（或方法），而只能用未隐藏的类方法间接操作这些隐藏的属性和方法。
- 封装机制保证了类内部[数据结构](http://c.biancheng.net/data_structure/)的完整性，因为使用类的用户无法直接看到类中的数据结构，只能使用类允许公开的数据，很好地避免了外部对内部数据的影响，提高了程序的可维护性。除此之外，对一个类实现良好的封装，用户只能借助暴露出来的类方法来访问数据，我们只需要在这些暴露的方法中加入适当的控制逻辑，即可轻松实现用户对类中属性或方法的不合理操作。
- 和其它面向对象的编程语言（如 C++、Java）不同，Python 类中的变量和函数，不是公有的（类似 public 属性），就是私有的（类似 private），这 2 种属性的区别如下：
  - public：公有属性的类变量和类函数，在类的外部、类内部以及子类（后续讲继承特性时会做详细介绍）中，都可以正常访问；
  - private：私有属性的类变量和类函数，只能在本类内部使用，类的外部以及子类都无法使用。
- 但是，Python 并没有提供 public、private 这些修饰符。为了实现类的封装，Python 采取了下面的方法：
  - 默认情况下，Python 类中的变量和方法都是公有（public）的，它们的名称前都没有下划线（_）；这个是双下划线
  - 如果类中的变量和函数，其名称以双下划线“__”开头，则该变量（函数）为私有变量（私有函数），其属性等同于 private。

- 除此之外，还可以定义以单下划线“\_”开头的类属性或者类方法（例如 \_name、\_display(self)），这种类属性和类方法通常被视为私有属性和私有方法，虽然它们也能通过类对象正常访问，但这是一种约定俗称的用法，初学者一定要遵守。

- 注意，Python 类中还有以双下划线开头和结尾的类方法（例如类的构造函数\__init__(self)），这些都是 Python 内部定义的，用于 Python 内部调用。我们自己定义类属性或者类方法时，不要使用这种格式。

  ```
  class CLanguage :
      def setname(self, name):
          if len(name) < 3:
              raise ValueError('名称长度必须大于3！')
          self.__name = name
      def getname(self):
          return self.__name
      #为 name 配置 setter 和 getter 方法
      name = property(getname, setname)
      def setadd(self, add):
          if add.startswith("http://"):
              self.__add = add
          else:
              raise ValueError('地址必须以 http:// 开头') 
      def getadd(self):
          return self.__add
     
      #为 add 配置 setter 和 getter 方法
      add = property(getadd, setadd)
      #定义个私有方法
      def __display(self):
          print(self.__name,self.__add)
  clang = CLanguage()
  clang.name = "C语言中文网"
  clang.add = "http://c.biancheng.net"
  print(clang.name)
  print(clang.add)
  
  C语言中文网
  http://c.biancheng.net
  ```

  - 上面程序中，CLanguage 将 name 和 add 属性都隐藏了起来，但同时也提供了可操作它们的“窗口”，也就是各自的 setter 和 getter 方法，这些方法都是公有（public）的。

  - 不仅如此，以 add 属性的 setadd() 方法为例，通过在该方法内部添加控制逻辑，即通过调用 startswith() 方法，控制用户输入的地址必须以“http://”开头，否则程序将会执行 raise 语句抛出 ValueError 异常。

  - 通过此程序的运行逻辑不难看出，通过对 CLanguage 类进行良好的封装，使得用户仅能通过暴露的 setter() 和 getter() 方法操作 name 和 add 属性，而通过对 setname() 和 setadd() 方法进行适当的设计，可以避免用户对类中属性的不合理操作，从而提高了类的可维护性和安全性。

  - 细心的读者可能还发现，CLanguage 类中还有一个 \__display() 方法，由于该类方法为私有（private）方法，且该类没有提供操作该私有方法的“窗口”，因此我们无法在类的外部使用它。换句话说，如下调用 __display() 方法是不可行的：

    ```
    #尝试调用私有的 display() 方法
    clang.__display()
    
    Traceback (most recent call last):
      File "D:\python3.6\1.py", line 33, in <module>
        clang.__display()
    AttributeError: 'CLanguage' object has no attribute '__display'
    ```

- python封装底层原理
  - 事实上，Python 封装特性的实现纯属“投机取巧”，之所以类对象无法直接调用以双下划线开头命名的类属性和类方法，是因为其底层实现时，Python 偷偷改变了它们的名称。

  - 事实上，对于以双下划线开头命名的类属性或类方法，Python 在底层实现时，将它们的名称都偷偷改成了 "_类名__属性（方法）名" 的格式。

  - 就以 CLanguage 类中的\_\_display() 为例，Python 在底层将其方法名偷偷改成了“_CLanguage__display()”。例如，在 CLanguage 类的基础上，执行如下代码：

    ```
    clang = CLanguage()
    #调用name的setname()方法
    clang.name = "C语言中文网"
    #调用add的setadd()方法
    clang.add = "http://c.biancheng.net"
    #直接调用隐藏的display()方法
    clang._CLanguage__display()
    
    C语言中文网 http://c.biancheng.net
    ```

  - 不仅如此，那些原本我们认为是私有的类属性（例如 `__name` 和 `__add`），其底层的名称也改成了“_类名__属性名”的这种格式

  ```
  clang = CLanguage()
  clang.name = "C语言中文网"
  clang.add = "http://c.biancheng.net"
  #直接调用 name 和 add 私有属性
  print(clang._CLanguage__name,clang._CLanguage__add)
  
  C语言中文网 http://c.biancheng.net
  ```

  - 甚至于，我们还可以通过这种方式修改 clang 对象的私有属性

    ```
    clang._CLanguage__name = "Python教程"
    clang._CLanguage__add = "http://c.biancheng.net/python"
    print(clang._CLanguage__name,clang._CLanguage__add)
    
    Python教程 http://c.biancheng.net/python
    ```

  - Python 类中所有的属性和方法，都是公有（public）属性，如果希望 Python 底层修改类属性或者类方法的名称，以此将它们隐藏起来，只需将它们的名称前添加双下划线（“__”）即可。

###### 继承

- Python 中，实现继承的类称为子类，被继承的类称为父类（也可称为基类、超类）

- 子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。语法格式如下：

  ```
  class 类名(父类1, 父类2, ...)：
      #类定义部分
  ```

  - 如果该类没有显式指定继承自哪个类，则默认继承 object 类（object 类是 Python 中所有类的父类，即要么是直接父类，要么是间接父类）。另外，Python 的继承是多继承机制（和 [C++](http://c.biancheng.net/cplus/) 一样），即一个子类可以同时拥有多个直接父类。

  ```
  class People:
      def say(self):
          print("我是一个人，名字是：",self.name)
  class Animal:
      def display(self):
          print("人也是高级动物")
  #同时继承 People 和 Animal 类
  #其同时拥有 name 属性、say() 和 display() 方法
  class Person(People, Animal):
      pass
  zhangsan = Person()
  zhangsan.name = "张三"
  zhangsan.say()
  zhangsan.display()
  
  我是一个人，名字是： 张三
  人也是高级动物
  
  可以看到，虽然 Person 类为空类，但由于其继承自 People 和 Animal 这 2 个类，因此实际上 Person 并不空，它同时拥有这 2 个类所有的属性和方法。
  ```

  - 子类拥有父类所有的属性和方法，即便该属性或方法是私有（private）的，看封装的底层实现即可知道，python的封装只是投机取巧改了名字

- 事实上，大部分面向对象的编程语言，都只支持单继承，即子类有且只能有一个父类。而 Python 却支持多继承（C++也支持多继承）。和单继承相比，多继承容易让代码逻辑复杂、思路混乱，一直备受争议，中小型项目中较少使用，后来的 [Java](http://c.biancheng.net/java/)、[C#](http://c.biancheng.net/csharp/)、[PHP](http://c.biancheng.net/php/) 等干脆取消了多继承。

- 使用多继承经常需要面临的问题是，多个父类中包含同名的类方法。对于这种情况，Python 的处置措施是：根据子类继承多个父类时这些父类的前后次序决定，即排在前面父类中的类方法会覆盖排在后面父类中的同名类方法。

- 虽然 Python 在语法上支持多继承，但逼不得已，建议大家不要使用多继承。

###### 父类方法重写

- 前面讲过在 [Python](http://c.biancheng.net/python/) 中，子类继承了父类，那么子类就拥有了父类所有的类属性和类方法。通常情况下，子类会在此基础上，扩展一些新的类属性和类方法。但凡事都有例外，我们可能会遇到这样一种情况，即子类从父类继承得来的类方法中，大部分是适合子类使用的，但有个别的类方法，并不能直接照搬父类的，如果不对这部分类方法进行修改，子类对象无法使用。针对这种情况，我们就需要在子类中重复父类的方法。

- 重写，有时又称覆盖，是一个意思，指的是对类中已有方法的内部实现进行修改。

  ```
  class Bird:
      #鸟有翅膀
      def isWing(self):
          print("鸟有翅膀")
      #鸟会飞
      def fly(self):
          print("鸟会飞")
  class Ostrich(Bird):
      # 重写Bird类的fly()方法
      def fly(self):
          print("鸵鸟不会飞")
  # 创建Ostrich对象
  ostrich = Ostrich()
  #调用 Ostrich 类中重写的 fly() 类方法
  ostrich.fly()
  
  鸵鸟不会飞
  
  ostrich 调用的是重写之后的 fly() 类方法。
  ```

- 事实上，如果我们在子类中重写了从父类继承来的类方法，那么当在类的外部通过子类对象调用该方法时，Python 总是会执行子类中重写的方法。这就产生一个新的问题，即如果想调用父类中被重写的这个方法，很简单，前面讲过，Python 中的类可以看做是一个独立空间，而类方法其实就是出于该空间中的一个函数。而如果想要全局空间中，调用类空间中的函数，只需要在调用该函数是备注类名即可

  ```
  class Bird:
      #鸟有翅膀
      def isWing(self):
          print("鸟有翅膀")
      #鸟会飞
      def fly(self):
          print("鸟会飞")
  class Ostrich(Bird):
      # 重写Bird类的fly()方法
      def fly(self):
          print("鸵鸟不会飞")
  # 创建Ostrich对象
  ostrich = Ostrich()
  #调用 Bird 类中的 fly() 方法
  Bird.fly(ostrich)
  
  鸟会飞
  ```

  - 此程序中，需要大家注意的一点是，使用类名调用其类方法，Python 不会为该方法的第一个 self 参数自定绑定值，因此采用这种调用方法，需要手动为 self 参数赋值。

###### 子类化内置类型

- Python 中内置有一个 object 类，它是所有内置类型的共同祖先，也是所有没有显式指定父类的类（包括用户自定义的）的共同祖先。因此在实际编程过程中，如果想实现与某个内置类型具有类似行为的类时，最好的方法就是将这个内置类型子类化。

- 内置类型子类化，其实就是自定义一个新类，使其继承有类似行为的内置类，通过重定义这个新类实现指定的功能。

- 举个例子，如下所示创建了一个名为 newDict 的类，其中 newDictError 是自定义的异常类：

  ```
  class newDictError(ValueError):
    """如果向newDict 添加重复值，则引发此异常"""
  class newDict(dict):
    """不接受重复值的字典"""
    def __setitem__(self,key,value):
      if value in self.values():
        if ((key in self and self[key]!=value) or (key not in self)):
          raise newDictError("这个值已经存在，并对应不同的键")
      super().__setitem__(key,value)
  demoDict = newDict()
  demoDict['key']='value'
  demoDict['other_key']='value2'
  print(demoDict)
  demoDict['other_key']='value'
  print(demoDict)
  
  {'key': 'value', 'other_key': 'value2'}
  Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\demo.py", line 15, in <module>
      demoDict['other_key']='value'
    File "C:\Users\mengma\Desktop\demo.py", line 9, in __setitem__
      raise newDictError("这个值已经存在，并对应不同的键")
  newDictError: 这个值已经存在，并对应不同的键
  ```

  - 可以看到，newDict 是 Python 中 dict 类型的子类，所以其大部分行为都和 dict 内置类相同，唯一不同之处在于，newDict 不允许字典中多个键对应相同的值。如果用户试图添加具有相同值的新元素，则会引发 newDictError 异常，并给出提示信息。

  - 由于目前尚未学习如何处理异常，因此这里没有 newDictError 做任何处理，异常处理会在后续章节做详细讲解。

  - 另外，如果查看现有代码你会发现，其实很多类都是对 Python 内置类的部分实现，它们作为子类的速度更快，代码更整洁。比如，list 类型用来管理序列，如果一个类需要在内部处理序列，那么就可以对 list 进行子类化，示例代码如下：

    ```
    class myList(list):
      def __init__(self,name):
        self.name = name
      def dir(self,nesting = 0):
        offset = " " * nesting
        print("%s%s/" % (offset,self.name))
        for element in self:
          if hasattr(element , 'dir'):
            element.dir(nesting + 1)
          else:
            print("%s %s" % (offset,element))
    demoList = myList('C语言中文网')
    demoList.append('http://c.biancheng.net')
    print(demoList.dir())
    
    C语言中文网/
    http://c.biancheng.net
    None
    ```

  - 除了 Python 中常用的基本内置类型，collections 模块中还额外提供了很多有用的容器，这些容器可以满足大部分情况。

###### super()函数：调用父类的构造方法

- 前面不止一次讲过，[Python](http://c.biancheng.net/python/) 中子类会继承父类所有的类属性和类方法。严格来说，类的构造方法其实就是实例方法，因此毫无疑问，父类的构造方法，子类同样会继承。

- 但我们知道，Python 是一门支持多继承的面向对象编程语言，如果子类继承的多个父类中包含同名的类实例方法，则子类对象在调用该方法时，会优先选择排在最前面的父类中的实例方法。显然，构造方法也是如此。

  ```
  class People:
      def __init__(self,name):
          self.name = name
      def say(self):
          print("我是人，名字为：",self.name)
  class Animal:
      def __init__(self,food):
          self.food = food
      def display(self):
          print("我是动物,我吃",self.food)
  #People中的 name 属性和 say() 会遮蔽 Animal 类中的
  class Person(People, Animal):
      pass
  per = Person("zhangsan")
  per.say()
  #per.display()
  
  我是人，名字为： zhangsan
  ```

  - 上面程序中，Person 类同时继承 People 和 Animal，其中 People 在前。这意味着，在创建 per 对象时，其将会调用从 People 继承来的构造函数。因此我们看到，上面程序在创建 per 对象的同时，还要给 name 属性进行赋值。

  - 但如果去掉最后一行的注释，运行此行代码，Python 解释器会报如下错误：

    ```
    Traceback (most recent call last):
      File "D:\python3.6\Demo.py", line 18, in <module>
        per.display()
      File "D:\python3.6\Demo.py", line 11, in display
        print("我是动物,我吃",self.food)
    AttributeError: 'Person' object has no attribute 'food'
    ```

    - 这是因为，从 Animal 类中继承的 display() 方法中，需要用到 food 属性的值，但由于 People 类的构造方法“遮蔽”了Animal 类的构造方法，使得在创建 per 对象时，Animal 类的构造方法未得到执行，所以程序出错。

- 针对这种情况，正确的做法是定义 Person 类自己的构造方法（等同于重写第一个直接父类的构造方法）。但需要注意，如果在子类中定义构造方法，则必须在该方法中调用父类的构造方法。

- 在子类中的构造方法中，调用父类构造方法的方式有 2 种，分别是：

  1. 类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要额外备注类名（此方式又称为未绑定方法）；
  2. 使用 super() 函数。但如果涉及多继承，该函数只能调用第一个直接父类的构造方法。
  3. 也就是说，涉及到多继承时，在子类构造函数中，调用第一个父类构造方法的方式有以上 2 种，而调用其它父类构造方法的方式只能使用未绑定方法。

- Python 2.x 中，super() 函数的使用语法格式如下：

  ```
  super(Class, obj).__init__(self,...)
  ```

  - Class 值得是子类的类名，obj 通常指的就是 self。

- 但在 Python 3.x 中，super() 函数有一种更简单的语法格式，推荐大家使用这种格式

  ```
  super().__init__(self,...)
  ```

  ```
  class People:
      def __init__(self,name):
          self.name = name
      def say(self):
          print("我是人，名字为：",self.name)
  class Animal:
      def __init__(self,food):
          self.food = food
      def display(self):
          print("我是动物,我吃",self.food)
  class Person(People, Animal):
      #自定义构造方法
      def __init__(self,name,food):
          #调用 People 类的构造方法
          super().__init__(name)
          #super(Person,self).__init__(name) #执行效果和上一行相同
          #People.__init__(self,name)#使用未绑定方法调用 People 类构造方法
          #调用其它父类的构造方法，需手动给 self 传值
          Animal.__init__(self,food)    
  per = Person("zhangsan","熟食")
  per.say()
  per.display()
  
  我是人，名字为： zhangsan
  我是动物,我吃 熟食
  ```

  - 可以看到，Person 类自定义的构造方法中，调用 People 类构造方法，可以使用 super() 函数，也可以使用未绑定方法。但是调用 Animal 类的构造方法，只能使用未绑定方法。

- 前面已经讲解了 super() 函数的用法，值得一提的是，Python 2 中 super() 函数的用法和 Python 3 大致相同，唯一的区别在于，Python 2 中不能使用零参数形式的格式，必须提供至少一个参数。

- 对于想要编写跨版本兼容代码的程序员来说，还要注意一件事，即 Python 2 中的 super() 函数只适用于新式类，在旧式类中不能使用 super()。

- 那么，什么是旧式类和新式类呢？在早期版本的 Python 中，所有类并没有一个共同的祖先 object，如果定义一个类，但没有显式指定其祖先，那么就被解释为旧式类

- Python 2.x 版本中，为了向后兼容保留了旧式类。该版本中的新式类必须显式继承 object 或者其他新式类

- 而在 Python 3.x 版本中，不再保留旧式类的概念。因此，没有继承任何其他类的类都隐式地继承自 object。

- 可以说，在 Python 3.x 中，显式声明某个类继承自 object 似乎是冗余的。但如果考虑跨版本兼容，那么就必须将 object 作为所有基类的祖先，因为如果不这么做的话，这些类将被解释为旧式类，最终会导致难以诊断的问题。

###### super()使用注意事项

- 混用super与显示类调用，分析如下程序，C 类使用了 `__init__()` 方法调用它的基类，会造成 B 类被调用了 2 次：

  ```
  class A:
      def __init__(self):
          print("A",end=" ")
          super().__init__()
  class B:
      def __init__(self):
          print("B",end=" ")
          super().__init__()
  class C(A,B):
      def __init__(self):
          print("C",end=" ")
          A.__init__(self)
          B.__init__(self)
  print("MRO:",[x.__name__ for x in C.__mro__])
  C()
  
  MRO: ['C', 'A', 'B', 'object']
  C A B B
  ```

  - 出现以上这种情况的原因在于，C 的实例调用 `A.__init__(self)`，使得 `super(A,self).__init__()` 调用了 `B.__init__()` 方法。换句话说，super 应该被用到整个类的层次结构中。
  - 但是，有时这种层次结构的一部分位于第三方代码中，我们无法确定外部包的这些代码中是否使用 super()，因此，当需要对某个第三方类进行子类化时，最好查看其内部代码以及 MRO 中其他类的内部代码。

- 不同种类的参数，使用 super 的另一个问题是初始化过程中的参数传递。如果没有相同的签名，一个类怎么能调用其基类的 __init__() 代码呢？这会导致下列问题：

  ```
  class commonBase:
      def __init__(self):
          print("commonBase")
          super().__init__()
  class base1(commonBase):
      def __init__(self):
          print("base1")
          super().__init__()
  class base2(commonBase):
      def __init__(self):
          print("base2")
          super().__init__()
  class myClass(base1,base2):
      def __init__(self,arg):
          print("my base")
          super().__init__(arg)
  myClass(10)
  
  my base
  Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\demo.py", line 20, in <module>
      myClass(10)
    File "C:\Users\mengma\Desktop\demo.py", line 19, in __init__
      super().__init__(arg)
  TypeError: __init__() takes 1 positional argument but 2 were given
  ```

  - 一种解决方法是使用 *args 和 **kwargs 包装的参数和关键字参数，这样即使不使用它们，所有的构造函数也会传递所有参数

    ```
    class commonBase:
        def __init__(self,*args,**kwargs):
            print("commonBase")
            super().__init__()
    class base1(commonBase):
        def __init__(self,*args,**kwargs):
            print("base1")
            super().__init__(*args,**kwargs)
    class base2(commonBase):
        def __init__(self,*args,**kwargs):
            print("base2")
            super().__init__(*args,**kwargs)
    class myClass(base1,base2):
        def __init__(self,arg):
            print("my base")
            super().__init__(arg)
    myClass(10)
    
    my base
    base1
    base2
    commonBase
    ```

    - 不过，这是一种很糟糕的解决方法，由于任何参数都可以传入，所有构造函数都可以接受任何类型的参数，这会导致代码变得脆弱。另一种解决方法是在 MyClass 中显式地使用特定类的 __init__() 调用，但这无疑会导致第一种错误。

- 如果想要避免程序中出现以上的这些问题，这里给出几点建议：

  - 尽可能避免使用多继承，可以使用一些设计模式来替代它；
  - super 的使用必须一致，即在类的层次结构中，要么全部使用 super，要么全不用。混用 super 和传统调用是一种混乱的写法；
  - 如果代码需要兼容 Python 2.x，在 Python 3.x 中应该显式地继承自 object。在 Python 2.x 中，没有指定任何祖先地类都被认定为旧式类。
  - 调用父类时应提前查看类的层次结构，也就是使用类的 `__mro__` 属性或者 mro() 方法查看有关类的 MRO。

###### \__slots__:限制类实例动态添加属性和方法

- 通过学习《[Python类变量和实例变量](http://c.biancheng.net/view/2283.html)》一节，了解了如何动态的为单个实例对象添加属性，甚至如果必要的话，还可以为所有的类实例对象统一添加属性（通过给类添加属性）。

- 那么，[Python](http://c.biancheng.net/python/) 是否也允许动态地为类或实例对象添加方法呢？答案是肯定的。我们知道，类方法又可细分为实例方法、静态方法和类方法，Python 语言允许为类动态地添加这 3 种方法；但对于实例对象，则只允许动态地添加实例方法，不能添加类方法和静态方法。

- 为单个实例对象添加方法，不会影响该类的其它实例对象；而如果为类动态地添加方法，则所有的实例对象都可以使用。

  ```
  class CLanguage:
      pass
  #下面定义了一个实例方法
  def info(self):
      print("正在调用实例方法")
  #下面定义了一个类方法
  @classmethod
  def info2(cls):
      print("正在调用类方法")
  #下面定义个静态方法
  @staticmethod
  def info3():
      print("正在调用静态方法")
  #类可以动态添加以上 3 种方法，会影响所有实例对象
  CLanguage.info = info
  CLanguage.info2 = info2
  CLanguage.info3 = info3
  clang = CLanguage()
  #如今，clang 具有以上 3 种方法
  clang.info()
  clang.info2()
  clang.info3()
  #类实例对象只能动态添加实例方法，不会影响其它实例对象
  clang1 = CLanguage()
  clang1.info = info
  #必须手动为 self 传值
  clang1.info(clang1)
  
  正在调用实例方法
  正在调用类方法
  正在调用静态方法
  正在调用实例方法
  ```

- 显然，动态给类或者实例对象添加属性或方法，是非常灵活的。但与此同时，如果胡乱地使用，也会给程序带来一定的隐患，即程序中已经定义好的类，如果不做任何限制，是可以做动态的修改的。

- 庆幸的是，Python 提供了 `__slots__` 属性，通过它可以避免用户频繁的给实例对象动态地添加属性或方法。再次声明，`__slots__` 只能限制为实例对象动态添加属性和方法，而无法限制动态地为类添加属性和方法。

- `__slots__` 属性值其实就是一个元组，只有其中指定的元素，才可以作为动态添加的属性或者方法的名称。举个例子：

  ```
  class CLanguage:
      __slots__ = ('name','add','info')
  ```

  - 可以看到， CLanguage 类中指定了 `__slots__` 属性，这意味着，该类的实例对象仅限于动态添加 name、add、info 这 3 个属性以及 name()、add() 和 info() 这 3 个方法。注意，对于动态添加的方法，`__slots__` 限制的是其方法名，并不限制参数的个数。

- 比如，在 CLanguage 类的基础上，添加如下代码并运行：

  ```
  def info(self,name):
      print("正在调用实例方法",self.name)
  clang = CLanguage()
  clang.name = "C语言中文网"
  #为 clang 对象动态添加 info 实例方法
  clang.info = info
  clang.info(clang,"Python教程")
  
  正在调用实例方法 C语言中文网
  
  def info(self,name):
      print("正在调用实例方法",self.name)
  clang = CLanguage()
  clang.name = "C语言中文网"
  clang.say = info
  clang.say(clang,"Python教程")
  
  Traceback (most recent call last):
    File "D:\python3.6\1.py", line 9, in <module>
      clang.say = info
  AttributeError: 'CLanguage' object has no attribute 'say'
  ```

  - 显然，根据 `__slots__` 属性的设置，CLanguage 类的实例对象是不能动态添加以 say 为名称的方法的。

- 另外本节前面提到，`__slots__` 属性限制的对象是类的实例对象，而不是类，因此下面的代码是合法的：

  ```
  def info(self):
      print("正在调用实例方法")
  CLanguage.say = info
  clang = CLanguage()
  clang.say()
  
  正在调用实例方法
  ```

- 此外，`__slots__` 属性对由该类派生出来的子类，也是不起作用的

  ```
  class CLanguage:
      __slots__ = ('name','add','info')
  #Clanguage 的空子类
  class CLangs(CLanguage):
      pass
  #定义的实例方法
  def info(self):
      print("正在调用实例方法")
  clang = CLangs()
  #为子类对象动态添加 say() 方法
  clang.say = info
  clang.say(clang)
  
  正在调用实例方法
  ```

  - 显然，`__slots__` 属性只对当前所在的类起限制作用。
  - 因此，如果子类也要限制外界为其实例对象动态地添加属性和方法，必须在子类中设置 `__slots__` 属性。
- 注意，如果为子类也设置有 `__slots__` 属性，那么子类实例对象允许动态添加的属性和方法，是子类中 `__slots__` 属性和父类 `__slots__` 属性的和。

###### type():动态创建类

- type() 函数属于 [Python](http://c.biancheng.net/python/) 内置函数，通常用来查看某个变量的具体类型。其实，type() 函数还有一个更高级的用法，即创建一个自定义类型（也就是创建一个类）。

- type() 函数的语法格式有 2 种，分别如下：

  ```
  type(obj) 
  type(name, bases, dict)
  ```

  - 以上这 2 种语法格式，各参数的含义及功能分别是：
    - 第一种语法格式用来查看某个变量（类对象）的具体类型，obj 表示某个变量或者类对象。
    - 第二种语法格式用来创建类，其中 name 表示类的名称；bases 表示一个元组，其中存储的是该类的父类；dict 表示一个字典，用于表示类内定义的属性或者方法。

  ```
  #定义一个实例方法
  def say(self):
      print("我要学 Python！")
  #使用 type() 函数创建类
  CLanguage = type("CLanguage",(object,),dict(say = say, name = "C语言中文网"))
  #创建一个 CLanguage 实例对象
  clangs = CLanguage()
  #调用 say() 方法和 name 属性
  clangs.say()
  print(clangs.name)
  
  我要学 Python！
  C语言中文网
  ```

  - Python 元组语法规定，当 (object,) 元组中只有一个元素时，最后的逗号（,）不能省略。
  - 此程序中通过 type() 创建了类，其类名为 CLanguage，继承自 objects 类，且该类中还包含一个 say() 方法和一个 name 属性。
  - 有读者可能会问，如何判断 dict 字典中添加的是方法还是属性？很简单，如果该键值对中，值为普通变量（如 "C语言中文网"），则表示为类添加了一个类属性；反之，如果值为外部定义的函数（如 say() ），则表示为类添加了一个实例方法。
  - 可以看到，使用 type() 函数创建的类，和直接使用 class 定义的类并无差别。事实上，我们在使用 class 定义类时，Python 解释器底层依然是用 type() 来创建这个类。

###### MetaClass元类

- MetaClass元类，本质也是一个类，但和普通类的用法不同，它可以对类内部的定义（包括类属性和类方法）进行动态的修改。可以这么说，使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法。

- 举个例子，根据实际场景的需要，我们要为多个类添加一个 name 属性和一个 say() 方法。显然有多种方法可以实现，但其中一种方法就是使用 MetaClass 元类。

- 如果在创建类时，想用 MetaClass 元类动态地修改内部的属性或者方法，则类的创建过程将变得复杂：先创建 MetaClass 元类，然后用元类去创建类，最后使用该类的实例化对象实现功能。

- 和前面章节创建的类不同，如果想把一个类设计成 MetaClass 元类，其必须符合以下条件：

  1. 必须显式继承自 type 类；
  2. 类中需要定义并实现 `__new__`() 方法，该方法一定要返回该类的一个实例对象，因为在使用元类创建类时，该 `__new__`() 方法会自动被执行，用来修改新建的类。

  ```
  #定义一个元类
  class FirstMetaClass(type):
      # cls代表动态修改的类
      # name代表动态修改的类名
      # bases代表被动态修改的类的所有父类
      # attr代表被动态修改的类的所有属性、方法组成的字典
      def __new__(cls, name, bases, attrs):
          # 动态为该类添加一个name属性
          attrs['name'] = "C语言中文网"
          attrs['say'] = lambda self: print("调用 say() 实例方法")
          return super().__new__(cls,name,bases,attrs)
  ```

  - 此程序中，首先可以断定 FirstMetaClass 是一个类。其次，由于该类继承自 type 类，并且内部实现了 `__new__`() 方法，因此可以断定 FirstMetaCLass 是一个元类。

  - 可以看到，在这个元类的 `__new__`() 方法中，手动添加了一个 name 属性和 say() 方法。这意味着，通过 FirstMetaClass 元类创建的类，会额外添加 name 属性和 say() 方法

    ```
    #定义类时，指定元类
    class CLanguage(object,metaclass=FirstMetaClass):
        pass
    clangs = CLanguage()
    print(clangs.name)
    clangs.say()
    
    C语言中文网
    调用 say() 实例方法
    ```

    - 可以看到，在创建类时，通过在标注父类的同时指定元类（格式为`metaclass=元类名`），则当 [Python](http://c.biancheng.net/python/) 解释器在创建这该类时，FirstMetaClass 元类中的 `__new__` 方法就会被调用，从而实现动态修改类属性或者类方法的目的。
    - 显然，FirstMetaClass 元类的 `__new__`() 方法动态地为 Clanguage 类添加了 name 属性和 say() 方法，因此，即便该类在定义时是空类，它也依然有 name 属性和 say() 方法。
    - 对于 MetaClass 元类，它多用于创建 API，因此我们几乎不会使用到它。

- metaclass 这样“逆天”的存在，会"扭曲变形"正常的 Python 类型模型，所以，如果使用不慎，对于整个代码库造成的风险是不可估量的。换句话说，metaclass 仅仅是给小部分 Python 开发者，在开发框架层面的 Python 库时使用的。而在应用层，metaclass 往往不是很好的选择。

###### 多态

- 我们都知道，[Python](http://c.biancheng.net/python/) 是弱类型语言，其最明显的特征是在使用变量时，无需为其指定具体的数据类型。这会导致一种情况，即同一变量可能会被先后赋值不同的类对象，例如：

  ```
  class CLanguage:
      def say(self):
          print("赋值的是 CLanguage 类的实例对象")
  class CPython:
      def say(self):
          print("赋值的是 CPython 类的实例对象")
  a = CLanguage()
  a.say()
  a = CPython()
  a.say()
  
  赋值的是 CLanguage 类的实例对象
  赋值的是 CPython 类的实例对象
  ```

  - 可以看到，a 可以被先后赋值为 CLanguage 类和 CPython 类的对象，但这并不是多态。类的多态特性，还要满足以下 2 个前提条件：
    1. 继承：多态一定是发生在子类和父类之间；
    2. 重写：子类重写了父类的方法。

- 改写上面的代码

  ```
  class CLanguage:
      def say(self):
          print("调用的是 Clanguage 类的say方法")
  class CPython(CLanguage):
      def say(self):
          print("调用的是 CPython 类的say方法")
  class CLinux(CLanguage):
      def say(self):
          print("调用的是 CLinux 类的say方法")
  a = CLanguage()
  a.say()
  a = CPython()
  a.say()
  a = CLinux()
  a.say()
  
  调用的是 Clanguage 类的say方法
  调用的是 CPython 类的say方法
  调用的是 CLinux 类的say方法
  ```

  - 可以看到，CPython 和 CLinux 都继承自 CLanguage 类，且各自都重写了父类的 say() 方法。从运行结果可以看出，同一变量 a 在执行同一个 say() 方法时，由于 a 实际表示不同的类实例对象，因此 a.say() 调用的并不是同一个类中的 say() 方法，这就是多态。

- 但是，仅仅学到这里，读者还无法领略 Python 类使用多态特性的精髓。其实，Python 在多态的基础上，衍生出了一种更灵活的编程机制。

  ```
  class WhoSay:
      def say(self,who):
          who.say()
  class CLanguage:
      def say(self):
          print("调用的是 Clanguage 类的say方法")
  class CPython(CLanguage):
      def say(self):
          print("调用的是 CPython 类的say方法")
  class CLinux(CLanguage):
      def say(self):
          print("调用的是 CLinux 类的say方法")
  a = WhoSay()
  #调用 CLanguage 类的 say() 方法
  a.say(CLanguage())
  #调用 CPython 类的 say() 方法
  a.say(CPython())
  #调用 CLinux 类的 say() 方法
  a.say(CLinux())
  
  调用的是 Clanguage 类的say方法
  调用的是 CPython 类的say方法
  调用的是 CLinux 类的say方法
  ```

  - 此程序中，通过给 WhoSay 类中的 say() 函数添加一个 who 参数，其内部利用传入的 who 调用 say() 方法。这意味着，当调用 WhoSay 类中的 say() 方法时，我们传给 who 参数的是哪个类的实例对象，它就会调用那个类中的 say() 方法。

###### 枚举类

- 一些具有特殊含义的类，其实例化对象的个数往往是固定的，比如用一个类表示月份，则该类的实例对象最多有 12 个；再比如用一个类表示季节，则该类的实例化对象最多有 4 个。

- 针对这种特殊的类，[Python](http://c.biancheng.net/python/) 3.4 中新增加了 Enum 枚举类。也就是说，对于这些实例化对象个数固定的类，可以用枚举类来定义。

  ```
  from enum import Enum
  class Color(Enum):
      # 为序列值指定value值
      red = 1
      green = 2
      blue = 3
  ```

  - 如果想将一个类定义为枚举类，只需要令其继承自 enum 模块中的 Enum 类即可。例如在上面程序中，Color 类继承自 Enum 类，则证明这是一个枚举类。

- 在 Color 枚举类中，red、green、blue 都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为 name 和 value，其中 name 属性值为该枚举值的变量名（如 red），value 代表该枚举值的序号（序号通常从 1 开始）。

- 和普通类的用法不同，枚举类不能用来实例化对象，但这并不妨碍我们访问枚举类中的成员。访问枚举类成员的方式有多种，例如以 Color 枚举类为例，在其基础上添加如下代码：

  ```
  #调用枚举成员的 3 种方式
  print(Color.red)
  print(Color['red'])
  print(Color(1))
  #调取枚举成员中的 value 和 name
  print(Color.red.value)
  print(Color.red.name)
  #遍历枚举类中所有成员的 2 种方式
  for color in Color:
      print(color)
      
  Color.red
  Color.red
  Color.red
  1
  red
  Color.red
  Color.green
  Color.blue
  ```

- 枚举类成员之间不能比较大小，但可以用 == 或者 is 进行比较是否相等

  ```
  print(Color.red == Color.green)
  print(Color.red.name is Color.green.name)
  
  Flase
  Flase
  ```

- 需要注意的是，枚举类中各个成员的值，不能在类的外部做任何修改，也就是说，下面语法的做法是错误的：

  ```
  Color.red = 4
  ```

- 除此之外，该枚举类还提供了一个 `__members__` 属性，该属性是一个包含枚举类中所有成员的字典，通过遍历该属性，也可以访问枚举类中的各个成员。例如：

  ```
  for name,member in Color.__members__.items():
      print(name,"->",member)
      
  red -> Color.red
  green -> Color.green
  blue -> Color.blue
  ```

- 值得一提的是，Python 枚举类中各个成员必须保证 name 互不相同，但 value 可以相同

  ```
  from enum import Enum
  class Color(Enum):
      # 为序列值指定value值
      red = 1
      green = 1
      blue = 3
  print(Color['green'])
  
  Color.red
  ```

  - 可以看到，Color 枚举类中 red 和 green 具有相同的值（都是 1），Python 允许这种情况的发生，它会将 green 当做是 red 的别名，因此当访问 green 成员时，最终输出的是 red。

- 在实际编程过程中，如果想避免发生这种情况，可以借助 @unique 装饰器，这样当枚举类中出现相同值的成员时，程序会报 ValueError 错误。

  ```
  #引入 unique
  from enum import Enum,unique
  #添加 unique 装饰器
  @unique
  class Color(Enum):
      # 为序列值指定value值
      red = 1
      green = 1
      blue = 3
  print(Color['green'])
  
  Traceback (most recent call last):
    File "D:\python3.6\demo.py", line 3, in <module>
      class Color(Enum):
    File "D:\python3.6\lib\enum.py", line 834, in unique
      (enumeration, alias_details))
  ValueError: duplicate values found in <enum 'Color'>: green -> red
  ```

- 除了通过继承 Enum 类的方法创建枚举类，还可以使用 Enum() 函数创建枚举类

  ```
  from enum import Enum
  #创建一个枚举类
  Color = Enum("Color",('red','green','blue'))
  #调用枚举成员的 3 种方式
  print(Color.red)
  print(Color['red'])
  print(Color(1))
  #调取枚举成员中的 value 和 name
  print(Color.red.value)
  print(Color.red.name)
  #遍历枚举类中所有成员的 2 种方式
  for color in Color:
      print(color)
      
  Color.red
  Color.red
  Color.red
  1
  red
  Color.red
  Color.green
  Color.blue
  ```

  - Enum() 函数可接受 2 个参数，第一个用于指定枚举类的类名，第二个参数用于指定枚举类中的多个成员。

#### 类特殊成员

- Python 类中，凡是以双下划线 "\__" 开头和结尾命名的成员（属性和方法），都被称为类的特殊成员（特殊属性和特殊方法）。例如，类的 `__init__(self)` 构造方法就是典型的特殊方法。
- Python 类中的特殊成员，其特殊性类似 C++ 类的 private 私有成员，即不能在类的外部直接调用，但允许借助类中的普通方法调用甚至修改它们。如果需要，还可以对类的特殊方法进行重写，从而实现一些特殊的功能。

###### \__new__()

- `__new__()` 是一种负责创建类实例的静态方法，它无需使用 staticmethod 装饰器修饰，且该方法会优先 `__init__()` 初始化方法被调用。

- 一般情况下，覆写 `__new__()` 的实现将会使用合适的参数调用其超类的 `super().__new__()`，并在返回之前修改实例

```
class demoClass:
    instances_created = 0
    def __new__(cls,*args,**kwargs):
        print("__new__():",cls,args,kwargs)
        instance = super().__new__(cls)
        instance.number = cls.instances_created
        cls.instances_created += 1
        return instance
    def __init__(self,attribute):
        print("__init__():",self,attribute)
        self.attribute = attribute
test1 = demoClass("abc")
test2 = demoClass("xyz")
print(test1.number,test1.instances_created)
print(test2.number,test2.instances_created)

__new__(): <class '__main__.demoClass'> ('abc',) {}
__init__(): <__main__.demoClass object at 0x0000026FC0DF8080> abc
__new__(): <class '__main__.demoClass'> ('xyz',) {}
__init__(): <__main__.demoClass object at 0x0000026FC0DED358> xyz
0 2
1 2
```

- `__new__()` 通常会返回该类的一个实例，但有时也可能会返回其他类的实例，如果发生了这种情况，则会跳过对 `__init__()` 方法的调用。而在某些情况下（比如需要修改不可变类实例（[Python](http://c.biancheng.net/python/) 的某些内置类型）的创建行为），利用这一点会事半功倍

```
class nonZero(int):
    def __new__(cls,value):
        return super().__new__(cls,value) if value != 0 else None
    def __init__(self,skipped_value):
        #此例中会跳过此方法
        print("__init__()")
        super().__init__()
print(type(nonZero(-12)))
print(type(nonZero(0)))

__init__()
<class '__main__.nonZero'>
<class 'NoneType'>
```

- 那么，什么情况下使用 `__new__()` 呢？答案很简单，在 `__init__()` 不够用的时候。例如，前面例子中对 Python 不可变的内置类型（如 int、str、float 等）进行了子类化，这是因为一旦创建了这样不可变的对象实例，就无法在 `__init__`() 方法中对其进行修改。
- 有些读者可能会认为，`__new__()` 对执行重要的对象初始化很有用，如果用户忘记使用 super()，可能会漏掉这一初始化。虽然这听上去很合理，但有一个主要的缺点，即如果使用这样的方法，那么即便初始化过程已经是预期的行为，程序员明确跳过初始化步骤也会变得更加困难。不仅如此，它还破坏了“`__init__()` 中执行所有初始化工作”的潜规则。
- 注意，由于 `__new__()` 不限于返回同一个类的实例，所以很容易被滥用，不负责任地使用这种方法可能会对代码有害，所以要谨慎使用。一般来说，对于特定问题，最好搜索其他可用的解决方案，最好不要影响对象的创建过程，使其违背程序员的预期。比如说，前面提到的覆写不可变类型初始化的例子，完全可以用工厂方法（一种[设计模式](http://c.biancheng.net/design_pattern/)）来替代。
- Python中大量使用 `__new__()` 方法且合理的，就是 MetaClass 元类。

###### \__repr__():显示属性

- 前面章节中，我们经常会直接输出类的实例化对象，例如：

  ```
  class CLanguage:
      pass
  clangs = CLanguage()
  print(clangs)
  
  <__main__.CLanguage object at 0x000001A7275221D0>
  ```

  - 通常情况下，直接输出某个实例化对象，本意往往是想了解该对象的基本信息，例如该对象有哪些属性，它们的值各是多少等等。但默认情况下，我们得到的信息只会是“类名+object at+内存地址”，对我们了解该实例化对象帮助不大。

- 那么，有没有可能自定义输出实例化对象时的信息呢？答案是肯定，通过重写类的 `__repr__()` 方法即可。事实上，当我们输出某个实例化对象时，其调用的就是该对象的 `__repr__()` 方法，输出的是该方法的返回值。

  ```
  class CLanguage:
      def __init__(self):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
      def __repr__(self):
          return "CLanguage[name="+ self.name +",add=" + self.add +"]"
  clangs = CLanguage()
  print(clangs)
  
  CLanguage[name=C语言中文网,add=http://c.biancheng.net]
  ```

###### \__del__():销毁对象

- 调用 `__init__()` 方法构造当前类的实例化对象，而本节要学的 `__del__()` 方法，功能正好和 `__init__()` 相反，其用来销毁实例化对象。

- 事实上在编写程序时，如果之前创建的类实例化对象后续不再使用，最好在适当位置手动将其销毁，释放其占用的内存空间（整个过程称为垃圾回收（简称GC））。

- 大多数情况下，Python 开发者不需要手动进行垃圾回收，因为 Python 有自动的垃圾回收机制（下面会讲），能自动将不需要使用的实例对象进行销毁。

- 无论是手动销毁，还是 Python 自动帮我们销毁，都会调用 `__del__()` 方法

  ```
  class CLanguage:
      def __init__(self):
          print("调用 __init__() 方法构造对象")
      def __del__(self):
          print("调用__del__() 销毁对象，释放其空间")
  clangs = CLanguage()
  del clangs
  
  调用 __init__() 方法构造对象
  调用__del__() 销毁对象，释放其空间
  ```

- 但是，读者千万不要误认为，只要为该实例对象调用 `__del__()` 方法，该对象所占用的内存空间就会被释放

  ```
  class CLanguage:
      def __init__(self):
          print("调用 __init__() 方法构造对象")
      def __del__(self):
          print("调用__del__() 销毁对象，释放其空间")
  clangs = CLanguage()
  #添加一个引用clangs对象的实例对象
  cl = clangs
  del clangs
  print("***********")
  
  调用 __init__() 方法构造对象
  ***********
  调用__del__() 销毁对象，释放其空间
  ```

  - 注意，最后一行输出信息，是程序执行即将结束时调用 `__del__()` 方法输出的。
  - 可以看到，当程序中有其它变量（比如这里的 cl）引用该实例对象时，即便手动调用 `__del__()` 方法，该方法也不会立即执行。这和 Python 的垃圾回收机制的实现有关。

- Python 采用自动引用计数（简称 ARC）的方式实现垃圾回收机制。该方法的核心思想是：每个 Python 对象都会配置一个计数器，初始 Python 实例对象的计数器值都为 0，如果有变量引用该实例对象，其计数器的值会加 1，依次类推；反之，每当一个变量取消对该实例对象的引用，计数器会减 1。如果一个 Python 对象的的计数器值为 0，则表明没有变量引用该 Python 对象，即证明程序不再需要它，此时 Python 就会自动调用 `__del__()` 方法将其回收。

- 如果在上面程序结尾，添加如下语句：

  ```
  del cl
  print("-----------")
  
  调用 __init__() 方法构造对象
  ***********
  调用__del__() 销毁对象，释放其空间
  -----------
  ```

  - 可以看到，当执行 del cl 语句时，其应用的对象实例对象 C 的计数器继续 -1（变为 0），对于计数器为 0 的实例对象，Python 会自动将其视为垃圾进行回收。

- 需要额外说明的是，如果我们重写子类的 `__del__()` 方法（父类为非 object 的类），则必须显式调用父类的 `__del__()` 方法，这样才能保证在回收子类对象时，其占用的资源（可能包含继承自父类的部分资源）能被彻底释放。

  ```
  class CLanguage:
      def __del__(self):
          print("调用父类 __del__() 方法")
  class cl(CLanguage):
      def __del__(self):
          print("调用子类 __del__() 方法")
  c = cl()
  del c
  
  调用子类 __del__() 方法
  ```

###### \__dir__():列出对象的所有属性

- 前面在介绍 [Python](http://c.biancheng.net/python/) 内置函数时，提到了 dir() 函数，通过此函数可以某个对象拥有的所有的属性名和方法名，该函数会返回一个包含有所有属性名和方法名的有序列表。

  ```
  class CLanguage:
      def __init__ (self,):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
      def say():
          pass
  clangs = CLanguage()
  print(dir(clangs))
  
  ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'add', 'name', 'say']
  ```

  - 通过 dir() 函数，不仅仅输出本类中新添加的属性名和方法（最后 3 个），还会输出从父类（这里为 object 类）继承得到的属性名和方法名。
  - 值得一提的是，dir() 函数的内部实现，其实是在调用参数对象 `__dir__()` 方法的基础上，对该方法返回的属性名和方法名做了排序。

- 除了使用 dir() 函数，我们完全可以自行调用该对象具有的 `__dir__()` 方法：

  ```
  class CLanguage:
      def __init__ (self,):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
      def say():
          pass
  clangs = CLanguage()
  print(clangs.__dir__())
  
  ['name', 'add', '__module__', '__init__', 'say', '__dict__', '__weakref__', '__doc__', '__repr__', '__hash__', '__str__', '__getattribute__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__new__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__']
  ```

  - 显然，使用 `__dir__()` 方法和 dir() 函数输出的数据是相同，仅仅顺序不同。

###### \__dict__:查看对象内部所有属性名和属性值组成的字典

- 在 [Python](http://c.biancheng.net/python/) 类的内部，无论是类属性还是实例属性，都是以字典的形式进行存储的，其中属性名作为键，而值作为该键对应的值。

- 为了方便用户查看类中包含哪些属性，Python 类提供了 `__dict__` 属性。需要注意的一点是，该属性可以用类名或者类的实例对象来调用，用类名直接调用 `__dict__`，会输出该由类中所有类属性组成的字典；而使用类的实例对象调用 `__dict__`，会输出由类中所有实例属性组成的字典。

  ```
  class CLanguage:
      a = 1
      b = 2
      def __init__ (self):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
  #通过类名调用__dict__
  print(CLanguage.__dict__)
  #通过类实例对象调用 __dict__
  clangs = CLanguage()
  print(clangs.__dict__)
  
  {'__module__': '__main__', 'a': 1, 'b': 2, '__init__': <function CLanguage.__init__ at 0x0000022C69833E18>, '__dict__': <attribute '__dict__' of 'CLanguage' objects>, '__weakref__': <attribute '__weakref__' of 'CLanguage' objects>, '__doc__': None}
  {'name': 'C语言中文网', 'add': 'http://c.biancheng.net'}
  ```

- 不仅如此，对于具有继承关系的父类和子类来说，父类有自己的 `__dict__`，同样子类也有自己的 `__dict__`，它不会包含父类的 `__dict__`

  ```
  class CLanguage:
      a = 1
      b = 2
      def __init__ (self):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
         
  class CL(CLanguage):
      c = 1
      d = 2
      def __init__ (self):
          self.na = "Python教程"
          self.ad = "http://c.biancheng.net/python"
  #父类名调用__dict__
  print(CLanguage.__dict__)
  #子类名调用__dict__
  print(CL.__dict__)
  #父类实例对象调用 __dict__
  clangs = CLanguage()
  print(clangs.__dict__)
  #子类实例对象调用 __dict__
  cl = CL()
  print(cl.__dict__)
  
  {'__module__': '__main__', 'a': 1, 'b': 2, '__init__': <function CLanguage.__init__ at 0x000001721A853E18>, '__dict__': <attribute '__dict__' of 'CLanguage' objects>, '__weakref__': <attribute '__weakref__' of 'CLanguage' objects>, '__doc__': None}
  {'__module__': '__main__', 'c': 1, 'd': 2, '__init__': <function CL.__init__ at 0x000001721CD15510>, '__doc__': None}
  {'name': 'C语言中文网', 'add': 'http://c.biancheng.net'}
  {'na': 'Python教程', 'ad': 'http://c.biancheng.net/python'}
  ```

  - 显然，通过子类直接调用的 `__dict__` 中，并没有包含父类中的 a 和 b 类属性；同样，通过子类对象调用的 `__dict__`，也没有包含父类对象拥有的 name 和 add 实例属性。

- 除此之外，借助由类实例对象调用 `__dict__` 属性获取的字典，可以使用字典的方式对其中实例属性的值进行修改

  ```
  class CLanguage:
      a = "aaa"
      b = 2
      def __init__ (self):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
  #通过类实例对象调用 __dict__
  clangs = CLanguage()
  print(clangs.__dict__)
  clangs.__dict__['name'] = "Python教程"
  print(clangs.name)
  
  {'name': 'C语言中文网', 'add': 'http://c.biancheng.net'}
  Python教程
  ```

  - 注意，无法通过类似的方式修改类变量的值。

###### setattr、getattr、hasattr

- hasattr() 函数用来判断某个类实例对象是否包含指定名称的属性或方法。该函数的语法格式如下：

  ```
  hasattr(obj, name)
  ```

  - 其中 obj 指的是某个类的实例对象，name 表示指定的属性名或方法名。同时，该函数会将判断的结果（True 或者 False）作为返回值反馈回来。

    ```
    class CLanguage:
        def __init__ (self):
            self.name = "C语言中文网"
            self.add = "http://c.biancheng.net"
        def say(self):
            print("我正在学Python")
    clangs = CLanguage()
    print(hasattr(clangs,"name"))
    print(hasattr(clangs,"add"))
    print(hasattr(clangs,"say"))
    
    True
    True
    True
    ```

  - 显然，无论是属性名还是方法名，都在 hasattr() 函数的匹配范围内。因此，我们只能通过该函数判断实例对象是否包含该名称的属性或方法，但不能精确判断，该名称代表的是属性还是方法。

- getattr() 函数获取某个类实例对象中指定属性的值。没错，和 hasattr() 函数不同，该函数只会从类对象包含的所有属性中进行查找。

  ```
  getattr(obj, name[, default])
  ```

  - 其中，obj 表示指定的类实例对象，name 表示指定的属性名，而 default 是可选参数，用于设定该函数的默认返回值，即当函数查找失败时，如果不指定 default 参数，则程序将直接报 AttributeError 错误，反之该函数将返回 default 指定的值。

    ```
    class CLanguage:
        def __init__ (self):
            self.name = "C语言中文网"
            self.add = "http://c.biancheng.net"
        def say(self):
            print("我正在学Python")
    clangs = CLanguage()
    print(getattr(clangs,"name"))
    print(getattr(clangs,"add"))
    print(getattr(clangs,"say"))
    print(getattr(clangs,"display",'nodisplay'))
    
    C语言中文网
    http://c.biancheng.net
    <bound method CLanguage.say of <__main__.CLanguage object at 0x000001FC2F2E3198>>
    nodisplay
    ```

  - 可以看到，对于类中已有的属性，getattr() 会返回它们的值，而如果该名称为方法名，则返回该方法的状态信息；反之，如果该明白不为类对象所有，要么返回默认的参数，要么程序报 AttributeError 错误。

- setattr() 函数的功能相对比较复杂，它最基础的功能是修改类实例对象中的属性值。其次，它还可以实现为实例对象动态添加属性或者方法。

  ```
  setattr(obj, name, value)
  ```

  - 下面例子演示如何通过该函数修改某个类实例对象的属性值：

    ```
    class CLanguage:
        def __init__ (self):
            self.name = "C语言中文网"
            self.add = "http://c.biancheng.net"
        def say(self):
            print("我正在学Python")
    clangs = CLanguage()
    print(clangs.name)
    print(clangs.add)
    setattr(clangs,"name","Python教程")
    setattr(clangs,"add","http://c.biancheng.net/python")
    print(clangs.name)
    print(clangs.add)
    
    C语言中文网
    http://c.biancheng.net
    Python教程
    http://c.biancheng.net/python
    ```

  - 甚至利用 setattr() 函数，还可以将类属性修改为一个类方法，同样也可以将类方法修改成一个类属性。例如：

    ```
    def say(self):
        print("我正在学Python")
    class CLanguage:
        def __init__ (self):
            self.name = "C语言中文网"
            self.add = "http://c.biancheng.net"
    clangs = CLanguage()
    print(clangs.name)
    print(clangs.add)
    setattr(clangs,"name",say)
    clangs.name(clangs)
    
    C语言中文网
    http://c.biancheng.net
    我正在学Python
    ```

  - 使用 setattr() 函数对实例对象中执行名称的属性或方法进行修改时，如果该名称查找失败，Python 解释器不会报错，而是会给该实例对象动态添加一个指定名称的属性或方法

    ```
    def say(self):
        print("我正在学Python")
    class CLanguage:
        pass
    clangs = CLanguage()
    setattr(clangs,"name","C语言中文网")
    setattr(clangs,"say",say)
    print(clangs.name)
    clangs.say(clangs)
    
    C语言中文网
    我正在学Python
    ```

    - 可以看到，虽然 CLanguage 为空类，但通过 setattr() 函数，我们为 clangs 对象动态添加了一个 name 属性和一个 say() 方法。

###### issubclass和isinstance：检查类型

- [Python](http://c.biancheng.net/python/) 提供了如下两个函数来检查类型：
  - issubclass(cls, class_or_tuple)：检查 cls 是否为后一个类或元组包含的多个类中任意类的子类。
  - isinstance(obj, class_or_tuple)：检查 obj 是否为后一个类或元组包含的多个类中任意类的对象。

- 通过使用上面两个函数，程序可以方便地先执行检查，然后才调用方法，这样可以保证程序不会出现意外情况。

  ```
  # 定义一个字符串
  hello = "Hello";
  # "Hello"是str类的实例，输出True
  print('"Hello"是否是str类的实例: ', isinstance(hello, str))
  # "Hello"是object类的子类的实例，输出True
  print('"Hello"是否是object类的实例: ', isinstance(hello, object))
  # str是object类的子类，输出True
  print('str是否是object类的子类: ', issubclass(str, object))
  # "Hello"不是tuple类及其子类的实例，输出False
  print('"Hello"是否是tuple类的实例: ', isinstance(hello, tuple))
  # str不是tuple类的子类，输出False
  print('str是否是tuple类的子类: ', issubclass(str, tuple))
  # 定义一个列表
  my_list = [2, 4]
  # [2, 4]是list类的实例，输出True
  print('[2, 4]是否是list类的实例: ', isinstance(my_list, list))
  # [2, 4]是object类的子类的实例，输出True
  print('[2, 4]是否是object类及其子类的实例: ', isinstance(my_list, object))
  # list是object类的子类，输出True
  print('list是否是object类的子类: ', issubclass(list, object))
  # [2, 4]不是tuple类及其子类的实例，输出False
  print('[2, 4]是否是tuple类及其子类的实例: ', isinstance([2, 4], tuple))
  # list不是tuple类的子类，输出False
  print('list是否是tuple类的子类: ', issubclass(list, tuple))
  ```

  - 通过上面程序可以看出，issubclass() 和 isinstance() 两个函数的用法差不多，区别只是 issubclass() 的第一个参数是类名，而 isinstance() 的第一个参数是变量，这也与两个函数的意义对应：issubclass 用于判断是否为子类，而 isinstance() 用于判断是否为该类或子类的实例。

- issubclass() 和 isinstance() 两个函数的第二个参数都可使用元组

  ```
  data = (20, 'fkit')
  print('data是否为列表或元组: ', isinstance(data, (list, tuple))) # True
  # str不是list或者tuple的子类，输出False
  print('str是否为list或tuple的子类: ', issubclass(str, (list, tuple)))
  # str是list或tuple或object的子类，输出True
  print('str是否为list或tuple或object的子类 ', issubclass(str, (list, tuple, object)))
  ```

- 此外，Python 为所有类都提供了一个 `__bases__` 属性，通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组

  ```
  class A:
      pass
  class B:
      pass
  class C(A, B):
      pass
  print('类A的所有父类:', A.__bases__)
  print('类B的所有父类:', B.__bases__)
  print('类C的所有父类:', C.__bases__)
  
  类A的所有父类: (<class 'object'>,)
  类B的所有父类: (<class 'object'>,)
  类C的所有父类: (<class '__main__.A'>, <class '__main__.B'>)
  ```

  - 从上面的运行结果可以看出，如果在定义类时没有显式指定它的父类，则这些类默认的父类是 object 类。

- Python 还为所有类都提供了一个 `__subclasses__()` 方法，通过该方法可以查看该类的所有直接子类，该方法返回该类的所有子类组成的列表。例如在上面程序中增加如下两行：

  ```
  print('类A的所有子类:', A.__subclasses__())
  print('类B的所有子类:', B.__subclasses__())
  
  类A的所有子类: [<class '__main__.C'>]
  类B的所有子类: [<class '__main__.C'>]
  ```

###### \__call__()

- 本节再介绍 [Python](http://c.biancheng.net/python/) 类中一个非常特殊的实例方法，即 `__call__()`。该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。

  ```
  class CLanguage:
      # 定义__call__方法
      def __call__(self,name,add):
          print("调用__call__()方法",name,add)
  clangs = CLanguage()
  clangs("C语言中文网","http://c.biancheng.net")
  
  调用__call__()方法 C语言中文网 http://c.biancheng.net
  ```

  - 可以看到，通过在 CLanguage 类中实现 `__call__()` 方法，使的 clangs 实例对象变为了可调用对象。
  - Python 中，凡是可以将 () 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。

- 对于可调用对象，实际上“名称()”可以理解为是“名称.`__call__()`”的简写。仍以上面程序中定义的 clangs 实例对象为例，其最后一行代码还可以改写为如下形式：

  ```
  clangs.__call__("C语言中文网","http://c.biancheng.net")
  ```

- 这里再举一个自定义函数的例子

  ```
  def say():
      print("Python教程：http://c.biancheng.net/python")
  say()
  say.__call__()
  
  Python教程：http://c.biancheng.net/python
  Python教程：http://c.biancheng.net/python
  ```

  - 不仅如此，类中的实例方法也有以上 2 种调用方式

- 前面章节介绍了 hasattr() 函数的用法，该函数的功能是查找类的实例对象中是否包含指定名称的属性或者方法，但该函数有一个缺陷，即它无法判断该指定的名称，到底是类属性还是类方法。要解决这个问题，我们可以借助可调用对象的概念。要知道，类实例对象包含的方法，其实也属于可调用对象，但类属性却不是

  ```
  class CLanguage:
      def __init__ (self):
          self.name = "C语言中文网"
          self.add = "http://c.biancheng.net"
      def say(self):
          print("我正在学Python")
  clangs = CLanguage()
  if hasattr(clangs,"name"):
      print(hasattr(clangs.name,"__call__"))
  print("**********")
  if hasattr(clangs,"say"):
      print(hasattr(clangs.say,"__call__"))
      
  False
  **********
  True
  ```

  - 可以看到，由于 name 是类属性，它没有以 `__call__` 为名的 `__call__()` 方法；而 say 是类方法，它是可调用对象，因此它有 `__call__()` 方法。

###### 重载运算符

- 前面章节介绍了 [Python](http://c.biancheng.net/python/) 中的各个序列类型，每个类型都有其独特的操作方法，例如列表类型支持直接做加法操作实现添加元素的功能，字符串类型支持直接做加法实现字符串的拼接功能，也就是说，同样的运算符对于不同序列类型的意义是不一样的，这是怎么做到的呢？其实在 Python 内部，每种序列类型都是 Python 的一个类，例如列表是 list 类，字典是 dict 类等，这些序列类的内部使用了一个叫作“重载运算符”的技术来实现不同运算符所对应的操作。

- str(10),10是一个int类型，int类里面有重载的`__str__(self)`,所以在用str(10)的时候，默认用的是int类里面重载的函数，这和c++里面是不一样的，c++里面只能重载运算符，如果在类里面定义一个函数，形参也是一个int，返回的类型也是一个str，但是在c++里面不能这样调用，只能通过类对象来调用，但是python里面能直接这样调用

- 所谓重载运算符，指的是在类中定义并实现一个与运算符对应的处理方法，这样当类对象在进行运算符操作时，系统就会调用类中相应的方法来处理。

  ```
  class MyClass: #自定义一个类
      def __init__(self, name , age): #定义该类的初始化函数
          self.name = name #将传入的参数值赋值给成员交量
          self.age = age
      def __str__(self): #用于将值转化为字符串形式，等同于 str(obj)
          return "name:"+self.name+";age:"+str(self.age)
     
      __repr__ = __str__ #转化为供解释器读取的形式
     
      def __lt__(self, record): #重载 self<record 运算符
          if self.age < record.age:
              return True
          else:
              return False
     
      def __add__(self, record): #重载 + 号运算符
          return MyClass(self.name, self.age+record.age)
  myc = MyClass("Anna", 42) #实例化一个对象 Anna，并为其初始化
  mycl = MyClass("Gary", 23) #实例化一个对象 Gary，并为其初始化
  print(repr(myc)) #格式化对象 myc，
  print(myc) #解释器读取对象 myc，调用 repr
  print (str (myc)) #格式化对象 myc ，输出"name:Anna;age:42"
  print(myc < mycl) #比较 myc<mycl 的结果，输出 False
  print (myc+mycl) #进行两个 MyClass 对象的相加运算，输出 "name:Anna;age:65"
  
  name:Anna;age:42
  name:Anna;age:42
  name:Anna;age:42
  False
  name:Anna;age:65
  ```

  - 这个例子中，MyClass 类中重载了 repr、str、<、+ 运算符，并用 MyClass 实例化了两个对象 myc 和 mycl。
  - 通过将 myc 进行 repr、str 运算，从输出结果中可以看到，程序调用了重载的操作符方法 `__repr__` 和 `__str__`。而令 myc 和 mycl 进行 < 号的比较运算以及加法运算，从输出结果中可以看出，程序调用了重载 < 号的方法 `__lt__` 和 `__add__` 方法。

- Python 中常用的可重载的运算符

  | 重载运算符                                       | 含义                                                         |
  | ------------------------------------------------ | ------------------------------------------------------------ |
  | \__new__                                         | 创建类，在 `__init__` 之前创建对象                           |
  | \__init__                                        | 类的构造函数，其功能是创建类对象时做初始化工作。             |
  | \__del__                                         | 析构函数，其功能是销毁对象时进行回收资源的操作               |
  | \__add__                                         | 加法运算符 +，当类对象 X 做例如 X+Y 或者 X+=Y 等操作，内部会调用此方法。但如果类中对 `__iadd__` 方法进行了重载，则类对象 X 在做 X+=Y 类似操作时，会优先选择调用 `__iadd__` 方法。 |
  | \__radd__                                        | 当类对象 X 做类似 Y+X 的运算时，会调用此方法。               |
  | \__iadd__                                        | 重载 += 运算符，也就是说，当类对象 X 做类似 X+=Y 的操作时，会调用此方法。 |
  | \__or__                                          | “或”运算符 \|，如果没有重载 `__ior__`，则在类似 X\|Y、X\|=Y 这样的语句中，“或”符号生效 |
  | `__repr__，__str__`                              | 格式转换方法，分别对应函数 repr(X)、str(X)                   |
  | `__call__`                                       | 函数调用，类似于 X(*args, **kwargs) 语句                     |
  | `__getattr__`                                    | 点号运算，用来获取类属性                                     |
  | `__setattr__`                                    | 属性赋值语句，类似于 X.any=value                             |
  | `__delattr__`                                    | 删除属性，类似于 del X.any                                   |
  | `__getattribute__`                               | 获取属性，类似于 X.any                                       |
  | `__getitem__`                                    | 索引运算，类似于 X[key]，X[i:j]                              |
  | `__setitem__`                                    | 索引赋值语句，类似于 X[key], X[i:j]=sequence                 |
  | `__delitem__`                                    | 索引和分片删除                                               |
  | `__get__, __set__, __delete__`                   | 描述符属性，类似于 X.attr，X.attr=value，del X.attr          |
  | `__len__`                                        | 计算长度，类似于 len(X)                                      |
  | `__lt__，__gt__，__le__，__ge__，__eq__，__ne__` | 比较，分别对应于 <、>、<=、>=、=、!= 运算符。                |
  | `__iter__，__next__`                             | 迭代环境下，生成迭代器与取下一条，类似于 I=iter(X) 和 next() |
  | `__contains__`                                   | 成员关系测试，类似于 item in X                               |
  | `__index__`                                      | 整数值，类似于 hex(X)，bin(X)，oct(X)                        |
  | `__enter__，__exit__`                            | 在对类对象执行类似 with obj as var 的操作之前，会先调用 `__enter__` 方法，其结果会传给 var；在最终结束该操作之前，会调用 `__exit__` 方法（常用于做一些清理、扫尾的工作） |

###### 重载运算符实现自定义序列

- 除了前面章节介绍的几个类特殊方法（方法名以双下划线（__）开头和结尾），在 Python 类中，我们还可以通过重写几个特殊方法，实现自定义一个序列类。表 1 列出了和自定义序列类有关的几个特殊方法。

  | 方法名                      | 功能                                           |
  | --------------------------- | ---------------------------------------------- |
  | `__len__(self)`             | 返回序列类中存储元素的个数。                   |
  | `__contains__(self, value)` | 判断当前序列中是否包含 value 这个指定元素。    |
  | `__getitem__(self, key)`    | 通过指定的 key（键），返回对应的 value（值）。 |
  | `__setitem__(self, key)`    | 修改指定 key（键）对应的 value（值）。         |
  | `__delitem__(self, key)`    | 删除指定键值对。                               |

- 在对表 1 中的这些特殊方法进行重写时，在实现其基础功能的基础上，还可以根据实际情况，对各个方法的具体实现进行适当调整。以 `__setitem__()` 方法为例，当在序列中未找到指定 key 的情况下，该方法可以报错，当然也可以将此键值对添加到当前序列中。

- 另外值得一提的是，在实现自定义序列类时，并不是必须重写表 1 中全部的特殊方法。如果该自定义序列是一个不可变序列（即序列中的元素不能做修改），则无需重写 `__setitem__()` 和 `__delitem__()` 方法；反之，如果该自定义序列是一个可变序列，可以重写以上 5 个特殊方法。

- 下面程序实现了一个比较简单的序列类，这是一个字典类，其特点是只能存储 int 类型的元素：

  ```
  class IntDic:   
      def __init__(self):
          # 用于存储数据的字典
          self.__date = {}
      def __len__(self):
          return len(list(self.__date.values()))
             
      def __getitem__(self, key):
          # 如果在self.__changed中找到已经修改后的数据
          if key in self.__date :
              return self.__date[key]
          return None
      
      def __setitem__(self, key, value):
          #判断value是否为整数
          if not isinstance(value, int):
              raise TypeError('必须是整数')
          #修改现有 key 对应的 value 值，或者直接添加
          self.__date[key] = value
      def __delitem__(self, key):
          if key in self.__date : del self.__date[key]
  dic = IntDic()
  #输出序列中元素的个数，调用 __len__() 方法
  print(len(dic))
  #向序列中添加元素，调用 __setitem__() 方法
  dic['a'] = 1
  dic['b'] = 2
  print(len(dic))
  dic['a'] = 3
  dic['c'] = 4
  print(dic['a'])
  #删除指定元素，调用 __delitem__() 方法
  del dic['a']
  print(dic['a'])
  print(len(dic))
  
  0
  2
  3
  None
  2
  ```

###### 迭代器

- 前面章节中，已经对列表（list）、元组（tuple）、字典（dict）、集合（set）这些序列式容器做了详细的介绍。值得一提的是，这些序列式容器有一个共同的特性，它们都支持使用 for 循环遍历存储的元素，都是可迭代的，因此它们又有一个别称，即迭代器。

- 从字面来理解，迭代器指的就是支持迭代的容器，更确切的说，是支持迭代的容器类对象，这里的容器可以是列表、元组等这些 [Python](http://c.biancheng.net/python/) 提供的基础容器，也可以是自定义的容器类对象，只要该容器支持迭代即可。

- 《[Python实现自定义序列](http://c.biancheng.net/view/vip_6085.html)》一节中，已经学会了如何自定义一个序列类，但该序列类对象并不支持迭代，因此还不能称之为迭代器。如果要自定义实现一个迭代器，则类中必须实现如下 2 个方法：

  1. `__next__(self)`：返回容器的下一个元素。
  2. `__iter__(self)`：该方法返回一个迭代器（iterator）。

- 下面程序自定义了一个简易的列表容器迭代器，支持迭代：

  ```
  class listDemo:
      def __init__(self):
          self.__date=[]
          self.__step = 0
      def __next__(self):
          if self.__step <= 0:
              raise StopIteration
          self.__step -= 1
          #返回下一个元素
          return self.__date[self.__step]
      def __iter__(self):
          #实例对象本身就是迭代器对象，因此直接返回 self 即可
          return self
      #添加元素
      def __setitem__(self,key,value):
          self.__date.insert(key,value)
          self.__step += 1
  mylist = listDemo()
  mylist[0]=1
  mylist[1]=2
  for i in mylist:
      print (i)
      
  2
  1
  ```

- 除此之外，Python 内置的 iter() 函数也会返回一个迭代器，该函数的语法格式如下：

  ```
  iter(obj[, sentinel])
  ```

  - 其中，obj 必须是一个可迭代的容器对象，而 sentinel 作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象，具体功能后面会讲。
  - 可调用对象，指的是该类的实例对象可以像函数那样，直接以“对象名()”的形式被使用。通过在类中添加 `__call__()` 方法，就可以将该类的实例对象编程可调用对象。

- 我们常用的是仅有 1 个参数的 iter() 函数，通过传入一个可迭代的容器对象，我们可以获得一个迭代器，通过调用该迭代器中的 `__next__()` 方法即可实现迭代。

  ```
  # 将列表转换为迭代器
  myIter = iter([1, 2, 3])
  # 依次获取迭代器的下一个元素
  print(myIter.__next__())
  print(myIter.__next__())
  print(myIter.__next__())
  print(myIter.__next__())
  
  1
  2
  3
  Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\demo.py", line 7, in <module>
      print(myIter.__next__())
  StopIteration
  ```

  - 也可以使用 next() 内置函数来迭代，即 next(myIter)，和 `__next__()` 方法是完全一样的。
  - 从程序的执行结果可以看出，当迭代完存储的所有元素之后，如果继续迭代，则 `__next__()` 方法会抛出 StopIteration 异常。

- 这里介绍 iter() 函数第 2 个参数的作用，如果使用该参数，则要求第一个 obj 参数必须传入可调用对象（可以不支持迭代），这样当使用返回的迭代器调用 `__next__()` 方法时，它会通过执行 obj() 调用 `__call__()` 方法，如果该方法的返回值和第 2 个参数值相同，则输出 StopInteration 异常；反之，则输出 `__call__()` 方法的返回值。

  ```
  class listDemo:
      def __init__(self):
          self.__date=[]
          self.__step = 0
      def __setitem__(self,key,value):
          self.__date.insert(key,value)
          self.__step += 1
      #是该类实例对象成为可调用对象
      def __call__(self):
          self.__step-=1
          return self.__date[self.__step]
  mylist = listDemo()
  mylist[0]=1
  mylist[1]=2
  #将 mylist 变为迭代器
  a = iter(mylist,1)
  print(a.__next__())
  print(a.__next__())
  
  2
  Traceback (most recent call last):
    File "D:\python3.6\1.py", line 20, in <module>
      print(a.__next__())
  StopIteration
  ```

  - 输出结果中，之所以最终抛出 StopIteration 异常，是因为这里原本要输出的元素 1 和 iter() 函数的第 2 个参数相同。
  - 迭代器本身是一个底层的特性和概念，在程序中并不常用，但它为生成器这一更有趣的特性提供了基础。有关生成器的相关知识，会在后续章节中介绍。

- 迭代去实现字符串的逆序输出

  - 项目要求是这样的，定义一个类，要求在实现迭代器功能的基础上，能够对用户输入的字符串做逆序输出操作。
  - 实现思路是这样的，自定义一个类并重载其 `__init__()` 初始化方法，实现为自身私有成员赋值。同时重载 `__iter__()` 和 `__next__()` 方法，使其具有迭代器功能。在此基础上，如果想实现对用户输入的字符串进行逆序输出，就需要在 `__next__()` 方法中实现从后往前返回字符。

  ```
  class Reverse:
      def __init__(self, string):
          self.__string = string
          self.__index = len(string)
      def __iter__(self):
          return self
      def __next__(self):
          self.__index -= 1
          return self.__string[self.__index]
  revstr = Reverse('Python')
  for c in revstr:
      print(c,end=" ")
      
  n o h t y P n o h t y P Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\demo.py", line 11, in <module>
      for c in revstr:
    File "C:\Users\mengma\Desktop\demo.py", line 9, in __next__
      return self.__string[self.__index]
  IndexError: string index out of range
  ```

  - 可以看到，上面程序在逆序输出两遍"python"的同时，Python解释器报出 IndexError 错误，这是什么原因呢？

  - 很简单，因为程序没有设置遍历的终止条件，换句话说，没有对 `__index` 私有变量的值对限制，这里 `__index` 的取值范围应为（`-len(self.__index), len(self.__index)`），这也是导致上面程序运行结果的根本原因。

  - 编写迭代器最容易忽视的一个环节，就是在自定义类中加入对循环结束的判断，并抛出 StopIteration 异常，只有这么做了，for 循环才会接收到 StopIteration 异常，并当做终止信号来结束循环。

    ```
    class Reverse:
        def __init__(self, string):
            self.__string = string
            self.__index = len(string)
        def __iter__(self):
            return self
        def __next__(self):
            if self.__index == 0:
                raise(StopIteration)
            self.__index -= 1
            return self.__string[self.__index]
    revstr = Reverse('Python')
    for c in revstr:
        print(c,end=" ")
        
    n o h t y P
    ```

###### 生成器

- 前面章节中，已经详细介绍了什么是迭代器。生成器本质上也是迭代器，不过它比较特殊。

- 以 list 容器为例，在使用该容器迭代一组数据时，必须事先将所有数据存储到容器中，才能开始迭代；而生成器却不同，它可以实现在迭代的同时生成元素。

- 也就是说，对于可以用某种算法推算得到的多个数据，生成器并不会一次性生成它们，而是什么时候需要，才什么时候生成。

- 不仅如此，生成器的创建方式也比迭代器简单很多，大体分为以下 2 步：

  1. 定义一个以 yield 关键字标识返回值的函数；
  2. 调用刚刚创建的函数，即可创建一个生成器。

  ```
  def intNum():
      print("开始执行")
      for i in range(5):
          yield i
          print("继续执行")
  num = intNum()
  ```

  - 由此，我们就成功创建了一个 num 生成器对象。显然，和普通函数不同，intNum() 函数的返回值用的是 yield 关键字，而不是 return 关键字，此类函数又成为生成器函数。
  - 和 return 相比，yield 除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。不仅如此，即便调用生成器函数，[Python](http://c.biancheng.net/python/) 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。
  - 要想使生成器函数得以执行，或者想使执行完 yield 语句立即暂停的程序得以继续执行，有以下 2 种方式：
    1. 通过生成器（上面程序中的 num）调用 next() 内置函数或者 `__next__()` 方法；
    2. 通过 for 循环遍历生成器。

  ```
  #调用 next() 内置函数
  print(next(num))
  #调用 __next__() 方法
  print(num.__next__())
  #通过for循环遍历生成器
  for i in num:
      print(i)
  
  开始执行
  0
  继续执行
  1
  继续执行
  2
  继续执行
  3
  继续执行
  4
  继续执行
  ```

  - 首先，在创建有 num 生成器的前提下，通过其调用 next() 内置函数，会使 Python 解释器开始执行 intNum() 生成器函数中的代码，因此会输出“开始执行”，程序会一直执行到`yield i`，而此时的 i==0，因此 Python 解释器输出“0”。由于受到 yield 的影响，程序会在此处暂停。
  - 然后，我们使用 num 生成器调用 `__next__()` 方法，该方法的作用和 next() 函数完全相同（事实上，next() 函数的底层执行的也是 `__next__()` 方法），它会是程序继续执行，即输出“继续执行”，程序又会执行到`yield i`，此时 i==1，因此输出“1”，然后程序暂停。
  - 最后，我们使用 for 循环遍历 num 生成器，之所以能这么做，是因为 for 循环底层会不断地调用 next() 函数，使暂停的程序继续执行，因此会输出后续的结果。
  - 注意，在 Python 2.x 版本中不能使用 `__next__()` 方法，可以使用 next() 内置函数，另外生成器还有 next() 方法（即以 num.next() 的方式调用）。

- 除此之外，还可以使用 list() 函数和 tuple() 函数，直接将生成器能生成的所有值存储成列表或者元组的形式。

  ```
  num = intNum()
  print(list(num))
  num = intNum()
  print(tuple(num))
  
  开始执行
  继续执行
  继续执行
  继续执行
  继续执行
  继续执行
  [0, 1, 2, 3, 4]
  开始执行
  继续执行
  继续执行
  继续执行
  继续执行
  继续执行
  (0, 1, 2, 3, 4)
  ```

  - 通过输出结果可以判断出，list() 和 tuple() 底层实现和 for 循环的遍历过程是类似的。
  - 相比迭代器，生成器最明显的优势就是节省内存空间，即它不会一次性生成所有的数据，而是什么时候需要，什么时候生成。

###### 生成器(send, close,throw)方法

- send()方法

  - 我们知道，通过调用 next() 或者 `__next__()` 方法，可以实现从外界控制生成器的执行。除此之外，通过 send() 方法，还可以向生成器中传值。

  - 值得一提的是，send() 方法可带一个参数，也可以不带任何参数（用 None 表示）。其中，当使用不带参数的 send() 方法时，它和 next() 函数的功能完全相同。例如：

    ```
    def intNum():
        print("开始执行")
        for i in range(5):
            yield i
            print("继续执行")
    num = intNum()
    print(num.send(None))
    print(num.send(None))
    
    开始执行
    0
    继续执行
    1
    ```

    - 虽然 send(None) 的功能是 next() 完全相同，但更推荐使用 next()，不推荐使用 send(None)。

  - 这里重点讲解一些带参数的 send(value) 的用法，其具备 next() 函数的部分功能，即将暂停在 yield 语句出的程序继续执行，但与此同时，该函数还会将 value 值作为 yield 语句返回值赋值给接收者。

  - 注意，带参数的 send(value) 无法启动执行生成器函数。也就是说，程序中第一次使用生成器调用 next() 或者 send() 函数时，不能使用带参数的 send() 函数。

    ```
    def foo():
        bar_a = yield "hello"
        bar_b = yield bar_a
        yield bar_b
    f = foo()
    print(f.send(None))
    print(f.send("C语言中文网"))
    print(f.send("http://c.biancheng.net"))
    
    hello
    C语言中文网
    http://c.biancheng.net
    ```

    - 分析一下此程序的执行流程：

      1) 首先，构建生成器函数，并利用器创建生成器（对象）f 。

      2) 使用生成器 f 调用无参的 send() 函数，其功能和 next() 函数完全相同，因此开始执行生成器函数，即执行到第一个 yield "hello" 语句，该语句会返回 "hello" 字符串，然后程序停止到此处（注意，此时还未执行对 bar_a 的赋值操作）。

      3) 下面开始使用生成器 f 调用有参的 send() 函数，首先它会将暂停的程序开启，同时还会将其参数“C语言中文网”赋值给当前 yield 语句的接收者，也就是 bar_a 变量。程序一直执行完 yield bar_a 再次暂停，因此会输出“C语言中文网”。
      4)  最后依旧是调用有参的 send() 函数，同样它会启动餐厅的程序，同时将参数“http://c.biancheng.net”传给 bar_b，然后执行完 yield bar_b 后（输出 http://c.biancheng.net），程序执行再次暂停。

- close()

  - 当程序在生成器函数中遇到 yield 语句暂停运行时，此时如果调用 close() 方法，会阻止生成器函数继续执行，该函数会在程序停止运行的位置抛出 GeneratorExit 异常。

    ```
    def foo():
        try:
            yield 1
        except GeneratorExit:
            print('捕获到 GeneratorExit')
    f = foo()
    print(next(f))
    f.close()
    
    1
    捕获到 GeneratorExit
    ```

  - 注意，虽然通过捕获 GeneratorExit 异常，可以继续执行生成器函数中剩余的代码，带这部分代码中不能再包含 yield 语句，否则程序会抛出 RuntimeError 异常

    ```
    def foo():
        try:
            yield 1
        except GeneratorExit:
            print('捕获到 GeneratorExit')
            yield 2 #抛出 RuntimeError 异常
    f = foo()
    print(next(f))
    f.close()
    
    1
    捕获到 GeneratorExit Traceback (most recent call last):
      File "D:\python3.6\1.py", line 10, in <module>
        f.close()
    RuntimeError: generator ignored GeneratorExit
    ```

  - 另外，生成器函数一旦使用 close() 函数停止运行，后续将无法再调用 next() 函数或者 `__next__()` 方法启动执行，否则会抛出 StopIteration 异常。例如：

    ```
    def foo():
        yield "c.biancheng.net"
        print("生成器停止执行")
    f = foo()
    print(next(f)) #输出 "c.biancheng.net"
    f.close()
    next(f) #原本应输出"生成器停止执行"
    
    c.biancheng.net
    Traceback (most recent call last):
      File "D:\python3.6\1.py", line 8, in <module>
        next(f) #原本应输出"生成器停止执行"
    StopIteration
    ```

- throw()

  - 生成器 throw() 方法的功能是，在生成器函数执行暂停处，抛出一个指定的异常，之后程序会继续执行生成器函数中后续的代码，直到遇到下一个 yield 语句。需要注意的是，如果到剩余代码执行完毕没有遇到下一个 yield 语句，则程序会抛出 StopIteration 异常。

    ```
    def foo():
        try:
            yield 1
        except ValueError:
            print('捕获到 ValueError')
    f = foo()
    print(next(f))
    f.throw(ValueError)
    
    1
    捕获到 ValueError
    Traceback (most recent call last):
      File "D:\python3.6\1.py", line 9, in <module>
        f.throw(ValueError)
    StopIteration
    ```

    - 显然，一开始生成器函数在 yield 1 处暂停执行，当执行 throw() 方法时，它会先抛出 ValueError 异常，然后继续执行后续代码找到下一个 yield 语句，该程序中由于后续不再有 yield 语句，因此程序执行到最后，会抛出一个 StopIteration 异常。

###### @函数装饰器及用法

- 前面章节中，我们已经讲解了 [Python](http://c.biancheng.net/python/) 内置的 3 种函数装饰器，分别是 ＠staticmethod、＠classmethod 和 @property，其中 staticmethod()、classmethod() 和 property() 都是 Python 的内置函数。

- 那么，函数装饰器的工作原理是怎样的呢？假设用 funA() 函数装饰器去装饰 funB() 函数

  ```
  #funA 作为装饰器函数
  def funA(fn):
      #...
      fn() # 执行传入的fn参数
      #...
      return '...'
  @funA
  def funB():
      #...
  ```

  - 上面程序完全等价于下面的程序

    ```
    def funA(fn):
        #...
        fn() # 执行传入的fn参数
        #...
        return '...'
    def funB():
        #...
    funB = funA(funB)
    ```

  - 通过比对以上 2 段程序不难发现，使用函数装饰器 A() 去装饰另一个函数 B()，其底层执行了如下 2 步操作：

    1. 将 B 作为参数传给 A() 函数；
    2. 将 A() 函数执行完成的返回值反馈回 B。

- 举个实例：

  ```
  #funA 作为装饰器函数
  def funA(fn):
      print("C语言中文网")
      fn() # 执行传入的fn参数
      print("http://c.biancheng.net")
      return "装饰器函数的返回值"
  @funA
  def funB():
      print("学习 Python")
      
  C语言中文网
  学习 Python
  http://c.biancheng.net
  
  在此基础上，如果在程序末尾添加如下语句：
  print(funB)
  
  装饰器函数的返回值
  ```

  - 显然，被“＠函数”修饰的函数不再是原来的函数，而是被替换成一个新的东西（取决于装饰器的返回值），即如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名；同样，如果装饰器返回的是一个函数的名称，那么被修饰的函数名依然表示一个函数。
  - 实际上，所谓函数装饰器，就是通过装饰器函数，在不修改原函数的前提下，来对函数的功能进行合理的扩充。

- 在分析 funA() 函数装饰器和 funB() 函数的关系时，细心的读者可能会发现一个问题，即当 funB() 函数无参数时，可以直接将 funB 作为 funA() 的参数传入。但是，如果被修饰的函数本身带有参数，那应该如何传值呢？

  - 比较简单的解决方法就是在函数装饰器中嵌套一个函数，该函数带有的参数个数和被装饰器修饰的函数相同

    ```
    def funA(fn):
        # 定义一个嵌套函数
        def say(arc):
            print("Python教程:",arc)
        return say
    @funA
    def funB(arc):
        print("funB():", a)
    funB("http://c.biancheng.net/python")
    
    Python教程: http://c.biancheng.net/python
    ```

  - 其实，它和如下程序是等价的：

    ```
    def funA(fn):
        # 定义一个嵌套函数
        def say(arc):
            print("Python教程:",arc)
        return say
    def funB(arc):
        print("funB():", a)
       
    funB = funA(funB)
    funB("http://c.biancheng.net/python")
    ```

  - 显然，通过 funB() 函数被装饰器 funA() 修饰，funB 就被赋值为 say。这意味着，虽然我们在程序显式调用的是 funB() 函数，但其实执行的是装饰器嵌套的 say() 函数。

  - 但还有一个问题需要解决，即如果当前程序中，有多个（≥ 2）函数被同一个装饰器函数修饰，这些函数带有的参数个数并不相等，怎么办呢？最简单的解决方式是用 \*args 和 \\**kwargs 作为装饰器内部嵌套函数的参数，*args 和 **kwargs 表示接受任意数量和类型的参数。

    ```
    def funA(fn):
        # 定义一个嵌套函数
        def say(*args,**kwargs):
            fn(*args,**kwargs)
        return say
    @funA
    def funB(arc):
        print("C语言中文网：",arc)
    @funA
    def other_funB(name,arc):
        print(name,arc)
    funB("http://c.biancheng.net")
    other_funB("Python教程：","http://c.biancheng.net/python")
    
    C语言中文网： http://c.biancheng.net
    Python教程： http://c.biancheng.net/python
    ```

- 上面示例中，都是使用一个装饰器的情况，但实际上，Python 也支持多个装饰器

  ```
  @funA
  @funB
  @funC
  def fun():
      #...
      
  上面程序的执行顺序是里到外，所以它等效于下面这行代码：
  fun = funA( funB ( funC (fun) ) )
  ```

###### 装饰器的应用场景

- 装饰器用于身份认证

  - 首先是最常见的身份认证的应用。这个很容易理解，举个最常见的例子，大家登录微信，需要输入用户名密码，然后点击确认，这样服务器端便会查询你的用户名是否存在、是否和密码匹配等等。如果认证通过，就可以顺利登录；反之，则提示你登录失败。

  - 再比如一些网站，你不登录也可以浏览内容，但如果你想要发布文章或留言，在点击发布时，服务器端便会查询你是否登录。如果没有登录，就不允许这项操作等等。

  - 如下是一个实现身份认证的简单示例：

    ```
    import functools
    def authenticate(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            request = args[0]
            # 如果用户处于登录状态
            if check_user_logged_in(request):
                # 执行函数 post_comment()
                return func(*args, **kwargs)  
            else:
                raise Exception('Authentication failed')
        return wrapper
       
    @authenticate
    def post_comment(request, ...)
        ...
    ```

    - 对于函数来说，它也有自己的一些属性，例如 `__name__` 属性，代码中 @functools.wraps(func) 也是一个装饰器，如果不使用它，则 `post_comment.__name__` 的值为 wrapper。而使用它之后，则 `post_comment.__name__` 的值依然为 post_comment。
    - 上面这段代码中，定义了装饰器 authenticate，函数 post_comment() 则表示发表用户对某篇文章的评论，每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。

- 装饰器用于日志记录

  - 日志记录同样是很常见的一个案例。在实际工作中，如果你怀疑某些函数的耗时过长，导致整个系统的延迟增加，想在线上测试某些函数的执行时间，那么，装饰器就是一种很常用的手段。

    ```
    import time
    import functools
    def log_execution_time(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            start = time.perf_counter()
            res = func(*args, **kwargs)
            end = time.perf_counter()
            print('{} took {} ms'.format(func.__name__, (end - start) * 1000))
            return res
        return wrapper
       
    @log_execution_time
    def calculate_similarity(items):
        ...
    ```

    - 装饰器 log_execution_time 记录某个函数的运行时间，并返回其执行结果。如果你想计算任何函数的执行时间，在这个函数上方加上@log_execution_time即可。

- 装饰器用于输入合理性检查

  - 在大型公司的机器学习框架中，调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检查。这样就可以大大避免输入不正确对机器造成的巨大开销。

    ```
    import functools
    def validation_check(input):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            ... # 检查输入是否合法
       
    @validation_check
    def neural_network_training(param1, param2, ...):
        ...
    ```

  - 其实在工作中，很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现。

  - 试想一下，如果没有输入的合理性检查，很容易出现“模型训练了好几个小时后，系统却报错说输入的一个参数不对，成果付之一炬”的现象。这样的“惨案”，大大减缓了开发效率，也对机器资源造成了巨大浪费。

- 缓存装饰器

  - 关于缓存装饰器的用法，其实十分常见，这里以 Python 内置的 LRU cache 为例来说明。LRU cache，在 Python 中的表示形式是 @lru_cache。@lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除最近最久未使用的数据。

  - 正确使用缓存装饰器，往往能极大地提高程序运行效率。举个例子，大型公司服务器端的代码中往往存在很多关于设备的检查，比如使用的设备是安卓还是 iPhone，版本号是多少。这其中的一个原因，就是一些新的功能，往往只在某些特定的手机系统或版本上才有（比如 Android v200+）。

  - 这样一来，我们通常使用缓存装饰器来包裹这些检查函数，避免其被反复调用，进而提高程序运行效率，比如写成下面这样：

    ```
    @lru_cache
    def check(param1, param2, ...) # 检查用户设备类型，版本号等等
        ...
    ```

#### 文件操作

- 路径中的 D:\ 指的是“根文件夹”，它包含了所有其他文件夹。在 Windows 中，根文件夹名为 D:\，也称为 D: 盘。在 OS X 和 Linux 中，根文件夹是 /。本教程使用的是 Windows 风格的根文件夹，如果你在 OS X 或 Linux 上输入交互式环境的例子，请用 / 代替。

- 另外，附加卷（诸如 DVD 驱动器或 USB 闪存驱动器），在不同的操作系统上显示也不同。在 Windows 上，它们表示为新的、带字符的根驱动器。诸如 D:\ 或 E:\。在 OS X 上，它们表示为新的文件夹，在 /Volumes 文件夹下。在 Linux 上，它们表示为新的文件夹，在 /mnt 文件夹下。同时也要注意，虽然文件夹名称和文件名在 Windows 和 OS X 上是不区分大小写的，但在 Linux 上是区分大小写的。

- 在 Windows 上，路径书写使用反斜杠 "\\" 作为文件夹之间的分隔符。但在 OS X 和 Linux 上，使用正斜杠 "/" 作为它们的路径分隔符。如果想要程序运行在所有操作系统上，在编写 Python 脚本时，就必须处理这两种情况。

- 好在，用 os.path.join() 函数来做这件事很简单。如果将单个文件和路径上的文件夹名称的字符串传递给它，os.path.join() 就会返回一个文件路径的字符串，包含正确的路径分隔符。在交互式环境中输入以下代码：

  ```python
  >>> import os
  >>> os.path.join('demo', 'exercise')
  'demo\\exercise'
  ```

  - 因为此程序是在 Windows 上运行的，所以 os.path.join('demo', 'exercise') 返回 'demo\\exercise'（请注意，反斜杠有两个，因为每个反斜杠需要由另一个反斜杠字符来转义）。如果在 OS X 或 Linux 上调用这个函数，该字符串就会是 'demo/exercise'。

- 不仅如此，如果需要创建带有文件名称的文件存储路径，os.path.join() 函数同样很有用。例如，下面的例子将一个文件名列表中的名称，添加到文件夹名称的末尾：

  ```python
  import os
  myFiles = ['accounts.txt', 'details.csv', 'invite.docx']
  for filename in myFiles:
      print(os.path.join('C:\\demo\\exercise', filename))
      
  C:\demo\exercise\accounts.txt
  C:\demo\exercise\details.csv
  C:\demo\exercise\invite.docx
  ```

- 在 [Python](http://c.biancheng.net/python/) 中，利用 os.getcwd() 函数可以取得当前工作路径的字符串，还可以利用 os.chdir() 改变它。

  ```python
  >>> import os
  >>> os.getcwd()
  'C:\\Users\\mengma\\Desktop'
  >>> os.chdir('C:\\Windows\\System32')
  >>> os.getcwd()
  'C:\\Windows\\System32'
  ```

  - 可以看到，原本当前工作路径为 'C:\\Users\\mengma\\Desktop'（也就是桌面），通过 os.chdir() 函数，将其改成了 'C:\\Windows\\System32'。

  - 需要注意的是，如果使用 os.chdir() 修改的工作目录不存在，Python 解释器会报错

    ```python
    >>> os.chdir('C:\\error')
    Traceback (most recent call last):
      File "<pyshell#6>", line 1, in <module>
        os.chdir('C:\\error')
    FileNotFoundError: [WinError 2] 系统找不到指定的文件。: 'C:\\error'
    ```

- Python os.path 模块提供了一些函数，可以实现绝对路径和相对路径之间的转换，以及检查给定的路径是否为绝对路径，比如说：

  - 调用 os.path.abspath(path) 将返回 path 参数的绝对路径的字符串，这是将相对路径转换为绝对路径的简便方法。

  - 调用 os.path.isabs(path)，如果参数是一个绝对路径，就返回 True，如果参数是一个相对路径，就返回 False。

  - 调用 os.path.relpath(path, start) 将返回从 start 路径到 path 的相对路径的字符串。如果没有提供 start，就使用当前工作目录作为开始路径。

  - 调用 os.path.dirname(path) 将返回一个字符串，它包含 path 参数中最后一个斜杠之前的所有内容；调用 os.path.basename(path) 将返回一个字符串，它包含 path 参数中最后一个斜杠之后的所有内容。

    ```python
    >>> os.getcwd()
    'C:\\Windows\\System32'
    >>> os.path.abspath('.')
    'C:\\Windows\\System32'
    >>> os.path.abspath('.\\Scripts')
    'C:\\Windows\\System32\\Scripts'
    >>> os.path.isabs('.')
    False
    >>> os.path.isabs(os.path.abspath('.'))
    True
    >>> os.path.relpath('C:\\Windows', 'C:\\')
    'Windows'
    >>> os.path.relpath('C:\\Windows', 'C:\\spam\\eggs')
    '..\\..\\Windows'
    >>> path = 'C:\\Windows\\System32\\calc.exe'
    >>> os.path.basename(path)
    'calc.exe'
    >>> os.path.dirname(path)
    'C:\\Windows\\System32'
    ```

  - 除此之外，如果同时需要一个路径的目录名称和基本名称，就可以调用 os.path.split() 获得这两个字符串的元组

    ```python
    >>> path = 'C:\\Windows\\System32\\calc.exe'
    >>> os.path.split(path)
    ('C:\\Windows\\System32', 'calc.exe')
    ```

    - 可以调用 os.path.dirname()和 os.path.basename()，将它们的返回值放在一个元组中，从而得到同样的元组。但使用 os.path.split() 无疑是很好的快捷方式。

- 同时，如果提供的路径不存在，许多 Python 函数就会崩溃并报错，但好在 os.path 模块提供了以下函数用于检测给定的路径是否存在，以及它是文件还是文件夹：

  - 如果 path 参数所指的文件或文件夹存在，调用 os.path.exists(path) 将返回 True，否则返回 False。

  - 如果 path 参数存在，并且是一个文件，调用 os.path.isfile(path) 将返回 True，否则返回 False。

  - 如果 path 参数存在，并且是一个文件夹，调用 os.path.isdir(path) 将返回 True，否则返回 False。

    ```python
    >>> os.path.exists('C:\\Windows')
    True
    >>> os.path.exists('C:\\some_made_up_folder')
    False
    >>> os.path.isdir('C:\\Windows\\System32')
    True
    >>> os.path.isfile('C:\\Windows\\System32')
    False
    >>> os.path.isdir('C:\\Windows\\System32\\calc.exe')
    False
    >>> os.path.isfile('C:\\Windows\\System32\\calc.exe')
    True
    ```

- 文件的应用级操作可以分为以下 3 步，每一步都需要借助对应的函数实现：

  1. 打开文件：使用 open() 函数，该函数会返回一个文件对象；
  2. 对已打开文件做读/写操作：读取文件内容可使用 read()、readline() 以及 readlines() 函数；向文件中写入内容，可以使用 write() 函数。
  3. 关闭文件：完成对文件的读/写操作之后，最后需要关闭文件，可以使用 close() 函数。

###### open()

- open() 函数用于创建或打开指定文件，该函数的常用语法格式如下：

  ```python
  file = open(file_name [, mode='r' [ , buffering=-1 [ , encoding = None ]]])
  ```

  - 此格式中，用 [] 括起来的部分为可选参数，即可以使用也可以省略。其中，各个参数所代表的含义如下：

    - file：表示要创建的文件对象。
    - file_name：要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。
    - mode：可选参数，用于指定文件的打开模式。可选的打开模式如表 1 所示。如果不写，则默认以只读（r）模式打开文件。
    - buffering：可选参数，用于指定对文件做读写操作时，是否使用缓冲区（本节后续会详细介绍）。
    - encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同，以 Windows 为例，其默认为 cp936（实际上就是 GBK 编码）。

    | 模式 | 意义                                                         | 注意事项                                                     |
    | ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | r    | 只读模式打开文件，读文件内容的指针会放在文件的开头。         | 操作的文件必须存在。                                         |
    | rb   | 以二进制格式、采用只读模式打开文件，读文件内容的指针位于文件的开头，一般用于非文本文件，如图片文件、音频文件等。 |                                                              |
    | r+   | 打开文件后，既可以从头读取文件内容，也可以从开头向文件中写入新的内容，写入的新内容会覆盖文件中等长度的原有内容。 |                                                              |
    | rb+  | 以二进制格式、采用读写模式打开文件，读写文件的指针会放在文件的开头，通常针对非文本文件（如音频文件）。 |                                                              |
    | w    | 以只写模式打开文件，若该文件存在，打开时会清空文件中原有的内容。 | 若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。 |
    | wb   | 以二进制格式、只写模式打开文件，一般用于非文本文件（如音频文件） |                                                              |
    | w+   | 打开文件后，会对原有内容进行清空，并对该文件有读写权限。     |                                                              |
    | wb+  | 以二进制格式、读写模式打开文件，一般用于非文本文件           |                                                              |
    | a    | 以追加模式打开一个文件，对文件只有写入权限，如果文件已经存在，文件指针将放在文件的末尾（即新写入内容会位于已有内容之后）；反之，则会创建新文件。 |                                                              |
    | ab   | 以二进制格式打开文件，并采用追加模式，对文件只有写权限。如果该文件已存在，文件指针位于文件末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。 |                                                              |
    | a+   | 以读写模式打开文件；如果文件存在，文件指针放在文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。 |                                                              |
    | ab+  | 以二进制模式打开文件，并采用追加模式，对文件具有读写权限，如果文件存在，则文件指针位于文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。 |                                                              |

  ![](http://c.biancheng.net/uploads/allimg/190228/2-1Z22QI61c59.gif)

- 默认打开 "a.txt" 文件。

  ```python
  #当前程序文件同目录下没有 a.txt 文件
  file = open("a.txt")
  print(file)
  
  <_io.TextIOWrapper name='a.txt' mode='r' encoding='cp936'>
  ```

  - 当以默认模式打开文件时，默认使用 r 权限，该权限要求打开的文件必须存在
  - 可以看到，当前输出结果中，输出了 file 文件对象的相关信息，包括打开文件的名称、打开模式、打开文件时所使用的编码格式。

- 使用 open() 打开文件时，默认采用 GBK 编码。但当要打开的文件不是 GBK 编码格式时，可以在使用 open() 函数时，手动指定打开文件的编码格式，例如：

  ```
  file = open("a.txt",encoding="utf-8")
  ```

  - 手动修改 encoding 参数的值，仅限于文件以文本的形式打开，也就是说，以二进制格式打开时，不能对 encoding 参数的值做任何修改，否则程序会抛出 ValueError 异常

- 通常情况下、建议大家在使用 open() 函数时打开缓冲区，即不需要修改 buffing 参数的值。如果 buffing 参数的值为 0（或者 False），则表示在打开指定文件时不使用缓冲区；如果 buffing 参数值为大于 1 的整数，该整数用于指定缓冲区的大小（单位是字节）；如果 buffing 参数的值为负数，则代表使用默认的缓冲区大小。

- 成功打开文件之后，可以调用文件对象本身拥有的属性获取当前文件的部分信息，其常见的属性为：

  - file.name：返回文件的名称；

  - file.mode：返回打开文件时，采用的文件打开模式；

  - file.encoding：返回打开文件时使用的编码格式；

  - file.closed：判断文件是否己经关闭。

    ```python
    # 以默认方式打开文件
    f = open('my_file.txt')
    # 输出文件是否已经关闭
    print(f.closed)
    # 输出访问模式
    print(f.mode)
    #输出编码格式
    print(f.encoding)
    # 输出文件名
    print(f.name)
    
    False
    r
    cp936
    my_file.txt
    ```

- 使用 open() 函数打开的文件对象，必须手动进行关闭（后续章节会详细讲解），Python 垃圾回收机制无法自动回收打开文件所占用的资源。

###### 文本格式和二进制格式

- open() 函数第二个参数是一个字符串，用于指定文件的打开方式，如果该字符串中出现 b，则表示以二进制格式打开文件；反之，则以普通的文本格式打开文件。
- 根据我们以往的经验，文本文件通常用来保存肉眼可见的字符，比如 .txt 文件、.c 文件、.dat 文件等，用文本编辑器打开这些文件，我们能够顺利看懂文件的内容。而二进制文件通常用来保存视频、图片、音频等不可阅读的内容，当用文本编辑器打开这些文件，会看到一堆乱码，根本看不懂。
- 实际上，从数据存储的角度上分析，二进制文件和文本文件没有区别，它们的内容都是以二进制的形式保存在磁盘中的。
- 我们之所以能看懂文本文件的内容，是因为文本文件中采用的是 ASCII、UTF-8、GBK 等字符编码，文本编辑器可以识别出这些编码格式，并将编码值转换成字符展示出来。而对于二进制文件，文本编辑器无法识别这些文件的编码格式，只能按照字符编码格式胡乱解析，所以最终看到的是一堆乱码。
- 使用 open() 函数以文本格式打开文件和以二进制格式打开文件，唯一的区别是对文件中换行符的处理不同。
- 在 Windows 系统中，文件中用 "\r\n" 作为行末标识符（即换行符），当以文本格式读取文件时，会将 "\r\n" 转换成 "\n"；反之，以文本格式将数据写入文件时，会将 "\n" 转换成 "\r\n"。这种隐式转换换行符的行为，对用文本格式打开文本文件是没有问题的，但如果用文本格式打开二进制文件，就有可能改变文本中的数据（将 \r\n 隐式转换为 \n）。
- 而在 Unix/Linux 系统中，默认的文件换行符就是 \n，因此在 Unix/Linux 系统中文本格式和二进制格式并无本质的区别。
- 总的来说，为了保险起见，对于 Windows平台最好用 b 打开二进制文件；对于 Unix/Linux 平台，打开二进制文件，可以用 b，也可以不用。

###### read()

- [Python](http://c.biancheng.net/python/) 提供了如下 3 种函数，它们都可以帮我们实现读取文件中数据的操作：

  1. read() 函数：逐个字节或者字符读取文件中的内容；
  2. readline() 函数：逐行读取文件中的内容；
  3. readlines() 函数：一次性读取文件中多行内容。

- read()函数

  - 对于借助 open() 函数，并以可读模式（包括 r、r+、rb、rb+）打开的文件，可以调用 read() 函数逐个字节（或者逐个字符）读取文件中的内容。如果文件是以文本模式（非二进制模式）打开的，则 read() 函数会逐个字符进行读取；反之，如果文件以二进制模式打开，则 read() 函数会逐个字节进行读取。

    ```python
    file.read([size])
    ```

  - file 表示已打开的文件对象；size 作为一个可选参数，用于指定一次最多可读取的字符（字节）个数，如果省略，则默认一次性读取所有内容。

  - 当操作文件结束后，必须调用 close() 函数手动将打开的文件进行关闭，这样可以避免程序发生不必要的错误。

  - 我们也可以通过使用 size 参数，指定 read() 每次可读取的最大字符（或者字节）数

    ```python
    Python教程
    http://c.biancheng.net/python/
    #以 utf-8 的编码格式打开指定文件
    f = open("my_file.txt",encoding = "utf-8")
    #输出读取到的数据
    print(f.read(6))
    #关闭文件
    f.close()
    
    Python
    ```

  - 再次强调，size 表示的是一次最多可读取的字符（或字节）数，因此，即便设置的 size 大于文件中存储的字符（字节）数，read() 函数也不会报错，它只会读取文件中所有的数据。

  - 除此之外，对于以二进制格式打开的文件，read() 函数会逐个字节读取文件中的内容

    ```python
    #以二进制形式打开指定文件
    f = open("my_file.txt",'rb+')
    #输出读取到的数据
    print(f.read())
    #关闭文件
    f.close()
    
    b'Python\xe6\x95\x99\xe7\xa8\x8b\r\nhttp://c.biancheng.net/python/'
    ```

    - 上面中的\x的6个字节其实是中文的字符，因为是以b格式打开的，只是会读取二进制的，但是ASCII二进制的会输出字母，但是中文的不会输出来
    - 可以看到，输出的数据为 bytes 字节串。我们可以调用 decode() 方法，将其转换成我们认识的字符串。

  - 在使用 read() 函数时，如果 Python 解释器提示`UnicodeDecodeError`异常，其原因在于，目标文件使用的编码格式和 open() 函数打开该文件时使用的编码格式不匹配。要解决这个问题，要么将 open() 函数中的 encoding 参数值修改为和目标文件相同的编码格式，要么重新生成目标文件（即将该文件的编码格式改为和 open() 函数中的 encoding 参数相同）。除此之外，还有一种方法：先使用二进制模式读取文件，然后调用 bytes 的 decode() 方法，使用目标文件的编码格式，将读取到的字节串转换成认识的字符串。

    ```python
    #以二进制形式打开指定文件，该文件编码格式为 utf-8
    f = open("my_file.txt",'rb+')
    byt = f.read()
    print(byt)
    print("\n转换后：")
    print(byt.decode('utf-8'))
    #关闭文件
    f.close()
    
    b'Python\xe6\x95\x99\xe7\xa8\x8b\r\nhttp://c.biancheng.net/python/'
    
    转换后：
    Python教程
    http://c.biancheng.net/python/
    ```

- readline()用于读取文件中的一行，包含最后的换行符“\n”

  ```
  file.readline([size])
  ```

  - file 为打开的文件对象；size 为可选参数，用于指定读取每一行时，一次最多读取的字符（字节）数。
  - size是每一行最多读取的字节数，并不是读取多少行，所以这个函数最多读取一行

- readlines() 函数用于读取文件中的所有行，它和调用不指定 size 参数的 read() 函数类似，只不过该函数返回是一个字符串列表，其中每个元素为文件中的一行内容。

  ```python
  file.readlines()
  
  f = open("my_file.txt",'rb')
  byt = f.readlines()
  print(byt)
  
  [b'Python\xbd\xcc\xb3\xcc\r\n', b'http://c.biancheng.net/python/']
  ```

###### write()和writelines()

- [Python](http://c.biancheng.net/python/) 中的文件对象提供了 write() 函数，可以向文件中写入指定内容。该函数的语法格式如下：

  ```
  file.write(string)
  ```

  - file 表示已经打开的文件对象；string 表示要写入文件的字符串（或字节串，仅适用写入二进制文件中）。

  - 在使用 write() 向文件中写入数据，需保证使用 open() 函数是以 r+、w、w+、a 或 a+ 的模式打开文件，否则执行 write() 函数会抛出 io.UnsupportedOperation 错误。

  - 如果向文件写入数据后，不想马上关闭文件，也可以调用文件对象提供的 flush() 函数，它可以实现将缓冲区的数据写入文件中。

    ```python
    f = open("a.txt", 'w')
    f.write("写入一行新数据")
    f.flush()
    ```

  - 有读者可能会想到，通过设置 open() 函数的 buffering 参数可以关闭缓冲区，这样数据不就可以直接写入文件中了？对于以二进制格式打开的文件，可以不使用缓冲区，写入的数据会直接进入磁盘文件；但对于以文本格式打开的文件，必须使用缓冲区，否则 Python 解释器会 ValueError 错误。

- Python 的文件对象中，不仅提供了 write() 函数，还提供了 writelines() 函数，可以实现将字符串列表写入文件中。写入函数只有 write() 和 writelines() 函数，而没有名为 writeline 的函数。

  - 还是以 a.txt 文件为例，通过使用 writelines() 函数，可以轻松实现将 a.txt 文件中的数据复制到其它文件中

    ```python
    f = open('a.txt', 'r')
    n = open('b.txt','w+')
    n.writelines(f.readlines())
    n.close()
    f.close()
    ```

  - 执行此代码，在 a.txt 文件同级目录下会生成一个 b.txt 文件，且该文件中包含的数据和 a.txt 完全一样。

  - 需要注意的是，使用 writelines() 函数向文件中写入多行数据时，不会自动给各行添加换行符。上面例子中，之所以 b.txt 文件中会逐行显示数据，是因为 readlines() 函数在读取各行数据时，读入了行尾的换行符。

###### seek()和tell()

- 文件指针用于标明文件读写的起始位置。假如把文件看成一个水流，文件中每个数据（以 b 模式打开，每个数据就是一个字节；以普通模式打开，每个数据就是一个字符）就相当于一个水滴，而文件指针就标明了文件将要从文件的哪个位置开始读起

- tell() 函数用于判断文件指针当前所处的位置，而 seek() 函数用于移动文件指针到文件的指定位置。

- 当向文件中写入数据时，如果不是文件的尾部，写入位置的原有数据不会自行向后移动，新写入的数据会将文件中处于该位置的数据直接覆盖掉。

- tell() 函数

  ```python
  file.tell()
  
  http://c.biancheng.net
  
  f = open("a.txt",'r')
  print(f.tell())
  print(f.read(3))
  print(f.tell())
  
  0
  htt
  3
  ```

  - 可以看到，当使用 open() 函数打开文件时，文件指针的起始位置为 0，表示位于文件的开头处，当使用 read() 函数从文件中读取 3 个字符之后，文件指针同时向后移动了 3 个字符的位置。这就表明，当程序使用文件对象读写数据时，文件指针会自动向后移动：读写了多少个数据，文件指针就自动向后移动多少个位置。

- seek() 函数用于将文件指针移动至指定位置

  ```
  file.seek(offset[, whence])
  ```

  - file：表示文件对象；

  - whence：作为可选参数，用于指定文件指针要放置的位置，该参数的参数值有 3 个选择：0 代表文件头（默认值）、1 代表当前位置、2 代表文件尾。

  - offset：表示相对于 whence 位置文件指针的偏移量，正数表示向后偏移，负数表示向前偏移。例如，当`whence == 0 &&offset == 3`（即 seek(3,0) ），表示文件指针移动至距离文件开头处 3 个字符的位置；当`whence == 1 &&offset == 5`（即 seek(5,1) ），表示文件指针向后移动，移动至距离当前位置 5 个字符处。

  - 当 offset 值非 0 时，[Python](http://c.biancheng.net/python/) 要求文件必须要以二进制格式打开，否则会抛出 io.UnsupportedOperation 错误。

    ```python
    f = open('a.txt', 'rb')
    # 判断文件指针的位置
    print(f.tell())
    # 读取一个字节，文件指针自动后移1个数据
    print(f.read(1))
    print(f.tell())
    # 将文件指针从文件开头，向后移动到 5 个字符的位置
    f.seek(5)
    print(f.tell())
    print(f.read(1))
    # 将文件指针从当前位置，向后移动到 5 个字符的位置
    f.seek(5, 1)
    print(f.tell())
    print(f.read(1))
    # 将文件指针从文件结尾，向前移动到距离 2 个字符的位置
    f.seek(-1, 2)
    print(f.tell())
    print(f.read(1))
    
    0
    b'h'
    1
    5
    b'/'
    11
    b'a'
    21
    b't'
    ```

###### with as

- 任何一门编程语言中，文件的输入输出、数据库的连接断开等，都是很常见的资源管理操作。但资源都是有限的，在写程序时，必须保证这些资源在使用过后得到释放，不然就容易造成资源泄露，轻者使得系统处理缓慢，严重时会使系统崩溃。

- 例如，前面在介绍文件操作时，一直强调打开的文件最后一定要关闭，否则会程序的运行造成意想不到的隐患。但是，即便使用 close() 做好了关闭文件的操作，如果在打开文件或文件操作过程中抛出了异常，还是无法及时关闭文件。

- 为了更好地避免此类问题，不同的编程语言都引入了不同的机制。在 [Python](http://c.biancheng.net/python/) 中，对应的解决方式是使用 with as 语句操作上下文管理器（context manager），它能够帮助我们自动分配并且释放资源。

- 简单的理解，同时包含 `__enter__()` 和 `__exit__()` 方法的对象就是上下文管理器。常见构建上下文管理器的方式有 2 种，分别是基于类实现和基于生成器实现

- 例如，使用 with as 操作已经打开的文件对象（本身就是上下文管理器），无论期间是否抛出异常，都能保证 with as 语句执行完毕后自动关闭已经打开的文件。

  ```
  with 表达式 [as target]：
      代码块
  ```

  - 此格式中，用 [] 括起来的部分可以使用，也可以省略。其中，target 参数用于指定一个变量，该语句会将 expression 指定的结果保存到该变量中。with as 语句中的代码块如果不想执行任何语句，可以直接使用 pass 语句代替。

  ```python
  举个例子，假设有一个 a.txt 文件
  C语言中文网
  http://c.biancheng.net
  在和 a.txt 同级目录下，创建一个 .py 文件，并编写如下代码：
  with open('a.txt', 'a') as f:
      f.write("\nPython教程")
      
  C语言中文网
  http://c.biancheng.net
  Python教程
  ```

  - 可以看到，通过使用 with as 语句，即便最终没有关闭文件，修改文件内容的操作也能成功。

###### with as底层原理

- 在介绍 with as 语句时讲到，该语句操作的对象必须是上下文管理器。那么，到底什么是上下文管理器呢？
- 简单的理解，同时包含 `__enter__()` 和 `__exit__()` 方法的对象就是上下文管理器。也就是说，上下文管理器必须实现如下两个方法：
  1. `__enter__`(self)：进入上下文管理器自动调用的方法，该方法会在 with as 代码块执行之前执行。如果 with 语句有 as子句，那么该方法的返回值会被赋值给 as 子句后的变量；该方法可以返回多个值，因此在 as 子句后面也可以指定多个变量（多个变量必须由“()”括起来组成元组）。
  2. `__exit__`（self, exc_type, exc_value, exc_traceback）：退出上下文管理器自动调用的方法。该方法会在 with as 代码块执行之后执行。如果 with as 代码块成功执行结束，程序自动调用该方法，调用该方法的三个参数都为 None：如果 with as 代码块因为异常而中止，程序也自动调用该方法，使用 sys.exc_info 得到的异常信息将作为调用该方法的参数。

- 当 with as 操作上下文管理器时，就会在执行语句体之前，先执行上下文管理器的 `__enter__()` 方法，然后再执行语句体，最后执行 `__exit__()` 方法。


- 构建上下文管理器，常见的有 2 种方式：基于类实现和基于生成器实现。

- 基于类的上下文管理器

  - 通过上面的介绍不难发现，只要一个类实现了 `__enter__()` 和 `__exit__()` 这 2 个方法，程序就可以使用 with as 语句来管理它，通过 `__exit__()` 方法的参数，即可判断出 with 代码块执行时是否遇到了异常。其实，上面程序中的文件对象也实现了这两个方法，因此可以接受 with as 语句的管理。

  - 下面我们自定义一个实现上下文管理协议的类，并尝试用 with as 语句来管理它：

    ```python
    class FkResource:
        def __init__(self, tag):
            self.tag = tag
            print('构造器,初始化资源: %s' % tag)
        # 定义__enter__方法，with体之前的执行的方法
        def __enter__(self):
            print('[__enter__ %s]: ' % self.tag)
            # 该返回值将作为as子句中变量的值
            return 'fkit'  # 可以返回任意类型的值
        # 定义__exit__方法，with体之后的执行的方法
        def __exit__(self, exc_type, exc_value, exc_traceback):
            print('[__exit__ %s]: ' % self.tag)
            # exc_traceback为None，代表没有异常
            if exc_traceback is None:
                print('没有异常时关闭资源')
            else:
                print('遇到异常时关闭资源')
                return False   # 可以省略，默认返回None也被看做是False
    with FkResource('孙悟空') as dr:
        print(dr)
        print('[with代码块] 没有异常')
    print('------------------------------')
    with FkResource('白骨精'):
        print('[with代码块] 异常之前的代码')
        raise Exception
        print('[with代码块] ~~~~~~~~异常之后的代码')
        
    构造器,初始化资源: 孙悟空
    [__enter__ 孙悟空]:
    fkit
    [with代码块] 没有异常
    [__exit__ 孙悟空]:
    没有异常时关闭资源
    ------------------------------
    构造器,初始化资源: 白骨精
    [__enter__ 白骨精]:
    [with代码块] 异常之前的代码
    [__exit__ 白骨精]:
    遇到异常时关闭资源
    Traceback (most recent call last):
      File "C:\Users\mengma\Desktop\1.py", line 26, in <module>
        raise Exception
    Exception
    ```

    - 上面程序定义了一个 FkResource 类，并包含了 `__enter__()` 和 `__exit__()` 两个方法，因此该类的对象可以被 with as 语句管理。
    - 此外，程序中两次使用 with as 语句管理 FkResource 对象。第一次代码块没有出现异常，第二次代码块出现了异常。从上面的输出结果来看，使用 with as 语句管理资源，无论代码块是否有异常，程序总可以自动执行 `__exit__()` 方法。
    - 注意，当出现异常时，如果 `__exit__` 返回 False（默认不写返回值时，即为 False），则会重新抛出异常，让 with as 之外的语句逻辑来处理异常；反之，如果返回 True，则忽略异常，不再对异常进行处理。

- 基于生成器的上下文管理器

  - 除了基于类的上下文管理器，它还可以基于生成器实现。接下来先看一个例子。比如，我们可以使用装饰器 contextlib.contextmanager，来定义自己所需的基于生成器的上下文管理器，用以支持 with as 语句：

    ```python
    from contextlib import contextmanager
    @contextmanager
    def file_manager(name, mode):
        try:
            f = open(name, mode)
            yield f
        finally:
            f.close()
           
    with file_manager('a.txt', 'w') as f:
        f.write('hello world')
    ```

    - 这段代码中，函数 file_manager() 就是一个生成器，当我们执行 with as 语句时，便会打开文件，并返回文件对象 f；当 with 语句执行完后，finally 中的关闭文件操作便会执行。另外可以看到，使用基于生成器的上下文管理器时，不再用定义 `__enter__()` 和 `__exit__()` 方法，但需要加上装饰器 @contextmanager，这一点新手很容易疏忽。
    - 需要强调的是，基于类的上下文管理器和基于生成器的上下文管理器，这两者在功能上是一致的。只不过，基于类的上下文管理器更加灵活，适用于大型的系统开发，而基于生成器的上下文管理器更加方便、简洁，适用于中小型程序。但是，无论使用哪一种，不用忘记在方法“`__exit__()`”或者是 finally 块中释放资源，这一点尤其重要。

###### Pickle模块

- [Python](http://c.biancheng.net/python/) 中有个序列化过程叫作 pickle，它能够实现任意对象与文本之间的相互转化，也可以实现任意对象与二进制之间的相互转化。也就是说，pickle 可以实现 Python 对象的存储及恢复。

- 值得一提的是，pickle 是 python 语言的一个标准模块，安装 python 的同时就已经安装了 pickle 库，因此它不需要再单独安装，使用 import 将其导入到程序中，就可以直接使用。

- pickle 模块提供了以下 4 个函数供我们使用：

  - dumps()：将 Python 中的对象序列化成二进制对象，并返回；
  - loads()：读取给定的二进制对象数据，并将其转换为 Python 对象；
  - dump()：将 Python 中的对象序列化成二进制对象，并写入文件；
  - load()：读取指定的序列化数据文件，并返回对象。
  - 以上这 4 个函数可以分成两类，其中 dumps 和 loads 实现基于内存的 Python 对象与二进制互转；dump 和 load 实现基于文件的 Python 对象与二进制互转。

  ```
  dumps(obj, protocol=None, *, fix_imports=True)
  
  import pickle
  tup1 = ('I love Python', {1,2,3}, None)
  #使用 dumps() 函数将 tup1 转成 p1
  p1 = pickle.dumps(tup1)
  print(p1)
  
  b'\x80\x03X\r\x00\x00\x00I love Pythonq\x00cbuiltins\nset\nq\x01]q\x02(K\x01K\x02K\x03e\x85q\x03Rq\x04N\x87q\x05.'
  ```

- 此格式中各个参数的含义为：

  - obj：要转换的 Python 对象；
  - protocol：pickle 的转码协议，取值为 0、1、2、3、4，其中 0、1、2 对应 Python 早期的版本，3 和 4 则对应 Python 3.x 版本及之后的版本。未指定情况下，默认为 3。
  - 其它参数：为了兼容 Python 2.x 版本而保留的参数，Python 3.x 中可以忽略。

  ```
  loads(data, *, fix_imports=True, encoding='ASCII', errors='strict')
  
  import pickle
  tup1 = ('I love Python', {1,2,3}, None)
  p1 = pickle.dumps(tup1)
  #使用 loads() 函数将 p1 转成 Python 对象
  t2 = pickle.loads(p1)
  print(t2)
  
  ('I love Python', {1, 2, 3}, None)
  ```

  - data 参数表示要转换的二进制对象，其它参数只是为了兼容 Python 2.x 版本而保留的，可以忽略。
  - 注意，在使用 loads() 函数将二进制对象反序列化成 Python 对象时，会自动识别转码协议，所以不需要将转码协议当作参数传入。并且，当待转换的二进制对象的字节数超过 pickle 的 Python 对象时，多余的字节将被忽略。

  ```
  dump (obj, file,protocol=None, *, fix mports=True)
  
  import pickle
  tup1 = ('I love Python', {1,2,3}, None)
  #使用 dumps() 函数将 tup1 转成 p1
  with open ("a.txt", 'wb') as f: #打开文件
      pickle.dump(tup1, f) #用 dump 函数将 Python 对象转成二进制对象文件
  ```

- 其中各个参数的具体含义如下：

  - obj：要转换的 Python 对象。
  - file：转换到指定的二进制文件中，要求该文件必须是以"wb"的打开方式进行操作。
  - protocol：和 dumps() 函数中 protocol 参数的含义完全相同，因此这里不再重复描述。
  - 其他参数：为了兼容以前 Python 2.x版本而保留的参数，可以忽略。
  - 运行完此程序后，会在该程序文件同级目录中，生成 a.txt 文件，但由于其内容为二进制数据，因此直接打开会看到乱码。

  ```
  load(file, *, fix_imports=True, encoding='ASCII', errors='strict')
  
  import pickle
  tup1 = ('I love Python', {1,2,3}, None)
  #使用 dumps() 函数将 tup1 转成 p1
  with open ("a.txt", 'wb') as f: #打开文件
      pickle.dump(tup1, f) #用 dump 函数将 Python 对象转成二进制对象文件
  with open ("a.txt", 'rb') as f: #打开文件
      t3 = pickle.load(f) #将二进制文件对象转换成 Python 对象
      print(t3)
      
  ('I love Python', {1, 2, 3}, None)
  ```

  - file 参数表示要转换的二进制对象文件（必须以 "rb" 的打开方式操作文件），其它参数只是为了兼容 Python 2.x 版本而保留的参数，可以忽略。

- 看似强大的 pickle 模块，其实也有它的短板，即 pickle 不支持并发地访问持久性对象，在复杂的系统环境下，尤其是读取海量数据时，使用 pickle 会使整个系统的`I/O`读取性能成为瓶颈。这种情况下，可以使用 ZODB。

- ZODB 是一个健壮的、多用户的和面向对象的数据库系统，专门用于存储 Python 语言中的对象数据，它能够存储和管理任意复杂的 Python 对象，并支持事务操作和并发控制。并且，ZODB 也是在 Python 的序列化操作基础之上实现的，因此要想有效地使用 ZODB，必须先学好 pickle。

###### fileinput模块

- 前面章节中，我们学会了使用 open() 和 read()（或者 readline()、readlines() ）组合，来读取单个文件中的数据。但在某些场景中，可能需要读取多个文件的数据，这种情况下，再使用这个组合，显然就不合适了。

- 庆幸的是，[Python](http://c.biancheng.net/python/) 提供了 fileinput 模块，通过该模块中的 input() 函数，我们能同时打开指定的多个文件，还可以逐个读取这些文件中的内容。

  ```
  fileinput.input（files="filename1, filename2, ...", inplace=False, backup='', bufsize=0, mode='r', openhook=None）
  ```

- 此函数会返回一个 FileInput 对象，它可以理解为是将多个指定文件合并之后的文件对象。其中，各个参数的含义如下：

  - files：多个文件的路径列表；
  - inplace：用于指定是否将标准输出的结果写回到文件，此参数默认值为 False；
  - backup：用于指定备份文件的扩展名；
  - bufsize：指定缓冲区的大小，默认为 0；
  - mode：打开文件的格式，默认为 r（只读格式）；
  - openhook：控制文件的打开方式，例如编码格式等。

- 和 open() 函数不同，input() 函数不能指定打开文件的编码格式，这意味着使用该函数读取的所有文件，除非以二进制方式进行读取，否则该文件编码格式都必须和当前操作系统默认的编码格式相同，不然 Python 解释器可能会提示 UnicodeDecodeError 错误。

- 和 open() 函数返回单个的文件对象不同，fileinput 对象无需调用类似 read()、readline()、readlines() 这样的函数，直接通过 for 循环即可按次序读取多个文件中的数据。

  | 函数名                  | 功能描述                                        |
  | ----------------------- | ----------------------------------------------- |
  | fileinput.filename()    | 返回当前正在读取的文件名称。                    |
  | fileinput.fileno()      | 返回当前正在读取文件的文件描述符。              |
  | fileinput.lineno()      | 返回当前读取了多少行。                          |
  | fileinput.filelineno()  | 返回当前正在读取的内容位于当前文件中的行号。    |
  | fileinput.isfirstline() | 判断当前读取的内容在当前文件中是否位于第 1 行。 |
  | fileinput.nextfile()    | 关闭当前正在读取的文件，并开始读取下一个文件。  |
  | fileinput.close()       | 关闭 FileInput 对象。                           |

```
举个例子。假设使用 input() 读取 2 个文件，分别为 my_file.txt 和 file.txt，它们位于同一目录，且各自包含的内容如下所示：

#file.txt
Python教程
http://c.biancheng.net/python/

#my_file.txt
Linux教程
http://c.biancheng.net/linux_tutorial/

import fileinput
#使用for循环遍历 fileinput 对象
for line in fileinput.input(files=('my_file.txt', 'file.txt')):
    # 输出读取到的内容
    print(line)
# 关闭文件流
fileinput.close()

Linux教程

http://c.biancheng.net/linux_tutorial/
Python教程

http://c.biancheng.net/python/
```

- 读取文件内容的次序，取决于 input() 函数中文件名的先后次序。

###### linecache模块：随机读取文件指定行

- 除了可以借助 fileinput 模块实现读取文件外，[Python](http://c.biancheng.net/python/) 还提供了 linecache 模块。和前者不同，linecache 模块擅长读取指定文件中的指定行。换句话说，如果我们想读取某个文件中指定行包含的数据，就可以使用 linecache 模块。

- 值得一提的是，linecache 模块常用来读取 Python 源文件中的代码，它使用的是 UTF-8 编码格式来读取文件内容。这意味着，使用该模块读取的文件，其编码格式也必须为 UTF-8，否则要么读取出来的数据是乱码，要么直接读取失败（Python 解释器会报 SyntaxError 异常）。

  | 函数基本格式                                             | 功能                                                         |
  | -------------------------------------------------------- | ------------------------------------------------------------ |
  | linecache.getline(filename, lineno, module_globals=None) | 读取指定模块中指定文件的指定行（仅读取指定文件时，无需指定模块）。其中，filename 参数用来指定文件名，lineno 用来指定行号，module_globals 参数用来指定要读取的具体模块名。注意，当指定文件以相对路径的方式传给 filename 参数时，该函数以按照 sys.path 规定的路径查找该文件。 |
  | linecache.clearcache()                                   | 如果程序某处，不再需要之前使用 getline() 函数读取的数据，则可以使用该函数清空缓存。 |
  | linecache.checkcache(filename=None)                      | 检查缓存的有效性，即如果使用 getline() 函数读取的数据，其实在本地已经被修改，而我们需要的是新的数据，此时就可以使用该函数检查缓存的是否为新的数据。注意，如果省略文件名，该函数将检车所有缓存数据的有效性。 |

```
import linecache
import string
#读取string模块中第 3 行的数据
print(linecache.getline(string.__file__, 3))
# 读取普通文件的第2行
print(linecache.getline('my_file.txt', 2))

Public module variables:

http://c.biancheng.net/linux_tutorial/

在执行该程序之前，需保证 my_file.txt 文件是以 UTF-8 编码格式保存的（Python 提供的模块，通常编码格式为 UTF-8）
```

###### pathlib模块

- 和前面章节中引入的模板不同，pathlib 模块中包含的是一些类，它们的继承关系如图 1 所示。

  ![](http://c.biancheng.net/uploads/allimg/200110/2-2001101134132V.gif)

- pathlib 模块的操作对象是各种操作系统中使用的路径（例如指定文件位置的路径，包括绝对路径和相对路径）。这里简单介绍一下图 1 中包含的几个类的具体功能：

  - PurePath 类会将路径看做是一个普通的字符串，它可以实现将多个指定的字符串拼接成适用于当前操作系统的路径格式，同时还可以判断任意两个路径是否相等。注意，使用 PurePath 操作的路径，它并不会关心该路径是否真实有效。
  - PurePosixPath 和 PureWindowsPath 是 PurePath 的子类，前者用于操作 UNIX（包括 Mac OS X）风格的路径，后者用于操作 Windows 风格的路径。
  - Path 类和以上 3 个类不同，它操作的路径一定是真实有效的。Path 类提供了判断路径是否真实存在的方法。
  - PosixPath 和 WindowPath 是 Path 的子类，分别用于操作 Unix（Mac OS X）风格的路径和 Windows 风格的路径。

- 注意，UNIX 操作系统和 Windows 操作系统上，路径的格式是完全不同的，主要区别在于根路径和路径分隔符，UNIX 系统的根路径是斜杠（/），而 Windows 系统的根路径是盘符（C:）；UNIX 系统路径使用的分隔符是斜杠（/），而 Windows 使用的是反斜杠（\）。

- PurePath 类（以及 PurePosixPath 类和 PureWindowsPath 类）都提供了大量的构造方法、实例方法以及类实例属性，供我们使用。

  - 需要注意的是，在使用 PurePath 类时，考虑到操作系统的不同，如果在 UNIX 或 Mac OS X 系统上使用 PurePath 创建对象，该类的构造方法实际返回的是 PurePosixPath 对象；反之，如果在 Windows 系统上使用 PurePath 创建对象，该类的构造方法返回的是 PureWindowsPath 对象。
  - 当然，我们完全可以直接使用 PurePosixPath 类或者 PureWindowsPath 类创建指定操作系统使用的类对象。

  ```
  例如，在 Windows 系统上执行如下语句：
  from pathlib import *
  # 创建PurePath，实际上使用PureWindowsPath
  path = PurePath('my_file.txt')
  print(type(path))
  
  <class 'pathlib.PureWindowsPath'>
  显然，在 Windows 操作系统上，使用 PurePath 类构造函数创建的是 PureWindowsPath 类对象。
  
  除此之外，PurePath 在创建对象时，也支持传入多个路径字符串，它们会被拼接成一个路径格式的字符串。
  from pathlib import *
  # 创建PurePath，实际上使用PureWindowsPath
  path = PurePath('http:','c.biancheng.net','python')
  print(path)
  http:\c.biancheng.net\python
  
  可以看到，由于本机为 Windows 系统，因此这里输出的是适用于 Windows 平台的路径。如果想在 Windows 系统上输出 UNIX 风格的路径字符串，就需要使用 PurePosixPath 类
  from pathlib import *
  path = PurePosixPath('http:','c.biancheng.net','python')
  print(path)
  
  http:/c.biancheng.net/python
  
  值的一提的是，如果在使用 PurePath 类构造方法时，不传入任何参数，则等同于传入点‘.’（表示当前路径）作为参数
  from pathlib import *
  path = PurePath()
  print(path)
  path = PurePath('.')
  print(path)
  
  .
  .
  
  另外，如果传入 PurePath 构造方法中的多个参数中，包含多个根路径，则只会有最后一个根路径及后面的子路径生效。
  from pathlib import *
  path = PurePath('C://','D://','my_file.txt')
  print(path)
  
  D:\my_file.txt
  
  需要注意的是，如果传给 PurePath 构造方法的参数中包含有多余的斜杠或者点（ . ，表示当前路径），会直接被忽略（ .. 不会被忽略）。举个例子：
  from pathlib import *
  path = PurePath('C://./my_file.txt')
  print(path)
  
  C:\my_file.txt
  
  PurePath 类还重载各种比较运算符，多余同种风格的路径字符串来说，可以判断是否相等，也可以比较大小（实际上就是比较字符串的大小）；对于不同种风格的路径字符串之间，只能判断是否相等（显然，不可能相等），但不能比较大小。
  from pathlib import *
  # Unix风格的路径区分大小写
  print(PurePosixPath('C://my_file.txt') == PurePosixPath('c://my_file.txt'))
  # Windows风格的路径不区分大小写
  print(PureWindowsPath('C://my_file.txt') == PureWindowsPath('c://my_file.txt'))
  
  False
  True
  
  比较特殊的是，PurePath 类对象支持直接使用斜杠（/）作为多个字符串之间的连接符，
  from pathlib import *
  path = PurePosixPath('C://')
  print(path / 'my_file.txt')
  
  C:/my_file.txt
  
  通过以上方式构建的路径，其本质上就是字符串，因此我们完全可以使用 str() 将 PurePath 对象转换成字符串
  from pathlib import *
  # Unix风格的路径区分大小写
  path = PurePosixPath('C://','my_file.txt')
  print(str(path))
  
  C:/my_file.txt
  
  ```

- 表 1 中罗列出了常用的以下 PurePath 类实例方法和属性。由于从本质上讲，PurePath 的操作对象是字符串，因此表 1 中的这些实例属性和实例方法，实质也是对字符串进行操作。这些方法在官网手册上查看

- 和 PurPath 类相比，Path 类的最大不同，就是支持对路径的真实性进行判断。

- Path 是 PurePath 的子类，因此 Path 类除了支持 PurePath 提供的各种构造函数、实例属性以及实例方法之外，还提供甄别路径字符串有效性的方法，甚至还可以判断该路径对应的是文件还是文件夹，如果是文件，还支持对文件进行读写等操作。

- 和 PurePath 一样，Path 同样有 2 个子类，分别为 PosixPath（表示 UNIX 风格的路径）和 WindowsPath（表示 Windows 风格的路径）。

###### os.path模块

- 相比 pathlib 模块，os.path 模块不仅提供了一些操作路径字符串的方法，还包含一些或者指定文件属性的一些方法

  | 方法                                | 说明                                                         |
  | ----------------------------------- | ------------------------------------------------------------ |
  | os.path.abspath(path)               | 返回 path 的绝对路径。                                       |
  | os.path.basename(path)              | 获取 path 路径的基本名称，即 path 末尾到最后一个斜杠的位置之间的字符串。 |
  | os.path.commonprefix(list)          | 返回 list（多个路径）中，所有 path 共有的最长的路径。        |
  | os.path.dirname(path)               | 返回 path 路径中的目录部分。                                 |
  | os.path.exists(path)                | 判断 path 对应的文件是否存在，如果存在，返回 True；反之，返回 False。和 lexists() 的区别在于，exists()会自动判断失效的文件链接（类似 Windows 系统中文件的快捷方式），而 lexists() 却不会。 |
  | os.path.lexists(path)               | 判断路径是否存在，如果存在，则返回 True；反之，返回 False。  |
  | os.path.expanduser(path)            | 把 path 中包含的 "~" 和 "~user" 转换成用户目录。             |
  | os.path.expandvars(path)            | 根据环境变量的值替换 path 中包含的 "$name" 和 "${name}"。    |
  | os.path.getatime(path)              | 返回 path 所指文件的最近访问时间（浮点型秒数）。             |
  | os.path.getmtime(path)              | 返回文件的最近修改时间（单位为秒）。                         |
  | os.path.getctime(path)              | 返回文件的创建时间（单位为秒，自 1970 年 1 月 1 日起（又称 Unix 时间））。 |
  | os.path.getsize(path)               | 返回文件大小，如果文件不存在就返回错误。                     |
  | os.path.isabs(path)                 | 判断是否为绝对路径。                                         |
  | os.path.isfile(path)                | 判断路径是否为文件。                                         |
  | os.path.isdir(path)                 | 判断路径是否为目录。                                         |
  | os.path.islink(path)                | 判断路径是否为链接文件（类似 Windows 系统中的快捷方式）。    |
  | os.path.ismount(path)               | 判断路径是否为挂载点。                                       |
  | os.path.join(path1[, path2[, ...]]) | 把目录和文件名合成一个路径。                                 |
  | os.path.normcase(path)              | 转换 path 的大小写和斜杠。                                   |
  | os.path.normpath(path)              | 规范 path 字符串形式。                                       |
  | os.path.realpath(path)              | 返回 path 的真实路径。                                       |
  | os.path.relpath(path[, start])      | 从 start 开始计算相对路径。                                  |
  | os.path.samefile(path1, path2)      | 判断目录或文件是否相同。                                     |
  | os.path.sameopenfile(fp1, fp2)      | 判断 fp1 和 fp2 是否指向同一文件。                           |
  | os.path.samestat(stat1, stat2)      | 判断 stat1 和 stat2 是否指向同一个文件。                     |
  | os.path.split(path)                 | 把路径分割成 dirname 和 basename，返回一个元组。             |
  | os.path.splitdrive(path)            | 一般用在 windows 下，返回驱动器名和路径组成的元组。          |
  | os.path.splitext(path)              | 分割路径，返回路径名和文件扩展名的元组。                     |
  | os.path.splitunc(path)              | 把路径分割为加载点与文件。                                   |
  | os.path.walk(path, visit, arg)      | 遍历path，进入每个目录都调用 visit 函数，visit 函数必须有 3 个参数(arg, dirname, names)，dirname 表示当前目录的目录名，names 代表当前目录下的所有文件名，args 则为 walk 的第三个参数。 |
  | os.path.supports_unicode_filenames  | 设置是否可以将任意 Unicode 字符串用作文件名。                |

  ```
  from os import path
  # 获取绝对路径
  print(path.abspath("my_file.txt"))
  # 获取共同前缀
  print(path.commonprefix(['C://my_file.txt', 'C://a.txt']))
  # 获取共同路径
  print(path.commonpath(['http://c.biancheng.net/python/', 'http://c.biancheng.net/shell/']))
  # 获取目录
  print(path.dirname('C://my_file.txt'))
  # 判断指定目录是否存在
  print(path.exists('my_file.txt'))
  
  C:\Users\mengma\Desktop\my_file.txt
  C://
  http:\c.biancheng.net
  C://
  True
  ```

###### fnmatch模块

- fnmatch 模块主要用于文件名称的匹配，其能力比简单的字符串匹配更强大，但比使用正则表达式相比稍弱。。如果在数据处理操作中，只需要使用简单的通配符就能完成文件名的匹配，则使用 fnmatch 模块是不错的选择。

  | 函数名                                 | 功能                                                         |
  | -------------------------------------- | ------------------------------------------------------------ |
  | fnmatch.filter(names, pattern)         | 对 names 列表进行过滤，返回 names 列表中匹配 pattern 的文件名组成的子集合。 |
  | fnmatch.fnmatch(filename, pattern)     | 判断 filename 文件名，是否和指定 pattern 字符串匹配          |
  | fnmatch.fnmatchcase(filename, pattern) | 和 fnmatch() 函数功能大致相同，只是该函数区分大小写。        |
  | fnmatch.translate(pattern)             | 将一个 UNIX shell 风格的 pattern 字符串，转换为正则表达式    |

- fnmatch 模块匹配文件名的模式使用的就是 UNIX shell 风格，其支持使用如下几个通配符：

  - *：可匹配任意个任意字符。
  - ？：可匹配一个任意字符。
  - [字符序列]：可匹配中括号里字符序列中的任意字符。该字符序列也支持中画线表示法。比如 [a-c] 可代表 a、b 和 c 字符中任意一个。
  - [!字符序列]：可匹配不在中括号里字符序列中的任意字符。

  ```
  import fnmatch
  #filter()
  print(fnmatch.filter(['dlsf', 'ewro.txt', 'te.py', 'youe.py'], '*.txt'))
  #fnmatch()
  for file in ['word.doc','index.py','my_file.txt']:
      if fnmatch.fnmatch(file,'*.txt'):
          print(file)
  #fnmatchcase()
  print([addr for addr in ['word.doc','index.py','my_file.txt','a.TXT'] if fnmatch.fnmatchcase(addr, '*.txt')])
  #translate()
  print(fnmatch.translate('a*b.txt'))
  
  ['ewro.txt']
  my_file.txt
  ['my_file.txt']
  (?s:a.*b\.txt)\Z
  ```

###### os模块

- 除前面章节介绍的各种函数之外，os 模块还提供了大量操作文件和目录的函数，本节将介绍 os 模块下常用的函数。

- os模块与目录相关的函数

  - os.getcwd()：获取当前目录。

  - os.chdir(path)：改变当前目录。

  - os.fchdir(fd)：通过文件描述利改变当前目录。该函数与上一个函数的功能基本相似，只是该函数以文件描述符作为参数来代表目录。

  - os.chroot(path)：改变当前进程的根目录。

  - os.listdir(path)：返回 path 对应目录下的所有文件和子目录。

  - os.mkdir(path[, mode])：创建 path 对应的目录，其中 mode 用于指定该目录的权限。该 mode参数代表一个 UNIX 风格的权限，比如 0o777 代表所有者可读/可写/可执行、组用户可读/可写/可执行、其他用户可读/可写/可执行。

  - os.makedirs(path[, mode])：其作用类似于 mkdir()，但该函数的功能更加强大，它可以边归创建目录。比如要创建 abc/xyz/wawa 目录，如果在当前目录下没有 abc 目录，那么使用 mkdir() 函数就会报错，而使用 makedirs() 函数则会先创建 abc，然后在其中创建 xyz 子目录，最后在 xyz 子目录下创建 wawa 子目录。

  - os.rmdir(path)：删除 path 对应的空目录。如果目录非空，则抛出一个 OSError 异常。程序可以先用 os.remove() 函数删除文件。

  - os.removedirs(path)：边归删除目录。其功能类似于 rmdir()，但该函数可以递归删除 abc/xyz/wawa 目录，它会从 wawa 子目录开始删除，然后删除 xyz 子目录，最后删除 abc 目录。

    ```
    import os
    # 获取当前目录
    print(os.getcwd())  # G:\publish\codes\12.7
    # 改变当前目录
    os.chdir('../12.6')
    # 再次获取当前目录
    print(os.getcwd())  # G:\publish\codes\12.6
    
    import os
    path = 'my_dir'
    # 直接在当前目录下创建目录
    os.mkdir(path, 0o755)
    path = "abc/xyz/wawa"
    # 递归创建目录
    os.makedirs(path, 0o755)
    
    正如从上面代码所看到的，直接在当前目录下创建 mydir 子目录，因此可以使用 mkdir() 函数创建；需要程序递归创建 abc/xyz/wawa 目录，因此使用 makedirs() 函数。
    
    import os
    path = 'my_dir'
    # 直接删除当前目录下的子目录
    os.rmdir(path)
    path = "abc/xyz/wawa"
    # 递归删除子目录
    os.removedirs(path)
    
    上面程序中第 5 行代码使用 rmdir() 函数删除当前目录下的 my_dir 子目录，该函数不会执行递归删除；第 8 行代码使用 removedirs() 函数删除 abc/xyz/wawa 目录，该函数会执行递归删除，它会先删除 wawa 子目录，然后删除 xyz 子目录，最后才删除 abc 目录。
    
    import os
    path = 'my_dir'
    # 直接重命名当前目录下的子目录
    os.rename(path, 'your_dir')
    path = "abc/xyz/wawa"
    # 递归重命名子目录
    os.renames(path, 'foo/bar/haha')
    
    上面程序中第 5 行代码直接重命名当前目录下的 my_dir 子目录，程序会将该子目录重命名为 your_dir；第 8 行代码则执行递归重命名，程序会将 wawa 重命名为 haba，将 xyz 重命名为 bar，将 abc 重命名为 foo。
    ```

- os模块与权限相关的函数

  - os.access(path, mode)：检查 path 对应的文件或目录是否具有指定权限。该函数的第二个参数可能是以下四个状态值的一个或多个值：

    - os.F_OK：判断是否存在。
    - os.R_OK：判断是否可读。
    - os.W_OK：判断是否可写。
    - os.X_OK：判断是否可执行。

  - os.chrnod(path, mode)：更改权限。其中 mode 参数代表要改变的权限，该参数支持的值可以是以下一个或多个值的组合：

    - stat.S_IXOTH：其他用户有执行权限。
    - stat.S_IWOTH：其他用户有写权限。
    - stat.S_TROTH：其他用户有读权限。
    - stat.S_IRWXO：其他用户有全部权限。
    - stat.S_IXGRP：组用户有执行权限。
    - stat.S_IWGRP：组用户有写权限。
    - stat.S_IRGRP：组用户有读权限。
    - stat.S_IRWXG：组用户有全部权限。
    - stat.S_IXUSR：所有者有执行权限。
    - stat.S_IWUSR：所有者有写权限。
    - stat.S_IRUSR：所有者有读权限。
    - stat.S_IRWXU：所有者有全部权限。
    - stat.S_IREAD：Windows 将该文件设为只读的。
    - stat.S_IWRITE：Windows 将该文件设为可写的。

  - os.chown(path, uid, gid)：更改文件的所有者。其中 uid 代表用户 id，gid 代表组 id。该命令主要在 UNIX 文件系统下有效。

  - os.fchmod(fd, mode)：改变一个文件的访问权限，该文件由文件描述符 fd 指定。该函数的功能与 os.chmod() 函数的功能相似，只是该函数使用 fd 代表文件。

  - os.fchown(fd, uid, gid)：改变文件的所有者，该文件由文件描述符 fd 指定。该函数的功能与 os.chown() 函数的功能相似，只是该函数使用 fd 代表文件。

    ```
    import os
    # 判断当前目录的权限
    ret = os.access('.', os.F_OK|os.R_OK|os.W_OK|os.X_OK)
    print("os.F_OK|os.R_OK|os.W_OK|os.X_OK - 返回值:", ret)
    # 判断os.access_test.py文件的权限
    ret = os.access('os.access_test.py', os.F_OK|os.R_OK|os.W_OK)
    print("os.F_OK|os.R_OK|os.W_OK - 返回值:", ret)
    
    os.F_OK|os.R_OK|os.W_OK|os.X_OK - 返回值：True
    os.F_OK|os.R_OK|os.W_OK - 返回值：False
    
    import os, stat
    # 将os.chmod_test.py文件改为只读
    os.chmod('os.chmod_test.py', stat.S_IREAD)
    # 判断是否可写
    ret = os.access('os.chmod_test.py', os.W_OK)
    print("os.W_OK - 返回值:", ret)
    
    os.chmod_test.py 变成只读文件。
    ```

- os模块与文件访问相关的函数

  - os.open(file, flags[, mode])：打开一个文件，并且设置打开选项，mode 参数是可选的。该函数返回文件描述符。其中 flags 代表打开文件的旗标，它支持如下一个或多个选项：

    - os.O_RDONLY：以只读的方式打开。
    - os.O_WRONLY：以只写的方式打开。
    - os.O_RDWR：以读写的方式打开。
    - os.O_NONBLOCK：打开时不阻塞。
    - os.O_APPEND：以追加的方式打开。
    - os.O_CREAT：创建并打开一个新文件。
    - os.O_TRUNC：打开一个文件并截断它的长度为0（必须有写权限）。
    - os.O_EXCL：在创建文件时，如果指定的文件存在，则返回错误。
    - os.O_SHLOCK：自动获取共享锁。
    - os.O_EXLOCK：自动获取独立锁。
    - os.O_DIRECT：消除或减少缓存效果。
    - os.O_FSYNC：同步写入。
    - os.O_NOFOLLOW：不追踪软链接。

  - os.read(fd, n)：从文件描述符 fd 中读取最多 n 个字节，返回读到的字符串。如果文件描述符副对应的文件己到达结尾，则返回一个空字节串。

  - os.write(fd, str)：将字节串写入文件描述符 fd 中，返回实际写入的字节串长度。

  - os.close(fd)：关闭文件描述符 fd。

  - os.lseek(fd, pos, how)：该函数同样用于移动文件指针。其中 how 参数指定从哪里开始移动，如果将 how 设为 0 或 SEEK_SET，则表明从文件开头开始移动；如果将 how 设为 1 或 SEEK_CUR，则表明从文件指针当前位置开始移动；如果将 how 设为 2 或 SEEK_END，则表明从文件结束处开始移动。上面几个函数同样可用于执行文件的读写，程序通常会先通过 os.open() 打开文件，然后调用 os.read()、os.write() 来读写文件，当操作完成后通过 os.close() 关闭文件。

  - os.fdopen(fd[, mode[, bufsize]])：通过文件描述符 fd 打开文件，并返回对应的文件对象。

  - os.closerange(fd_low, fd_high)：关闭从 fd_low（包含）到 fd_high（不包含）范围的所有文件描述符。

  - os.dup(fd)：复制文件描述符。

  - os.dup2(fd,fd2)：将一个文件描述符fd复制到另一个文件描述符fd2中。

  - os.ftruncate(fd, length)：将 fd 对应的文件截断到 length 长度，因此此处传入的 length 参数不应该超过文件大小。

  - os.remove(path)：删除 path 对应的文件。如果 path 是一个文件夹，则抛出 OSError 错误。如果要删除目录，则使用 os.rmdir()。

  - os.link(src, dst)：创建从 src 到 dst 的硬链接。硬链接是 UNIX 系统的概念，如果在 Windows 系统中就是复制目标文件。

  - os.symlink(src, dst)：创建从 src 到 dst 的符号链接，对应于 Windows 的快捷方式。、

    - 由于 Windows 权限的缘故，因此必须以管理员身份执行 os.symlink() 函数来创建快捷方式。

    ```
    import os
    # 以读写、创建方式打开文件
    f = os.open('abc.txt', os.O_RDWR|os.O_CREAT)
    # 写入文件内容
    len1 = os.write(f, '水晶潭底银鱼跃，\n'.encode('utf-8'))
    len2 = os.write(f, '清徐风中碧竿横。\n'.encode('utf-8'))
    # 将文件指针移动到开始处
    os.lseek(f, 0, os.SEEK_SET)
    # 读取文件内容
    data = os.read(f, len1 + len2)
    # 打印读取到字节串
    print(data)
    # 将字节串恢复成字符串
    print(data.decode('utf-8'))
    os.close(f)
    
    import os
    # 为os.link_test.py文件创建快捷方式
    os.symlink('os.link_test.py', 'tt')
    # 为os.link_test.py文件创建硬连接（Windows上就是复制文件）
    os.link('os.link_test.py', 'dst')
    
    上面程序使用 symlink() 函数为指定文件创建符号链接，在 Windows 系统中就是创建快捷方式；使用 link() 函数创建硬链接，在 Windows 系统中就是复制文件。
    将会看到程序在当前目录下创建了一个名为“tt”的快捷方式，并将 os.link_test.py 文件复制为 dst 文件。
    ```

###### tempfile模块：生成临时文件和临时目录

- tempfile 模块专门用于创建临时文件和临时目录，它既可以在 UNIX 平台上运行良好，也可以在 Windows 平台上运行良好。

  | tempfile 模块函数                                            | 功能描述                                                     |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | tempfile.TemporaryFile(mode='w+b', buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None) | 创建临时文件。该函数返回一个类文件对象，也就是支持文件 I/O。 |
  | tempfile.NamedTemporaryFile(mode='w+b', buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True) | 创建临时文件。该函数的功能与上一个函数的功能大致相同，只是它生成的临时文件在文件系统中有文件名。 |
  | tempfile.SpooledTemporaryFile(max_size=0, mode='w+b', buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None) | 创建临时文件。与 TemporaryFile 函数相比，当程序向该临时文件输出数据时，会先输出到内存中，直到超过 max_size 才会真正输出到物理磁盘中。 |
  | tempfile.TemporaryDirectory(suffix=None, prefix=None, dir=None) | 生成临时目录。                                               |
  | tempfile.gettempdir()                                        | 获取系统的临时目录。                                         |
  | tempfile.gettempdirb()                                       | 与 gettempdir() 相同，只是该函数返回字节串。                 |
  | tempfile.gettempprefix()                                     | 返回用于生成临时文件的前缀名。                               |
  | tempfile.gettempprefixb()                                    | 与 gettempprefix() 相同，只是该函数返回字节串。              |

- tempfile 模块还提供了 tempfile.mkstemp() 和 tempfile.mkdtemp() 两个低级别的函数。上面介绍的 4 个用于创建临时文件和临时目录的函数都是高级别的函数，高级别的函数支持自动清理，而且可以与 with 语句一起使用，而这两个低级别的函数则不支持，因此一般推荐使用高级别的函数来创建临时文件和临时目录。

- tempfile 模块还提供了 tempfile.tempdir 属性，通过对该属性赋值可以改变系统的临时目录。

  ```
  import tempfile
  # 创建临时文件
  fp = tempfile.TemporaryFile()
  print(fp.name)
  fp.write('两情若是久长时，'.encode('utf-8'))
  fp.write('又岂在朝朝暮暮。'.encode('utf-8'))
  # 将文件指针移到开始处，准备读取文件
  fp.seek(0)
  print(fp.read().decode('utf-8')) # 输出刚才写入的内容
  # 关闭文件，该文件将会被自动删除
  fp.close()
  # 通过with语句创建临时文件，with会自动关闭临时文件
  with tempfile.TemporaryFile() as fp:
      # 写入内容
      fp.write(b'I Love Python!')
      # 将文件指针移到开始处，准备读取文件
      fp.seek(0)
      # 读取文件内容
      print(fp.read()) # b'I Love Python!'
  # 通过with语句创建临时目录
  with tempfile.TemporaryDirectory() as tmpdirname:
      print('创建临时目录', tmpdirname)
      
  C:\Users\admin\AppData\Local\Temp\tmphvehw9z1
  两情若是久长时，又岂在朝朝暮暮。
  b'I Love Python!'
  创建临时目录C:\Users\admin\AppData\Local\Temp\tmp3sjbnwob
  
  上面第一行输出结果就是程序生成的临时文件的文件名，最后一行输出结果就是程序生成的临时目录的目录名。需要注意的是，不要去找临时文件或临时文件夹，因为程序退出时该临时文件和临时文件夹都会被删除。
  ```

- 上面程序以两种方式来创建临时文件：

  1. 第一种方式是手动创建临时文件，读写临时文件后需要主动关闭它，当程序关闭该临时文件时，该文件会被自动删除。
  2. 第二种方式则是使用 with 语句创建临时文件，这样 with 语句会自动关闭临时文件

- 上面程序最后还创建了临时目录。由于程序使用 with 语句来管理临时目录，因此程序也会自动删除该临时目录。

#### 模块

- 模块，英文为 Modules，至于模块到底是什么，可以用一句话总结：模块就是 Python 程序。换句话说，任何 Python 程序都可以作为模块，包括在前面章节中写的所有 Python 程序，都可以作为模块。

  ```
  举个简单的例子，在某一目录下（桌面也可以）创建一个名为 hello.py 文件，其包含的代码如下：
  def say ():
      print("Hello,World!")
      
  在同一目录下，再创建一个 say.py 文件，其包含的代码如下：
  #通过 import 关键字，将 hello.py 模块引入此文件
  import hello
  hello.say()
  
  Hello,World!
  ```

  - say.py 文件中使用了原本在 hello.py 文件中才有的 say() 函数，相对于 say.py 来说，hello.py 就是一个自定义的模块（有关自定义模块，后续章节会做详细讲解），我们只需要将 hellp.py 模块导入到 say.py 文件中，就可以直接在 say.py 文件中使用模块中的资源。
  - 与此同时，当调用模块中的 say() 函数时，使用的语法格式为“模块名.函数”，这是因为，相对于 say.py 文件，hello.py 文件中的代码自成一个命名空间，因此在调用其他模块中的函数时，需要明确指明函数的出处，否则 Python 解释器将会报错。

###### import导入模块

- 我们使用了一些数学函数，例如余弦函数 cos()、绝对值函数 fabs() 等，它们位于 Python 标准库中的 math（或 cmath）模块中，只需要将此模块导入到当前程序，就可以直接拿来用。

- import 还有更多详细的用法，主要有以下两种：

  1. `import 模块名1 [as 别名1], 模块名2 [as 别名2]，…`：使用这种语法格式的 import 语句，会导入指定模块中的所有成员（包括变量、函数、类等）。不仅如此，当需要使用模块中的成员时，需用该模块名（或别名）作为前缀，否则 Python 解释器会报错。
  2. `from 模块名 import 成员名1 [as 别名1]，成员名2 [as 别名2]，…`： 使用这种语法格式的 import 语句，只会导入模块中指定的成员，而不是全部成员。同时，当程序中使用该成员时，无需附加任何前缀，直接使用成员名（或别名）即可。

- 如果模块中包含空格或者以数字开头，就需要使用 Python 提供的 `__import__()` 内置函数引入模块。例如，当模块名为"demo text" 时，引入方法如下：

  ```
  __import__("demo text")
  
  C语言中文网
  ```

  - 使用 `__import__()` 函数引入模块名时，要以字符串的方式将模块名引入，否则会报 SyntaxError 错误。

###### 自定义模块

- 当直接运行一个模块时，name 变量的值为 `__main__`；而将模块被导入其他程序中并运行该程序时，处于模块中的 `__name__` 变量的值就变成了模块名。因此，如果希望测试函数只有在直接运行模块文件时才执行，则可在调用测试函数时增加判断，即只有当 `__name__ =='__main__'` 时才调用测试函数。

- 为自定义模块添加说明文档，和函数或类的添加方法相同，即只需在模块开头的位置定义一个字符串即可。例如，为 demo.py 模板文件添加一个说明文档：

  ```
  '''
  demo 模块中包含以下内容：
  name 字符串变量：初始值为“Python教程”
  add    字符串变量：初始值为“http://c.biancheng.net/python”
  say() 函数
  CLanguage类：包含 name 和 add 属性和 say() 方法。
  '''
  ```

  - 在此基础上，我们可以通过模板的 `__doc__` 属性，来访问模板的说明文档。例如，在 test.py 文件中添加如下代码：

  ```
  import demo
  print(demo.__doc__)
  
  Python教程 http://c.biancheng.net/python
  
  demo 模块中包含以下内容：
  name 字符串变量：初始值为“Python教程”
  add    字符串变量：初始值为“http://c.biancheng.net/python”
  say() 函数
  CLanguage类：包含 name 和 add 属性和 say() 方法。
  ```

###### python导入模块的3种方式

- 很多初学者经常遇到这样的问题，即自定义 [Python](http://c.biancheng.net/python/) 模板后，在其它文件中用 import（或 from...import） 语句引入该文件时，Python 解释器同时如下错误：

  ModuleNotFoundError: No module named '模块名'

  意思是 Python 找不到这个模块名，这是什么原因导致的呢？要想解决这个问题，读者要先搞清楚 Python 解释器查找模块文件的过程。

- 通常情况下，当使用 import 语句导入模块后，Python 会按照以下顺序查找指定的模块文件：

  - 在当前目录，即当前执行的程序文件所在目录下查找；
  - 到 PYTHONPATH（环境变量）下的每个目录中查找；
  - 到 Python 默认的安装目录下查找。

- 以上所有涉及到的目录，都保存在标准模块 sys 的 sys.path 变量中，通过此变量我们可以看到指定程序文件支持查找的所有目录。换句话说，如果要导入的模块没有存储在 sys.path 显示的目录中，那么导入该模块并运行程序时，Python 解释器就会抛出 ModuleNotFoundError（未找到模块）异常。

- 解决“Python找不到指定模块”的方法有 3 种，分别是：

  1. 向 sys.path 中临时添加模块文件存储位置的完整路径；
  2. 将模块放在 sys.path 变量中已包含的模块加载路径中；
  3. 设置 path 系统环境变量。

- 在详细介绍这 3 种方式之前，为了能更方便地讲解，本节使用前面章节已建立好的 hello.py 自定义模块文件（D:\python_module\hello.py）和 say.py 程序文件（C:\Users\mengma\Desktop\say.py，位于桌面上），它们各自包含的代码如下：

  ```
  #hello.py
  def say ():
      print("Hello,World!")
  #say.py
  import hello
  hello.say()
  
  显然，hello.py 文件和 say.py 文件并不在同一目录
  ```

- 导入模块方式一：临时添加模块完整路径

  - 模块文件的存储位置，可以临时添加到 sys.path 变量中，即向 sys.path 中添加 D:\python_module（hello.py 所在目录），在 say.py 中的开头位置添加如下代码：

    ```
    import sys
    sys.path.append('D:\\python_module')
    ```

    - 在添加完整路径中，路径中的 '\' 需要使用 \ 进行转义，否则会导致语法错误

    - 我们在 say.py 文件中输出 sys.path 变量的值，会得到以下结果：

      ```
      ['C:\\Users\\mengma\\Desktop', 'D:\\python3.6\\Lib\\idlelib', 'D:\\python3.6\\python36.zip', 'D:\\python3.6\\DLLs', 'D:\\python3.6\\lib', 'D:\\python3.6', 'C:\\Users\\mengma\\AppData\\Roaming\\Python\\Python36\\site-packages', 'D:\\python3.6\\lib\\site-packages', 'D:\\python3.6\\lib\\site-packages\\win32', 'D:\\python3.6\\lib\\site-packages\\win32\\lib', 'D:\\python3.6\\lib\\site-packages\\Pythonwin', 'D:\\python_module']
      ```

    - 该输出信息中，红色部分就是临时添加进去的存储路径。需要注意的是，通过该方法添加的目录，只能在执行当前文件的窗口中有效，窗口关闭后即失效。

- 导入模块方式二：将模块保存在指定位置

  - 如果要安装某些通用性模块，比如复数功能支持的模块、矩阵计算支持的模块、图形界面支持的模块等，这些都属于对 Python 本身进行扩展的模块，这种模块应该直接安装在 Python 内部，以便被所有程序共享，此时就可借助于 Python 默认的模块加载路径。

  - Python 程序默认的模块加载路径保存在 sys.path 变量中，因此，我们可以在 say.py 程序文件中先看看 sys.path 中保存的默认加载路径，向 say.py 文件中输出 sys.path 的值，如下所示：

    ```
    ['C:\\Users\\mengma\\Desktop', 'D:\\python3.6\\Lib\\idlelib', 'D:\\python3.6\\python36.zip', 'D:\\python3.6\\DLLs', 'D:\\python3.6\\lib', 'D:\\python3.6', 'C:\\Users\\mengma\\AppData\\Roaming\\Python\\Python36\\site-packages', 'D:\\python3.6\\lib\\site-packages', 'D:\\python3.6\\lib\\site-packages\\win32', 'D:\\python3.6\\lib\\site-packages\\win32\\lib', 'D:\\python3.6\\lib\\site-packages\\Pythonwin']
    ```

  - 上面的运行结果中，列出的所有路径都是 Python 默认的模块加载路径，但通常来说，我们默认将 Python 的扩展模块添加在 `lib\site-packages` 路径下，它专门用于存放 Python 的扩展模块和包。

  - 所以，我们可以直接将我们已编写好的 hello.py 文件添加到 `lib\site-packages` 路径下，就相当于为 Python 扩展了一个 hello 模块，这样任何 Python 程序都可使用该模块。

- 导入模块方式三：设置环境变量

  - PYTHONPATH 环境变量（简称 path 变量）的值是很多路径组成的集合，Python 解释器会按照 path 包含的路径进行一次搜索，直到找到指定要加载的模块。当然，如果最终依旧没有找到，则 Python 就报 ModuleNotFoundError 异常。

  - Linux 平台的环境变量是通过 .bash_profile 文件来设置的，使用无格式编辑器打开该文件，在该文件中添加 PYTHONPATH 环境变量

    ```
    #设置PYTHON PATH 环境变量
    PYTHONPATH=.:/home/mengma/python_module
    ```

  - 在完成了 PYTHONPATH 变量值的设置后，在 .bash_profile 文件的最后添加导出 PYTHONPATH 变量的语句。

    ```
    #导出PYTHONPATH 环境变量
    export PYTHONPATH
    ```

  - 重新登录 Linux 平台，或者执行如下命令

    ```
    source.bash_profile
    ```

    - 这两种方式都是为了运行该文件，使在文件中设置的 PYTHONPATH 变量值生效。

- 在导入模块后，可以在模块文件所在目录下看到一个名为“__pycache__”的文件夹，打开该文件夹，可以看到 Python 为每个模块都生成一个 *.cpython-36.pyc 文件，比如 Python 为 fk_module 模块生成一个 fk_ module.cpython-36.pyc 文件，该文件其实是 Python 为模块编译生成的字节码，用于提升该模块的运行效率。

###### \__all__变量

- 事实上，当我们向文件导入某个模块时，导入的是该模块中那些名称不以下划线（单下划线“_”或者双下划线“__”）开头的变量、函数和类。因此，如果我们不想模块文件中的某个成员被引入到其它文件中使用，可以在其名称前添加下划线。
- 除此之外，还可以借助模块提供的 `__all__` 变量，该变量的值是一个列表，存储的是当前模块中一些成员（变量、函数或者类）的名称。通过在模块文件中设置 `__all__` 变量，当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用 `__all__` 列表中指定的成员。
  - 也就是说，只有以“from 模块名 import *”形式导入的模块，当该模块设有 `__all__` 变量时，只能导入该变量指定的成员，未指定的成员是无法导入的。
  - 再次声明，`__all__` 变量仅限于在其它文件中以“from 模块名 import *”的方式引入。也就是说，如果使用以下 2 种方式引入模块，则 `__all__` 变量的设置是无效的。
    - 以“import 模块名”的形式导入模块。通过该方式导入模块后，总可以通过模块名前缀（如果为模块指定了别名，则可以使用模快的别名作为前缀）来调用模块内的所有成员（除了以下划线开头命名的成员）。
    - 以“from 模块名 import 成员”的形式直接导入指定成员。使用此方式导入的模块，`__all__` 变量即便设置，也形同虚设。

###### python包：存放多个模块的文件夹

- 实际开发中，一个大型的项目往往需要使用成百上千的 [Python](http://c.biancheng.net/python/) 模块，如果将这些模块都堆放在一起，势必不好管理。而且，使用模块可以有效避免变量名或函数名重名引发的冲突，但是如果模块名重复怎么办呢？因此，Python提出了包（Package）的概念。
- 什么是包呢？简单理解，包就是文件夹，只不过在该文件夹下必须存在一个名为“`__init__.py`” 的文件。
  - 注意，这是 Python 2.x 的规定，而在 Python 3.x 中，`__init__.py` 对包来说，并不是必须的。
- 每个包的目录下都必须建立一个 `__init__.py` 的模块，可以是一个空模块，可以写一些初始化代码，其作用就是告诉 Python 要将该目录当成包来处理。
  - 注意，`__init__.py` 不同于其他模块文件，此模块的模块名不是 `__init__`，而是它所在的包名。例如，在 settings 包中的 `__init__.py` 文件，其模块名就是 settings。
- 包是一个包含多个模块的文件夹，它的本质依然是模块，因此包中也可以包含包。例如，在前面章节中，我们安装了 numpy 模块之后可以在 Lib\site-packages 安装目录下找到名为 numpy 的文件夹，它就是安装的 numpy 模块（其实就是一个包）

###### 创建包导入包

- 《[Python包](http://c.biancheng.net/view/4667.html)》一节中已经提到，包其实就是文件夹，更确切的说，是一个包含“`__init__.py`”文件的文件夹。因此，如果我们想手动创建一个包，只需进行以下 2 步操作：

  1. 新建一个文件夹，文件夹的名称就是新建包的包名；
  2. 在该文件夹中，创建一个 `__init__.py` 文件（前后各有 2 个下划线‘_’），该文件中可以不编写任何代码。当然，也可以编写一些 [Python](http://c.biancheng.net/python/) 初始化代码，则当有其它程序文件导入包时，会自动执行该文件中的代码

- 例如，现在我们创建一个非常简单的包，该包的名称为 my_package

  - 创建一个文件夹，其名称设置为 my_package；

  - 在该文件夹中添加一个 `__init__.py` 文件，此文件中可以不编写任何代码

  - 创建好包之后，我们就可以向包中添加模块（也可以添加包）。这里给 my_package 包添加 2 个模块，分别是 module1.py、module2.py

    ```
    #module1.py模块文件
    def display(arc):
        print(arc)
    #module2.py 模块文件
    class CLanguage:
        def display(self):
            print("http://c.biancheng.net/python/")
            
    my_package
         ┠── __init__.py
         ┠── module1.py
         ┗━━  module2.py
    ```

- 通过前面的学习我们知道，包其实本质上还是模块，因此导入模块的语法同样也适用于导入包。无论导入我们自定义的包，还是导入从他处下载的第三方包，导入方法可归结为以下 3 种：

  1. `import 包名[.模块名 [as 别名]]`
  2. `from 包名 import 模块名 [as 别名]`
  3. `from 包名.模块名 import 成员名 [as 别名]`

- 当直接导入指定包时，程序会自动执行该包所对应文件夹下的 `__init__.py` 文件中的代码

- 直接导入包名，并不会将包中所有模块全部导入到程序中，它的作用仅仅是导入并执行包下的 `__init__.py` 文件，因此，运行该程序，在执行 `__init__.py` 文件中代码的同时，还会抛出 AttributeError 异常（访问的对象不存在）：

- 既然包也是模块，那么这种语法格式自然也支持 `from 包名 import *` 这种写法，它和 import 包名 的作用一样，都只是将该包的 `__init__.py` 文件导入并执行。

###### \__init__.py的作用

- 前面章节中，已经对包的创建和导入进行了详细讲解，并提供了大量的实例，这些实例虽然可以正常运行，但存在一个通病，即为了调用包内模块的成员（变量、函数或者类），代码中包含了诸多的 import 导入语句，非常繁琐。

- 我们知道，导入包就等同于导入该包中的 `__init__.py` 文件，因此完全可以在 `__init__.py` 文件中直接编写实现模块功能的变量、函数和类，但实际上并推荐大家这样做，因为包的主要作用是包含多个模块。因此 `__init__.py` 文件的主要作用是导入该包内的其他模块。

- 也就是说，通过在 `__init__.py` 文件使用 import 语句将必要的模块导入，这样当向其他程序中导入此包时，就可以直接导入包名，也就是使用`import 包名`（或`from 包名 import *`）的形式即可。

- 上节中，我们已经创建好的 my_package 包，该包名包含 module1 模块、module2 模块和 `__init__.py` 文件。现在向 my_package 包的 `__init__.py` 文件中编写如下代码：

  ```
  # 从当前包导入 module1 模块
  from . import module1
  #from .module1 import * 
  # 从当前包导入 module2 模块
  #from . import module2
  from .module2 import * 
  ```

  - 可以看到，在 `__init__.py` 文件中用点（.）来表示当前包的包名，除此之外，from import 语句的用法和在程序中导入包的用法完全相同。

  - 总的来说，`__init__.py` 文件是通过如下 2 种方式来导入包中模块的：

    ```
    # 从当前包导入指定模块
    from . import 模块名
    # 从.模块名 导入所有成员到包中
    from .模块名 import *
    ```

    - 第 1 种方式用于导入当前包（模块）中的指定模块，这样即可在包中使用该模块。当在其他程序使用模块内的成员时，需要添加“包名.模块名”作为前缀
    - 第 2 种方式表示从指定模块中导入所有成员，采用这种导入方式，在其他程序中使用该模块的成员时，只要使用包名作为前缀即可

###### 查看模块方法

- 正确导入模块或者包之后，怎么知道该模块中具体包含哪些成员（变量、函数或者类）呢？

- dir()函数

  - 通过 dir() 函数，我们可以查看某指定模块包含的全部成员（包括变量、函数和类）。注意这里所指的全部成员，不仅包含可供我们调用的模块成员，还包含所有名称以双下划线“__”开头和结尾的成员，而这些“特殊”命名的成员，是为了在本模块中使用的，并不希望被其它文件调用。

  - 这里以导入 string 模块为例，string 模块包含操作字符串相关的大量方法

    ```
    import string
    print(dir(string))
    
    ['Formatter', 'Template', '_ChainMap', '_TemplateMetaclass', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_re', '_string', 'ascii_letters', 'ascii_lowercase', 'ascii_uppercase', 'capwords', 'digits', 'hexdigits', 'octdigits', 'printable', 'punctuation', 'whitespace']
    ```

  - 可以看到，通过 dir() 函数获取到的模块成员，不仅包含供外部文件使用的成员，还包含很多“特殊”（名称以 2 个下划线开头和结束）的成员，列出这些成员，对我们并没有实际意义。

  - 这里给读者推荐一种可以忽略显示 dir() 函数输出的特殊成员的方法

    ```
    import string
    print([e for e in dir(string) if not e.startswith('_')])
    ```

- 除了使用 dir() 函数之外，还可以使用 `__all__` 变量，借助该变量也可以查看模块（包）内包含的所有成员。

  - 和 dir() 函数相比，`__all__` 变量在查看指定模块成员时，它不会显示模块中的特殊成员，同时还会根据成员的名称进行排序显示。
  - 不过需要注意的是，并非所有的模块都支持使用 `__all__` 变量，因此对于获取有些模块的成员，就只能使用 dir() 函数。

###### \__doc__属性：查看文档

- 在使用 dir() 函数和 `__all__` 变量的基础上，虽然我们能知晓指定模块（或包）中所有可用的成员（变量、函数和类），比如：

  ```
  import string
  print(string.__all__)
  
  ['ascii_letters', 'ascii_lowercase', 'ascii_uppercase', 'capwords', 'digits', 'hexdigits', 'octdigits', 'printable', 'punctuation', 'whitespace', 'Formatter', 'Template']
  ```

  - 但对于以上的输出结果，对于不熟悉 string 模块的用户，还是不清楚这些名称分别表示的是什么意思，更不清楚各个成员有什么功能。

- 针对这种情况，我们可以使用 help() 函数来获取指定成员（甚至是该模块）的帮助信息。以前面章节创建的 my_package 包为例，该包中包含 `__init__.py` 、module1.py 和 module2.py 这 3 个模块，它们各自包含的内容分别如下所示：

  ```
  #***__init__.py 文件中的内容***
  from my_package.module1 import *
  from my_package.module2 import *
  #***module1.py 中的内容***
  #module1.py模块文件
  def display(arc):
      '''
      直接输出指定的参数
      '''
      print(arc)
  #***module2.py中的内容***
  #module2.py 模块文件
  class CLanguage:
      '''
      CLanguage是一个类，其包含：
      display() 方法
      '''
      def display(self):
          print("http://c.biancheng.net/python/")
  ```

  - 现在，我们先借助 dir() 函数，查看 my_package 包中有多少可供我们调用的成员：

    ```
    import my_package
    print([e for e in dir(my_package) if not e.startswith('_')])
    
    ['CLanguage', 'display', 'module1', 'module2']
    
    通过此输出结果可以得知，在 my_package 包中，有以上 4 个成员可供我们使用。接下来，我们使用 help() 函数来查看这些成员的具体含义（以 module1 为例）：
    import my_package
    help(my_package.module1)
    
    Help on module my_package.module1 in my_package:
    
    NAME
        my_package.module1 - #module1.py模块文件
    
    FUNCTIONS
        display(arc)
            直接输出指定的参数
    
    FILE
        c:\users\mengma\desktop\my_package\module1.py
    ```

    - 通过输出结果可以得知，module1 实际上是一个模块文件，其包含 display() 函数，该函数的功能是直接输出指定的 arc 参数。同时，还显示出了该模块具体的存储位置。

  - 值得一提的是，之所以我们可以使用 help() 函数查看具体成员的信息，是因为该成员本身就包含表示自身身份的说明文档（本质是字符串，位于该成员内部开头的位置）。前面讲过，无论是函数还是类，都可以使用 `__doc__` 属性获取它们的说明文档，模块也不例外。

    ```
    import my_package
    print(my_package.module1.display.__doc__)
    
    直接输出指定的参数
    ```

    - help() 函数底层也是借助 `__doc__` 属性实现的。

###### \__file__:查看模块的源文件路径

- 前面章节提到，当指定模块（或包）没有说明文档时，仅通过 help() 函数或者 `__doc__` 属性，无法有效帮助我们理解该模块（包）的具体功能。在这种情况下，我们可以通过 `__file__` 属性查找该模块（或包）文件所在的具体存储位置，直接查看其源代码。

- 仍以前面章节创建的 my_package 包为例，下面代码尝试使用 `__file__` 属性获取该包的存储路径：

  ```
  import my_package
  print(my_package.__file__)
  
  C:\Users\mengma\Desktop\my_package\__init__.py
  ```

  - 注意，因为当引入 my_package 包时，其实际上执行的是 `__init__.py` 文件，因此这里查看 my_package 包的存储路径，输出的 `__init__.py` 文件的存储路径。

- 再以 string 模块为例：

  ```
  import string
  print(string.__file__)
  
  D:\python3.6\lib\string.py
  ```

- 注意，并不是所有模块都提供 `__file__` 属性，因为并不是所有模块的实现都采用 [Python](http://c.biancheng.net/python/) 语言，有些模块采用的是其它编程语言（如 C 语言）。

#### 异常处理机制

- 借助异常处理机制，甚至在程序崩溃前也可以做一些必要的工作，例如将内存中的数据写入文件、关闭打开的文件、释放分配的内存等。
- Python 异常处理机制会涉及 try、except、else、finally 这 4 个关键字，同时还提供了可主动使程序引发异常的 raise 语句

###### 常见异常类型

- 编写程序时遇到的错误可大致分为 2 类，分别为语法错误和运行时错误。

- 语法错误多是开发者疏忽导致的，属于真正意义上的错误，是解释器无法容忍的，因此，只有将程序中的所有语法错误全部纠正，程序才能执行。

  ```
  SyntaxError: Missing parentheses in call to 'print'
  ```

- 运行时错误

  ```
  a = 1/0
  
  >>> a = 1/0
  Traceback (most recent call last):
    File "<pyshell#2>", line 1, in <module>
      a = 1/0
  ZeroDivisionError: division by zero
  ```

  - 以上运行输出结果中，前两段指明了错误的位置，最后一句表示出错的类型。在 Python 中，把这种运行时产生错误的情况叫做**异常（Exceptions）**。这种异常情况还有很多，常见的几种异常情况如表 1 所示。

    | 异常类型          | 含义                                                         | 实例                                                         |
    | ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | AssertionError    | 当 assert 关键字后的条件为假时，程序运行会停止并抛出 AssertionError 异常 | >>> demo_list = ['C语言中文网'] >>> assert len(demo_list) > 0 >>> demo_list.pop() 'C语言中文网' >>> assert len(demo_list) > 0 Traceback (most recent call last):  File "<pyshell#6>", line 1, in <module>   assert len(demo_list) > 0 AssertionError |
    | AttributeError    | 当试图访问的对象属性不存在时抛出的异常                       | >>> demo_list = ['C语言中文网'] >>> demo_list.len Traceback (most recent call last):  File "<pyshell#10>", line 1, in <module>   demo_list.len AttributeError: 'list' object has no attribute 'len' |
    | IndexError        | 索引超出序列范围会引发此异常                                 | >>> demo_list = ['C语言中文网'] >>> demo_list[3] Traceback (most recent call last):  File "<pyshell#8>", line 1, in <module>   demo_list[3] IndexError: list index out of range |
    | KeyError          | 字典中查找一个不存在的关键字时引发此异常                     | >>> demo_dict={'C语言中文网':"c.biancheng.net"} >>> demo_dict["C语言"] Traceback (most recent call last):  File "<pyshell#12>", line 1, in <module>   demo_dict["C语言"] KeyError: 'C语言' |
    | NameError         | 尝试访问一个未声明的变量时，引发此异常                       | >>> C语言中文网 Traceback (most recent call last):  File "<pyshell#15>", line 1, in <module>   C语言中文网 NameError: name 'C语言中文网' is not defined |
    | TypeError         | 不同类型数据之间的无效操作                                   | >>> 1+'C语言中文网' Traceback (most recent call last):  File "<pyshell#17>", line 1, in <module>   1+'C语言中文网' TypeError: unsupported operand type(s) for +: 'int' and 'str' |
    | ZeroDivisionError | 除法运算中除数为 0 引发此异常                                | >>> a = 1/0 Traceback (most recent call last):  File "<pyshell#2>", line 1, in <module>   a = 1/0 ZeroDivisionError: division by zero |

- 当一个程序发生异常时，代表该程序在执行时出现了非正常的情况，无法再执行下去。默认情况下，程序是要终止的。如果要避免程序退出，可以使用捕获异常的方式获取这个异常的名称，再通过其他的逻辑代码让程序继续运行，这种根据异常做出的逻辑处理叫作异常处理。
- 开发者可以使用异常处理全面地控制自己的程序。异常处理不仅仅能够管理正常的流程运行，还能够在程序出错时对程序进行必的处理。大大提高了程序的健壮性和人机交互的友好性。

###### try except

- 用`try except`语句块捕获并处理异常，其基本语法结构如下所示：

  ```
  try:
      可能产生异常的代码块
  except [ (Error1, Error2, ... ) [as e] ]:
      处理异常的代码块1
  except [ (Error3, Error4, ... ) [as e] ]:
      处理异常的代码块2
  except  [Exception]:
      处理其它异常
  ```

  - 该格式中，[] 括起来的部分可以使用，也可以省略。其中各部分的含义如下：
    - (Error1, Error2,...) 、(Error3, Error4,...)：其中，Error1、Error2、Error3 和 Error4 都是具体的异常类型。显然，一个 except 块可以同时处理多种异常。
    - [as e]：作为可选参数，表示给异常类型起一个别名 e，这样做的好处是方便在 except 块中调用异常类型（后续会用到）。
    - [Exception]：作为可选参数，可以代指程序可能发生的所有异常情况，其通常用在最后一个 except 块。

- 从`try except`的基本语法格式可以看出，try 块有且仅有一个，但 except 代码块可以有多个，且每个 except 块都可以同时处理多种异常。

- 当程序发生不同的意外情况时，会对应特定的异常类型，Python 解释器会根据该异常类型选择对应的 except 块来处理该异常。

- try except 语句的执行流程如下：

  1. 首先执行 try 中的代码块，如果执行过程中出现异常，系统会自动生成一个异常类型，并将该异常提交给 Python 解释器，此过程称为捕获异常。
  2. 当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为处理异常。如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出。

  ```
  try:
      a = int(input("输入被除数："))
      b = int(input("输入除数："))
      c = a / b
      print("您输入的两个数相除的结果是：", c )
  except (ValueError, ArithmeticError):
      print("程序发生了数字格式异常、算术异常之一")
  except :
      print("未知异常")
  print("程序继续运行")
  
  输入被除数：a
  程序发生了数字格式异常、算术异常之一
  程序继续运行
  ```

  - 上面程序中，第 6 行代码使用了（ValueError, ArithmeticError）来指定所捕获的异常类型，这就表明该 except 块可以同时捕获这 2 种类型的异常；第 8 行代码只有 except 关键字，并未指定具体要捕获的异常类型，这种省略异常类的 except 语句也是合法的，它表示可捕获所有类型的异常，一般会作为异常捕获的最后一个 except 块。
  - 除此之外，由于 try 块中引发了异常，并被 except 块成功捕获，因此程序才可以继续执行，才有了“程序继续运行”的输出结果。

- 通过前面的学习，我们已经可以捕获程序中可能发生的异常，并对其进行处理。但是，由于一个 except 可以同时处理多个异常，那么我们如何知道当前处理的到底是哪种异常呢？其实，每种异常类型都提供了如下几个属性和方法，通过调用它们，就可以获取当前处理异常类型的相关信息：

  - args：返回异常的错误编号和描述字符串；
  - str(e)：返回异常信息，但不包括异常信息的类型；
  - repr(e)：返回较全的异常信息，包括异常信息的类型。

  ```
  try:
      1/0
  except Exception as e:
      # 访问异常的错误编号和详细信息
      print(e.args)
      print(str(e))
      print(repr(e))
      
  ('division by zero',)
  division by zero
  ZeroDivisionError('division by zero',)
  ```

- 一个 try 块也可以对应多个 except 块，一个 except 块可以同时处理多种异常。如果我们想使用一个 except 块处理所有异常，就可以这样写

  ```
  try:
      #...
  except Exception:
      #...
  ```

  - 对于 try 块中可能出现的任何异常，Python 解释器都会交给仅有的这个 except 块处理，因为它的参数是 Exception，表示可以接收任何类型的异常。
  - 对于可以接收任何异常的 except 来说，其后可以跟 Exception，也可以不跟任何参数，但表示的含义都是一样的。

- 这里就要详细介绍一下 Exception。要知道，为了表示程序中可能出现的各种异常，Python 提供了大量的异常类，这些异常类之间有严格的继承关系，图 1 显示了 Python 的常见异常类之间的继承关系。

![](http://c.biancheng.net/uploads/allimg/190215/2-1Z2151H054Q0.gif)

- 从图 1 中可以看出，BaseException 是 Python 中所有异常类的基类，但对于我们来说，最主要的是 Exception 类，因为程序中可能出现的各种异常，都继承自 Exception。
  - 如果用户要实现自定义异常，不应该继承 BaseException ，而应该继承 Exception 类
  - 当 try 块捕获到异常对象后，Python 解释器会拿这个异常类型依次和各个 except 块指定的异常类进行比较，如果捕获到的这个异常类，和某个 except 块后的异常类一样，又或者是该异常类的子类，那么 Python 解释器就会调用这个 except 块来处理异常；反之，Python 解释器会继续比较，直到和最后一个 except 比较完，如果没有比对成功，则证明该异常无法处理。
  - 当一个 try 块配有多个 except 块时，这些 except 块应遵循这样一个排序规则，即可处理全部异常的 except 块（参数为 Exception，也可以什么都不写）要放到所有 except 块的后面，且所有父类异常的 except 块要放到子类异常的 except 块的后面。

###### try except else

- 使用 else 包裹的代码，只有当 try 块没有捕获到任何异常时，才会得到执行；反之，如果 try 块捕获到异常，即便调用对应的 except 处理完异常，else 块中的代码也不会得到执行。

  ```
  try:
      result = 20 / int(input('请输入除数:'))
      print(result)
  except ValueError:
      print('必须输入整数')
  except ArithmeticError:
      print('算术错误，除数不能为 0')
  else:
      print('没有出现异常')
  print("继续执行")
  
  请输入除数:4
  5.0
  没有出现异常
  继续执行
  ```

- 既然 Python 解释器按照顺序执行代码，那么 else 块有什么存在的必要呢？直接将 else 块中的代码编写在 try except 块的后面，不是一样吗？

  ```
  请输入除数:a
  必须输入整数
  继续执行
  ```

  - 可以看到，当我们试图进行非法输入时，程序会发生异常并被 try 捕获，Python 解释器会调用相应的 except 块处理该异常。但是异常处理完毕之后，Python 解释器并没有接着执行 else 块中的代码，而是跳过 else，去执行后续的代码。

  - 也就是说，else 的功能，只有当 try 块捕获到异常时才能显现出来。在这种情况下，else 块中的代码不会得到执行的机会。而如果我们直接把 else 块去掉，将其中的代码编写到 try except 的后面：

    ```
    try:
        result = 20 / int(input('请输入除数:'))
        print(result)
    except ValueError:
        print('必须输入整数')
    except ArithmeticError:
        print('算术错误，除数不能为 0')
    print('没有出现异常')
    print("继续执行")
    
    请输入除数:a
    必须输入整数
    没有出现异常
    继续执行
    ```

  - 可以看到，如果不使用 else 块，try 块捕获到异常并通过 except 成功处理，后续所有程序都会依次被执行。

###### try except fin'ally

- 和 else 语句不同，finally 只要求和 try 搭配使用，而至于该结构中是否包含 except 以及 else，对于 finally 不是必须的（else 必须和 try except 搭配使用）。

- 在整个异常处理机制中，finally 语句的功能是：无论 try 块是否发生异常，最终都要进入 finally 语句，并执行其中的代码块。

- 基于 finally 语句的这种特性，在某些情况下，当 try 块中的程序打开了一些物理资源（文件、数据库连接等）时，由于这些资源必须手动回收，而回收工作通常就放在 finally 块中。

  - Python 垃圾回收机制，只能帮我们回收变量、类对象占用的内存，而无法自动完成类似关闭文件、数据库连接等这些的工作。

- 读者可能会问，回收这些物理资源，必须使用 finally 块吗？当然不是，但使用 finally 块是比较好的选择。首先，try 块不适合做资源回收工作，因为一旦 try 块中的某行代码发生异常，则其后续的代码将不会得到执行；其次 except 和 else 也不适合，它们都可能不会得到执行。而 finally 块中的代码，无论 try 块是否发生异常，该块中的代码都会被执行。

  ```
  try:
      a = int(input("请输入 a 的值:"))
      print(20/a)
  except:
      print("发生异常！")
  else:
      print("执行 else 块中的代码")   
  finally :
      print("执行 finally 块中的代码")
      
  请输入 a 的值:4
  5.0
  执行 else 块中的代码
  执行 finally 块中的代码
  ```

- 当 try 块中代码发生异常，导致程序崩溃时，在崩溃前 Python 解释器也会执行 finally 块中的代码。

###### raise

- [Python](http://c.biancheng.net/python/) 允许我们在程序中手动设置异常，使用 raise 语句即可。

- raise 语句的基本语法格式为：

  ```
  raise [exceptionName [(reason)]]
  ```

  - 其中，用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述。如果可选参数全部省略，则 raise 会把当前错误原样抛出；如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息。

  - 也就是说，raise 语句有如下三种常用的用法：

    1. raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。
    2. raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。
    3. raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。

  - 每次执行 raise 语句，都只能引发一次执行的异常

    ```
    >>> raise
    Traceback (most recent call last):
      File "<pyshell#1>", line 1, in <module>
        raise
    RuntimeError: No active exception to reraise
    >>> raise ZeroDivisionError
    Traceback (most recent call last):
      File "<pyshell#0>", line 1, in <module>
        raise ZeroDivisionError
    ZeroDivisionError
    >>> raise ZeroDivisionError("除数不能为零")
    Traceback (most recent call last):
      File "<pyshell#2>", line 1, in <module>
        raise ZeroDivisionError("除数不能为零")
    ZeroDivisionError: 除数不能为零
    ```

- 我们手动让程序引发异常，很多时候并不是为了让其崩溃。事实上，raise 语句引发的异常通常用 try except（else finally）异常处理结构来捕获并进行处理。

  ```
  try:
      a = input("输入一个数：")
      #判断用户输入的是否为数字
      if(not a.isdigit()):
          raise ValueError("a 必须是数字")
  except ValueError as e:
      print("引发异常：",repr(e))
      
  输入一个数：a
  引发异常： ValueError('a 必须是数字',)
  ```

  - 可以看到，当用户输入的不是数字时，程序会进入 if 判断语句，并执行 raise 引发 ValueError 异常。但由于其位于 try 块中，因为 raise 抛出的异常会被 try 捕获，并由 except 块进行处理。
  - 虽然程序中使用了 raise 语句引发异常，但程序的执行是正常的，手动抛出的异常并不会导致程序崩溃。

- 正如前面所看到的，在使用 raise 语句时可以不带参数

  ```
  try:
      a = input("输入一个数：")
      if(not a.isdigit()):
          raise ValueError("a 必须是数字")
  except ValueError as e:
      print("引发异常：",repr(e))
      raise
      
  输入一个数：a
  引发异常： ValueError('a 必须是数字',)
  Traceback (most recent call last):
    File "D:\python3.6\1.py", line 4, in <module>
      raise ValueError("a 必须是数字")
  ValueError: a 必须是数字
  ```

  - 这里重点关注位于 except 块中的 raise，由于在其之前我们已经手动引发了 ValueError 异常，因此这里当再使用 raise 语句时，它会再次引发一次。
  - 当在没有引发过异常的程序使用无参的 raise 语句时，它默认引发的是 RuntimeError 异常

###### sys.exc_info()

- 在实际调试程序的过程中，有时只获得异常的类型是远远不够的，还需要借助更详细的异常信息才能解决问题。

- 捕获异常时，有 2 种方式可获得更多的异常信息，分别是：

  1. 使用 sys 模块中的 exc_info 方法；
  2. 使用 traceback 模块中的相关函数。

- 模块 sys 中，有两个方法可以返回异常的全部信息，分别是 exc_info() 和 last_traceback()，这两个函数有相同的功能和用法，本节仅以 exc_info() 方法为例。

- exc_info() 方法会将当前的异常信息以元组的形式返回，该元组中包含 3 个元素，分别为 type、value 和 traceback，它们的含义分别是：

  - type：异常类型的名称，它是 BaseException 的子类
  - value：捕获到的异常实例。
  - traceback：是一个 traceback 对象。

  ```
  #使用 sys 模块之前，需使用 import 引入
  import sys
  try:
      x = int(input("请输入一个被除数："))
      print("30除以",x,"等于",30/x)
  except:
      print(sys.exc_info())
      print("其他异常...")
  
  当输入 0 时，程序运行结果为
  请输入一个被除数：0
  (<class 'ZeroDivisionError'>, ZeroDivisionError('division by zero',), <traceback object at 0x000001FCF638DD48>)
  其他异常...
  ```

  - 输出结果中，第 2 行是抛出异常的全部信息，这是一个元组，有 3 个元素，第一个元素是一个 ZeroDivisionError 类；第 2 个元素是异常类型 ZeroDivisionError 类的一个实例；第 3 个元素为一个 traceback 对象。其中，通过前 2 个元素可以看出抛出的异常类型以及描述信息，对于第 3 个元素，是一个 traceback 对象，无法直接看出有关异常的信息，还需要对其做进一步处理。

- 要查看 traceback 对象包含的内容，需要先引进 traceback 模块，然后调用 traceback 模块中的 print_tb 方法，并将 sys.exc_info() 输出的 traceback 对象作为参数参入。

  ```python
  #使用 sys 模块之前，需使用 import 引入
  import sys
  #引入traceback模块
  import traceback
  try:
      x = int(input("请输入一个被除数："))
      print("30除以",x,"等于",30/x)
  except:
      #print(sys.exc_info())
      traceback.print_tb(sys.exc_info()[2])
      print("其他异常...")
  
  请输入一个被除数：0
    File "C:\Users\mengma\Desktop\demo.py", line 7, in <module>
      print("30除以",x,"等于",30/x)
  其他异常...
  ```

  - 可以看到，输出信息中包含了更多的异常信息，包括文件名、抛出异常的代码所在的行数、抛出异常的具体代码。

###### traceback模块

- 除了使用 sys.exc_info() 方法获取更多的异常信息之外，还可以使用 traceback 模块，该模块可以用来查看异常的传播轨迹，追踪异常触发的源头。

- 下面示例显示了如何显示异常传播轨迹

  ```
  class SelfException(Exception):
      pass
  def main():
      firstMethod()
  def firstMethod():
      secondMethod()
  def secondMethod():
      thirdMethod()
  def thirdMethod():
      raise SelfException("自定义异常信息")
  main()
  
  Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\1.py", line 11, in <module>
      main()
    File "C:\Users\mengma\Desktop\1.py", line 4, in main                   <--mian函数
      firstMethod()
    File "C:\Users\mengma\Desktop\1.py", line 6, in firstMethod        <--第三个
      secondMethod()
    File "C:\Users\mengma\Desktop\1.py", line 8, in secondMethod   <--第二个
      thirdMethod()
    File "C:\Users\mengma\Desktop\1.py", line 10, in thirdMethod     <--异常源头
      raise SelfException("自定义异常信息")
  SelfException: 自定义异常信息
  ```

  - 上面程序中 main() 函数调用 firstMethod()，firstMethod() 调用 secondMethod()，secondMethod() 调用 thirdMethod()，thirdMethod() 直接引发一个 SelfException 异常
  - 从输出结果可以看出，异常从 thirdMethod() 函数开始触发，传到 secondMethod() 函数，再传到 firstMethod() 函数，最后传到 main() 函数，在 main() 函数止，这个过程就是整个异常的传播轨迹。

- 在实际应用程序的开发中，大多数复杂操作都会被分解成一系列函数或方法调用。这是因为，为了具有更好的可重用性，会将每个可重用的代码单元定义成函数或方法，将复杂任务逐渐分解为更易管理的小型子任务。由于一个大的业务功能需要由多个函数或方法来共同实现，在最终编程模型中，很多对象将通过一系列函数或方法调用来实现通信，执行任务。

- 所以，当应用程序运行时，经常会发生一系列函数或方法调用，从而形成“函数调用战”。异常的传播则相反，只要异常没有被完全捕获（包括异常没有被捕获，或者异常被处理后重新引发了新异常），异常就从发生异常的函数或方法逐渐向外传播，首先传给该函数或方法的调用者，该函数或方法的调用者再传给其调用者，直至最后传到 [Python](http://c.biancheng.net/python/) 解释器，此时 Python 解释器会中止该程序，并打印异常的传播轨迹信息。

- 很多初学者一看到输出结果所示的异常提示信息，就会惊慌失措，他们以为程序出现了很多严重的错误，其实只有一个错误，系统提示那么多行信息，只不过是显示异常依次触发的轨迹。

- 使用 traceback 模块查看异常传播轨迹，首先需要将 traceback 模块引入，该模块提供了如下两个常用方法：

  - traceback.print_exc()：将异常传播轨迹信息输出到控制台或指定文件中。
  - format_exc()：将异常传播轨迹信息转换成字符串。

- 可能有读者好奇，从上面方法看不出它们到底处理哪个异常的传播轨迹信息。实际上我们常用的 print_exc() 是 print_exc([limit[, file]]) 省略了 limit、file 两个参数的形式。而 print_exc([limit[, file]]) 的完整形式是 `print_exception(etype, value, tb[,limit[, file]])`，在完整形式中，前面三个参数用于分别指定异常的如下信息：

  - etype：指定异常类型；
  - value：指定异常值；
  - tb：指定异常的traceback 信息；

- 当程序处于 except 块中时，该 except 块所捕获的异常信息可通过 sys 对象来获取，其中 sys.exc_type、sys.exc_value、sys.exc_traceback 就代表当前 except 块内的异常类型、异常值和异常传播轨迹。

- 简单来说， print_exc([limit[, file]]) 相当于如下形式：

  ```
  print_exception(sys.exc_etype, sys.exc_value, sys.exc_tb[, limit[, file]])
  ```

  - 也就是说，使用 print_exc([limit[, file]]) 会自动处理当前 except 块所捕获的异常。该方法还涉及两个参数：

    1. limit：用于限制显示异常传播的层数，比如函数 A 调用函数 B，函数 B 发生了异常，如果指定 limit=1，则只显示函数 A 里面发生的异常。如果不设置 limit 参数，则默认全部显示。
    2. file：指定将异常传播轨迹信息输出到指定文件中。如果不指定该参数，则默认输出到控制台。

    ```
    # 导入trackback模块
    import traceback
    class SelfException(Exception): pass
    def main():
        firstMethod()
    def firstMethod():
        secondMethod()
    def secondMethod():
        thirdMethod()
    def thirdMethod():
        raise SelfException("自定义异常信息")
    try:
        main()
    except:
        # 捕捉异常，并将异常传播信息输出控制台
        traceback.print_exc()
        # 捕捉异常，并将异常传播信息输出指定文件中
        traceback.print_exc(file=open('log.txt', 'a'))
    ```

###### 自定义一个异常类

- 自定义一个异常类，通常应继承自 Exception 类（直接继承），当然也可以继承自那些本身就是从 Exception 继承而来的类（间接继承 Exception）。

- 虽然所有类同时继承自 BaseException，但它是为系统退出异常而保留的，假如直接继承 BaseException，可能会导致自定义异常不会被捕获，而是直接发送信号退出程序运行，脱离了我们自定义异常类的初衷。

- 系统自带的异常只要触发会自动抛出（比如 NameError、ValueError 等），但用户自定义的异常需要用户自己决定什么时候抛出。也就是说，自定义的异常需要使用 raise 手动抛出。

  ```
  class InputError(Exception):
      '''当输出有误时，抛出此异常'''
      #自定义异常类型的初始化
      def __init__(self, value):
          self.value = value
      # 返回异常类对象的说明信息
      def __str__(self):
          return ("{} is invalid input".format(repr(self.value)))
     
  try:
      raise InputError(1) # 抛出 MyInputError 这个异常
  except InputError as err:
      print('error: {}'.format(err))
      
  error: 1 is invalid input
  ```

###### logging模块调试程序

- 无论使用哪种编程语言，最常用的调试代码的方式是：使用输出语句（比如 C 语言中使用 printf，Python 中使用 print() 函数）输出程序运行过程中一些关键的变量的值，查看它们的值是否正确，从而找到出错的地方。这种调试方法最大的缺点是，当找到问题所在之后，需要再将用于调试的输出语句删掉。

- 在 Python 中，有一种比频繁使用 print() 调试程序更简便的方法，就是使用 logging 模块，该模块可以很容易地创建自定义的消息记录，这些日志消息将描述程序执行何时到达日志函数调用，并列出指定的任何变量当时的值。

- 启用 logging 模块很简单，直接将下面的代码复制到程序开头：

  ```
  import logging
  logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')
  ```

  - 读者不需要关心这两行代码的具体工作原理，但基本上，当 Python 记录一个事件的日志时，它会创建一个 LogRecord 对象，保存关于该事件的信息。

- 假如我们编写了如下一个函数，其设计的初衷是用来计算一个数的阶乘，但该函数有些问题，需要调试：

  ```
  import logging
  logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')
  logging.debug('Start of program')
  def factorial(n):
      logging.debug('Start of factorial(%s%%)' % (n))
      total = 1
      for i in range(n + 1):
          total *= i
          logging.debug('i is ' + str(i) + ', total is ' + str(total))
      logging.debug('End of factorial(%s%%)' % (n))
      return total
  print(factorial(5))
  logging.debug('End of program')
  
  2019-09-11 14:14:56,928 - DEBUG - Start of program
  2019-09-11 14:14:56,945 - DEBUG - Start of factorial(5%)
  2019-09-11 14:14:56,959 - DEBUG - i is 0, total is 0
  2019-09-11 14:14:56,967 - DEBUG - i is 1, total is 0
  2019-09-11 14:14:56,979 - DEBUG - i is 2, total is 0
  2019-09-11 14:14:56,991 - DEBUG - i is 3, total is 0
  2019-09-11 14:14:57,000 - DEBUG - i is 4, total is 0
  2019-09-11 14:14:57,013 - DEBUG - i is 5, total is 0
  2019-09-11 14:14:57,024 - DEBUG - End of factorial(5%)
  0
  2019-09-11 14:14:57,042 - DEBUG - End of program
  ```

  - 可以看到，通过 logging.debug() 函数可以打印日志信息，这个 debug() 函数将调用 basicConfig() 打印一行信息，这行信息的格式是在 basicConfig() 函数中指定的，并且包括传递给 debug() 的消息。

  - 分析程序的运行结果，factorial(5) 返回 0 作为 5 的阶乘的结果，这显然是不对的。for 循环应该用从 1 到 5 的数，乘以 total 的值，但 logging.debug() 显示的日志信息表明，i 变量从 0 开始，而不是 1。因为 0 乘任何数都是 0，所以接下来的迭代中，total 的值都是错的。日志消息提供了可以追踪的痕迹，帮助我们弄清楚程序运行过程哪里不对。

  - 将代码行 for i in range（n + 1）：改为 for i in range（1，n + 1）：，再次运行程序，输出结果为：

    ```
    2019-09-11 14:21:18,047 - DEBUG - Start of program
    2019-09-11 14:21:18,067 - DEBUG - Start of factorial(5%)
    2019-09-11 14:21:18,072 - DEBUG - i is 1, total is 1
    2019-09-11 14:21:18,082 - DEBUG - i is 2, total is 2
    2019-09-11 14:21:18,087 - DEBUG - i is 3, total is 6
    2019-09-11 14:21:18,093 - DEBUG - i is 4, total is 24
    2019-09-11 14:21:18,101 - DEBUG - i is 5, total is 120
    2019-09-11 14:21:18,106 - DEBUG - End of factorial(5%)
    120
    2019-09-11 14:21:18,123 - DEBUG - End of program
    ```

- logging日志级别

  - 日志级别”提供了一种方式，按重要性对日志消息进行分类。5 个日志级别如表 1 所示，从最不重要到最重要。利用不同的日志函数，消息可以按某个级别记入日志。

    | 级别     | 对应的函数         | 描述                                                         |
    | -------- | ------------------ | ------------------------------------------------------------ |
    | DEBUG    | logging.debug()    | 最低级别，用于小细节，通常只有在诊断问题时，才会关心这些消息。 |
    | INFO     | logging.info()     | 用于记录程序中一般事件的信息，或确认一切工作正常。           |
    | WARNING  | logging.warning()  | 用于表示可能的问题，它不会阻止程序的工作，但将来可能会。     |
    | ERROR    | logging.error()    | 用于记录错误，它导致程序做某事失败。                         |
    | CRITICAL | logging.critical() | 最高级别，用于表示致命的错误，它导致或将要导致程序完全停止工作。 |

  - 日志消息将会作为一个字符串，传递给这些函数。另外，日志级别只是一种建议，归根到底还是由程序员自己来决定日志消息属于哪一种类型。

  ```
  >>>import logging
  >>> logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')
  >>> logging.debug('Some debugging details.')
  2019-09-11 14:32:34,249 - DEBUG - Some debugging details.
  >>> logging.info('The logging module is working.')
  2019-09-11 14:32:47,456 - INFO - The logging module is working.
  >>> logging.warning('An error message is about to be logged.')
  2019-09-11 14:33:02,391 - WARNING - An error message is about to be logged.
  >>> logging.error('An error has occurred.')
  2019-09-11 14:33:14,413 - ERROR - An error has occurred.
  >>> logging.critical('The program is unable to recover!')
  2019-09-11 14:33:24,071 - CRITICAL - The program is unable to recover!
  ```

  - 日志级别的好处在于，我们可以改变想看到的日志消息的优先级。比如说，向 basicConfig() 函数传入 logging.DEBUG 作为 level 关键字参数，这将显示所有级别为 DEBUG 的日志消息。当开发了更多的程序后，我们可能只对错误感兴趣，在这种情况下，可以将 basicConfig() 的 level 参数设置为 logging.ERROR，这将只显示 ERROR 和 CRITICAL 消息，跳过 DEBUG、INFO 和 WARNING 消息。

- logging禁用日志

  - 在调试完程序后，可能并不希望所有这些日志消息出现在屏幕上，这时就可以使用 logging.disable() 函数禁用这些日志消息，从而不必进入到程序中，手工删除所有的日志调用。

  - logging.disable() 函数的用法是，向其传入一个日志级别，它会禁止该级别以及更低级别的所有日志消息。因此，如果想要禁用所有日志，只要在程序中添加 logging.disable(logging.CRITICAL) 即可，例如：

    ```
    >>> import logging
    >>> logging.basicConfig(level=logging.INFO, format=' %(asctime)s - %(levelname)s - %(message)s')
    >>> logging.critical('Critical error! Critical error!')
    2019-09-11 14:42:14,833 - CRITICAL - Critical error! Critical error!
    >>> logging.disable(logging.CRITICAL)
    >>> logging.critical('Critical error! Critical error!')
    >>> logging.error('Error! Error!')
    ```

    - 因为 logging.disable() 将禁用它之后的所有消息，所以可以将其添加到程序中更接近 import logging 的位置，这样更容易找到它，方便根据需要注释掉它，或取消注释，从而启用或禁用日志消息。

- 将日志消息输出到文件中

  - 虽然日志消息很有用，但它们可能塞满屏幕，让你很难读到程序的输出。考虑到这种情况，可以将日志信息写入到文件，既能使屏幕保持干净，又能保存信息，一举两得。

  - 将日志消息输出到文件中的实现方法很简单，只需要设置 logging.basicConfig() 函数中的 filename 关键字参数即可，例如：

    ```
    >>> import logging
    >>> logging.basicConfig(filename='demo.txt', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
    ```

    - 此程序中，将日志消息存储到了 demo.txt 文件中，该文件就位于运行的程序文件所在的目录。

###### assert调试程序

- assert 语句的完整语法格式为：

  ```
  assert 条件表达式 [,描述信息]
  ```

  - assert 语句的作用是：当条件表达式的值为真时，该语句什么也不做，程序正常运行；反之，若条件表达式的值为假，则 assert 会抛出 AssertionError 异常。其中，[,描述信息] 作为可选参数，用于对条件表达式可能产生的异常进行描述。

  ```
  s_age = input("请输入您的年龄:")
  age = int(s_age)
  assert 20 < age < 80 , "年龄不在 20-80 之间"
  print("您输入的年龄在20和80之间")
  
  请输入您的年龄:10
  Traceback (most recent call last):
    File "C:\Users\mengma\Desktop\1.py", line 3, in <module>
      assert 20 < age < 80 , "年龄不在 20-80 之间"
  AssertionError: 年龄不在 20-80 之间
  ```

- 通常情况下，assert 可以和 try except 异常处理语句配合使用，以前面代码为例：

  ```
  try:
      s_age = input("请输入您的年龄:")
      age = int(s_age)
      assert 20 < age < 80 , "年龄不在 20-80 之间"
      print("您输入的年龄在20和80之间")
  except AssertionError as e:
      print("输入年龄不正确",e)
      
  请输入您的年龄:10
  输入年龄不正确 年龄不在 20-80 之间
  ```

  - 通过在程序的适当位置，使用 assert 语句判断变量或表达式的值，可以起到调试代码的作用。
  - 当在命令行模式运行 Python 程序时，传入 -O（注意是大写）参数，可以禁用程序中包含的 assert 语句。
