#### python理解

- cpu执行的都是机器码，所以无论是编译型语言还是解释型语言最后都要编译为机器码来运行，不同的操作系统可执行文件的格式不同，例如linux下支持的是ELF格式，windows下使用的是PE格式，编译型语言例如c，要经历预处理、编译、汇编、链接四个过程，最后生成可执行文件，这个可执行文件操作系统是可以直接执行的，不用借助其他的中间件。可执行文件里面都是机器码。可执行文件放在虚拟内存里面，按照分页管理，用到哪部分机器码，就由操作系统按照内存映射将哪部分机器码放到物理内存中。每一个进程按照虚拟内存来说都有独立的内存区域，所以不用担心内存的问题。编译型语言例如python，其没有c语言的四个过程，但是如果想要运行就必须要有机器码，所以python在不同的平台上都实现了解释器，这个解释器是一个可执行程序，在linux下就是ELF文件，在windows下就是PE文件，在运行python程序的时候，由这个python解释器来将源代码编译为机器码来运行，这个过程不是说编译全部的，程序运行时需要哪部分代码就编译哪部分代码为机器码，将机器码放到内存中，这样就能直接运行。至于这个编译是如何控制的，也就是如何确定需要哪部分代码这是python解释器要实现的，使用者不需要管。所以python源文件是不能直接由操作系统执行的，必须借助python解释器。这也是python运行比较慢的原因

- python源码能跨平台运行，其中的差异都由不同平台上的python编译器隐藏了。例如不同的平台对于文件的管理是不同的，对于文件的底层实现是不同的。如果python源码中打开一个文件open(file)这个操作，不同的平台对于打开文件底层都是不同的，机器码也是不同的，但是这个机器码在相同的平台下是固定的，例如打开文件在linux下的机器码是固定的，这样python解释器就能将打开文件这个操作转换为机器码，然后将这个机器码放到内存中(内存中有代码段和数据段)，不同的解释器就是用来隐藏这个差异的，对我们用户来说打开文件都是一样的操作，其实底层都用解释器来隐藏了。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态。比如打开文件读写文件都在内核态，如果要用这些服务时，就会转到内存中的内核态里面去执行。python解释器应该也会实现这些转换，用户态到内核态，因为本身python解释器就是解释代码变成机器码来运行。操作系统只提供最基本的服务，具体的算法实现一般还是在用户态自己实现。

- python需要系统服务的一些会转到内核态，但是一些用户态的还是python本身自己就能实现，不用调用c和c++的库，例如数据计算时，数据计算主要是内存中的计算，定义变量时申请内存，计算时用机器码操作计算。这些python解释器就能转换为机器码来实现，不用先转换为c或者c++的库然后在转换为机器码，python解释器自己就能转换为机器码。所以一些numpy、pandas这些计算模块不用调用c或者c++的代码，用python的语法就能实现，剩下的交给python解释器就行。所以用pip下载的这些模块里面都没有动态库，只有py文件

- cpu指令是固定的，例如加减乘除移动访问，这些机器码对于cpu都是固定的，所有的语言最后都要生成cpu能执行的的这些固定的机器码。内存中有代码段和数据段。其实变量的定义和计算就是申请一个内存，然后计算，这个比较好说。如果涉及到操作系统提供的函数，就会涉及到一些底层的实现，这样生成的机器码比较复杂，放到内存中的也比较复杂，我们用户不用管这些，python解释器帮我们干了这些事情。其实操作系统提供的主要是一些文件操作以及网络服务之类的。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- 不同的编程语言对于操作系统提供的这些服务按照语法来说是不同的，但是最后生成的机器码都是一样的。不同的编程语言在一些功能上实现的方式不同，对于用户来说就是实现的简单与否。但是最后殊途同归，生成的机器码都是一样的。所以会有算法这种东西产生，不同的算法对于一个功能的实现可能是质的飞跃(不同的算法计算方式不一样)，这样生成的机器码就不会很啰嗦，生成的机器码就会很少，这样运算速度就会很快。所以算法对于运算的提升很大。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- python官网上的模块例如numpy，pandas官网上的都是.whl文件，whl文件本质上就是一个压缩文件，安装whl文件很简单，先手动下载文件然后手动安装时使用pip install xxx.whl，pip命令直接安装(不用先手动下载whl文件)也是命令自己下载whl文件，然后在解压安装，原理都是一样的。

- 查看可执行程序，windows下是where python， linux和mac下是which python

- pip安装包的路径查询，在pip install首次安装完成的时候会显示安装位置，如果已经安装使用pip install就会显示安装位置，windows下pip安装的模块一般都放在C:\Users\lylyx\AppData\Local\Programs\Python\Python39\Lib\site-packages里面

- mac下使用homebrew安装软件时使用brew info可以看到软件的依赖以及各种信息，如果直接安装例如brew install python3，里面的idle运行时就会提示Tkinter缺失(Tkinter模块("Tk 接口")是Python的标准Tk GUI工具包的接口。 作为 python 特定的GUI界面，是一个图像的窗口，tkinter是python 自带的，可以编辑的GUI界面)，这样就会出错。但是我们可以使用brew info python3，就是显示各种信息，包括依赖的tkinter问题，这样我们就能根据提示安装thinter，idle就能正常使用了

- pyc文件是py文件编译后生成的字节码文件(byte code)。pyc文件经过python解释器最终会生成机器码运行。为什么要手动提前生成pyc文件呢，主要是不想把源代码暴露出来。生成的pyc文件会放到当前目录下新创建的\__pycache__中

  ```
  命令生成pyc文件
  python -m foo.py
  代码来生成pyc文件
  import py_compile
  py_compile.compile('/path/to/foo.py')
  
  批量生成，针对一个目录下所有的py文件进行编译。python提供了一个模块叫compileall
  import compileall
  compileall.compile_dir(r'/path')
  ```

  - 生成的pyc文件使用python xxx.pyc来运行

#### 变量类型和运算符

- 变量在 Python 内部是有类型的，比如 int、float 等，但是我们在编程时无需关注变量类型，所有的变量都无需提前声明，赋值后就能使用。另外，可以将不同类型的数据赋值给同一个变量，所以变量的类型是可以改变的。
- Python 支持自增和自减运算符，但是它只支持一种形式，就是前自增和前自减，而取消了后自增和后自减，避免了给程序员造成混乱
