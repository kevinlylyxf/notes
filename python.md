#### python理解

- cpu执行的都是机器码，所以无论是编译型语言还是解释型语言最后都要编译为机器码来运行，不同的操作系统可执行文件的格式不同，例如linux下支持的是ELF格式，windows下使用的是PE格式，编译型语言例如c，要经历预处理、编译、汇编、链接四个过程，最后生成可执行文件，这个可执行文件操作系统是可以直接执行的，不用借助其他的中间件。可执行文件里面都是机器码。可执行文件放在虚拟内存里面，按照分页管理，用到哪部分机器码，就由操作系统按照内存映射将哪部分机器码放到物理内存中。每一个进程按照虚拟内存来说都有独立的内存区域，所以不用担心内存的问题。编译型语言例如python，其没有c语言的四个过程，但是如果想要运行就必须要有机器码，所以python在不同的平台上都实现了解释器，这个解释器是一个可执行程序，在linux下就是ELF文件，在windows下就是PE文件，在运行python程序的时候，由这个python解释器来将源代码编译为机器码来运行，这个过程不是说编译全部的，程序运行时需要哪部分代码就编译哪部分代码为机器码，将机器码放到内存中，这样就能直接运行。至于这个编译是如何控制的，也就是如何确定需要哪部分代码这是python解释器要实现的，使用者不需要管。所以python源文件是不能直接由操作系统执行的，必须借助python解释器。这也是python运行比较慢的原因

- python源码能跨平台运行，其中的差异都由不同平台上的python编译器隐藏了。例如不同的平台对于文件的管理是不同的，对于文件的底层实现是不同的。如果python源码中打开一个文件open(file)这个操作，不同的平台对于打开文件底层都是不同的，机器码也是不同的，但是这个机器码在相同的平台下是固定的，例如打开文件在linux下的机器码是固定的，这样python解释器就能将打开文件这个操作转换为机器码，然后将这个机器码放到内存中(内存中有代码段和数据段)，不同的解释器就是用来隐藏这个差异的，对我们用户来说打开文件都是一样的操作，其实底层都用解释器来隐藏了。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态。比如打开文件读写文件都在内核态，如果要用这些服务时，就会转到内存中的内核态里面去执行。python解释器应该也会实现这些转换，用户态到内核态，因为本身python解释器就是解释代码变成机器码来运行。操作系统只提供最基本的服务，具体的算法实现一般还是在用户态自己实现。

- python需要系统服务的一些会转到内核态，但是一些用户态的还是python本身自己就能实现，不用调用c和c++的库，例如数据计算时，数据计算主要是内存中的计算，定义变量时申请内存，计算时用机器码操作计算。这些python解释器就能转换为机器码来实现，不用先转换为c或者c++的库然后在转换为机器码，python解释器自己就能转换为机器码。所以一些numpy、pandas这些计算模块不用调用c或者c++的代码，用python的语法就能实现，剩下的交给python解释器就行。所以用pip下载的这些模块里面都没有动态库，只有py文件

- cpu指令是固定的，例如加减乘除移动访问，这些机器码对于cpu都是固定的，所有的语言最后都要生成cpu能执行的的这些固定的机器码。内存中有代码段和数据段。其实变量的定义和计算就是申请一个内存，然后计算，这个比较好说。如果涉及到操作系统提供的函数，就会涉及到一些底层的实现，这样生成的机器码比较复杂，放到内存中的也比较复杂，我们用户不用管这些，python解释器帮我们干了这些事情。其实操作系统提供的主要是一些文件操作以及网络服务之类的。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- 不同的编程语言对于操作系统提供的这些服务按照语法来说是不同的，但是最后生成的机器码都是一样的。不同的编程语言在一些功能上实现的方式不同，对于用户来说就是实现的简单与否。但是最后殊途同归，生成的机器码都是一样的。所以会有算法这种东西产生，不同的算法对于一个功能的实现可能是质的飞跃(不同的算法计算方式不一样)，这样生成的机器码就不会很啰嗦，生成的机器码就会很少，这样运算速度就会很快。所以算法对于运算的提升很大。要注意理解内核态和用户态。操作系统提供的都是在内核态。用户自己实现的在用户态

- python官网上的模块例如numpy，pandas官网上的都是.whl文件，whl文件本质上就是一个压缩文件，安装whl文件很简单，先手动下载文件然后手动安装时使用pip install xxx.whl，pip命令直接安装(不用先手动下载whl文件)也是命令自己下载whl文件，然后在解压安装，原理都是一样的。

- 查看可执行程序，windows下是where python， linux和mac下是which python

- pip安装包的路径查询，在pip install首次安装完成的时候会显示安装位置，如果已经安装使用pip install就会显示安装位置，windows下pip安装的模块一般都放在C:\Users\lylyx\AppData\Local\Programs\Python\Python39\Lib\site-packages里面

- mac下使用homebrew安装软件时使用brew info可以看到软件的依赖以及各种信息，如果直接安装例如brew install python3，里面的idle运行时就会提示Tkinter缺失(Tkinter模块("Tk 接口")是Python的标准Tk GUI工具包的接口。 作为 python 特定的GUI界面，是一个图像的窗口，tkinter是python 自带的，可以编辑的GUI界面)，这样就会出错。但是我们可以使用brew info python3，就是显示各种信息，包括依赖的tkinter问题，这样我们就能根据提示安装thinter，idle就能正常使用了

- pyc文件是py文件编译后生成的字节码文件(byte code)。pyc文件经过python解释器最终会生成机器码运行。为什么要手动提前生成pyc文件呢，主要是不想把源代码暴露出来。生成的pyc文件会放到当前目录下新创建的\__pycache__中

  ```
  命令生成pyc文件
  python -m foo.py
  代码来生成pyc文件
  import py_compile
  py_compile.compile('/path/to/foo.py')
  
  批量生成，针对一个目录下所有的py文件进行编译。python提供了一个模块叫compileall
  import compileall
  compileall.compile_dir(r'/path')
  ```

  - 生成的pyc文件使用python xxx.pyc来运行

#### 变量类型和运算符

- 变量在 Python 内部是有类型的，比如 int、float 等，但是我们在编程时无需关注变量类型，所有的变量都无需提前声明，赋值后就能使用。另外，可以将不同类型的数据赋值给同一个变量，所以变量的类型是可以改变的。

- Python 支持自增和自减运算符，但是它只支持一种形式，就是前自增和前自减，而取消了后自增和后自减，避免了给程序员造成混乱

- 变量（Variable）可以看成一个小箱子，专门用来“盛装”程序中的数据。每个变量都拥有独一无二的名字，通过变量的名字就能找到变量中的数据。

- 从底层看，程序中的数据最终都要放到内存（内存条）中，变量其实就是这块内存的名字。

- 和变量相对应的是常量（Constant），它们都是用来“盛装”数据的小箱子，不同的是：变量保存的数据可以被多次修改，而常量一旦保存某个数据之后就不能修改了。

- id() 内置函数，该函数的功能是获取变量（对象）所在的内存地址

- 在强类型的编程语言中，定义变量时要指明变量的类型，而且赋值的数据也必须是相同类型的，C语言、C++、[Java](http://c.biancheng.net/java/) 是强类型语言的代表。

- 和强类型语言相对应的是弱类型语言，Python、[JavaScript](http://c.biancheng.net/js/)、[PHP](http://c.biancheng.net/php/) 等脚本语言一般都是弱类型的。弱类型语言有两个特点：

  - 变量无须声明就可以直接赋值，对一个不存在的变量赋值就相当于定义了一个新变量。
  - 变量的数据类型可以随时改变，比如，同一个变量可以一会儿被赋值为整数，一会儿被赋值为字符串。

- 弱类型并不等于没有类型！弱类型是说在书写代码时不用刻意关注类型，但是在编程语言的内部仍然是有类型的。我们可以使用 type() 内置函数类检测某个变量或者表达式的类型，其类型的

  ```python
  >>>num = 10
  >>> type(num)
  <class 'int'>
  >>> num = 15.8
  >>> type(num)
  <class 'float'>
  >>> num = 20 + 15j
  >>> type(num)
  <class 'complex'>
  >>> type(3*15.6)
  <class 'float'>
  ```

- 弱类型语言的变量在内存中存储，每一种占据的字节数都是固定的，例如int占用四个字节，float占用8个字节一个。但是我们可以不用管，因为有python解释器，解释器就帮我们干了这个事，所以我们不用考虑变量的类型。

##### 整数

- Python 整数不分类型，或者说它只有一种类型的整数。Python 整数的取值范围是无限的，不管多大或者多小的数字，Python 都能轻松处理。当所用数值超过计算机自身的计算能力时，Python 会自动转用高精度计算（大数计算）。不管对于多大或者多小的整数，Python 只用一种类型存储，就是 int。无论对于多大的整数，type()的结果都为int

- 在 Python 中，可以使用多种进制来表示整数：

  1) 十进制形式

  我们平时常见的整数就是十进制形式，它由 0~9 共十个数字排列组合而成。

  注意，使用十进制形式的整数不能以 0 作为开头，除非这个数值本身就是 0。

  2) 二进制形式

  由 0 和 1 两个数字组成，书写时以`0b`或`0B`开头。例如，101 对应十进制数是 5。

  3) 八进制形式

  八进制整数由 0~7 共八个数字组成，以`0o`或`0O`开头。注意，第一个符号是数字 0，第二个符号是大写或小写的字母 O。

  在 Python 2.x 中，八进制数字还可以直接以`0`（数字零）开头。

  4) 十六进制形式

  由 0~9 十个数字以及 A~F（或 a~f）六个字母组成，书写时以`0x`或`0X`开头

- 为了提高数字的的可读性，Python 3.x 允许使用下划线`_`作为数字（包括整数和小数）的分隔符。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。下划线不会影响数字本身的值。

  ```python
  click = 1_301_547
  distance = 384_000_000
  print("Python教程阅读量：", click)
  print("地球和月球的距离：", distance)
  
  Python教程阅读量：1301547
  地球和月球的距离：384000000
  ```

##### 浮点数

- [Python](http://c.biancheng.net/python/) 中的小数有两种书写形式：

  1) 十进制形式

  这种就是我们平时看到的小数形式，例如 34.6、346.0、0.346。

  书写小数时必须包含一个小数点，否则会被 Python 当作整数处理。

  2) 指数形式

  Python 小数的指数形式的写法为：aEn 或 aen

  a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；`E`或`e`是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 a×10n。

- 只要写成指数形式就是小数，即使它的最终值看起来像一个整数。例如 14E3 等价于 14000，但 14E3 是一个小数。

- Python 只有一种小数类型，就是 float。C语言有两种小数类型，分别是 float 和 double：float 能容纳的小数范围比较小，double 能容纳的小数范围比较大。

- Python 能容纳极小和极大的浮点数。print 在输出浮点数时，会根据浮点数的长度和大小适当的舍去一部分数字，或者采用科学计数法。

  ```python
  f5 = 12e4
  print("f5Value: ", f5)
  print("f5Type: ", type(f5))
  f6 = 12.3 * 0.1
  print("f6Value: ", f6)
  print("f6Type: ", type(f6))
  
  f5Value:  120000.0
  f5Type:  <class 'float'>
  f6Value:  1.2300000000000002
  f6Type:  <class 'float'>
  ```

  - f5 的值是 120000，但是它依然是小数类型，而不是整数类型。

  -  f6中`12.3*0.1`的计算结果很明显是 1.23，但是 print 的输出却不精确。这是因为小数在内存中是以二进制形式存储的，小数点后面的部分在转换成二进制时很有可能是一串无限循环的数字，无论如何都不能精确表示，所以小数的计算结果一般都是不精确的

  - 为什么在计算这么简单的问题上，计算机会出现这样的低级错误呢？真正的原因在于十进制和数和二进制数的转换。计算机其实是不认识十进制数，它只认识二进制数，也就是说，当我们以十进制数进行运算的时候，计算机需要将各个十进制数转换成二进制数，然后进行二进制间的计算。以类似 0.1 这样的浮点数为例，如果手动将其转换成二进制，其结果为：

    ```
    0.1(10)=0.00011001100110011...(2)
    ```

    - 可以看到，结果是无限循环的，也就是说，0.1 转换成二进制数后，无法精确到等于十进制数的 0.1。同时，由于计算机存储的位数是有限制的，所以如果要存储的二进制位数超过了计算机存储位数的最大值，其后续位数会被舍弃（舍弃的原则是“0 舍 1 入”）。	

- 如果需要非常精确的结果，可以使用 decimal 模块（其实就是别人开发好的程序，我们可以直接拿来用），它实现的十进制数运算适合会计方面的应用和有高精度要求的应用

  ```python
  #使用模块前，需要使用 import 引入
  import decimal
  a = decimal.Decimal("10.0")
  b = decimal.Decimal("3")
  print(10.0/3)
  print(a/b)
  
  3.3333333333333335
  3.333333333333333333333333333
  ```

- 如果 decimal 模块还是无法满足需求，还可以使用 fractions 模块

  ```python
  #引入 decimal 模块
  from fractions import Fraction
  print(10/3)
  print(Fraction(10,3))
  
  3.3333333333333335
  10/3
  ```

  

##### 复数

- 复数（Complex）是 [Python](http://c.biancheng.net/python/) 的内置类型，直接书写即可。换句话说，Python 语言本身就支持复数，而不依赖于标准库或者第三方库。
- 复数由实部（real）和虚部（imag）构成，在 Python 中，复数的虚部以`j`或者`J`作为后缀，具体格式为：a + bj，a 表示实部，b 表示虚部。

```python
c1 = 12 + 0.2j
print("c1Value: ", c1)
print("c1Type", type(c1))
c2 = 6 - 1.2j
print("c2Value: ", c2)
#对复数进行简单计算
print("c1+c2: ", c1+c2)
print("c1*c2: ", c1*c2)

c1Value:  (12+0.2j)
c1Type <class 'complex'>
c2Value:  (6-1.2j)
c1+c2:  (18-1j)
c1*c2:  (72.24-13.2j)
```

- 复数在 Python 内部的类型是 complex，Python 默认支持对复数的简单计算。

##### 字符串

- Python中的字符串必须由双引号`" "`或者单引号`' '`包围

- Python 字符串中的双引号和单引号没有任何区别。而有些编程语言的双引号字符串可以解析变量，单引号字符串一律原样输出，例如 [PHP](http://c.biancheng.net/php/) 和 [JavaScript](http://c.biancheng.net/js/)。

- 字符串中对引号的处理有两种方案

  - 对引号进行转义，在引号前面添加反斜杠`\`就可以对引号进行转义，让 Python 把它作为普通文本对待
  - 使用不同的引号包围字符串。如果字符串内容中出现了单引号，那么我们可以使用双引号包围字符串，反之亦然

- 字符串的换行。Python 不是格式自由的语言，它对程序的换行、缩进都有严格的语法要求。要想换行书写一个比较长的字符串，必须在行尾添加反斜杠`\`

  ```
  s2 = 'It took me six months to write this Python tutorial. \
      Please give me more support. \
      I will keep it updated.'
  ```

  - 上面 s2 字符串的比较长，所以使用了转义字符`\`对字符串内容进行了换行，这样就可以把一个长字符串写成多行。

  - Python 也支持表达式的换行

    ```
    num = 20 + 3 / 4 + \
        2 * 3
    print(num)
    ```

- 长字符串。使用三个单引号或者双引号可以对多行内容进行注释，这其实是 Python 长字符串的写法。所谓长字符串，就是可以直接换行（不用加反斜杠`\`）书写的字符串。Python 长字符串由三个双引号`"""`或者三个单引号`'''`包围。在长字符串中放置单引号或者双引号不会导致解析错误。如果长字符串没有赋值给任何变量，那么这个长字符串就不会起到任何作用，和一段普通的文本无异，相当于被注释掉了。此时 Python 解释器并不会忽略长字符串，也会按照语法解析，只是长字符串起不到实际作用而已。当程序中有大段文本内容需要定义成字符串时，优先推荐使用长字符串形式，因为这种形式非常强大，可以在字符串中放置任何内容，包括单引号和双引号。长字符串中的换行、空格、缩进等空白符都会原样输出

  ```python
  longstr = '''
      It took me 6 months to write this Python tutorial.
      Please give me a to 'thumb' to keep it updated.
      The Python tutorial is available at http://c.biancheng.net/python/.
  '''
  print(longstr)
  
  
      It took me 6 months to write this Python tutorial.
      Please give me a to 'thumb' to keep it updated.
      The Python tutorial is available at http://c.biancheng.net/python/.
   
   字符串内容前后多出了两个空行，并且每一行的前面会多出四个空格。
  
  ```

- 原始字符串。Python 字符串中的反斜杠`\`有着特殊的作用，就是转义字符。转义字符有时候会带来一些麻烦，例如我要表示一个包含 Windows 路径`D:\Program Files\Python 3.8\python.exe`这样的字符串，在 Python 程序中直接这样写肯定是不行的，不管是普通字符串还是长字符串。因为`\`的特殊性，我们需要对字符串中的每个`\`都进行转义，也就是写成`D:\\Program Files\\Python 3.8\\python.exe\`这种形式才行。这种写法需要特别谨慎，稍有疏忽就会出错。为了解决转义字符的问题，Python 支持原始字符串。在原始字符串中，`\`不会被当作转义字符，所有的内容都保持“原汁原味”的样子。

  - 在普通字符串或者长字符串的开头加上`r`前缀，就变成了原始字符串

    ```
    str1 = r'原始字符串内容'
    str2 = r"""原始字符串内容"""
    
    rstr = r'D:\Program Files\Python 3.8\python.exe'
    print(rstr)
    ```

  - 如果普通格式的原始字符串中出现引号，程序同样需要对引号进行转义，否则 Python 照样无法对字符串的引号精确配对；但是和普通字符串不同的是，此时用于转义的反斜杠会变成字符串内容的一部分。

    ```
    str1 = r'I\'m a great coder!'
    print(str1)
    
    I\'m a great coder!
    ```

    - 需要注意的是，Python 原始字符串中的反斜杠仍然会对引号进行转义，因此原始字符串的结尾处不能是反斜杠，否则字符串结尾处的引号会被转义，导致字符串不能正确结束。

  - 在 Python 中有两种方式解决原始字符串中\这个问题：一种方式是改用长字符串的写法，不要使用原始字符串；另一种方式是单独书写反斜杠

    - 例如想表示`D:\Program Files\Python 3.8\`，可以这样写：

      ```
      str1 = r'D:\Program Files\Python 3.8' '\\'
      print(str1)
      
      我们先写了一个原始字符串r'D:\Program Files\Python 3.8'，紧接着又使用'\\'写了一个包含转义字符的普通字符串，Python 会自动将这两个字符串拼接在一起
      D:\Program Files\Python 3.8\
      ```

##### bytes

- bytes 类型用来表示一个字节串。“字节串“不是编程术语，是我自己“捏造”的一个词，用来和字符串相呼应。

- 字节串（bytes）和字符串（string）的对比：

  - 字符串由若干个字符组成，以字符为单位进行操作；字节串由若干个字节组成，以字节为单位进行操作。
  - 字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法都基本相同。
  - 字节串和字符串都是不可变序列，不能随意增加和删除数据。

- bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。说白了，bytes 只是简单地记录内存中的原始数据，至于如何使用这些数据，bytes 并不在意，你想怎么使用就怎么使用，bytes 并不约束你的行为。bytes 类型的数据非常适合在互联网上传输，可以用于网络通信编程；bytes 也可以用来存储图片、音频、视频等二进制格式的文件。

- 字符串和 bytes 存在着千丝万缕的联系，我们可以通过字符串来创建 bytes 对象，或者说将字符串转换成 bytes 对象。有以下三种方法可以达到这个目的：

  - 如果字符串的内容都是 ASCII 字符，那么直接在字符串前面添加`b`前缀就可以转换成 bytes。
  - bytes 是一个类，调用它的构造方法，也就是 bytes()，可以将字符串按照指定的字符集转换成 bytes；如果不指定字符集，那么默认采用 UTF-8。
  - 字符串本身有一个 encode() 方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8。

  ```
  #通过构造函数创建空 bytes
  b1 = bytes()
  #通过空字符串创建空 bytes
  b2 = b''
  #通过b前缀将字符串转换成 bytes
  b3 = b'http://c.biancheng.net/python/'
  print("b3: ", b3)
  print(b3[3])
  print(b3[7:22])
  #为 bytes() 方法指定字符集
  b4 = bytes('C语言中文网8岁了', encoding='UTF-8')
  print("b4: ", b4)
  #通过 encode() 方法将字符串转换成 bytes
  b5 = "C语言中文网8岁了".encode('UTF-8')
  print("b5: ", b5)
  
  
  b3:  b'http://c.biancheng.net/python/'
  112
  b'c.biancheng.net'
  b4:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
  b5:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
  ```

  - 从运行结果可以发现，对于非 ASCII 字符，print 输出的是它的字符编码值（十六进制形式），而不是字符本身。非 ASCII 字符一般占用两个字节以上的内存，而 bytes 是按照单个字节来处理数据的，所以不能一次处理多个字节。

- bytes 类也有一个 decode() 方法，通过该方法可以将 bytes 对象转换为字符串

  ```
  #通过 decode() 方法将 bytes 转换成字符串
  str1 = b5.decode('UTF-8')
  print("str1: ", str1)
  
  str1:  C语言中文网8岁了
  ```

##### bool

- True 和 False 是 Python 中的关键字，当作为 Python 代码输入时，一定要注意字母的大小写，否则解释器会报错。

- 布尔类型可以当做整数来对待，即 True 相当于整数值 1，False 相当于整数值 0。

  ```
  >>> False+1
  1
  >>> True+1
  2
  ```

- 在 Python 中，所有的对象都可以进行真假值的测试，包括字符串、元组、列表、字典、对象等

##### input()函数

- input() 是 [Python](http://c.biancheng.net/python/) 的内置函数，用于从控制台读取用户输入的内容。input() 函数总是以字符串的形式来处理用户输入的内容，所以用户输入的内容可以包含任何字符。

  ```
  str = input(tipmsg)
  ```

  - str 表示一个字符串类型的变量，input 会将读取到的字符串放入 str 中。
  - tipmsg 表示提示信息，它会显示在控制台上，告诉用户应该输入什么样的内容；如果不写 tipmsg，就不会有任何提示信息。

- 我们可以使用 Python 内置函数将字符串转换成想要的类型，比如：

  - int(string) 将字符串转换成 int 类型；
  - float(string) 将字符串转换成 float 类型；
  - bool(string) 将字符串转换成 bool 类型。

##### print

- print() 函数完全可以同时输出多个变量

- print() 函数的详细语法格式如下：

  ```
  print (value,...,sep='',end='\n',file=sys.stdout,flush=False)
  ```

  - value 参数可以接受任意多个变量或值，因此 print() 函数完全可以输出多个值

    ```
    user_name ＝ 'Charlie'
    user_age = 8
    #同时输出多个变量和字符串
    print("读者名：",user_name,"年龄：",user_age)
    
    读者名： Charlie 年龄： 8
    ```

  - 从输出结果来看，使用 print() 函数输出多个变量时，print() 函数默认以空格隔开多个变量，如果读者希望改变默认的分隔符，可通过 sep 参数进行设置。例如输出语句：

    ```
    #同时输出多个变量和字符串，指定分隔符
    print("读者名：" ,user_name,"年龄：",user_age,sep='|')
    
    读者名：|Charlie|年龄：|8
    ```

  - 在默认情况下，print() 函数输出之后总会换行，这是因为 print() 函数的 end 参数的默认值是“\n”，这个“\n”就代表了换行。如果希望 print() 函数输出之后不会换行，则重设 end 参数即可

    ```
    #设置end 参数，指定输出之后不再换行
    print(40,'\t',end＝"")
    print(5O,'\t',end＝"")
    print(60,'\t',end＝"")
    
    40    50    60
    ```

  - file 参数指定 print() 函数的输出目标，file 参数的默认值为 sys.stdout，该默认值代表了系统标准输出，也就是屏幕，因此 print() 函数默认输出到屏幕。实际上，完全可以通过改变该参数让 print() 函数输出到特定文件中

    ```
    f = open("demo.txt","w")#打开文件以便写入
    print('沧海月明珠有泪',file=f)
    print('蓝回日暖玉生烟',file=f)
    f.close()
    ```

  - print() 函数的 flush 参数用于控制输出缓存，该参数一般保持为 False 即可，这样可以获得较好的性能。
  
- print() 函数使用以`%`开头的转换说明符对各种类型的数据进行格式化输出

  | 转换说明符 | 解释                                   |
  | ---------- | -------------------------------------- |
  | %d、%i     | 转换为带符号的十进制整数               |
  | %o         | 转换为带符号的八进制整数               |
  | %x、%X     | 转换为带符号的十六进制整数             |
  | %e         | 转化为科学计数法表示的浮点数（e 小写） |
  | %E         | 转化为科学计数法表示的浮点数（E 大写） |
  | %f、%F     | 转化为十进制浮点数                     |
  | %g         | 智能选择使用 %f 或 %e 格式             |
  | %G         | 智能选择使用 %F 或 %E 格式             |
  | %c         | 格式化字符及其 ASCII 码                |
  | %r         | 使用 repr() 函数将表达式转换为字符串   |
  | %s         | 使用 str() 函数将表达式转换为字符串    |

  ```
  age = 8
  print("C语言中文网已经%d岁了！" % age)
  
  输出结果  C语言中文网已经8岁了！
  在 print() 函数中，由引号包围的是格式化字符串，它相当于一个字符串模板，可以放置一些转换说明符（占位符）。本例的格式化字符串中包含一个%d说明符，它最终会被后面的 age 变量的值所替代。中间的%是一个分隔符，它前面是格式化字符串，后面是要输出的表达式。
  
  格式化字符串中也可以包含多个转换说明符，这个时候也得提供多个表达式，用以替换对应的转换说明符；多个表达式必须使用小括号( )包围起来。
  name = "C语言中文网"
  age = 8
  url = "http://c.biancheng.net/"
  print("%s已经%d岁了，它的网址是%s。" % (name, age, url))
  
  C语言中文网已经8岁了，它的网址是http://c.biancheng.net/。
  
  如果没有中间的%分割就会出错，另外如果没有% ，两个中间有逗号分隔输出结果为  C语言中文网已经%d岁了！ 8
  ```

- 指定最小输出宽度

  - %10d 表示输出的整数宽度至少为 10；

  - %20s 表示输出的字符串宽度至少为 20。

    ```
    n = 1234567
    print("n(10):%10d." % n)
    print("n(5):%5d." % n)
    url = "http://c.biancheng.net/python/"
    print("url(35):%35s." % url)
    print("url(20):%20s." % url)
    
    n(10):   1234567.
    n(5):1234567.
    url(35):     http://c.biancheng.net/python/.
    url(20):http://c.biancheng.net/python/.
    ```

  - 从运行结果可以发现，对于整数和字符串，当数据的实际宽度小于指定宽度时，会在左侧以空格补齐；当数据的实际宽度大于指定宽度时，会按照数据的实际宽度输出。

- 指定对齐方式

  - 默认情况下，print() 输出的数据总是右对齐的。也就是说，当数据不够宽时，数据总是靠右边输出，而在左边补充空格以达到指定的宽度。Python 允许在最小宽度之前增加一个标志来改变对齐方式

    | 标志 | 说明                                               |
    | ---- | -------------------------------------------------- |
    | -    | 指定左对齐                                         |
    | +    | 表示输出的数字总要带着符号；正数带`+`，负数带`-`。 |
    | 0    | 表示宽度不足时补充 0，而不是补充空格。             |

    - 对于整数，指定左对齐时，在右边补 0 是没有效果的，因为这样会改变整数的值。
    - 对于小数，以上三个标志可以同时存在。
    - 对于字符串，只能使用`-`标志，因为符号对于字符串没有意义，而补 0 会改变字符串的值。

    ```
    n = 123456
    # %09d 表示最小宽度为9，左边补0
    print("n(09):%09d" % n)
    # %+9d 表示最小宽度为9，带上符号
    print("n(+9):%+9d" % n)
    f = 140.5
    # %-+010f 表示最小宽度为10，左对齐，带上符号
    print("f(-+0):%-+010f" % f)
    s = "Hello"
    # %-10s 表示最小宽度为10，左对齐
    print("s(-10):%-10s." % s)
    
    n(09):000123456
    n(+9):  +123456
    f(-+0):+140.500000
    s(-10):Hello     .
    ```

- 指定小数精度

  - 对于小数（浮点数），print() 还允许指定小数点后的数字位数，也即指定小数的输出精度。

  - 精度值需要放在最小宽度之后，中间用点号`.`隔开；也可以不写最小宽度，只写精度。具体格式如下：

    ```
    %m.nf
    %.nf
    
    m 表示最小宽度，n 表示输出精度，.是必须存在的。
    
    f = 3.141592653
    # 最小宽度为8，小数点后保留3位
    print("%8.3f" % f)
    # 最小宽度为8，小数点后保留3位，左边补0
    print("%08.3f" % f)
    # 最小宽度为8，小数点后保留3位，左边补0，带符号
    print("%+08.3f" % f)
    
       3.142
    0003.142
    +003.142
    ```

    

##### 转义字符

- 转义字符，就是那些以反斜杠`\`开头的字符。

- ASCII 编码为每个字符都分配了唯一的编号，称为编码值。在 [Python](http://c.biancheng.net/python/) 中，一个 ASCII 字符除了可以用它的实体（也就是真正的字符）表示，还可以用它的编码值表示。这种使用编码值来间接地表示字符的方式称为转义字符（Escape Character）。

- 转义字符以`\0`或者`\x`开头，以`\0`开头表示后跟八进制形式的编码值，以`\x`开头表示后跟十六进制形式的编码值，Python 中的转义字符只能使用八进制或者十六进制。

  ```
  \0dd
  \xhh
  ```

  - dd 表示八进制数字，hh 表示十六进制数字。

- ASCII 编码共收录了 128 个字符，`\0`和`\x`后面最多只能跟两位数字，所以八进制形式`\0`并不能表示所有的 ASCII 字符，只有十六进制形式`\x`才能表示所有 ASCII 字符。

- 字符 1、2、3、x、y、z 对应的 ASCII 码的八进制形式分别是 61、62、63、170、171、172，十六进制形式分别是 31、32、33、78、79、7A。下面的例子演示了转义字符的用法：使用八进制形式的转义字符没法表示 xyz，因为它们的编码值转换成八进制以后有三位。

  ```python
  str1 = "Oct: \061\062\063"
  str2 = "Hex: \x31\x32\x33\x78\x79\x7A"
  print(str1)
  print(str2)
  
  Oct: 123
  Hex: 123xyz
  ```

- 对于 ASCII 编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能用转义字符的形式来表示。不过，直接使用 ASCII 码记忆不方便，也不容易理解，所以，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下。

  | 转义字符 | 说明                                                         |
  | -------- | ------------------------------------------------------------ |
  | \n       | 换行符，将光标位置移到下一行开头。                           |
  | \r       | 回车符，将光标位置移到本行开头。                             |
  | \t       | 水平制表符，也即 Tab 键，一般相当于四个空格。                |
  | \a       | 蜂鸣器响铃。注意不是喇叭发声，现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效。 |
  | \b       | 退格（Backspace），将光标位置移到前一列。                    |
  | \\\      | 反斜线                                                       |
  | \\'      | 单引号                                                       |
  | \\"      | 双引号                                                       |
  | \\       | 在字符串行尾的续行符，即一行未完，转到下一行继续写。         |

```python
#使用\t排版
str1 = '网站\t\t域名\t\t\t年龄\t\t价值'
str2 = 'C语言中文网\tc.biancheng.net\t\t8\t\t500W'
str3 = '百度\t\twww.baidu.com\t\t20\t\t500000W'
print(str1)
print(str2)
print(str3)
print("--------------------")
# \n在输出时换行，\在书写字符串时换行
info = "Python教程：http://c.biancheng.net/python/\n\
C++教程：http://c.biancheng.net/cplus/\n\
Linux教程：http://c.biancheng.net/linux_tutorial/"
print(info)

网站        域名                年龄    价值
C语言中文网 c.biancheng.net     8       500W
百度        www.baidu.com       20      500000W
--------------------
Python教程：http://c.biancheng.net/python/
C++教程：http://c.biancheng.net/cplus/
Linux教程：http://c.biancheng.net/linux_tutorial/
```

##### 数据类型转换

- 虽然 [Python](http://c.biancheng.net/python/) 是弱类型编程语言，不需要像 [Java](http://c.biancheng.net/java/) 或 C 语言那样还要在使用变量前声明变量的类型，但在一些特定场景中，仍然需要用到类型转换。

  | 函 数                  | 作 用                                              |
  | ---------------------- | -------------------------------------------------- |
  | int(x)                 | 将 x 转换成整数类型                                |
  | float(x)               | 将 x 转换成浮点数类型                              |
  | complex(real，[,imag]) | 创建一个复数                                       |
  | str(x)                 | 将 x 转换为字符串                                  |
  | repr(x)                | 将 x 转换为表达式字符串                            |
  | eval(str)              | 计算在字符串中的有效 Python 表达式，并返回一个对象 |
  | chr(x)                 | 将整数 x 转换为一个字符                            |
  | ord(x)                 | 将一个字符 x 转换为它对应的整数值                  |
  | hex(x)                 | 将一个整数 x 转换为一个十六进制字符串              |
  | oct(x)                 | 将一个整数 x 转换为一个八进制的字符串              |

- 需要注意的是，在使用类型转换函数时，提供给它的数据必须是有意义的。例如，int() 函数无法将一个非数字字符串转换成整数

  ```
  >>> int("123") #转换成功
  123
  >>> int("123个") #转换失败
  Traceback (most recent call last):
    File "<pyshell#3>", line 1, in <module>
      int("123个")
  ValueError: invalid literal for int() with base 10: '123个'
  ```

##### 运算符

###### 算数运算符

| 运算符 | 说明                                | 实例        | 结果      |
| ------ | ----------------------------------- | ----------- | --------- |
| +      | 加                                  | 12.45 + 15  | 27.45     |
| -      | 减                                  | 4.56 - 0.26 | 4.3       |
| *      | 乘                                  | 5 * 3.6     | 18.0      |
| /      | 除法（和数学中的规则一样）          | 7 / 2       | 3.5       |
| //     | 整除（只保留商的整数部分）          | 7 // 2      | 3         |
| %      | 取余，即返回除法的余数              | 7 % 2       | 1         |
| **     | 幂运算/次方运算，即返回 x 的 y 次方 | 2 ** 4      | 16，即 24 |

- 当`+`用于数字时表示加法，但是当`+`用于字符串时，它还有拼接字符串（将两个字符串连接为一个）的作用

  ```
  name = "C语言中文网"
  url = "http://c.biancheng.net/"
  age = 8
  info = name + "的网址是" + url + "，它已经" + str(age) + "岁了。"
  print(info)
  ```

  - str() 函数用来将整数类型的 age 转换成字符串。

- `*`除了可以用作乘法运算，还可以用来重复字符串，也即将 n 个同样的字符串连接起来

  ```
  str1 = "hello "
  print(str1 * 4)
  
  hello hello hello hello 
  ```

- Python 支持`/`和`//`两个除法运算符，但它们之间是有区别的：

  - `/`表示普通除法，使用它计算出来的结果和数学中的计算结果相同。
  - `//`表示整除，只保留结果的整数部分，舍弃小数部分；注意是直接丢掉小数部分，而不是四舍五入。
  - `/`的计算结果总是小数，不管是否能除尽，也不管参与运算的是整数还是小数。
  - 当有小数参与运算时，`//`结果才是小数，否则就是整数。
  - 除数始终不能为 0，除以 0 是没有意义的，这将导致 ZeroDivisionError 错误

- Python ** 运算符用来求一个 x 的 y 次方，也即次方（乘方）运算符。由于开方是次方的逆运算，所以也可以使用 ** 运算符间接地实现开方运算。

  ```
  print('----次方运算----')
  print('3**4 =', 3**4)
  print('2**5 =', 2**5)
  print('----开方运算----')
  print('81**(1/4) =', 81**(1/4))
  print('32**(1/5) =', 32**(1/5))
  ```

###### 赋值运算符

- 连续赋值，Python 中的赋值表达式也是有值的，它的值就是被赋的那个值，或者说是左侧变量的值；如果将赋值表达式的值再赋值给另外一个变量，这就构成了连续赋值。

  ```
  a = b = c = 100
  ```

  - `=`具有右结合性，我们从右到左分析这个表达式：
    - c = 100 表示将 100 赋值给 c，所以 c 的值是 100；同时，c = 100 这个子表达式的值也是 100。
    - b = c = 100 表示将 c = 100 的值赋给 b，因此 b 的值也是 100。
    - 以此类推，a 的值也是 100。

  | 运算符 | 说 明            | 用法举例 | 等价形式                              |
  | ------ | ---------------- | -------- | ------------------------------------- |
  | =      | 最基本的赋值运算 | x = y    | x = y                                 |
  | +=     | 加赋值           | x += y   | x = x + y                             |
  | -=     | 减赋值           | x -= y   | x = x - y                             |
  | *=     | 乘赋值           | x *= y   | x = x * y                             |
  | /=     | 除赋值           | x /= y   | x = x / y                             |
  | %=     | 取余数赋值       | x %= y   | x = x % y                             |
  | **=    | 幂赋值           | x **= y  | x = x ** y                            |
  | //=    | 取整数赋值       | x //= y  | x = x // y                            |
  | &=     | 按位与赋值       | x &= y   | x = x & y                             |
  | \|=    | 按位或赋值       | x \|= y  | x = x \| y                            |
  | ^=     | 按位异或赋值     | x ^= y   | x = x ^ y                             |
  | <<=    | 左移赋值         | x <<= y  | x = x << y，这里的 y 指的是左移的位数 |
  | >>=    | 右移赋值         | x >>= y  | x = x >> y，这里的 y 指的是右移的位数 |

###### 位运算符

- [Python](http://c.biancheng.net/python/) 位运算按照数据在内存中的二进制位（Bit）进行操作，它一般用于底层开发（算法设计、驱动、图像处理、单片机等），在应用层开发（Web 开发、Linux 运维等）中并不常见。

  | 位运算符 | 说明     | 使用形式 | 举 例                            |
  | -------- | -------- | -------- | -------------------------------- |
  | &        | 按位与   | a & b    | 4 & 5                            |
  | \|       | 按位或   | a \| b   | 4 \| 5                           |
  | ^        | 按位异或 | a ^ b    | 4 ^ 5                            |
  | ~        | 按位取反 | ~a       | ~4                               |
  | <<       | 按位左移 | a << b   | 4 << 2，表示整数 4 按位左移 2 位 |
  | >>       | 按位右移 | a >> b   | 4 >> 2，表示整数 4 按位右移 2 位 |

- Python 左移运算符`<<`用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补 0。
- Python 右移运算符`>>`用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。

###### 比较运算符

| 比较运算符 | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| >          | 大于，如果`>`前面的值大于后面的值，则返回 True，否则返回 False。 |
| <          | 小于，如果`<`前面的值小于后面的值，则返回 True，否则返回 False。 |
| ==         | 等于，如果`==`两边的值相等，则返回 True，否则返回 False。    |
| >=         | 大于等于（等价于数学中的 ≥），如果`>=`前面的值大于或者等于后面的值，则返回 True，否则返回 False。 |
| <=         | 小于等于（等价于数学中的 ≤），如果`<=`前面的值小于或者等于后面的值，则返回 True，否则返回 False。 |
| !=         | 不等于（等价于数学中的 ≠），如果`!=`两边的值不相等，则返回 True，否则返回 False。 |
| is         | 判断两个变量所引用的对象是否相同，如果相同则返回 True，否则返回 False。 |
| is not     | 判断两个变量所引用的对象是否不相同，如果不相同则返回 True，否则返回 False。 |

- 初学 Python，大家可能对 is 比较陌生，很多人会误将它和 == 的功能混为一谈，但其实 is 与 == 有本质上的区别，完全不是一码事儿。== 用来比较两个变量的值是否相等，而 is 则用来比对两个变量引用的是否是同一个对象

  ```
  import time  #引入time模块
  t1 = time.gmtime() # gmtime()用来获取当前时间
  t2 =  time.gmtime()
  print(t1 == t2) #输出True
  print(t1 is t2) #输出False
  
  True
  False
  ```

  - time 模块的 gmtime() 方法用来获取当前的系统时间，精确到秒级，因为程序运行非常快，所以 t1 和 t1 得到的时间是一样的。== 用来判断 t1 和 t2 的值是否相等，所以返回 True。
  - 虽然 t1 和 t2 的值相等，但它们是两个不同的对象（每次调用 gmtime() 都返回不同的对象），所以`t1 is t2`返回 False。这就好像两个双胞胎姐妹，虽然她们的外貌是一样的，但它们是两个人。
  - 那么，如何判断两个对象是否相同呢？答案是判断两个对象的内存地址。如果内存地址相同，说明两个对象使用的是同一块内存，当然就是同一个对象了；这就像两个名字使用了同一个身体，当然就是同一个人了。

###### 逻辑运算符

| 逻辑运算符 | 含义                           | 基本格式 | 说明                                                         |
| ---------- | ------------------------------ | -------- | ------------------------------------------------------------ |
| and        | 逻辑与运算，等价于数学中的“且” | a and b  | 当 a 和 b 两个表达式都为真时，a and b 的结果才为真，否则为假。 |
| or         | 逻辑或运算，等价于数学中的“或” | a or b   | 当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。 |
| not        | 逻辑非运算，等价于数学中的“非” | not a    | 如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。 |

- 有些不负责任的 Python 教程说：Python 逻辑运算符用于操作 bool 类型的表达式，执行结果也是 bool 类型，这两点其实都是错误的！Python 逻辑运算符可以用来操作任何类型的表达式，不管表达式是不是 bool 类型；同时，逻辑运算的结果也不一定是 bool 类型，它也可以是任意类型。

  ```
  print(100 and 200)
  print(45 and 0)
  print("" or "http://c.biancheng.net/python/")
  print(18.5 or "http://c.biancheng.net/python/")
  
  200
  0
  http://c.biancheng.net/python/
  18.5
  ```

  - 在 Python 中，and 和 or 不一定会计算右边表达式的值，有时候只计算左边表达式的值就能得到最终结果。
  - 另外，and 和 or 运算符会将其中一个表达式的值作为最终结果，而不是将 True 或者 False 作为最终结果。

- 对于 and 运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 Python 按照下面的规则执行 and 运算：

  - 如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时 and 会把左边表达式的值作为最终结果。
  - 如果左边表达式的值为真，那么最终值是不能确定的，and 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

- 对于 or 运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以 Python 按照下面的规则执行 or 运算：

  - 如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时 or 会把左边表达式的值作为最终结果。
  - 如果左边表达式的值为假，那么最终值是不能确定的，or 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

###### 三目运算符

- 假设现在有两个数字，我们希望获得其中较大的一个，那么可以使用 if else 语句

  ```
  if a>b:
      max = a;
  else:
      max = b;
  
  但是 Python 提供了一种更加简洁的写法
  max = a if a>b else b
  ```

  - 这是一种类似于其它编程语言中三目运算符`? :`的写法。Python 是一种极简主义的编程语言，它没有引入`? :`这个新的运算符，而是使用已有的 if else 关键字来实现相同的功能。

- 使用 if else 实现三目运算符（条件运算符）的格式如下：

  ```
  exp1 if contion else exp2
  ```

  - condition 是判断条件，exp1 和 exp2 是两个表达式。如果 condition 成立（结果为真），就执行 exp1，并把 exp1 的结果作为整个表达式的结果；如果 condition 不成立（结果为假），就执行 exp2，并把 exp2 的结果作为整个表达式的结果。

- 前面的语句`max = a if a>b else b`的含义是：

  - 如果 a>b 成立，就把 a 作为整个表达式的值，并赋给变量 max；
  - 如果 a> b 不成立，就把 b 作为整个表达式的值，并赋给变量 max。

- Python 三目运算符支持嵌套，如此可以构成更加复杂的表达式。在嵌套时需要注意 if 和 else 的配对

  ```
  a if a>b else c if c>d else d
  应该理解为：
  a if a>b else ( c if c>d else d )
  ```

###### 运算符优先级和结合性

| 运算符说明 | Python运算符            | 优先级 | 结合性 | 优先级顺序 |
| ---------- | ----------------------- | ------ | ------ | ---------- |
| 小括号     | ( )                     | 19     | 无     | 最高       |
| 索引运算符 | x[i] 或 x[i1: i2 [:i3]] | 18     | 左     |            |
| 属性访问   | x.attribute             | 17     | 左     |            |
| 乘方       | **                      | 16     | 右     |            |
| 按位取反   | ~                       | 15     | 右     |            |
| 符号运算符 | +（正号）、-（负号）    | 14     | 右     |            |
| 乘除       | *、/、//、%             | 13     | 左     |            |
| 加减       | +、-                    | 12     | 左     |            |
| 位移       | >>、<<                  | 11     | 左     |            |
| 按位与     | &                       | 10     | 右     |            |
| 按位异或   | ^                       | 9      | 左     |            |
| 按位或     | \|                      | 8      | 左     |            |
| 比较运算符 | ==、!=、>、>=、<、<=    | 7      | 左     |            |
| is 运算符  | is、is not              | 6      | 左     |            |
| in 运算符  | in、not in              | 5      | 左     |            |
| 逻辑非     | not                     | 4      | 右     |            |
| 逻辑与     | and                     | 3      | 左     |            |
| 逻辑或     | or                      | 2      | 左     |            |
| 逗号运算符 | exp1, exp2              | 1      | 左     | 最低       |

- 所谓结合性，就是当一个表达式中出现多个优先级相同的运算符时，先执行哪个运算符：先执行左边的叫左结合性，先执行右边的叫右结合性。
- 例如对于表达式对于`100 / 25 * 16`，`/`和`*`的优先级相同，应该先执行哪一个呢？这个时候就不能只依赖运算符优先级决定了，还要参考运算符的结合性。`/`和`*`都具有左结合性，因此先执行左边的除法，再执行右边的乘法，最终结果是 64。
- Python 中大部分运算符都具有左结合性，也就是从左到右执行；只有 ** 乘方运算符、单目运算符（例如 not 逻辑非运算符）、赋值运算符和三目运算符例外，它们具有右结合性，也就是从右向左执行
- 当一个表达式中出现多个运算符时，Python 会先比较各个运算符的优先级，按照优先级从高到低的顺序依次执行；当遇到优先级相同的运算符时，再根据结合性决定先执行哪个运算符：如果是左结合性就先执行左边的运算符，如果是右结合性就先执行右边的运算符。

#### 列表、元组、字典、集合

- Python 序列（Sequence）是指按特定顺序依次排列的一组数据，它们可以占用一块连续的内存，也可以分散到多块内存中。Python 中的序列类型包括列表（list）、元组（tuple）、字典（dict）和集合（set）。
- 在 Python 编程中，我们既需要独立的变量来保存一份数据，也需要序列来保存大量数据。
- 列表（list）和元组（tuple）比较相似，它们都按顺序保存元素，所有的元素占用一块连续的内存，每个元素都有自己的索引，因此列表和元组的元素都可以通过索引（index）来访问。它们的区别在于：列表是可以修改的，而元组是不可修改的。
- 字典（dict）和集合（set）存储的数据都是无序的，每份元素占用不同的内存，其中字典元素以 `key-value` 的形式保存。

##### 序列

- 所谓序列，指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可通过每个值所在位置的编号（称为索引）访问它们。
- 在 [Python](http://c.biancheng.net/python/) 中，序列类型包括字符串、列表、元组、集合和字典，这些序列支持以下几种通用的操作，但比较特殊的是，集合和字典不支持索引、切片、相加和相乘操作。
- 字符串也是一种常见的序列，它也可以直接通过索引访问字符串内的字符。

###### 序列索引

- 序列中，每个元素都有属于自己的编号（索引）。从起始元素开始，索引值从 0 开始递增
- Python 还支持索引值是负数，此类索引是从右向左计数，换句话说，从最后一个元素开始计数，从索引值 -1 开始。在使用负值作为列序中各元素的索引值时，是从 -1 开始，而不是从 0 开始。

###### 序列切片

- 切片操作是访问序列中元素的另一种方法，它可以访问一定范围内的元素，通过切片操作，可以生成一个新的序列。

- 序列实现切片操作的语法格式如下：

  ```
  sname[start : end : step]
  ```

  - sname：表示序列的名称；

  - start：表示切片的开始索引位置（包括该位置），此参数也可以不指定，会默认为 0，也就是从序列的开头进行切片；

  - end：表示切片的结束索引位置（不包括该位置），如果不指定，则默认为序列的长度；

  - step：表示在切片过程中，隔几个存储位置（包含当前位置）取一次元素，也就是说，如果 step 的值大于 1，则在进行切片去序列元素时，会“跳跃式”的取元素。如果省略设置 step 的值，则最后一个冒号就可以省略。

    ```
    str="C语言中文网"
    #取索引区间为[0,2]之间（不包括索引2处的字符）的字符串
    print(str[:2])
    #隔 1 个字符取一个字符，区间是整个字符串
    print(str[::2])
    #取整个字符串，此时 [] 中只需一个冒号即可
    print(str[:])
    ```

###### 序列相加

- Python 中，支持两种类型相同的序列使用“+”运算符做相加操作，它会将两个序列进行连接，但不会去除重复的元素。这里所说的“类型相同”，指的是“+”运算符的两侧序列要么都是列表类型，要么都是元组类型，要么都是字符串。

###### 序列相乘

- Python 中，使用数字 n 乘以一个序列会生成新的序列，其内容为原来序列被重复 n 次的结果

- 比较特殊的是，列表类型在进行乘法运算时，还可以实现初始化指定长度列表的功能。例如如下的代码，将创建一个长度为 5 的列表，列表中的每个元素都是 None，表示什么都没有。

  ```
  #列表的创建用 []，后续讲解列表时会详细介绍
  list = [None]*5
  print(list)
  
  [None, None, None, None, None]
  ```

###### 检查元素是否包含在序列中

- Python 中，可以使用 in 关键字检查某元素是否为序列的成员

  ```
  value in sequence
  ```

  - value 表示要检查的元素，sequence 表示指定的序列。

  - 例如，检查字符‘c’是否包含在字符串“c.biancheng.net”中

    ```
    str="c.biancheng.net"
    print('c'in str)
    
    True
    ```

- 和 in 关键字用法相同，但功能恰好相反的，还有 not in 关键字，它用来检查某个元素是否不包含在指定的序列中

###### 内置函数

| 函数        | 功能                                                         |
| ----------- | ------------------------------------------------------------ |
| len()       | 计算序列的长度，即返回序列中包含多少个元素。                 |
| max()       | 找出序列中的最大元素。注意，对序列使用 sum() 函数时，做加和操作的必须都是数字，不能是字符或字符串，否则该函数将抛出异常，因为解释器无法判定是要做连接操作（+ 运算符可以连接两个序列），还是做加和操作。 |
| min()       | 找出序列中的最小元素。                                       |
| list()      | 将序列转换为列表。                                           |
| str()       | 将序列转换为字符串。                                         |
| sum()       | 计算元素和。                                                 |
| sorted()    | 对元素进行排序。                                             |
| reversed()  | 反向序列中的元素。                                           |
| enumerate() | 将序列组合为一个索引序列，多用在 for 循环中。                |

##### 列表

- [Python](http://c.biancheng.net/python/) 中没有数组，但是加入了更加强大的列表。如果把数组看做是一个集装箱，那么 Python 的列表就是一个工厂的仓库。

- 从形式上看，列表会将所有元素都放在一对中括号`[ ]`里面，相邻元素之间用逗号`,`分隔

- 从内容上看，列表可以存储整数、小数、字符串、列表、元组等任何类型的数据，并且同一个列表中元素的类型也可以不同

  ```
  ["http://c.biancheng.net/python/", 1, [2,3,4] , 3.0]
  ```

  - 列表中同时包含字符串、整数、列表、浮点数这些数据类型。

- 在使用列表时，虽然可以将不同类型的数据放入到同一个列表中，但通常情况下不这么做，同一列表中只放入同一类型的数据，这样可以提高程序的可读性。

- 在其它 Python 教程中，经常用 list 代指列表，这是因为列表的数据类型就是 list，通过 type() 函数就可以知道

###### 创建列表

- 使用[]直接创建列表

- 使用list()函数创建列表，内置的函数 list()，使用它可以将其它数据类型转换为列表类型

  ```python
  #将字符串转换成列表
  list1 = list("hello")
  print(list1)
  #将元组转换成列表
  tuple1 = ('Python', 'Java', 'C++', 'JavaScript')
  list2 = list(tuple1)
  print(list2)
  #将字典转换成列表
  dict1 = {'a':100, 'b':42, 'c':9}
  list3 = list(dict1)
  print(list3)
  #将区间转换成列表
  range1 = range(1, 6)
  list4 = list(range1)
  print(list4)
  #创建空列表
  print(list())
  ```

- 访问列表元素使用索引或者切片
- 删除列表，对于已经创建的列表，如果不再使用，可以使用`del`关键字将其删除。实际开发中并不经常使用 del 来删除列表，因为 Python 自带的垃圾回收机制会自动销毁无用的列表，即使开发者不手动删除，Python 也会自动将其回收。

###### 列表添加元素

- 使用`+`运算符可以将多个序列连接起来；列表是序列的一种，所以也可以使用`+`进行连接，这样就相当于在第一个列表的末尾添加了另一个列表。`+`更多的是用来拼接列表，而且执行效率并不高

- append() 方法用于在列表的末尾追加元素

  ```
  listname.append(obj)
  ```

  - obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等

    ```
    l = ['Python', 'C++', 'Java']
    #追加元素
    l.append('PHP')
    print(l)
    #追加元组，整个元组被当成一个元素
    t = ('JavaScript', 'C#', 'Go')
    l.append(t)
    print(l)
    #追加列表，整个列表也被当成一个元素
    l.append(['Ruby', 'SQL'])
    print(l)
    
    ['Python', 'C++', 'Java', 'PHP']
    ['Python', 'C++', 'Java', 'PHP', ('JavaScript', 'C#', 'Go')]
    ['Python', 'C++', 'Java', 'PHP', ('JavaScript', 'C#', 'Go'), ['Ruby', 'SQL']]
    ```

  - 当给 append() 方法传递列表或者元组时，此方法会将它们视为一个整体，作为一个元素添加到列表中，从而形成包含列表和元组的新列表

- extend()方法添加元素。extend() 和 append() 的不同之处在于：extend() 不会把列表或者元祖视为一个整体，而是把它们包含的元素逐个添加到列表中。

  ```
  listname.extend(obj)
  ```

  - obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等，但不能是单个的数字

- insert()方法插入元素。append() 和 extend() 方法只能在列表末尾插入元素，如果希望在列表中间某个位置插入元素，那么可以使用 insert() 方法。

  ```
  listname.insert(index , obj)
  ```

  - index 表示指定位置的索引值。insert() 会将 obj 插入到 listname 列表第 index 个元素的位置。
  - 当插入列表或者元祖时，insert() 也会将它们视为一个整体，作为一个元素插入到列表中，这一点和 append() 是一样的。

###### 删除元素

- 在 [Python](http://c.biancheng.net/python/) 列表中删除元素主要分为以下 3 种场景：

  - 根据目标元素所在位置的索引进行删除，可以使用 del 关键字或者 pop() 方法；
  - 根据元素本身的值进行删除，可使用列表（list类型）提供的 remove() 方法；
  - 将列表中所有元素全部删除，可使用列表（list类型）提供的 clear() 方法。

- del根据索引值删除元素

  - del 是 Python 中的关键字，专门用来执行删除操作，它不仅可以删除整个列表，还可以删除列表中的某些元素

  - del 可以删除列表中的单个元素

    ```
    del listname[index]
    ```

  - del 也可以删除中间一段连续的元素

    ```
    del listname[start : end]
    del 会删除从索引 start 到 end 之间的元素，不包括 end 位置的元素。
    ```

- pop()根据索引值删除元素

  - pop() 方法用来删除列表中指定索引处的元素

    ```
    listname.pop(index)
    ```

    - index 表示索引值。如果不写 index 参数，默认会删除列表中的最后一个元素，类似于[数据结构](http://c.biancheng.net/data_structure/)中的“出栈”操作。

  - 大部分编程语言都会提供和 pop() 相对应的方法，就是 push()，该方法用来将元素添加到列表的尾部，类似于数据结构中的“入栈”操作。但是 Python 是个例外，Python 并没有提供 push() 方法，因为完全可以使用 append() 来代替 push() 的功能。

- remove()根据元素值进行删除

  - 除了 del 关键字，Python 还提供了 remove() 方法，该方法会根据元素本身的值来进行删除操作。
  - remove() 方法只会删除第一个和指定值相同的元素，而且必须保证该元素是存在的，否则会引发 ValueError 错误。所以我们在使用 remove() 删除元素时最好提前判断一下。

- clear()删除列表所有元素

###### 修改元素

- 提供了两种修改列表（list）元素的方法，你可以每次修改单个元素，也可以每次修改一组元素（多个）。

- 修改单个元素非常简单，直接对元素赋值即可

  ```
  nums = [40, 36, 89, 2, 36, 100, 7]
  nums[2] = -26  #使用正数索引
  nums[-3] = -66.2  #使用负数索引
  print(nums)
  
  [40, 36, -26, 2, -66.2, 100, 7]
  ```

  - 使用索引得到列表元素后，通过`=`赋值就改变了元素的值。

- Python 支持通过切片语法给一组元素赋值。在进行这种操作时，如果不指定步长（step 参数），Python 就不要求新赋值的元素个数与原来的元素个数相同；这意味，该操作既可以为列表添加元素，也可以为列表删除元素。

  ```
  修改一组元素的值
  nums = [40, 36, 89, 2, 36, 100, 7]
  #修改第 1~4 个元素的值（不包括第4个元素）
  nums[1: 4] = [45.25, -77, -52.5]
  print(nums)
  [40, 45.25, -77, -52.5, 36, 100, 7]
  
  
  如果对空切片（slice）赋值，就相当于插入一组新的元素：
  nums = [40, 36, 89, 2, 36, 100, 7]
  #在4个位置插入元素
  nums[4: 4] = [-77, -52.5, 999]
  print(nums)
  [40, 36, 89, 2, -77, -52.5, 999, 36, 100, 7]
  
  使用切片语法赋值时，Python 不支持单个值，例如下面的写法就是错误的：
  nums[4: 4] = -77
  
  但是如果使用字符串赋值，Python 会自动把字符串转换成序列，其中的每个字符都是一个元素
  s = list("Hello")
  s[2:4] = "XYZ"
  print(s)
  ['H', 'e', 'X', 'Y', 'Z', 'o']
  ```

- 使用切片语法时也可以指定步长（step 参数），但这个时候就要求所赋值的新元素的个数与原有元素的个数相同

  ```
  nums = [40, 36, 89, 2, 36, 100, 7]
  #步长为2，为第1、3、5个元素赋值
  nums[1: 6: 2] = [0.025, -99, 20.5]
  print(nums)
  [40, 0.025, 89, -99, 36, 20.5, 7]
  ```

###### 查找元素

- 提供了 index() 和 count() 方法，它们都可以用来查找元素。

- index() 方法用来查找某个元素在列表中出现的位置（也就是索引），如果该元素不存在，则会导致 ValueError 错误，所以在查找之前最好使用 count() 方法判断一下。

  ```
  listname.index(obj, start, end)
  ```

  - start 和 end 参数用来指定检索范围：
    - start 和 end 可以都不写，此时会检索整个列表；
    - 如果只写 start 不写 end，那么表示检索从 start 到末尾的元素；
    - 如果 start 和 end 都写，那么表示检索 start 和 end 之间的元素。
  - index() 方法会返回元素所在列表中的索引值。

- count() 方法用来统计某个元素在列表中出现的次数

  ```
  listname.count(obj)
  ```

  - 如果 count() 返回 0，就表示列表中不存在该元素，所以 count() 也可以用来判断列表中的某个元素是否存在。
