### STL基础

- STL，英文全称 s[tan](http://c.biancheng.net/ref/tan.html)dard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。

- C++ 对模板（Template）支持得很好，STL 就是借助模板把常用的[数据结构](http://data.biancheng.net/)及其算法都实现了一遍，并且做到了数据结构和算法的分离。例如，vector 的底层为顺序表（数组），list 的底层为双向链表，deque 的底层为循环队列，set 的底层为红黑树，hash_set 的底层为哈希表。

- 从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和[数据结构](http://c.biancheng.net/data_structure/)的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等

- 泛型，实质上就是不使用具体数据类型（例如 int、double、float 等），而是使用一种通用类型来进行程序设计的方法，该方法可以大规模的减少程序代码的编写量，让程序员可以集中精力用于业务逻辑的实现。

- 通常认为，[STL](http://c.biancheng.net/stl/) 是由容器、算法、迭代器、函数对象、适配器、内存分配器这 6 部分构成，其中后面 4 部分是为前 2 部分服务的

  | STL的组成  | 含义                                                         |
  | ---------- | ------------------------------------------------------------ |
  | 容器       | 一些封装[数据结构](http://c.biancheng.net/data_structure/)的模板类，例如 vector 向量容器、list 列表容器等。 |
  | 算法       | STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 <algorithm> 中，少部分位于头文件 <numeric> 中。 |
  | 迭代器     | 在 [C++](http://c.biancheng.net/cplus/) STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。 |
  | 函数对象   | 如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。 |
  | 适配器     | 可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。 |
  | 内存分配器 | 为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。 |

- 按照 C++ 标准库的规定，所有标准头文件都不再有扩展名。以 <vector> 为例，此为无扩展名的形式，而 <vector.h> 为有扩展名的形式。但是，或许是为了向下兼容，或许是为了内部组织规划，某些 STL 版本同时存储具备扩展名和无扩展名的两份文件

- 学习 C++ 标准库，特别是 STL，经常需要考量算法和成员函数的效能（也就是运行效率，又称复杂度），因此每个学习 STL 的读者都需要掌握一种衡量算法（或成员函数）复杂度的方法，目前最常用的方法称为大 O 表示法（注意，不是数字 0，而是字母 O）。

- 使用大 O 表示法衡量某个算法的复杂度，其实就是将该算法的运行时间用输入量为 n 的函数表示出来。这里的输入量 n 在 STL 中通常指的是算法操作的元素个数。举个例子，当算法运行时间随元素个数成线性增长时（即如果元素个数呈倍数增长，运行时间也呈倍数增长），该算法的复杂度用 O(n) 来表示；反之，如果算法的运行时间和输入量 n 无关，则该算法的复杂度就用 O(1) 来表示。

- 值得注意的是，大 O 表示法并不关心算法运行所消耗的具体时间，换句话说，对于那些影响算法运行效率较小的因素，使用大 O 表示法表示时会直接将其忽略。例如，某个算法运行的复杂度为 O(n)，呈线性增长，但至于线性增长的具体程度（是 100n 还是 2n），在大 O 表示法看来，它们是一样的。也就是说，采用这种测量法则，任何两个线性算法都将被视为具有相同的复杂度。采用大 O 表示法甚至会出现这种一种情况，即带有巨大常量的线性算法，很有可能会比小常量的指数算法更受欢迎，因为该方法无法显示出真实的运行时间。所以请读者记住，大 O 表示法只是某种度量方法，它所显示的算法的最佳复杂度，并不一定就是真正的最佳（最快）算法。

### STL序列式容器

- 序列式容器，包括 array、vector、deque、list 和 forward_list 容器。

- 所谓STL序列式容器，其共同的特点是不会对存储的元素进行排序，元素排列的顺序取决于存储它们的顺序。

- 简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。STL 提供有 3 类标准容器，分别是序列容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器

  | 容器种类 | 功能                                                         |
  | :------- | ------------------------------------------------------------ |
  | 序列容器 | 主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。 |
  | 排序容器 | 包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。 |
  | 哈希容器 | [C++](http://c.biancheng.net/cplus/) 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。 |

##### 迭代器

- [迭代器](https://www.cnblogs.com/wengle520/p/12492708.html)，包括迭代器的原理和实现，可以看一看很好。

- STL通过类型别名的方式实现了对外统一；在不同的容器中类型别名的真实迭代器类型是不一样的，而且真实迭代器类型对于++、--、*、->等基本操作的实现方式也是不同的。（PS：迭代器很好地诠释了接口与实现分离的意义）

- 迭代器就是类里面有一个内部类，来实现迭代器的功能（对数据元素进行读写），里面重载了一些符号，来让迭代器对数据的访问形式对外是一样的。

- 为了提高C++编程的效率，STL（Standard Template Library）中提供了许多容器，包括vector、list、map、set等。然而有些容器（vector）可以通过下标索引的方式访问容器里面的数据，但是大部分的容器（list、map、set）不能使用这种方式访问容器中的元素。为了统一访问不同容器时的访问方式，STL为每种容器在实现的时候设计了一个内嵌的iterator类，不同的容器有自己专属的迭代器（专属迭代器负责实现对应容器访问元素的具体细节），使用迭代器来访问容器中的数据。除此之外，通过迭代器可以将容器和通用算法结合在一起，只要给予算法不同的迭代器，就可以对不同容器执行相同的操作，例如find查找函数（因为迭代器提供了统一的访问方式，这是使用迭代器带来的好处）。迭代器对一些基本操作如*、->、++、==、!=、=进行了重载，使其具有了遍历复杂数据结构的能力，其遍历机制取决于所遍历的容器，所有迭代器的使用和指针的使用非常相似。通过begin，end函数获取容器的头部和尾部迭代器，end迭代器不包含在容器之内，当begin和end返回的迭代器相同时表示容器为空。

- 无论是序列容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器（iterator）”来实现。那么，迭代器到底是什么呢？我们知道，尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 [C++](http://c.biancheng.net/cplus/) 的[指针](http://c.biancheng.net/c/80/)非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。

- 例如你有一个简单的查找容器中最小值的函数findMin，如果没有迭代器，那么你就必须定义适用于数组版本的findMin和适用于链表版本的findMin，如果以后有更多容器需要使用findMin，那就只好继续添加重载……而如果每个容器又需要更多的函数例如findMax，sort，那简直就是重载地狱……。如果我们将这些遍历容器的操作都封装成迭代器，那么诸如findMin一类的算法就都可以针对迭代器编程而不是针对具体容器编程，工作量一下子就少了很多！

- STL标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。

- 常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。

  - 前向迭代器（forward iterator）
    假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。
  - 双向迭代器（bidirectional iterator）
    双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 --p 或者 p-- 操作（即一次向后移动一个位置）。
  - 随机访问迭代器（random access iterator）
    随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：
    - p+=i：使得 p 往后移动 i 个元素。
    - p-=i：使得 p 往前移动 i 个元素。
    - p+i：返回 p 后面第 i 个元素的迭代器。
    - p-i：返回 p 前面第 i 个元素的迭代器。
    - p[i]：返回 p 后面第 i 个元素的引用。
  - 随机访问迭代器还可以用 <、>、<=、>= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。

  | 容器                               | 对应的迭代器类型 |
  | ---------------------------------- | ---------------- |
  | array                              | 随机访问迭代器   |
  | vector                             | 随机访问迭代器   |
  | deque                              | 随机访问迭代器   |
  | list                               | 双向迭代器       |
  | set / multiset                     | 双向迭代器       |
  | map / multimap                     | 双向迭代器       |
  | forward_list                       | 前向迭代器       |
  | unordered_map / unordered_multimap | 前向迭代器       |
  | unordered_set / unordered_multiset | 前向迭代器       |
  | stack                              | 不支持迭代器     |
  | queue                              | 不支持迭代器     |
  - 容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。

- 尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种

  | 迭代器定义方式 | 具体格式                                   |
  | -------------- | ------------------------------------------ |
  | 正向迭代器     | 容器类名::iterator 迭代器名;               |
  | 常量正向迭代器 | 容器类名::const_iterator 迭代器名;         |
  | 反向迭代器     | 容器类名::reverse_iterator 迭代器名;       |
  | 常量反向迭代器 | 容器类名::const_reverse_iterator 迭代器名; |
  - 每一个容器里面都有迭代器，迭代器就是一个嵌套类，类名就是上面这四个，但是每个迭代器的功能和操作不一样，上面的随机，双向迭代器就是他的类型，代表了不同的功能，其只是一个标识，区分不同的迭代器有什么操作和功能。
  - 前向，双向迭代器不支持用“<”进行比较，但是可以用==和!=比较

##### 序列式容器

- 所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。
- array<T,N>（数组容器）：表示可以存储 N 个 T 类型的元素，是 [C++](http://c.biancheng.net/cplus/) 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；
- vector<T>（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；
- deque<T>（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；
- list<T>（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。
- forward_list<T>（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。
- 注意，其实除此之外，stack<T> 和 queue<T> 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器。

##### array

- array 容器是 [C++](http://c.biancheng.net/cplus/) 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。

- array 容器配备了随机访问迭代器

- array 容器以类模板的形式定义在 <array> 头文件，并位于命名空间 std 中

  ```
  namespace std{
      template <typename T, size_t N>
      class array;
  }
  ```

  - 在 array<T,N> 类模板中，T 用于指明容器中的存储的具体数据类型，N 用于指明容器的大小，需要注意的是，这里的 N 必须是常量，不能用变量表示。

###### 初始化

- 创建具有 10 个 double 类型元素的 array 容器

  ```
  std::array<double, 10> values;
  ```

  - 创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。

- 如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值

  ```
  std::array<double, 10> values {};
  ```

  - 使用该语句，容器中所有的元素都会被初始化为 0.0。

- 在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化

  ```
  std::array<double, 10> values {0.5,1.0,1.5,,2.0};
  ```

  - 这里只初始化了前 4 个元素，剩余的元素都会被初始化为 0.0。

##### vector

###### 创建vector容器

- 创建存储 double 类型元素的一个 vector 容器,这是一个空的 vector 容器，因为容器中没有元素，所以没有为其分配空间。当添加第一个元素（比如使用 push_back() 函数）时，vector 会自动分配内存。

  ```
  std::vector<double> values;
  ```

  - 在创建好空容器的基础上，还可以像下面这样通过调用 reserve() 成员函数来增加容器的容量

  ```
  values.reserve(20);
  ```

  - 这样就设置了容器的内存分配，即至少可以容纳 20 个元素。注意，如果 vector 的容量在执行此语句之前，已经大于或等于 20 个元素，那么这条语句什么也不做；另外，调用 reserve() 不会影响已存储的元素，也不会生成任何元素，即 values 容器内此时仍然没有任何元素。
  - 如果调用 reserve() 来增加容器容量，之前创建好的任何迭代器（例如开始迭代器和结束迭代器）都可能会失效，这是因为，为了增加容器的容量，vector<T> 容器的元素可能已经被复制或移到了新的内存地址。所以后续再使用这些迭代器时，最好重新生成一下。

- 除了创建空 vector 容器外，还可以在创建的同时指定初始值以及元素个数

  ```
  std::vector<int> primes {2, 3, 5, 7, 11, 13, 17, 19};
  ```

- 在创建 vector 容器时，也可以指定元素个数

  ```
  std::vector<double> values(20);
  ```

  - values 容器开始时就有 20 个元素，它们的默认初始值都为 0。

  - 圆括号 () 和大括号 {} 是有区别的，前者（例如 (20) ）表示元素的个数，而后者（例如 {20} ） 则表示 vector 容器中只有一个元素 20。

  - 如果不想用 0 作为默认值，也可以指定一个其它值

    ```
    std::vector<double> values(20, 1.0);
    第二个参数指定了所有元素的初始值，因此这 20 个元素的值都是 1.0。
    ```

  - 圆括号 () 中的 2 个参数，既可以是常量，也可以用变量来表示

    ```
    int num=20;
    double value =1.0;
    std::vector<double> values(num, value);
    ```

- 通过存储元素类型相同的其它 vector 容器，也可以创建新的 vector 容器

  ```
  std::vector<char>value1(5, 'c');
  std::vector<char>value2(value1);
  ```

  - value2 容器中也具有 5 个字符 'c'。在此基础上，如果不想复制其它容器中所有的元素，可以用一对[指针](http://c.biancheng.net/c/80/)或者迭代器来指定初始值的范围

    ```
    int array[]={1,2,3};
    std::vector<int>values(array, array+2);//values 将保存{1,2}
    std::vector<int>value1{1,2,3,4,5};
    std::vector<int>value2(std::begin(value1),std::begin(value1)+3);//value2保存{1,2,3}
    ```

- C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 vector 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。

- vector 容器还有一个 std::swap(x , y) 非成员函数（其中 x 和 y 是存储相同类型元素的 vector 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。

###### vector迭代器

- vector 容器的迭代器也是随机访问迭代器
- 和 array 容器不同，vector 容器可以随着存储元素的增加，自行申请更多的存储空间。因此，在创建 vector 对象时，我们可以直接创建一个空的 vector 容器，并不会影响后续使用该容器。但这会产生一个问题，即在初始化空的 vector 容器时，不能使用迭代器
- 对于空的 vector 容器来说，begin() 和 end() 成员函数返回的迭代器是相等的
- 对于空的 vector 容器来说，可以通过调用 push_back() 或者借助 resize() 成员函数实现初始化容器的目的。
- vector 容器在申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。

###### vector访问元素

- `容器名[n]`这种获取元素的方式，需要确保下标 n 的值不会超过容器的容量（可以通过 capacity() 成员函数获取），否则会发生越界访问的错误。幸运的是，和 array 容器一样，vector 容器也提供了 at() 成员函数，当传给 at() 的索引会造成越界时，会抛出`std::out_of_range`异常。
- vector 容器还提供了 2 个成员函数，即 front() 和 back()，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用这 2 个函数返回的引用，可以访问（甚至修改）容器中的首尾元素。
- vector 容器还提供了 data() 成员函数，该函数的功能是返回指向容器中首个元素的[指针](http://c.biancheng.net/c/80/)。通过该指针也可以访问甚至修改容器中的元素
- 如果想访问 vector 容器中多个元素，可以借助 size() 成员函数，该函数可以返回 vector 容器中实际存储的元素个数。这里不要使用 capacity() 成员函数，因为它返回的是 vector 容器的容量，而不是实际存储元素的个数，这两者是有差别的。

###### vector容量(ca'pacity)和大小(size)区别

- vector 容器的容量（用 capacity 表示），指的是在不分配更多内存的情况下，容器可以保存的最多元素个数；而 vector 容器的大小（用 size 表示），指的是它实际所包含的元素个数。

- 对于一个 vector 对象来说，通过该模板类提供的 capacity() 成员函数，可以获得当前容器的容量；通过 size() 成员函数，可以获得容器当前的大小

- 当 vector 容器的大小和容量相等时，如果再向其添加（或者插入）一个元素，vector 往往会申请多个存储空间，而不仅仅只申请 1 个。

- 一旦 vector 容器的内存被重新分配，则和 vector 容器中元素相关的所有引用、指针以及迭代器，都可能会失效，最稳妥的方法就是重新生成。

- 可以调用 reserve() 成员函数来增加容器的容量（但并不会改变存储元素的个数）；而通过调用成员函数 resize() 可以改变容器的大小，并且该函数也可能会导致 vector 容器容量的增加

- 仅通过 reserve() 成员函数增加 value 容器的容量，其大小并没有改变；但通过 resize() 成员函数改变 value 容器的大小，它的容量可能会发生改变。另外需要注意的是，通过 resize() 成员函数减少容器的大小（多余的元素会直接被删除），不会影响容器的容量。

- resize增加大小时，增加的会默认初始化

- 在实际场景中，我们可能需要将容器的容量和大小保存在变量中，要知道 vector<T> 对象的容量和大小类型都是 vector<T>::size_type 类型。因此，当定义一个变量去保存这些值时

  ```
  vector<int>::size_type cap = value.capacity();
  vector<int>::size_type size = value.size();
  ```

  - size_type 类型是定义在由 vector 类模板生成的 vecotr 类中的，它表示的真实类型和操作系统有关，在 32 位架构下普遍表示的是 unsigned int 类型，而在 64 位架构下普通表示 unsigned long 类型。

  - 我们还可以使用 auto 关键字代替 vector<int>::size_type

    ```
    auto cap = value.capacity();
    auto size = value.size();
    ```

###### vector添加元素

- 向 vector 容器中添加元素的唯一方式就是使用它的成员函数，如果不调用成员函数，非成员函数既不能添加也不能删除元素。这意味着，vector 容器对象必须通过它所允许的函数去访问，迭代器显然不行。

- 迭代器只是访问已有的，可以读取和修改，新添加的肯定不能用迭代器访问。

- emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。

  ```c++
  为了让大家清楚的了解它们之间的区别，我们创建一个包含类对象的 vector 容器
  
  class testDemo
  {
  public:
      testDemo(int num):num(num){
          std::cout << "调用构造函数" << endl;
      }
      testDemo(const testDemo& other) :num(other.num) {
          std::cout << "调用拷贝构造函数" << endl;
      }
      testDemo(testDemo&& other) :num(other.num) {
          std::cout << "调用移动构造函数" << endl;
      }
  private:
      int num;
  };
  int main()
  {
      cout << "emplace_back:" << endl;
      std::vector<testDemo> demo1;
      demo1.emplace_back(2);  
      cout << "push_back:" << endl;
      std::vector<testDemo> demo2;
      demo2.push_back(2);
  }
  
  emplace_back:
  调用构造函数
  push_back:
  调用构造函数
  调用移动构造函数
  
  在此基础上，读者可尝试将 testDemo 类中的移动构造函数注释掉，再运行程序会发现，运行结果变为：
  emplace_back:
  调用构造函数
  push_back:
  调用构造函数
  调用拷贝构造函数
  ```

  - push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。
  - 显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议大家优先选用 emplace_back()。
  - 由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。

###### vector插入元素

- insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种

  | 语法格式                        | 用法说明                                                     |
  | ------------------------------- | ------------------------------------------------------------ |
  | iterator insert(pos,elem)       | 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 |
  | iterator insert(pos,n,elem)     | 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 |
  | iterator insert(pos,first,last) | 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 |
  | iterator insert(pos,initlist)   | 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 |

```
std::vector<int> demo{1,2};
    //第一种格式用法
    demo.insert(demo.begin() + 1, 3);//{1,3,2}
    //第二种格式用法
    demo.insert(demo.end(), 2, 5);//{1,3,2,5,5}
    //第三种格式用法
    std::array<int,3>test{ 7,8,9 };
    demo.insert(demo.end(), test.begin(), test.end());//{1,3,2,5,5,7,8,9}
    //第四种格式用法
    demo.insert(demo.end(), { 10,11 });//{1,3,2,5,5,7,8,9,10,11}
```

- emplace() 是 [C++](http://c.biancheng.net/cplus/) 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。emplace() 每次只能插入一个元素，而不是多个。

  ```
  iterator emplace (const_iterator pos, args...);
  ```

  - pos 为指定插入位置的迭代器；args... 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。

  - 简单的理解 args...，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。

    ```
    std::vector<int> demo1{1,2};
    //emplace() 每次只能插入一个 int 类型元素
    demo1.emplace(demo1.begin(), 3);
    3表示int是3，如果插入的是构造函数，这个位置要写传入构造函数的形参值，可以有多个。
    ```

- 当拷贝构造函数和移动构造函数同时存在时，insert() 会优先调用移动构造函数。通过 insert() 函数向 vector 容器中插入 testDemo 类对象，需要调用类的构造函数和移动构造函数（或拷贝构造函数）；而通过 emplace() 函数实现同样的功能，只需要调用构造函数即可。

- 简单的理解，就是 emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐大家优先使用 emplace()。

###### vector删除元素

- 无论是向现有 vector 容器中访问元素、添加元素还是插入元素，都只能借助 vector 模板类提供的成员函数，但删除 vector 容器的元素例外，完成此操作除了可以借助本身提供的成员函数，还可以借助一些全局函数。基于不同场景的需要，删除 vecotr 容器的元素，可以使用表 1 中所示的函数（或者函数组合）。

  | 函数                  | 功能                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | pop_back()            | 删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。成员函数 |
  | erase(pos)            | 删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。成员函数 |
  | swap(beg)、pop_back() | 先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。swap全局函数 |
  | erase(beg,end)        | 删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。 |
  | remove()              | 删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。全局函数，vector中是全局函数，list中有remove成员函数 |
  | clear()               | 删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。成员函数 |

- erase() 函数在删除元素时，会将删除位置后续的元素陆续前移，并将容器的大小减 1。

- 如果不在意容器中元素的排列顺序，可以结合 swap() 和 pop_back() 函数，同样可以实现删除容器中指定位置元素的目的。swap() 函数在头文件 `<algorithm>` 和 `<utility>` 中都有定义，使用时引入其中一个即可。

  ```
  	vector<int>demo{ 1,2,3,4,5 };
      //交换要删除元素和最后一个元素的位置
      swap(*(std::begin(demo)+1),*(std::end(demo)-1));//等同于 swap(demo[1],demo[4])
      demo.pop_back();
  ```

- 如果要删除容器中和指定元素值相同的所有元素，可以使用 remove() 函数，该函数定义在 `<algorithm>` 头文件中

  ```
  	vector<int>demo{ 1,3,3,4,3,5 };
      //交换要删除元素和最后一个元素的位置
      auto iter = std::remove(demo.begin(), demo.end(), 3);
  	cout << "size is :" << demo.size() << endl;
      cout << "capacity is :" << demo.capacity() << endl;
      //输出剩余的元素
      for (auto first = demo.begin(); first < iter;++first) {
          cout << *first << " ";
      }
      
  size is :6
  capacity is :6
  1 4 5
  ```

  - 在对容器执行完 remove() 函数之后，由于该函数并没有改变容器原来的大小和容量，因此无法使用之前的方法遍历容器，而是需要向程序中那样，借助 remove() 返回的迭代器完成正确的遍历。

  - remove() 的实现原理是，在遍历容器中的元素时，一旦遇到目标元素，就做上标记，然后继续遍历，直到找到一个非目标元素，即用此元素将最先做标记的位置覆盖掉，同时将此非目标元素所在的位置也做上标记，等待找到新的非目标元素将其覆盖。因此，如果将上面程序中 demo 容器的元素全部输出，得到的结果为 `1 4 5 4 3 5`。

  - remove算法并不会删除容器里的元素，而是将所有需要的元素放到容器开头，不需要的元素放到后面，最后返回的迭代器指向不需要的第一个元素。所以，上面的例子返回的迭代器指向第四个元素4，可以用erase删除此迭代器和尾迭代器之间的元素。

  - 既然通过 remove() 函数删除掉 demo 容器中的多个指定元素，该容器的大小和容量都没有改变，其剩余位置还保留了之前存储的元素。我们可以使用 erase() 成员函数删掉这些 "无用" 的元素。

    ```
    	vector<int>demo{ 1,3,3,4,3,5 };
        //交换要删除元素和最后一个元素的位置
        auto iter = std::remove(demo.begin(), demo.end(), 3);
        demo.erase(iter, demo.end());
        cout << "size is :" << demo.size() << endl;
        cout << "capacity is :" << demo.capacity() << endl;
        //输出剩余的元素
        for (int i = 0; i < demo.size();i++) {
            cout << demo[i] << " ";
        }
        remove()用于删除容器中指定元素时，常和 erase() 成员函数搭配使用。
    ```

###### vector避免不必要的扩容

- vector 容器的扩容过程是非常耗时的，并且当容器进行扩容后，之前和该容器相关的所有指针、迭代器以及引用都会失效。因此在使用 vector 容器过程中，我们应尽量避免执行不必要的扩容操作。

- 要实现这个目标，可以借助 vector 模板类中提供的 reserve() 成员方法。不过在讲解如何用 reserve() 方法避免 vector 容器进行不必要的扩容操作之前，vector 模板类中还提供有几个和 reserve() 功能类似的成员方法

  | 成员方法   | 功能                                                         |
  | ---------- | ------------------------------------------------------------ |
  | size()     | 告诉我们当前 vector 容器中已经存有多少个元素，但仅通过此方法，无法得知 vector 容器有多少存储空间。 |
  | capacity() | 告诉我们当前 vector 容器总共可以容纳多少个元素。如果想知道当前 vector 容器有多少未被使用的存储空间，可以通过 capacity()-size() 得知。注意，如果 size() 和 capacity() 返回的值相同，则表明当前 vector 容器中没有可用存储空间了，这意味着，下一次向 vector 容器中添加新元素，将导致 vector 容器扩容。 |
  | resize(n)  | 强制 vector 容器必须存储 n 个元素，注意，如果 n 比 size() 的返回值小，则容器尾部多出的元素将会被析构（删除）；如果 n 比 size() 大，则 vector 会借助默认构造函数创建出更多的默认值元素，并将它们存储到容器末尾；如果 n 比 capacity() 的返回值还要大，则 vector 会先扩增，在添加一些默认值元素。 |
  | reserve(n) | 强制 vector 容器的容量至少为 n。注意，如果 n 比当前 vector 容器的容量小，则该方法什么也不会做；反之如果 n 比当前 vector 容器的容量大，则 vector 容器就会扩容。 |

  - 只要有新元素要添加到 vector 容器中而恰好此时 vector 容器的容量不足时，该容器就会自动扩容。

- 避免 vector 容器执行不必要的扩容操作的关键在于，在使用 vector 容器初期，就要将其容量设为足够大的值。换句话说，在 vector 容器刚刚构造出来的那一刻，就应该借助 reserve() 成员方法为其扩充足够大的容量。
- 当然在实际场景中，我们可能并不知道 vector 容器到底要存储多少个元素。这种情况下，可以先预留出足够大的空间，当所有元素都存储到 vector 容器中之后，再去除多余的容量。
- 关于怎样去除 vector 容器多余的容量，可以借助该容器模板类提供的 shrink_to_fit() 成员方法，另外后续还会讲解如何使用 swap() 成员方法去除 vector 容器多余的容量，两种方法都可以。

###### 去除vector多余的容量

- 在使用 vector 容器的过程中，其容器会根据需要自行扩增。比如，使用 push_back()、insert()、emplace() 等成员方法向 vector 容器中添加新元素时，如果当前容器已满（即 size() == capacity()），则它会自行扩容以满足添加新元素的需求。当然，还可以调用 reserve() 成员方法来手动提升当前 vector 容器的容量。

- 除了可以添加元素外，vector 模板类中还提供了 pop_back()、erase()、clear() 等成员方法，可以轻松实现删除容器中已存储的元素。但需要注意得是，借助这些成员方法只能删除指定的元素，容器的容量并不会因此而改变。

- vector提供有一个 shrink_to_fit() 成员方法，该方法的功能是将当前 vector 容器的容量缩减至和实际存储元素的个数相等

- vector 模板类中还提供有 swap() 成员方法，该方法的基础功能是交换 2 个相同类型的 vector 容器（交换容量和存储的所有元素），但其也能用于去除 vector 容器多余的容量。

  ```
  vector<T>(x).swap(x);
  实例
  vector<int>(myvector).swap(myvector);
  ```

  - x 指当前要操作的容器，T 为该容器存储元素的类型。

  - 先执行 vector<int>(myvector)，此表达式会调用 vector 模板类中的拷贝构造函数，从而创建出一个临时的 vector 容器（后续称其为 tempvector）。vector 模板类中的拷贝构造函数只会为拷贝的元素分配存储空间。换句话说，tempvector 临时容器中没有空闲的存储空间，其容量等于存储元素的个数。

  - 然后借助 swap() 成员方法对 tempvector 临时容器和 myvector 容器进行调换，此过程不仅会交换 2 个容器存储的元素，还会交换它们的容量。换句话说经过 swap() 操作，myvetor 容器具有了 tempvector 临时容器存储的所有元素和容量，同时 tempvector 也具有了原 myvector 容器存储的所有元素和容量。值得一提的是，tempvector 临时容器并不为空，因为我们将 myvector 作为参数传递给了复制构造函数，该函数会将 myvector 容器中的所有元素拷贝一份，并存储到 tempvector 临时容器中。

  - 当整条语句执行结束时，临时的 tempvector 容器会被销毁，其占据的存储空间都会被释放。注意，这里释放的其实是原 myvector 容器占用的存储空间。

  - 当 swap() 成员方法用于清空 vector 容器时，可以套用如下的语法格式：

    ```
    vector<T>().swap(x);
    ```

###### 不要使用vector\<bool>

- 不推荐使用 vector<bool> 的原因有以下 2 个：
  1. 严格意义上讲，vector<bool> 并不是一个 STL 容器；
  2. vector<bool> 底层存储的并不是 bool 类型值。
- 实际上，为了节省空间，vector<bool> 底层在存储各个 bool 类型值时，每个 bool 值都只使用一个比特位（二进制位）来存储。也就是说在 vector<bool> 底层，一个字节可以存储 8 个 bool 类型值。在这种存储机制的影响下，operator[ ] 势必就需要返回一个指向单个比特位的引用，但显然这样的引用是不存在的。
- 如果在实际场景中需要使用 vector<bool> 这样的存储结构，该怎么办呢？很简单，可以选择使用 deque<bool> 或者 bitset 来替代 vector<bool>。
- deque 容器几乎具有 vecotr 容器全部的功能（拥有的成员方法也仅差 reserve() 和 capacity()），而且更重要的是，deque 容器可以正常存储 bool 类型元素。
- 还可以考虑用 bitset 代替 vector<bool>，其本质是一个模板类，可以看做是一种类似数组的存储结构。和后者一样，bitset 只能用来存储 bool 类型值，且底层存储机制也采用的是用一个比特位来存储一个 bool 值。
- 和 vector 容器不同的是，bitset 的大小在一开始就确定了，因此不支持插入和删除元素；另外 bitset 不是容器，所以不支持使用迭代器。

##### deque

- deque创建容器的方法和vector一样

- 和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。

- 和 array、vector 相同，[C++](http://c.biancheng.net/cplus/) 11 标准库新增的 begin() 和 end() 这 2 个全局函数也适用于 deque 容器。这 2 个函数的操作对象既可以是容器，也可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的[指针](http://c.biancheng.net/c/80/)，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。

- deque 容器还有一个`std::swap(x , y)` 非成员函数（其中 x 和 y 是存储相同类型元素的 deque 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。

- deque 容器迭代器的类型为随机访问迭代器

- 迭代器的功能是遍历容器，在遍历的同时可以访问（甚至修改）容器中的元素，但迭代器不能用来初始化空的 deque 容器。

  ```
  	vector<int>values;
      auto first = values.begin();
      //*first = 1;
      return 0;
      
      注释掉的语法是错误的，因为是空容器，没有元素，不能用迭代器来初始化，因为没有首元素，begin也不能返回首元素
  ```

- 当向 deque 容器添加元素时，deque 容器会申请更多的内存空间，同时其包含的所有元素可能会被复制或移动到新的内存地址（原来占用的内存会释放），这会导致之前创建的迭代器失效。

- 和 vector 容器不同，deque 容器没有提供 data() 成员函数，同时 deque 容器在存储元素时，也无法保证其会将元素存储在连续的内存空间中，因此尝试使用[指针](http://c.biancheng.net/c/80/)去访问 deque 容器中指定位置处的元素，是非常危险的。其余访问的形式和vector类似

- 插入和删除的形式和vector类似，只是多了在头部插入和删除，和头部emplace_front

##### list

- list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。
- list 容器中各个元素的前后顺序是靠[指针](http://c.biancheng.net/c/80/)来维系的，每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。其中第一个元素的前向指针总为 null，因为它前面没有元素；同样，尾部元素的后向指针也总为 null。
- 基于这样的存储结构，list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为`O(1)`）。并且在 list 容器中移动元素，也比其它容器的效率高。
- 使用 list 容器的缺点是，它不能像 array 和 vector 那样，通过位置直接访问元素。举个例子，如果要访问 list 容器中的第 6 个元素，它不支持`容器对象名[6]`这种语法格式，正确的做法是从容器中第一个元素或最后一个元素开始遍历容器，直到找到该位置。
- 实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。

###### list容器的创建

- 创建一个没有任何元素的空 list 容器：

  ```
  std::list<int> values;
  ```

  - 和空 array 容器不同，空的 list 容器在创建之后仍可以添加元素，因此创建 list 容器的方式很常用。

- 创建一个包含 n 个元素的 list 容器：

  ```
  std::list<int> values(10);
  ```

  - 通过此方式创建 values 容器，其中包含 10 个元素，每个元素的值都为相应类型的默认值（int类型的默认值为 0）。

- 创建一个包含 n 个元素的 list 容器，并为每个元素指定初始值

  ```
  std::list<int> values(10, 5);
  ```

  - 如此就创建了一个包含 10 个元素并且值都为 5 的 values 容器。

- 在已有 list 容器的情况下，通过拷贝该容器可以创建新的 list 容器

  ```
  std::list<int> value1(10);
  std::list<int> value2(value1);
  ```

  - 采用此方式，必须保证新旧容器存储的元素类型一致。

- 通过拷贝其他类型容器（或者普通数组）中指定区域内的元素，可以创建新的 list 容器

  ```
  //拷贝普通数组，创建list容器
  int a[] = { 1,2,3,4,5 };
  std::list<int> values(a, a+5);
  //拷贝其它类型的容器，创建 list 容器
  std::array<int, 5>arr{ 11,12,13,14,15 };
  std::list<int>values(arr.begin()+2, arr.end());//拷贝arr容器中的{13,14,15}
  ```

- [C++](http://c.biancheng.net/cplus/) 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 list 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。

- list 容器还有一个`std::swap(x , y)`非成员函数（其中 x 和 y 是存储相同类型元素的 list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。

- list中有成员函数sort()来进行容器中元素的排序

###### 迭代器

- 只有运用迭代器，才能访问 list 容器中存储的各个元素。
- 前面章节已经详细介绍了 array、vector、deque 容器的迭代器，和它们相比，list 容器迭代器最大的不同在于，其配备的迭代器类型为双向迭代器，而不再是随机访问迭代器。
- 这意味着，假设 p1 和 p2 都是双向迭代器，则它们支持使用 ++p1、 p1++、 p1--、 p1++、 *p1、 p1==p2 以及 p1!=p2 运算符，但不支持以下操作（其中 i 为整数）：
  - p1[i]：不能通过下标访问 list 容器中指定位置处的元素。
  - p1-=i、 p1+=i、 p1+i 、p1-i：双向迭代器 p1 不支持使用 -=、+=、+、- 运算符。
  - p1<p2、 p1>p2、 p1<=p2、 p1>=p2：双向迭代器 p1、p2 不支持使用 <、 >、 <=、 >= 比较运算符。

- 程序中比较迭代器之间的关系，用的是 != 运算符，因为它不支持 < 等运算符。另外在实际场景中，所有迭代器函数的返回值都可以传给使用 auto 关键字定义的变量，因为编译器可以自行判断出该迭代器的类型。
- 值得一提的是，list 容器在进行插入（insert()）、接合（splice()）等操作时，都不会造成原有的 list 迭代器失效，甚至进行删除操作，而只有指向被删除元素的迭代器失效，其他迭代器不受任何影响。

###### 访问元素

- 访问 list 容器中存储元素的方式很有限，即要么使用 front() 和 back() 成员函数，要么使用 list 容器迭代器。
- list 容器不支持随机访问，未提供下标操作符 [] 和 at() 成员函数，也没有提供 data() 成员函数。
- 对于修改容器指定元素的值，list 模板类提供有专门的成员函数 assign()

###### 添加元素

- list 模板类中，与“添加或插入新元素”相关的成员方法有如下几个：

  - push_front()：向 list 容器首个元素前添加新元素；
  - push_back()：向 list 容器最后一个元素后添加新元素；
  - emplace_front()：在容器首个元素前直接生成新的元素；
  - emplace_back()：在容器最后一个元素后直接生成新的元素；
  - emplace()：在容器的指定位置直接生成新的元素；
  - insert()：在指定位置插入新元素；
  - splice()：将其他 list 容器存储的多个元素添加到当前 list 容器的指定位置处。

- splice() 成员方法的作用对象是其它 list 容器，其功能是将其它 list 容器中的元素添加到当前 list 容器中指定位置处。

  | 语法格式                                                     | 功能                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | void splice (iterator position, list& x);                    | position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。 |
  | void splice (iterator position, list& x, iterator i);        | position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。 |
  | void splice (iterator position, list& x, iterator first, iterator last); | position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。 |

- list 容器底层使用的是链表存储结构，splice() 成员方法移动元素的方式是，将存储该元素的节点从 list 容器底层的链表中摘除，然后再链接到当前 list 容器底层的链表中。这意味着，当使用 splice() 成员方法将 x 容器中的元素添加到当前容器的同时，该元素会从 x 容器中删除。

###### empty和size的区别

- 模板类中都提供了 empty() 成员方法和 size() 成员方法，它们都可以用来判断容器是否为空。
- 建议使用 empty() 成员方法。理由很简单，无论是哪种容器，只要其模板类中提供了 empty() 成员方法，使用此方法都可以保证在 O(1) 时间复杂度内完成对“容器是否为空”的判断；但对于 list 容器来说，使用 size() 成员方法判断“容器是否为空”，可能要消耗 O(n) 的时间复杂度。
- 这个结论不仅适用于 vector、deque 和 list 容器，后续还会讲解更多容器的用法，该结论也依然适用。
- 为什么 list 容器这么特殊呢？这和 list 模板类提供了独有的 splice() 成员方法有关。由于 list 容器底层采用的是链式存储结构（也就是链表），该结构最大的特点就是，某一链表中存有元素的节点，无需经过拷贝就可以直接链接到其它链表中，且整个过程只需要消耗 O(1) 的时间复杂度。考虑到很多用户之所以选用 list 容器，就是看中了其底层存储结构的这一特性。因此，作为 list 容器设计者的我们，自然也想将 splice() 方法的时间复杂度设计为 O(1)。这里就产生了一个矛盾，即如果将 size() 设计为 O(1) 时间复杂度，则由于 splice() 成员方法会修改 list 容器存储元素的个数，因此该方法中就需要添加更新 size 变量的代码（更新方式无疑是通过遍历链表来实现），这也就意味着 splice() 成员方法的执行效率将无法达到 O(1)；反之，如果将 splice() 成员方法的执行效率提高到 O(1)，则 size() 成员方法将无法实现 O(1) 的时间复杂度。也就是说，list 容器中的 size() 和 splice() 总有一个要做出让步，即只能实现其中一个方法的执行效率达到 O(1)。值得一提的是，不同版本的 STL 标准库，其底层解决此冲突的抉择是不同的。以本教程所用的 C++ STL 标准模板库为例，其选择将 splice() 成员方法的执行效率达到 O(1)，而 size() 成员方法的执行效率为 O(n)。当然，有些版本的 STL 标准库中，选择将 size() 方法的执行效率设计为 O(1)。但不论怎样，选用 empty() 判断容器是否为空，效率总是最高的。所以，如果程序中需要判断当前容器是否为空，应优先考虑使用 empty()。

###### 删除元素

- 对 list 容器存储的元素执行删除操作，需要借助该容器模板类提供的成员函数。

  | 成员函数    | 功能                                                         |
  | ----------- | ------------------------------------------------------------ |
  | pop_front() | 删除位于 list 容器头部的一个元素。                           |
  | pop_back()  | 删除位于 list 容器尾部的一个元素。                           |
  | erase()     | 该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素。 |
  | clear()     | 删除 list 容器存储的所有元素。                               |
  | remove(val) | 删除容器中所有等于 val 的元素。                              |
  | unique()    | 删除容器中相邻的重复元素，只保留一份。                       |
  | remove_if() | 删除容器中满足条件的元素。                                   |

- unique() 函数有以下 2 种语法格式：

  ```
  void unique()
  void unique（BinaryPredicate）//传入一个二元谓词函数
  ```

  - 以上 2 种格式都能实现去除 list 容器中相邻重复的元素，仅保留一份。但第 2 种格式的优势在于，我们能自定义去重的规则

    ```
    bool demo(double first, double second)
    {
        return (int(first) == int(second));
    }
    int main()
    {
        list<double> mylist{ 1,1.2,1.2,3,4,4.5,4.6 };
        //删除相邻重复的元素，仅保留一份
        mylist.unique();//{1, 1.2, 3, 4, 4.5, 4.6}
        for (auto it = mylist.begin(); it != mylist.end(); ++it)
            cout << *it << ' ';
        cout << endl;
        //demo 为二元谓词函数，是我们自定义的去重规则
        mylist.unique(demo);
        for (auto it = mylist.begin(); it != mylist.end(); ++it)
            std::cout << *it << ' ';
        return 0;
    }
    
    1 1.2 3 4 4.5 4.6
    1 3 4
    ```

  - 除了以上一定谓词函数的方式，还可以使用 [lamba表达式](http://c.biancheng.net/view/433.html)以及[函数对象](http://c.biancheng.net/view/354.html)的方式定义。

  - 可以看到，通过调用无参的 unique()，仅能删除相邻重复（也就是相等）的元素，而通过我们自定义去重的规则，可以更好的满足在不同场景下去重的需求。

  - 除此之外，通过将自定义的谓词函数（不限定参数个数）传给 remove_if() 成员函数，list 容器中能使谓词函数成立的元素都会被删除

    ```
    	std::list<int> mylist{ 15, 36, 7, 17, 20, 39, 4, 1 };
        //删除 mylist 容器中能够使 lamba 表达式成立的所有元素。
        mylist.remove_if([](int value) {return (value < 10); }); //{15 36 17 20 39}
        for (auto it = mylist.begin(); it != mylist.end(); ++it)
            std::cout << ' ' << *it;
        return 0;
    ```

##### forward_list

- 由于单链表没有双向链表那样灵活，因此相比 list 容器，forward_list 容器的功能受到了很多限制。比如，由于单链表只能从前向后遍历，而不支持反向遍历，因此 forward_list 容器只提供前向迭代器，而不是双向迭代器。这意味着，forward_list 容器不具有 rbegin()、rend() 之类的成员函数。

- forward_list 容器底层使用单链表，也不是一无是处。比如，存储相同个数的同类型元素，单链表耗用的内存空间更少，空间利用率更高，并且对于实现某些操作单链表的执行效率也更高。

- 效率高是选用 forward_list 而弃用 list 容器最主要的原因，换句话说，只要是 list 容器和 forward_list 容器都能实现的操作，应优先选择 forward_list 容器。

- C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 forward_list 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。

- forward_list 容器还有一个`std::swap(x , y)`非成员函数（其中 x 和 y 是存储相同类型元素的 forward_list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。

- forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 <iterator> 中的 dis[tan](http://c.biancheng.net/ref/tan.html)ce() 函数

  ```
  std::forward_list<int> my_words{1,2,3,4};
  int count = std::distance(std::begin(my_words), std::end(my_words));
  ```

- forward_list 容器迭代器的移动除了使用 ++ 运算符单步移动，还能使用 advance() 函数

  ```
  std::forward_list<int> values{1,2,3,4};
      auto it = values.begin();
      advance(it, 2);
      while (it!=values.end())
      {
          cout << *it << " ";
          ++it;
      }
      3 4
  ```

### STL关联式容器

- 关联式容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。

- 弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。

- 也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序。

- 关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种[数据结构](http://c.biancheng.net/data_structure/)来组织和存储各个键值对。

- C++ STL 标准库提供了 4 种关联式容器，分别为 map、set、multimap、multiset

  | 关联式容器名称 | 特点                                                         |
  | -------------- | ------------------------------------------------------------ |
  | map            | 定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less<T>）。 |
  | set            | 定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less<T>）。 |
  | multimap       | 定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。 |
  | multiset       | 定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。 |

- 除此之外，C++ 11 还新增了 4 种哈希容器，即 unordered_map、unordered_multimap 以及 unordered_set、unordered_multiset。严格来说，它们也属于关联式容器，但由于哈希容器底层采用的是哈希表，而不是红黑树

##### pair用法

- 关联式容器存储的是“键值对”形式的数据

  ```
  <"C语言教程", "http://c.biancheng.net/c/">
  <"Python教程", "http://c.biancheng.net/python/">
  <"Java教程", "http://c.biancheng.net/java/">
  ```

  - 每行都表示一个键值对，其中第一个元素作为键（key），第二个元素作为值（value）。
  - 基于各个关联式容器存储数据的特点，只有各个键值对中的键和值全部对应相等时，才能使用 set 和 multiset 关联式容器存储，否则就要选用 map 或者 multimap 关联式容器。

- 考虑到“键值对”并不是普通类型数据，[C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素`<first, second>`。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素，再合适不过。

- pair 类模板定义在`<utility>`头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：

  ```c++
  #1) 默认构造函数，即创建空的 pair 对象
  pair();
  #2) 直接使用 2 个元素初始化成 pair 对象
  pair (const first_type& a, const second_type& b);
  #3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象
  template<class U, class V> pair (const pair<U,V>& pr);
  
  在 C++ 11 标准中，在引入右值引用的基础上，pair 类模板中又增添了如下 2 个构造函数
  #4) 移动构造函数
  template<class U, class V> pair (pair<U,V>&& pr);
  #5) 使用右值引用参数，创建 pair 对象
  template<class U, class V> pair (U&& a, V&& b);
  ```

- pair使用方法

  ```
  	// 调用构造函数 1，也就是默认构造函数
      pair <string, double> pair1;
      // 调用第 2 种构造函数
      pair <string, string> pair2("STL教程","http://c.biancheng.net/stl/");  
      // 调用拷贝构造函数
      pair <string, string> pair3(pair2);
      //调用移动构造函数
      pair <string, string> pair4(make_pair("C++教程", "http://c.biancheng.net/cplus/"));
      // 调用第 5 种构造函数
      pair <string, string> pair5(string("Python教程"), string("http://c.biancheng.net/python/"));  
  ```

  - 上面程序在创建 pair4 对象时，调用了 make_pair() 函数，它也是 <utility> 头文件提供的，其功能是生成一个 pair 对象。因此，当我们将 make_pair() 函数的返回值（是一个临时对象）作为参数传递给 pair() 构造函数时，其调用的是移动构造函数，而不是拷贝构造函数。

  - C++ 11 还允许我们手动为 pair1 对象赋值

    ```
    pair1.first = "Java教程";
    pair1.second = "http://c.biancheng.net/java/";
    cout << "new pair1: " << pair1.first << " " << pair1.second << endl;
    ```

  - 上面程序中 pair4 对象的创建过程，还可以写入如下形式，它们是完全等价的：

    ```
    pair <string, string> pair4 = make_pair("C++教程", "http://c.biancheng.net/cplus/");
    cout << "pair4: " << pair4.first << " " << pair4.second << endl;
    ```

- `<utility>`头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 <、<=、>、>=、==、!= 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。对于进行比较的 2 个 pair 对象，其对应的键和值的类型比较相同，否则将没有可比性

  ```
   	pair <string, int> pair1("STL教程", 20);
      pair <string, int> pair2("C++教程", 20);
      pair <string, int> pair3("C++教程", 30);
      //pair1和pair2的key不同，value相同
      if (pair1 != pair2) {
          cout << "pair != pair2" << endl;
      }
      //pair2和pair3的key相同，value不同
      if (pair2 != pair3) {
          cout << "pair2 != pair3" << endl;
      }
  ```

- pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。pair1.swap(pair2)

##### map

- map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 [C++](http://c.biancheng.net/cplus/) 基本数据类型（int、double 等）、使用结构体或类自定义的类型。

- 通常情况下，map 容器中存储的各个键值对都选用 string 字符串作为键的类型。

- 与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用`std::less<T>`排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 [STL](http://c.biancheng.net/stl/) 标准库中提供的其它排序规则（比如`std::greater<T>`），也可以自定义排序规则。

- 使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 pair<const K, T> 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。

- map 容器的模板定义如下

  ```
  template < class Key,                                     // 指定键（key）的类型
             class T,                                       // 指定值（value）的类型
             class Compare = less<Key>,                     // 指定排序规则
             class Alloc = allocator<pair<const Key,T> >    // 指定分配器对象的类型
             > class map;
  ```

  - map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。

###### map创建

- 通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器

  ```
  std::map<std::string, int>myMap;
  ```

  - 通过此方式创建出的 myMap 容器，初始状态下是空的，即没有存储任何键值对。鉴于空 map 容器可以根据需要随时添加新的键值对，因此创建空 map 容器是比较常用的。

- 在创建 map 容器的同时，也可以进行初始化

  ```
  std::map<std::string, int>myMap{ {"C语言教程",10},{"STL教程",20} };
  ```

  - map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：

    ```
    std::map<std::string, int>myMap{std::make_pair("C语言教程",10),std::make_pair("STL教程",20)};
    ```

- 可以利用先前已创建好的 map 容器，再创建一个新的 map 容器

  ```
  std::map<std::string, int>newMap(myMap);
  ```

  - 通过调用 map 容器的拷贝（复制）构造函数，即可成功创建一个和 myMap 完全一样的 newMap 容器。

  - C++ 11 标准中，还为 map 容器增添了移动构造函数。当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数

    ```c++
    #创建一个会返回临时 map 对象的函数
    std::map<std::string,int> disMap() {
        std::map<std::string, int>tempMap{ {"C语言教程",10},{"STL教程",20} };
        return tempMap;
    }
    //调用 map 类模板的移动构造函数创建 newMap 容器
    std::map<std::string, int>newMap(disMap());
    ```

- map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器

  ```
  std::map<std::string, int>myMap{ {"C语言教程",10},{"STL教程",20} };
  std::map<std::string, int>newMap(++myMap.begin(), myMap.end());
  ```

  - 通过调用 map 容器的双向迭代器，实现了在创建 newMap 容器的同时，将其初始化为包含一个 {"STL教程",20} 键值对的容器。

- 在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less<T> 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。

  - 如下 2 行创建 map 容器的方式，其实是等价的

    ```
    std::map<std::string, int>myMap{ {"C语言教程",10},{"STL教程",20} };
    std::map<std::string, int, std::less<std::string> >myMap{ {"C语言教程",10},{"STL教程",20} };
    ```

  - 手动修改了 myMap 容器的排序规则，令其作降序排序：

    ```
    std::map<std::string, int, std::greater<std::string> >myMap{ {"C语言教程",10},{"STL教程",20} };
    ```

###### map迭代器

- STL 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 ++p、p++、--p、p--、*p 操作，并且迭代器之间只能使用 == 或者 != 运算符进行比较。

- map 类模板中还提供了 find() 成员方法，它能帮我们查找指定 key 值的键值对，如果成功找到，则返回一个指向该键值对的双向迭代器；反之，其功能和 end() 方法相同。end返回的也是双向迭代器

- 在用迭代器进行访问数据的时候要注意，**访问的结果不是初始化的结果**，因为容器会自动排序，在使用迭代器进行访问的时候是排序后的容器。

- map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：不小于也可以是相等

  - lower_bound(key) 返回的是指向第一个键**不小于** key 的键值对的迭代器；
  - upper_bound(key) 返回的是指向第一个键**大于** key 的键值对的迭代器；
  - lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。

- equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。equal_range(key) 成员方法表示的一个范围，位于此范围中的键值对，其键的值都为 key。这样我们就可以打印出相同键的元素

  ```c++
   //创建一个 pair 对象，来接收 equal_range() 的返回值
      pair <std::map<string, string>::iterator, std::map<string, string>::iterator> myPair = myMap.equal_range("C语言教程");
      //通过遍历，输出 myPair 指定范围内的键值对
      for (auto iter = myPair.first; iter != myPair.second; ++iter) {
          cout << iter->first << " " << iter->second << endl;
      }
  ```

  - 和 lower_bound(key)、upper_bound(key) 一样，该方法也更常用于 multimap 容器，因为 map 容器中各键值对的键的值都是唯一的，因此通过 map 容器调用此方法，其返回的范围内最多也只有 1 个键值对。

###### map获取键对应的值

- map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。

- map 容器的类模板中提供了 2 种方法，可直接获取 map 容器指定键对应的值。

  - map 类模板中对`[ ]`运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。

    ```c++
    //创建并初始化 map 容器
        std::map<std::string, std::string>myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                                 {"C语言教程","http://c.biancheng.net/c/"},
                                                 {"Java教程","http://c.biancheng.net/java/"} };
        string cValue = myMap["C语言教程"];
        cout << cValue << endl;
        return 0;
    }
    http://c.biancheng.net/c/
    ```

    - 只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 ""，即空字符串（即使用该类型的默认值作为键值对的值）。

      ```
      //创建空 map 容器
          std::map<std::string, int>myMap;
          int cValue = myMap["C语言教程"];
          for (auto i = myMap.begin(); i != myMap.end(); ++i) {
              cout << i->first << " "<< i->second << endl;
          }
          C语言教程 0
      ```

    - 对于空的 myMap 容器来说，其内部没有以 "C语言教程" 为键的键值对，这种情况下如果使用 [ ] 运算符获取该键对应的值，其功能就转变成了向该 myMap 容器中添加一个`<"C语言教程",0>`键值对（由于 myMap 容器规定各个键值对的值的类型为 int，该类型的默认值为 0）。

    - \[ ] 运算符确实有“为 map 容器添加新键值对”的功能，但前提是要保证新添加键值对的键和当前 map 容器中已存储的键值对的键都不一样

      ```
      //创建空 map 容器
          std::map<string, string>myMap;
          myMap["STL教程"]="http://c.biancheng.net/java/";
          myMap["Python教程"] = "http://c.biancheng.net/python/";
          myMap["STL教程"] = "http://c.biancheng.net/stl/";
          for (auto i = myMap.begin(); i != myMap.end(); ++i) {
              cout << i->first << " " << i->second << endl;
          }
          Python教程 http://c.biancheng.net/python/
      	STL教程 http://c.biancheng.net/stl/
      ```

    - 程序中第 9 行代码已经为 map 容器添加了一个以 "STL教程" 作为键的键值对，则第 11 行代码的作用就变成了修改该键对应的值，而不再是为 map 容器添加新键值对。

  - 除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。

  - 除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。当 find() 方法查找失败时，其返回的迭代器指向的是容器中最后一个键值对之后的位置，即不指向任何有意义的键值对，也就没有所谓的 first 和 second 成员了。

    ```c++
    int main() {
        //创建并初始化 map 容器
        std::map<std::string, std::string>myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                                 {"C语言教程","http://c.biancheng.net/c/"},
                                                 {"Java教程","http://c.biancheng.net/java/"} };
        map< std::string, std::string >::iterator myIter = myMap.find("C语言教程");
        cout << myIter->first << " " << myIter->second << endl;
        return 0;
    }
    C语言教程 http://c.biancheng.net/c/
    ```
    
    
    
  - 如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值
  
    ```c++
    //创建并初始化 map 容器
        std::map<std::string, std::string>myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                                 {"C语言教程","http://c.biancheng.net/c/"},
                                                 {"Java教程","http://c.biancheng.net/java/"} };
        for (auto iter = myMap.begin(); iter != myMap.end(); ++iter) {
            //调用 string 类的 compare() 方法，找到一个键和指定字符串相同的键值对
            if (!iter->first.compare("C语言教程")) {
                cout << iter->first << " " << iter->second << endl;
            }
        }
    ```


###### map insert()插入数据的四种方式

- 除了使用 [ ] 运算符实现向 map 容器中添加新键值对外，map 类模板中还提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。

  - 这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。

- 自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。

  - 无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：

    ```
    //1、引用传递一个键值对
    pair<iterator,bool> insert (const value_type& val);
    //2、以右值引用的方式传递键值对
    template <class P>
    pair<iterator,bool> insert (P&& val);
    ```

    - val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：

      - 如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；
      - 如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。

      ```
      //创建一个空 map 容器
          std::map<string, string> mymap;
         
          //创建一个真实存在的键值对变量
          std::pair<string, string> STL = { "STL教程","http://c.biancheng.net/stl/" };
         
          //创建一个接收 insert() 方法返回值的 pair 对象
          std::pair<std::map<string, string>::iterator, bool> ret;
         
          //插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参
          ret = mymap.insert(STL);
          cout << "ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;
          //以右值引用的方式传递临时的键值对变量
          ret = mymap.insert({ "C语言教程","http://c.biancheng.net/c/" });
          cout << "ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;
          //插入失败样例
          ret = mymap.insert({ "STL教程","http://c.biancheng.net/java/" });
          cout << "ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;
      执行结果    
      ret.iter = <{STL教程, http://c.biancheng.net/stl/}, 1>
      ret.iter = <{C语言教程, http://c.biancheng.net/c/}, 1>
      ret.iter = <{STL教程, http://c.biancheng.net/stl/}, 0>
      ```

      - 从执行结果中不难看出，程序中共执行了 3 次插入操作，其中成功了 2 次，失败了 1 次：

        - 对于插入成功的 insert() 方法，其返回的 pair 对象中包含一个指向新插入键值对的迭代器和值为 1 的 bool 变量
        - 对于插入失败的 insert() 方法，同样会返回一个 pair 对象，其中包含一个指向 map 容器中键为 "STL教程" 的键值对和值为 0 的 bool 变量。

      - 另外，在程序中的第 21 行代码，还可以使用如下 2 种方式创建临时的键值对变量，它们是等价的：

        ```
        //调用 pair 类模板的构造函数
        ret = mymap.insert(pair<string,string>{ "C语言教程","http://c.biancheng.net/c/" });
        //调用 make_pair() 函数
        ret = mymap.insert(make_pair("C语言教程", "http://c.biancheng.net/c/"));
        ```

  - insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下

    ```
    //以普通引用的方式传递 val 参数
    iterator insert (const_iterator position, const value_type& val);
    //以右值引用的方式传递 val 键值对参数
    template <class P>
        iterator insert (const_iterator position, P&& val);
    ```

    - 其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：

      - 如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；

      - 如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。

        ```
        //创建一个空 map 容器
            std::map<string, string> mymap;
           
            //创建一个真实存在的键值对变量
            std::pair<string, string> STL = { "STL教程","http://c.biancheng.net/stl/" };
            //指定要插入的位置
            std::map<string, string>::iterator it = mymap.begin();
            //向 it 位置以普通引用的方式插入 STL
            auto iter1 = mymap.insert(it, STL);
            cout << iter1->first << " " << iter1->second << endl;
            //向 it 位置以右值引用的方式插入临时键值对
            auto iter2 = mymap.insert(it, std::pair<string, string>("C语言教程", "http://c.biancheng.net/c/"));
            cout << iter2->first << " " << iter2->second << endl;
            //插入失败样例
            auto iter3 = mymap.insert(it, std::pair<string, string>("STL教程", "http://c.biancheng.net/java/"));
            cout << iter3->first << " " << iter3->second << endl;
            return 0;
            
            执行结果：
            STL教程 http://c.biancheng.net/stl/
        C语言教程 http://c.biancheng.net/c/
        STL教程 http://c.biancheng.net/stl/
        ```

        - 再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。

  - insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：

    ```
    template <class InputIterator>
      void insert (InputIterator first, InputIterator last);
    ```

    - 其中 first 和 last 都是迭代器，它们的组合`<first,last>`可以表示某 map 容器中的指定区域。

  - 除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对

    ```
    void insert ({val1, val2, ...});
    std::map<std::string, std::string>mymap;
        //向 mymap 容器中添加 3 个键值对
        mymap.insert({ {"STL教程", "http://c.biancheng.net/stl/"},
                       { "C语言教程","http://c.biancheng.net/c/" },
                       { "Java教程","http://c.biancheng.net/java/" } });
        for (auto iter = mymap.begin(); iter != mymap.end(); ++iter) {
            cout << iter->first << " " << iter->second << endl;
        }
    ```

###### operator[]和insert()效率对比

- map 容器模板类中提供有 operator[ ] 和 insert() 这 2 个成员方法，而值得一提的是，这 2 个方法具有相同的功能，它们既可以实现向 map 容器中添加新的键值对元素，也可以实现更新（修改）map 容器已存储键值对的值。

  ```
  std::map<string, string> mymap;
      //借用 operator[] 添加新键值对
      mymap["STL教程"] = "http://c.biancheng.net/java/";
      cout << "old mymap：" << mymap["STL教程"] << endl;
      //借用 operator[] 更新某个键对应的值
      mymap["STL教程"] = "http://c.biancheng.net/stl/";
      cout << "new mymap：" << mymap["STL教程"] << endl;
      //借用insert()添加新键值对
      std::pair<string, string> STL = { "Java教程","http://c.biancheng.net/python/" };
      std::pair<std::map<string, string>::iterator, bool> ret;
      ret = mymap.insert(STL);
      cout << "old ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;
      //借用 insert() 更新键值对
      mymap.insert(STL).first->second = "http://c.biancheng.net/java/";
      cout << "new ret.iter = <" << ret.first->first << ", " << ret.first->second << ">" << endl;
      
      old mymap：http://c.biancheng.net/java/
  new mymap：http://c.biancheng.net/stl/
  old ret.iter = <{Java教程, http://c.biancheng.net/python/}, 1>
  new ret.iter = <Java教程, http://c.biancheng.net/java/>
  ```

- 当实现“向 map 容器中添加新键值对元素”的操作时，insert() 成员方法的执行效率更高；而在实现“更新 map 容器指定键值对的值”的操作时，operator[ ] 的效率更高。

  - 为什么实现向 map 容器中添加新键值对元素，insert() 方法的执行效率比 operator[ ] 更高

    ```
    mymap["STL教程"] = "http://c.biancheng.net/java/";
    ```

  - 此行代码中，mymap["STL教程"] 实际上是 mymap.operator[ ](“STL教程”) 的缩写（底层调用的 operator[ ] 方法），该方法会返回一个指向 “STL教程” 对应的 value 值的引用。

  - 但需要注意的是，由于此时 mymap 容器是空的，并没有 "STL教程" 对应的 value 值。这种情况下，operator[ ] 方法会默认构造一个 string 对象，并将其作为 "STL教程" 对应的 value 值，然后返回一个指向此 string 对象的引用。在此基础上，代码还会将 "http://c.biancheng.net.java/" 赋值给这个 string 对象。

  - 也就是说，上面这行代码的执行流程，可以等效为如下程序：

    ```
    typedef map<string, string> mstr;
    //创建要添加的默认键值对元素
    pair<mstr::iterator, bool>res = mymap.insert(mstr::value_type("STL教程", string()));
    //将新键值对的值赋值为指定的值
    res.first->second = "http://c.biancheng.net/java/";
    ```

  - 直接构造一个要添加的键值对元素

    ```
    mymap.insert(mstr::value_type("STL教程", "http://c.biancheng.net/java/"));
    ```

  - 此行代码和上面程序的执行效果完全相同，但它省略了创建临时 string 对象的过程以及析构该对象的过程，同时还省略了调用 string 类重载的赋值运算符。由于可见，同样是完成向 map 容器添加新键值对，insert() 方法比 operator[ ] 的执行效率更高。

- 更新map容器中的键值对operator[]效率更高

  -  operator[ ] 和 insert() 实现更新 mymap 容器中指定键对应的值的代码

    ```
    //operator[]
    mymap["STL教程"] = "http://c.biancheng.net/stl/";
    //insert()
    std::pair<string, string> STL = { "Java教程","http://c.biancheng.net/python/" };
    mymap.insert(STL).first->second = "http://c.biancheng.net/java/";
    ```

  - 从上面代码可以看到，insert() 方法在进行更新操作之前，需要有一个 pair 类型（也就是 map::value_type 类型）元素做参数。这意味着，该方法要多构造一个 pair 对象（附带要构造 2 个 string 对象），并且事后还要析构此 pair 对象（附带 2 个 string 对象的析构）。

  - 而和 insert() 方法相比，operator[ ] 就不需要使用 pair 对象，自然不需要构造（并析构）任何 pair 对象或者 string 对象。因此，对于更新已经存储在 map 容器中键值对的值，应优先使用 operator[ ] 方法。

###### emplace和emplace_hint()

- map 类模板中还提供了 emplace() 和 emplace_hint() 成员函数，也可以实现向 map 容器中插入新的键值对

- 值得一提的是，实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高

- 和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：

  ```
  template <class... Args>
    pair<iterator,bool> emplace (Args&&... args);
  ```

  - 参数 (Args&&... args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：

    - 当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；
    - 当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。

    ```
    //创建并初始化 map 容器
        std::map<string, string>mymap;
        //插入键值对
        pair<map<string, string>::iterator, bool> ret = mymap.emplace("STL教程", "http://c.biancheng.net/stl/");
        cout << "1、ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;
        //插入新键值对
        ret = mymap.emplace("C语言教程", "http://c.biancheng.net/c/");
        cout << "2、ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;
        //失败插入的样例
        ret = mymap.emplace("STL教程", "http://c.biancheng.net/java/");
        cout << "3、ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;
        
        ret.iter = <{STL教程, http://c.biancheng.net/stl/}, 1>
    2、ret.iter = <{C语言教程, http://c.biancheng.net/c/}, 1>
    3、ret.iter = <{STL教程, http://c.biancheng.net/stl/}, 0>
    ```

    - 程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。

- emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：

  ```
  template <class... Args>
    iterator emplace_hint (const_iterator position, Args&&... args);
  ```

  - 显然和 emplace() 语法格式相比，有以下 2 点不同：

    1. 该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；
    2. 该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。

    ```
    //创建并初始化 map 容器
        std::map<string, string>mymap;
        //指定在 map 容器插入键值对
        map<string, string>::iterator iter = mymap.emplace_hint(mymap.begin(),"STL教程", "http://c.biancheng.net/stl/");
        cout << iter->first << " " << iter->second << endl;
        iter = mymap.emplace_hint(mymap.begin(), "C语言教程", "http://c.biancheng.net/c/");
        cout << iter->first << " " << iter->second << endl;
        //插入失败样例
        iter = mymap.emplace_hint(mymap.begin(), "STL教程", "http://c.biancheng.net/java/");
        cout << iter->first << " " << iter->second << endl;
        
        STL教程 http://c.biancheng.net/stl/
    C语言教程 http://c.biancheng.net/c/
    STL教程 http://c.biancheng.net/stl/
    ```

    - 和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。

###### 插入效率对比

- 为什么 emplace() 和 emplace_hint() 的执行效率会比 insert() 高，原因很简单，它们向 map 容器插入键值对时，底层的实现方式不同：

  - 使用 insert() 向 map 容器中插入键值对的过程是，先创建该键值对，然后再将该键值对复制或者移动到 map 容器中的指定位置；
  - 使用 emplace() 或 emplace_hint() 插入键值对的过程是，直接在 map 容器中的指定位置构造该键值对。
  - 也就是说，向 map 容器中插入键值对时，emplace() 和 emplace_hint() 方法都省略了移动键值对的过程，因此执行效率更高

  ```
  class testDemo
  {
  public:
      testDemo(int num) :num(num) {
          std::cout << "调用构造函数" << endl;
      }
      testDemo(const testDemo& other) :num(other.num) {
          std::cout << "调用拷贝构造函数" << endl;
      }
      testDemo(testDemo&& other) :num(other.num) {
          std::cout << "调用移动构造函数" << endl;
      }
  private:
      int num;
  };
  int main()
  {
      //创建空 map 容器
      std::map<std::string, testDemo>mymap;
      cout << "insert():" << endl;
      mymap.insert({ "http://c.biancheng.net/stl/", testDemo(1) });
     
      cout << "emplace():" << endl;
      mymap.emplace( "http://c.biancheng.net/stl/:", 1);
      cout << "emplace_hint():" << endl;
      mymap.emplace_hint(mymap.begin(), "http://c.biancheng.net/stl/", 1);
      
  insert():
  调用构造函数
  调用移动构造函数
  调用移动构造函数
  emplace():
  调用构造函数
  emplace_hint():
  调用构造函数
  ```

  - 在使用 insert() 方法向 map 容器插入键值对时，整个插入过程调用了 1 次 tempDemo 类的构造函数，同时还调用了 2 次移动构造函数。实际上，程序第 28 行代码底层的执行过程，可以分解为以下 3 步：

    ```
    //构造类对象
    testDemo val = testDemo(1); //调用 1 次构造函数
    //构造键值对
    auto pai = make_pair("http://c.biancheng.net/stl/", val); //调用 1 次移动构造函数
    //完成插入操作
    mymap.insert(pai); //调用 1 次移动构造函数
    ```

  - 而完成同样的插入操作，emplace() 和 emplace_hint() 方法都只调用了 1 次构造函数，这足以证明，这 2 个方法是在 map 容器内部直接构造的键值对。

- 在实现向 map 容器中插入键值对时，应优先考虑使用 emplace() 或者 emplace_hint()。

##### multimap

- multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair<const K, T> 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。

- multimap 容器类模板的定义如下：

  ```
  template < class Key,                                   // 指定键（key）的类型
             class T,                                     // 指定值（value）的类型
             class Compare = less<Key>,                   // 指定排序规则
             class Alloc = allocator<pair<const Key,T> >  // 指定分配器对象的类型
             > class multimap;
  ```

###### multimap创建

- 创建 multimap 容器的方式可归为以下 5 种。

- 通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：

  ```
  std::multimap<std::string, std::string>mymultimap;
  ```

- 在创建 multimap 容器的同时，还可以进行初始化操作

  ```
  //创建并初始化 multimap 容器
  multimap<string, string>mymultimap{ {"C语言教程", "http://c.biancheng.net/c/"},
                                      {"Python教程", "http://c.biancheng.net/python/"},
                                      {"STL教程", "http://c.biancheng.net/stl/"} };
  ```

  - 使用此方式初始化 multimap 容器时，其底层会先将每一个`{key, value}`创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。

  - 我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：

    ```
    multimap<string, string>mymultimap{
        pair<string,string>{"C语言教程", "http://c.biancheng.net/c/"},
        pair<string,string>{ "Python教程", "http://c.biancheng.net/python/"},
        pair<string,string>{ "STL教程", "http://c.biancheng.net/stl/"}
    };
    //调用 make_pair() 函数，生成键值对元素
    //创建并初始化 multimap 容器
    multimap<string, string>mymultimap{
        make_pair("C语言教程", "http://c.biancheng.net/c/"),
        make_pair("Python教程", "http://c.biancheng.net/python/"),
        make_pair("STL教程", "http://c.biancheng.net/stl/")
    };
    ```

- 通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器

  ```
  multimap<string, string>newmultimap(mymultimap);
  ```

  - 还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作

    ```
    //创建一个会返回临时 multimap 对象的函数
    multimap<string, string> dismultimap() {
        multimap<string, string>tempmultimap{ {"C语言教程", "http://c.biancheng.net/c/"},{"Python教程", "http://c.biancheng.net/python/"} };
        return tempmultimap;
    }  
    //调用 multimap 类模板的移动构造函数创建 newMultimap 容器
    multimap<string, string>newmultimap(dismultimap());
    ```

    - 由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数。

- multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用

  ```
  //创建并初始化 multimap 容器
  multimap<string, string>mymultimap{ {"C语言教程", "http://c.biancheng.net/c/"},
                                      {"Python教程", "http://c.biancheng.net/python/"},
                                      {"STL教程", "http://c.biancheng.net/stl/"} };
  multimap<string, string>newmultimap(++mymultimap.begin(), mymultimap.end());
  ```

  - multimap 容器迭代器，和 map 容器迭代器的用法完全相同

- multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为`std::less<T>`，和map一样可以使用greater\<T>

- 和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。

- 另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此表 1 中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到。

  ```
  count(key)	在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。
  ```

  ```c++
  //创建并初始化 multimap 容器
      multimap<char, int>mymultimap{ {'a',10},{'b',20},{'b',15}, {'c',30} };
      //输出 mymultimap 容器存储键值对的数量
      cout << mymultimap.size() << endl;
      //输出 mymultimap 容器中存储键为 'b' 的键值对的数量
      cout << mymultimap.count('b') << endl;
      for (auto iter = mymultimap.begin(); iter != mymultimap.end(); ++iter) {
          cout << iter->first << " " << iter->second << endl;
      }
  ```

##### set

- set是关联式容器，关联式容器保存的都是pair类型的值，和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。

- 基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可

- map、multimap 容器都会自行根据键的大小对存储的键值对进行排序，set 容器也会如此，只不过 set 容器中各键值对的键 key 和值 value 是相等的，根据 key 排序，也就等价为根据 value 排序。

- 使用 set 容器存储的各个元素的值必须各不相同。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。对于初学者来说，切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。

- set 容器的类模板定义如下：

  ```c++
  template < class T,                        // 键 key 和值 value 的类型
             class Compare = less<T>,        // 指定 set 容器内部的排序规则
             class Alloc = allocator<T>      // 指定分配器对象的类型
             > class set;
  ```

  - 由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。

###### set创建

- 调用默认构造函数，创建空的 set 容器。

  ```
  std::set<std::string> myset;
  ```

  - 由此就创建好了一个 set 容器，该容器采用默认的`std::less<T>`规则，会对存储的 string 类型元素做升序排序。注意，由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。

- 除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化。例如：

  ```
  std::set<std::string> myset{"http://c.biancheng.net/java/",
                              "http://c.biancheng.net/stl/",
                              "http://c.biancheng.net/python/"};
  ```

- set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。

  ```
  std::set<std::string> copyset(myset);
  //等同于
  //std::set<std::string> copyset = myset
  ```

- C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化

  ```
  set<string> retSet() {
      std::set<std::string> myset{ "http://c.biancheng.net/java/",
                              "http://c.biancheng.net/stl/",
                              "http://c.biancheng.net/python/" };
      return myset;
  }
  std::set<std::string> copyset(retSet());
  //或者
  //std::set<std::string> copyset = retSet();
  ```

  - 由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化 copyset 容器时，其内部调用的是 set 类模板中的移动构造函数，而非拷贝构造函数。

- set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器

  ```
  std::set<std::string> myset{ "http://c.biancheng.net/java/",
                      "http://c.biancheng.net/stl/",
                      "http://c.biancheng.net/python/" };
  std::set<std::string> copyset(++myset.begin(), myset.end());
  ```

- 以上几种方式创建的 set 容器，都采用了默认的`std::less<T>`规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则

  ```
  std::set<std::string,std::greater<string> > myset{
      "http://c.biancheng.net/java/",
      "http://c.biancheng.net/stl/",
      "http://c.biancheng.net/python/"};
  ```

###### 迭代器

- 和 map 容器不同，[C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。

- 值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、--p、p--、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符。

  | 成员方法         | 功能                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | find(val)        | 在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
  | lower_bound(val) | 返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
  | upper_bound(val) | 返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
  | equal_range(val) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。 |
  - 以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。

    ```
    //创建并初始化set容器
        std::set<std::string> myset{ "http://c.biancheng.net/java/",
                                     "http://c.biancheng.net/stl/",
                                     "http://c.biancheng.net/python/"
        };
        //利用双向迭代器，遍历myset
        for (auto iter = myset.begin(); iter != myset.end(); ++iter) {
            cout << *iter << endl;
        }
        http://c.biancheng.net/java/
    http://c.biancheng.net/python/
    http://c.biancheng.net/stl/
    ```

  - 因为 iter 迭代器指向的是 set 容器存储的某个元素，而不是键值对，因此通过 *iter 可以直接获取该迭代器指向的元素的值。

- 如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。

- 虽然 C++ STL 标准中，set 类模板中包含 lower_bound()、upper_bound()、equal_range() 这 3 个成员函数，但它们更适用于 multiset 容器，几乎不会用于操作 set 容器。

###### set insert()

- 如果想向 set 容器中继续添加元素，可以借助 set 类模板提供的 insert() 方法。

- 只要给定目标元素的值，insert() 方法即可将该元素添加到 set 容器中，其语法格式如下：

  ```
  //普通引用方式传参
  pair<iterator,bool> insert (const value_type& val);
  //右值引用方式传参
  pair<iterator,bool> insert (value_type&& val);
  ```

  - val 表示要添加的新元素，该方法的返回值为 pair 类型。

  - 以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：

    - 当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；
    - 如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。

    ```c++
    //创建并初始化set容器
        std::set<std::string> myset;
        //准备接受 insert() 的返回值
        pair<set<string>::iterator, bool> retpair;
        //采用普通引用传值方式
        string str = "http://c.biancheng.net/stl/";
        retpair = myset.insert(str);
        cout << "iter->" << *(retpair.first) << " " << "bool = " << retpair.second << endl;
        //采用右值引用传值方式
        retpair = myset.insert("http://c.biancheng.net/python/");
        cout << "iter->" << *(retpair.first) << " " << "bool = " << retpair.second << endl;
    ```

    - map中insert是pair类型的值，set不用，因为set只需要传入一个值，我们只要传入类型相同的值就可以了

- insert() 还可以指定将新元素插入到 set 容器中的具体位置

  ```
  //以普通引用的方式传递 val 值
  iterator insert (const_iterator position, const value_type& val);
  //以右值引用的方式传递 val 值
  iterator insert (const_iterator position, value_type&& val);
  ```

  - 以上 2 种语法格式中，insert() 函数的返回值为迭代器：
    - 当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；
    - 当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。
  - 使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。

- insert() 方法支持向当前 set 容器中插入其它 set 容器指定区域内的所有元素，只要这 2 个 set 容器存储的元素类型相同即可。

  ```
  template <class InputIterator>
    void insert (InputIterator first, InputIterator last);
  ```

  - 其中 first 和 last 都是迭代器，它们的组合 [first,last) 可以表示另一 set 容器中的一块区域，该区域包括 first 迭代器指向的元素，但不包含 last 迭代器指向的元素。

- 采用如下格式的 insert() 方法，可实现一次向 set 容器中添加多个元素：

  ```
  void insert ( {E1, E2,...,En} );
  
  //创建并初始化set容器
      std::set<std::string> myset;
      //向 myset 中添加多个元素
      myset.insert({ "http://c.biancheng.net/stl/",
          "http://c.biancheng.net/python/",
          "http://c.biancheng.net/java/" });
  ```
  - C++ 11 标准的 set 类模板中，还提供有另外 2 个成员方法，分别为 implace() 和 implace_hint() 方法，借助它们不但能实现向 set 容器添加新元素的功能，其实现效率也比 insert() 成员方法更高。

###### emplace和emplace_hint

- set 类模板提供的所有成员方法中，能实现向指定 set 容器中添加新元素的，只有 3 个成员方法，分别为 insert()、emplace() 和 emplace_hint()

- emplace() 和 emplace_hint() 是 [C++](http://c.biancheng.net/cplus/) 11 标准加入到 set 类模板中的，相比具有同样功能的 insert() 方法，完成同样的任务，emplace() 和 emplace_hint() 的效率会更高。

- emplace() 方法的语法格式如下：

  ```
  template <class... Args>
    pair<iterator,bool> emplace (Args&&... args);
  ```

  - 其中，参数 (Args&&... args) 指的是，只需要传入构建新元素所需的数据即可，该方法可以自行利用这些数据构建出要添加的元素。比如，若 set 容器中存储的元素类型为自定义的结构体或者类，则在使用 emplace() 方法向容器中添加新元素时，构造新结构体变量（或者类对象）需要多少个数据，就需要为该方法传入相应个数的数据。

  - 另外，该方法的返回值类型为 pair 类型，其包含 2 个元素，一个迭代器和一个 bool 值：

    - 当该方法将目标元素成功添加到 set 容器中时，其返回的迭代器指向新插入的元素，同时 bool 值为 true；
    - 当添加失败时，则表明原 set 容器中已存在相同值的元素，此时返回的迭代器指向容器中具有相同键的这个元素，同时 bool 值为 false。

    ```
    //创建并初始化 set 容器
        std::set<string>myset;
        //向 myset 容器中添加元素
        pair<set<string, string>::iterator, bool> ret = myset.emplace("http://c.biancheng.net/stl/");
        cout << "myset size = " << myset.size() << endl;
        cout << "ret.iter = <" << *(ret.first) << ", " << ret.second << ">" << endl;
    ```

- emplace_hint() 方法的功能和 emplace() 类似

  ```
  template <class... Args>
    iterator emplace_hint (const_iterator position, Args&&... args);
  ```

  - 和 emplace() 方法相比，有以下 2 点不同：
    - 该方法需要额外传入一个迭代器，用来指明新元素添加到 set 容器的具体位置（新元素会添加到该迭代器指向元素的前面）；
    - 返回值是一个迭代器，而不再是 pair 对象。当成功添加元素时，返回的迭代器指向新添加的元素；反之，如果添加失败，则迭代器就指向 set 容器和要添加元素的值相同的元素。
  - 和 insert() 方法一样，虽然 emplace_hint() 方法中指定了添加新元素的位置，但 set 容器为了保持数据的有序状态，可能会移动其位置。

###### set删除数据

- 如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。

- set 类模板中，erase() 方法有 3 种语法格式，分别如下：

  ```
  //删除 set 容器中值为 val 的元素
  size_type erase (const value_type& val);
  //删除 position 迭代器指向的元素
  iterator  erase (const_iterator position);
  //删除 [first,last) 区间内的所有元素
  iterator  erase (const_iterator first, const_iterator last);
  ```

  - 第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。
  - 如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。

  ```
  //创建并初始化 set 容器
      std::set<int>myset{1,2,3,4,5};
      cout << "myset size = " << myset.size() << endl;
     
      //1) 调用第一种格式的 erase() 方法
      int num = myset.erase(2); //删除元素 2，myset={1,3,4,5}
      cout << "1、myset size = " << myset.size() << endl;
      cout << "num = " << num << endl;
      //2) 调用第二种格式的 erase() 方法
      set<int>::iterator iter = myset.erase(myset.begin()); //删除元素 1，myset={3,4,5}
      cout << "2、myset size = " << myset.size() << endl;
      cout << "iter->" << *iter << endl;
      //3) 调用第三种格式的 erase() 方法
      set<int>::iterator iter2 = myset.erase(myset.begin(), --myset.end());//删除元素 3,4，myset={5}
      cout << "3、myset size = " << myset.size() << endl;
      cout << "iter2->" << *iter2 << endl;
  ```

- 如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法,void clear();

##### multiset

- 前面章节中，对 set 容器做了详细的讲解。回忆一下，set 容器具有以下几个特性：

  - 不再以键值对的方式存储数据，因为 set 容器专门用于存储键和值相等的键值对，因此该容器中真正存储的是各个键值对的值（value）；
  - set 容器在存储数据时，会根据各元素值的大小对存储的元素进行排序（默认做升序排序）；
  - 存储到 set 容器中的元素，虽然其类型没有明确用 const 修饰，但正常情况下它们的值是无法被修改的；
  - set 容器存储的元素必须互不相等。

- 在此基础上，[C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) 标准库中还提供有一个和 set 容器相似的关联式容器，即 multiset 容器。所谓“相似”，是指 multiset 容器遵循 set 容器的前 3 个特性，仅在第 4 条特性上有差异。和 set 容器不同的是，multiset 容器可以存储多个值相同的元素。

- multiset 容器类模板的定义如下所示：

  ```
  template < class T,                        // 存储元素的类型
             class Compare = less<T>,        // 指定容器内部的排序规则
             class Alloc = allocator<T> >    // 指定分配器对象的类型
             > class multiset;
  ```

- 创建 multiset 容器，无疑需要调用 multiset 类模板中的构造函数。值得一提的是，multiset 类模板提供的构造函数，和 set 类模板中提供创建 set 容器的构造函数，是完全相同的。这意味着，创建 set 容器的方式，也同样适用于创建 multiset 容器。

- 创建方式和set完全一样，就是可以添加重复的元素

##### 自定义关联式容器的排序规则

- 为关联式容器自定义排序规则，有以下 2 种方法。

- 使用函数对象自定义排序规则

  - 无论关联式容器中存储的是基础类型（如 int、double、float 等）数据，还是自定义的结构体变量或类对象（包括 string 类），都可以使用函数对象的方式为该容器自定义排序规则。

    ```
    //定义函数对象类
    class cmp {
    public:
        //重载 () 运算符
        bool operator ()(const string &a,const string &b) {
            //按照字符串的长度，做升序排序(即存储的字符串从短到长)
            return  (a.length() < b.length());
        }
    };
    int main() {
        //创建 set 容器，并使用自定义的 cmp 排序规则
        std::set<string, cmp>myset{"http://c.biancheng.net/stl/",
                                   "http://c.biancheng.net/python/",
                                   "http://c.biancheng.net/java/"};
        //输出容器中存储的元素
        for (auto iter = myset.begin(); iter != myset.end(); ++iter) {
                cout << *iter << endl;
        }
        return 0;
    }
    
    http://c.biancheng.net/stl/
    http://c.biancheng.net/java/
    http://c.biancheng.net/python/
    ```

  - 重点分析一下 6~13 行代码，其定义了一个函数对象类，并在其重载 () 运算符的方法中自定义了新的排序规则，即按照字符串的长度做升序排序。在此基础上，程序第 17 行代码中，通过将函数对象类的类名 cmp 通过 set 类模板的第 2 个参数传递给 myset 容器，该容器内部排序数据的规则，就改为了以字符串的长度为标准做升序排序。

  - 此程序中创建的 myset 容器，由于是以字符串的长度为准进行排序，因此其无法存储相同长度的多个字符串。

- 重载关系运算符实现自定义排序

  - 其实在 STL 标准库中，本就包含几个可供关联式容器使用的排序规则，如表 1 表示。

    | 排序规则              | 功能                                                         |
    | --------------------- | ------------------------------------------------------------ |
    | std::less<T>          | 底层采用 < 运算符实现升序排序，各关联式容器默认采用的排序规则。 |
    | std::greater<T>       | 底层采用 > 运算符实现降序排序，同样适用于各个关联式容器。    |
    | std::less_equal<T>    | 底层采用 <= 运算符实现升序排序，多用于 multimap 和 multiset 容器。 |
    | std::greater_equal<T> | 底层采用 >= 运算符实现降序排序，多用于 multimap 和 multiset 容器。 |

  - 值得一提的是，表 1 中的这些排序规则，其底层也是采用函数对象的方式实现的。以 std::less<T> 为例，其底层实现为：

    ```
    template <typename T>
    class less {
        //定义新的排序规则
        bool operator()(const T &_lhs, const T &_rhs) const {
            return _lhs < _rhs;
        }
    }
    ```

    - 在此基础上，当关联式容器中存储的数据类型为自定义的结构体变量或者类对象时，通过对现有排序规则中所用的关系运算符进行重载，也能实现自定义排序规则的目的。

  - 当关联式容器中存储的元素类型为结构体指针变量或者类的指针对象时，只能使用函数对象的方式自定义排序规则，此方法不再适用。

    ```
    //自定义类
    class myString {
    public:
        //定义构造函数，向 myset 容器中添加元素时会用到
        myString(string tempStr) :str(tempStr) {};
        //获取 str 私有对象，由于会被私有对象调用，因此该成员方法也必须为 const 类型
        string getStr() const;
    private:
        string str;
    };
    string myString::getStr() const{
        return this->str;
    }
    //重载 < 运算符，参数必须都为 const 类型
    bool operator <(const myString &stra, const myString & strb) {
        //以字符串的长度为标准比较大小
        return stra.getStr().length() < strb.getStr().length();
    }
    int main() {
        //创建空 set 容器，仍使用默认的 less<T> 排序规则
        std::set<myString>myset;
        //向 set 容器添加元素，这里会调用 myString 类的构造函数
        myset.emplace("http://c.biancheng.net/stl/");
        myset.emplace("http://c.biancheng.net/c/");
        myset.emplace("http://c.biancheng.net/python/");
        //
        for (auto iter = myset.begin(); iter != myset.end(); ++iter) {
            myString mystr = *iter;
            cout << mystr.getStr() << endl;
        }
        return 0;
    }
    
    http://c.biancheng.net/c/
    http://c.biancheng.net/stl/
    http://c.biancheng.net/python/
    ```

  - 在这个程序中，虽然 myset 容器表面仍采用默认的 std::less<T> 排序规则，但由于我们对其所用的 < 运算符进行了重载，使得 myset 容器内部实则是以字符串的长度为基准，对各个 mystring 类对象进行排序。

  - 上面程序以全局函数的形式实现对 < 运算符的重载，还可以使用成员函数或者友元函数的形式实现。其中，当以成员函数的方式重载 < 运算符时，该成员函数必须声明为 const 类型，且参数也必须为 const 类型：

    ```
    bool operator <(const myString & tempStr) const {
        //以字符串的长度为标准比较大小
        return this->str.length() < tempStr.str.length();
    }
    
    至于参数的传值方式是采用按引用传递还是按值传递，都可以（建议采用按引用传递，效率更高）。
    ```

  - 如果以友元函数的方式重载 < 运算符时，要求参数必须使用 const 修饰：

    ```
    /类中友元函数的定义
    friend bool operator <(const myString &a, const myString &b);
    //类外部友元函数的具体实现
    bool operator <(const myString &stra, const myString &strb) {
        //以字符串的长度为标准比较大小
        return stra.str.length() < strb.str.length();
    }
    ```

- 本节所讲自定义排序规则的方法并不仅仅适用于 set 容器，其它关联式容器（map、multimap、multiset）也同样适用

##### 修改关联式容器中键值对的键

- 对于如何修改容器中某个键值对的键，所有关联式容器可以采用同一种解决思路，即先删除该键值对，然后再向容器中添加修改之后的新键值对。

- 那么，是否可以不删除目标键值对，而直接修改它的键呢？

- 首先可以明确的是，map 和 multimap 容器只能采用“先删除，再添加”的方式修改某个键值对的键。原因很简单，C++ STL 标准中明确规定，map 和 multimap 容器用于存储类型为 pair<const K, V> 的键值对。显然，只要目标键值对存储在当前容器中，键的值就无法被修改。

- 和 map、multimap 不同，C++ STL 标准中并没有用 const 限定 set 和 multiset 容器中存储元素的类型。换句话说，对于 set<T> 或者 multiset<T> 类型的容器，其存储元素的类型是 T 而不是 const T。

- 虽然 C++ STL 标准没有用 const 修饰 set 或者 multiset 容器中元素的类型，但也做了其它工作来限制用户修改容器的元素。例如上面代码中，*iter 会调用 operator，其返回的是一个 const T& 类型元素。这意味着，C++ STL 标准不允许用户借助迭代器来直接修改 set 或者 multiset 容器中的元素。

- 如何才能正确修改 set 或 multiset 容器中的元素呢？最直接的方式就是借助 const_cast 运算符，该运算符可以去掉指针或者引用的 const 限定符。

  ```
  class student {
  public:
      student(string name, int id, int age) :name(name), id(id), age(age) {
      }
      const int& getid() const {
          return id;
      }
      void setname(const string name){
          this->name = name;
      }
      string getname() const{
          return  name;
      }
      void setage(int age){
          this->age = age;
      }
      int getage() const{
          return  age;
      }
  private:
      string name;
      int id;
      int age;
  };
  set<student>::iterator iter = mymap.begin();
  (*iter).setname("xiaoming");
  上面这个修改的代码是错误的，只能用下面这个。
  set<student>::iterator iter = mymap.begin();
  const_cast<student&>(*iter).setname("xiaoming");
  ```

  - set 容器中每个元素也可以看做是键和值相等的键值对，但对于这里的 myset 容器来说，其实每个 student 对象的 id 才是真正的键，其它信息（name 和 age）只不过是和 id 绑定在一起而已。因此，在不破坏 myset 容器中元素的有序性的前提下（即不修改每个学生的 id），学生的其它信息是应该允许修改的，但有一个前提，即 myset 容器中存储的各个 student 对象不能被 const 修饰（这也是 set 容器中的元素类型不能被 const 修饰的原因）。
  - mymap 容器中的 {"zhangsan",10,20} 就变成了 {"xiaoming",10,20}。
  - 虽然使用 const_cast 能直接修改 set 或者 multiset 容器中的元素，但一定不要修改元素的键！如果要修改，只能采用“先删除，再添加”的方式。另外，不要试图以同样的方式修改 map 或者 multimap 容器中键值对的键，这违反了 C++ STL 标准的规定。

- 总的来说，map 和 multimap 容器中元素的键是无法直接修改的，但借助 const_cast，我们可以直接修改 set 和 multiset 容器中元素的非键部分。

### 无序关联式容器

- 无序关联式容器，又称哈希容器。和关联式容器一样，此类容器存储的也是键值对元素；不同之处在于，关联式容器默认情况下会对存储的元素做升序排序，而无序关联式容器不会。

- 和其它类容器相比，无序关联式容器擅长通过指定键查找对应的值，而遍历容器中存储元素的效率不如关联式容器。

- 和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，本教程将二者分开进行讲解，因为它们有本质上的不同：

  - 关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；
  - 无序容器的底层实现采用的是哈希表的存储结构。

- C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。

- 基于底层实现采用了不同的[数据结构](http://c.biancheng.net/data_structure/)，因此和关联式容器相比，无序容器具有以下 2 个特点：

  1. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，
  2. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。

- 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。

  | 无序容器           | 功能                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 |
  | unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。 |
  | unordered_set      | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 |
  | unordered_multiset | 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 |

- 有读者可能会问，既然无序容器和之前所学的关联式容器类似，那么在实际使用中应该选哪种容器呢？总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。

- C++ STL 标准库中，不仅是 unordered_map 容器，所有无序容器的底层实现都采用的是哈希表存储结构。更准确地说，是用“链地址法”（又称“开链法”）解决数据存储位置发生冲突的哈希表

  ![](http://c.biancheng.net/uploads/allimg/200221/1-200221131A4220.gif)
  - 当使用无序容器存储键值对时，会先申请一整块连续的存储空间，但此空间并不用来直接存储键值对，而是存储各个链表的头指针，各键值对真正的存储位置是各个链表的节点。STL 标准库通常选用 vector 容器存储各个链表的头指针。

  - 在 C++ STL 标准库中，将图 1 中的各个链表称为桶（bucket），每个桶都有自己的编号（从 0 开始）。当有新键值对存储到无序容器中时，整个存储过程分为如下几步：

    1. 将该键值对中键的值带入设计好的哈希函数，会得到一个哈希值（一个整数，用 H 表示）；
    2. 将 H 和无序容器拥有桶的数量 n 做整除运算（即 H % n），该结果即表示应将此键值对存储到的桶的编号；
    3. 建立一个新节点存储此键值对，同时将该节点链接到相应编号的桶上。

  - 另外值得一提的是，哈希表存储结构还有一个重要的属性，称为负载因子（load factor）。该属性同样适用于无序容器，用于衡量容器存储键值对的空/满程序，即负载因子越大，意味着容器越满，即各链表中挂载着越多的键值对，这无疑会降低容器查找目标键值对的效率；反之，负载因子越小，容器肯定越空，但并不一定各个链表中挂载的键值对就越少。举个例子，如果设计的哈希函数不合理，使得各个键值对的键带入该函数得到的哈希值始终相同（所有键值对始终存储在同一链表上）。这种情况下，即便增加桶数是的负载因子减小，该容器的查找效率依旧很差。

  - 无序容器中，负载因子的计算方法为：

    ```
    负载因子 = 容器存储的总键值对 / 桶数
    ```

    - 默认情况下，无序容器的最大负载因子为 1.0。如果操作无序容器过程中，使得最大复杂因子超过了默认值，则容器会自动增加桶数，并重新进行哈希，以此来减小负载因子的值。需要注意的是，此过程会导致容器迭代器失效，但指向单个键值对的引用或者指针仍然有效。

  - C++ STL 标准库为了方便用户更好地管控无序容器底层使用的哈希表存储结构，各个无序容器的模板类中都提供表 2 所示的成员方法。

    | 成员方法           | 功能                                                         |
    | ------------------ | ------------------------------------------------------------ |
    | bucket_count()     | 返回当前容器底层存储键值对时，使用桶的数量。                 |
    | max_bucket_count() | 返回当前系统中，unordered_map 容器底层最多可以使用多少个桶。 |
    | bucket_size(n)     | 返回第 n 个桶中存储键值对的数量。                            |
    | bucket(key)        | 返回以 key 为键的键值对所在桶的编号。                        |
    | load_factor()      | 返回 unordered_map 容器中当前的负载因子。                    |
    | max_load_factor()  | 返回或者设置当前 unordered_map 容器的最大负载因子。          |
    | rehash(n)          | 尝试重新调整桶的数量为等于或大于 n 的值。如果 n 大于当前容器使用的桶数，则该方法会是容器重新哈希，该容器新的桶数将等于或大于 n。反之，如果 n 的值小于当前容器使用的桶数，则调用此方法可能没有任何作用。 |
    | reserve(n)         | 将容器使用的桶数（bucket_count() 方法的返回值）设置为最适合存储 n 个元素的桶数。 |
    | hash_function()    | 返回当前容器使用的哈希函数对象。                             |

    - 程序中调用 reverse() 成员方法umap.reserve(9);是 umap 容器的桶数改为了 16，其最适合存储 9 个键值对。从侧面可以看出，一旦负载因子大于 1.0（9/8 > 1.0），则容器所使用的桶数就会翻倍式（8、16、32、...）的增加。

##### unordered_map

- unordered_map 容器在`<unordered_map>`头文件中

- unordered_map 容器模板的定义如下所示：

  ```
  template < class Key,                        //键值对中键的类型
             class T,                          //键值对中值的类型
             class Hash = hash<Key>,           //容器内部存储键值对所用的哈希函数
             class Pred = equal_to<Key>,       //判断各个键值对键相同的规则
             class Alloc = allocator< pair<const Key,T> >  // 指定分配器对象的类型
             > class unordered_map;
  ```

  - 以上 5 个参数中，必须显式给前 2 个参数传值，并且除特殊情况外，最多只需要使用前 4 个参数，各自的含义和功能如表 1 所示。

    | 参数                 | 含义                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | <key,T>              | 前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。 |
    | Hash = hash<Key>     | 用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash<key> 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。 |
    | Pred = equal_to<Key> | 要知道，unordered_map 容器中存储的各个键值对的键是不能相等的，而判断是否相等的规则，就由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to<key> 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。 |

  - 总的来说，当无序容器中存储键值对的键为自定义类型时，默认的哈希函数 hash 以及比较函数 equal_to 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。

###### unordered_map创建

- 创建方法和map一样，就是没有最后那个修改默认比较的方法。

###### 迭代器

- C++ STL 标准库中，unordered_map 容器迭代器的类型为前向迭代器（又称正向迭代器）。这意味着，假设 p 是一个前向迭代器，则其只能进行 *p、p++、++p 操作，且 2 个前向迭代器之间只能用 == 和 != 运算符做比较。

- 在 unordered_map 容器模板中，提供了表 1 所示的成员方法，可用来获取指向指定位置的前向迭代器。

  | 成员方法         | 功能                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | begin()          | 返回指向容器中第一个键值对的正向迭代器。                     |
  | end()            | 返回指向容器中最后一个键值对之后位置的正向迭代器。           |
  | cbegin()         | 和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 |
  | cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 |
  | find(key)        | 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。 |
  | equal_range(key) | 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。 |

  - 值得一提的是，equal_range(key) 很少用于 unordered_map 容器，因为该容器中存储的都是键不相等的键值对，即便调用该成员方法，得到的 2 个迭代器所表示的范围中，最多只包含 1 个键值对。事实上，该成员方法更适用于 unordered_multimap 容器

- 在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。

###### 获取元素

- unordered_map 容器类模板中，实现了对 [ ] 运算符的重载，使得我们可以像“利用下标访问普通数组中元素”那样，通过目标键值对的键获取到该键对应的值。

  - 需要注意的是，如果当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。

    ```
    //创建空 umap 容器
        unordered_map<string, string> umap;
        //[] 运算符在 = 右侧
        string str = umap["STL教程"];
        //[] 运算符在 = 左侧
        umap["C教程"] = "http://c.biancheng.net/c/";
       
        for (auto iter = umap.begin(); iter != umap.end(); ++iter) {
            cout << iter->first << " " << iter->second << endl;
        }
    C教程 http://c.biancheng.net/c/
    STL教程
    ```

  - 可以看到，当使用 [ ] 运算符向 unordered_map 容器中添加键值对时，分为 2 种情况：

    1. 当 [ ] 运算符位于赋值号（=）右侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为键值对要求的值类型的默认值（string 类型默认值为空字符串）；
    2. 当 [ ] 运算符位于赋值号（=）左侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为赋值号右侧的元素。

- unordered_map 类模板中，还提供有 at() 成员方法，和使用 [ ] 运算符一样，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出`out_of_range`异常。程序就挂了

- 通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况：

  1. 当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对；
  2. 当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。

- 除了 find() 成员方法之外，甚至可以借助 begin()/end() 或者 cbegin()/cend()，通过遍历整个容器中的键值对来找到目标键值对。

  ```
  //创建 umap 容器
      unordered_map<string, string> umap{
          {"Python教程","http://c.biancheng.net/python/"},
          {"Java教程","http://c.biancheng.net/java/"},
          {"Linux教程","http://c.biancheng.net/linux/"} };
      //遍历整个容器中存储的键值对
      for (auto iter = umap.begin(); iter != umap.end(); ++iter) {
          //判断当前的键值对是否就是要找的
          if (!iter->first.compare("Java教程")) {
              cout << iter->second << endl;
              break;
          }
          
          compare是string的成员函数
  ```

###### insert

-  insert() 方法可以将 pair 类型的键值对元素添加到 unordered_map 容器中，其语法格式有 2 种：

  ```
  //以普通方式传递参数
  pair<iterator,bool> insert ( const value_type& val );
  //以右值引用的方式传递参数
  template <class P>
      pair<iterator,bool> insert ( P&& val );
  ```

  - 以上 2 种格式中，参数 val 表示要添加到容器中的目标键值对元素；该方法的返回值为 pair类型值，内部包含一个 iterator 迭代器和 bool 变量：

    - 当 insert() 将 val 成功添加到容器中时，返回的迭代器指向新添加的键值对，bool 值为 True；
    - 当 insert() 添加键值对失败时，意味着当前容器中本就存储有和要添加键值对的键相等的键值对，这种情况下，返回的迭代器将指向这个导致插入操作失败的迭代器，bool 值为 False。

    ```
    //创建空 umap 容器
        unordered_map<string, string> umap;
        //构建要添加的键值对
        std::pair<string, string>mypair("STL教程", "http://c.biancheng.net/stl/");
        //创建接收 insert() 方法返回值的pair类型变量
        std::pair<unordered_map<string, string>::iterator, bool> ret;
        //调用 insert() 方法的第一种语法格式
        ret = umap.insert(mypair);
        //调用 insert() 方法的第二种语法格式
        ret = umap.insert(std::make_pair("Python教程","http://c.biancheng.net/python/"));
    ```

- insert() 方法还可以指定新键值对要添加到容器中的位置

  ```
  //以普通方式传递 val 参数
  iterator insert ( const_iterator hint, const value_type& val );
  //以右值引用方法传递 val 参数
  template <class P>
      iterator insert ( const_iterator hint, P&& val );
  ```

  - 以上 2 种语法格式中，hint 参数为迭代器，用于指定新键值对要添加到容器中的位置；val 参数指的是要添加容器中的键值对；方法的返回值为迭代器：

    - 如果 insert() 方法成功添加键值对，该迭代器指向新添加的键值对；
    - 如果 insert() 方法添加键值对失败，则表示容器中本就包含有相同键的键值对，该方法返回的迭代器就指向容器中键相同的键值对；

  - 以上 2 种语法格式中，虽然通过 hint 参数指定了新键值对添加到容器中的位置，但该键值对真正存储的位置，并不是 hint 参数说了算，最终的存储位置仍取决于该键值对的键的值。

    ```
    //创建空 umap 容器
        unordered_map<string, string> umap;
        //构建要添加的键值对
        std::pair<string, string>mypair("STL教程", "http://c.biancheng.net/stl/");
        //创建接收 insert() 方法返回值的迭代器类型变量
        unordered_map<string, string>::iterator iter;
        //调用第一种语法格式
        iter = umap.insert(umap.begin(), mypair);
        //调用第二种语法格式
        iter = umap.insert(umap.begin(),std::make_pair("Python教程", "http://c.biancheng.net/python/"));
    ```

- insert() 方法还支持将某一个 unordered_map 容器中指定区域内的所有键值对，复制到另一个 unordered_map 容器中

  ```
  template <class InputIterator>
      void insert ( InputIterator first, InputIterator last );
  ```

- 除了以上 3 种方式，insert() 方法还支持一次向 unordered_map 容器添加多个键值对，其语法格式如下：

  ```
  void insert ( initializer_list<value_type> il );
  ```

  - il 参数指的是可以用初始化列表的形式指定多个键值对元素。

  ```
  //创建空的 umap 容器
      unordered_map<string, string> umap;
      //向 umap 容器同时添加多个键值对
      umap.insert({ {"STL教程","http://c.biancheng.net/stl/"},
      {"Python教程","http://c.biancheng.net/python/"},
      {"Java教程","http://c.biancheng.net/java/"} });
  ```

###### emplace和emplace_hint

- emplace() 方法

  ```
  template <class... Args>
      pair<iterator, bool> emplace ( Args&&... args );
  ```

  - 其中，参数 args 表示可直接向该方法传递创建新键值对所需要的 2 个元素的值，其中第一个元素将作为键值对的键，另一个作为键值对的值。也就是说，该方法无需我们手动创建键值对，其内部会自行完成此工作。
  - 另外需要注意的是，该方法的返回值为 pair 类型值，其包含一个迭代器和一个 bool 类型值：
    - 当 emplace() 成功添加新键值对时，返回的迭代器指向新添加的键值对，bool 值为 True；
    - 当 emplace() 添加新键值对失败时，说明容器中本就包含一个键相等的键值对，此时返回的迭代器指向的就是容器中键相同的这个键值对，bool 值为 False。

- emplace_hint() 方法:

  ```
  template <class... Args>
      iterator emplace_hint ( const_iterator position, Args&&... args );
  ```

  - 和 emplace() 方法相同，emplace_hint() 方法内部会自行构造新键值对，因此我们只需向其传递构建该键值对所需的 2 个元素（第一个作为键，另一个作为值）即可。不同之处在于：
    - emplace_hint() 方法的返回值仅是一个迭代器，而不再是 pair 类型变量。当该方法将新键值对成功添加到容器中时，返回的迭代器指向新添加的键值对；反之，如果添加失败，该迭代器指向的是容器中和要添加键值对键相同的那个键值对。
    - emplace_hint() 方法还需要传递一个迭代器作为第一个参数，该迭代器表明将新键值对添加到容器中的位置。需要注意的是，新键值对添加到容器中的位置，并不是此迭代器说了算，最终仍取决于该键值对的键的值。

###### 删除元素

- C++ STL 标准库为了方便用户可以随时删除 unordered_map 容器中存储的键值对，unordered_map 容器类模板中提供了以下 2 个成员方法：
  - erase()：删除 unordered_map 容器中指定的键值对；
  - clear()：删除 unordered_map 容器中所有的键值对，即清空容器。
- 为了满足不同场景删除 unordered_map 容器中键值对的需要，此容器的类模板中提供了 3 种语法格式的 erase() 方法。
  -  erase() 方法可以接受一个正向迭代器，并删除该迭代器指向的键值对
  - 我们还可以直接将要删除键值对的键作为参数直接传给 erase() 方法，该方法会自行去 unordered_map 容器中找和给定键相同的键值对，将其删除。
  - 除了支持删除 unordered_map 容器中指定的某个键值对，erase() 方法还支持一次删除指定范围内的所有键值对

##### unordered_multimap

- 使用方法和unordered_map一样，只是能存储键相等的元素

##### unordered_set

- unordered_set 容器具有以下几个特性：

  1. 不再以键值对的形式存储数据，而是直接存储数据的值；
  2. 容器内部存储的各个元素的值都互不相等，且不能被修改。
  3. 不会对内部存储的数据进行排序（这和该容器底层采用哈希表结构存储数据有关

- 对于 unordered_set 容器不以键值对的形式存储数据，读者也可以这样认为，即 unordered_set 存储的都是键和值相等的键值对，为了节省存储空间，该类容器在实际存储时选择只存储每个键值对的值。

- unordered_set 容器的类模板定义如下

  ```
  template < class Key,            //容器中存储元素的类型
             class Hash = hash<Key>,    //确定元素存储位置所用的哈希函数
             class Pred = equal_to<Key>,   //判断各个元素是否相等所用的函数
             class Alloc = allocator<Key>   //指定分配器对象的类型
             > class unordered_set;
  ```

  - 以上 4 个参数中，只有第一个参数没有默认值，这意味着如果我们想创建一个 unordered_set 容器，至少需要手动传递 1 个参数。事实上，在 99% 的实际场景中最多只需要使用前 3 个参数（各自含义如表 1 所示），最后一个参数保持默认值即可。

    | 参数                 | 含义                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | Key                  | 确定容器存储元素的类型，如果读者将 unordered_set 看做是存储键和值相同的键值对的容器，则此参数则用于确定各个键值对的键和值的类型，因为它们是完全相同的，因此一定是同一数据类型的数据。 |
    | Hash = hash<Key>     | 指定 unordered_set 容器底层存储各个元素时，所使用的哈希函数。需要注意的是，默认哈希函数 hash<Key> 只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。 |
    | Pred = equal_to<Key> | unordered_set 容器内部不能存储相等的元素，而衡量 2 个元素是否相等的标准，取决于该参数指定的函数。 默认情况下，使用 STL 标准库中提供的 equal_to<key> 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。 |

  - 如果 unordered_set 容器中存储的元素为自定义的数据类型，则默认的哈希函数 hash<key> 以及比较函数 equal_to<key> 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。

- 此容器模板类中没有重载 [ ] 运算符，也没有提供 at() 成员方法。不仅如此，由于 unordered_set 容器内部存储的元素值不能被修改，因此无论使用那个迭代器方法获得的迭代器，都不能用于修改容器中元素的值。

- 基本方法都一样，包括创建什么的，直接看前面类推就可以了

##### unordered_multiset

- 和 unordered_set 容器不同的是，unordered_multiset 容器可以同时存储多个值相同的元素，且这些元素会存储到哈希表中同一个桶（本质就是链表）上。
- 和 unordered_set 容器一样，unordered_multiset 模板类也没有重载 [ ] 运算符，没有提供 at() 成员方法。不仅如此，无论是由哪个成员方法返回的迭代器，都不能用于修改容器中元素的值。
- 所有的使用方法和前面基本一样

##### 自定义无序容器的哈希函数和排序规则

- 虽然每种无序容器都指定了默认的 hash<key> 哈希函数和 equal_to<key> 比较规则，但它们仅适用于存储基本类型（比如 int、double、float、string 等）数据的无序容器。换句话说，如果无序容器存储的数据类型为自定义的结构体或类，则 STL 标准库提供的 hash<key> 和 equal_to<key> 将不再适用。

- 简单地理解哈希函数，它可以接收一个元素，并通过内部对该元素做再加工，最终会得出一个整形值并反馈回来。需要注意的是，哈希函数只是一个称谓，其本体并不是普通的函数形式，而是一个函数对象类。因此，如果我们想自定义个哈希函数，就需要自定义一个函数对象类。

- 举个例子，假设有如下一个 Person 类：

  ```
  class Person {
  public:
      Person(string name, int age) :name(name), age(age) {};
      string getName() const;
      int getAge() const;
  private:
      string name;
      int age;
  };
  string Person::getName() const {
      return this->name;
  }
  int Person::getAge() const {
      return this->age;
  }
  ```

  - 在此基础上，假设我们想创建一个可存储 Person 类对象的 unordered_set 容器，考虑到 Person 为自定义的类型，因此默认的 hash<key> 哈希函数不再适用，这时就需要以函数对象类的方式自定义一个哈希函数。比如：

    ```
    class hash_fun {
    public:
        int operator()(const Person &A) const {
            return A.getAge();
        }
    };
    
    重载 ( ) 运算符时，其参数必须为 const 类型，且该方法也必须用 const 修饰。
    ```

  - 我们利用 hash_fun 函数对象类的 ( ) 运算符重载方法，自定义了适用于 Person 类对象的哈希函数。该哈希函数每接收一个 Person 类对象，都会返回该对象的 age 成员变量的值。

  - 默认的 hash<key> 哈希函数，其底层也是以函数对象类的形式实现的。

  - 在创建存储 Person 类对象的 unordered_set 容器时，可以将 hash_fun 作为参数传递给该容器模板类中的 Pred 参数：

    ```
    std::unordered_set<Person, hash_fun> myset；
    ```

  - 此时创建的 myset 容器还无法使用，因为该容器使用的是默认的 std::equal_to<key> 比较规则，但此规则并不适用于该容器。

- 和哈希函数一样，无论创建哪种无序容器，都需要为其指定一种可比较容器中各个元素是否相等的规则。值得一提的是，默认情况下无序容器使用的 std::equal_to<key> 比较规则，其本质也是一个函数对象类，底层实现如下：

  ```
  template<class T>
  class equal_to
  {
  public:   
      bool operator()(const T& _Left, const T& _Right) const{
          return (_Left == _Right);
      }   
  };
  ```

  - 可以看到，该规则在底层实现过程中，直接用 == 运算符比较容器中任意 2 个元素是否相等，这意味着，如果容器中存储的元素类型，支持直接用 == 运算符比较是否相等，则该容器可以使用默认的 std::equal_to<key> 比较规则；反之，就不可以使用。
  - 显然，对于我们上面创建的 myset 容器，其内部存储的是 Person 类对象，不支持直接使用 == 运算符做比较。这种情况下，有以下 2 种方式可以解决此问题：
    1. 在 Person 类中重载 == 运算符，这会使得 std::equal_to<key> 比较规则中使用的 == 运算符变得合法，myset 容器就可以继续使用 std::equal_to<key> 比较规则；
    2. 以函数对象类的方式，自定义一个适用于 myset 容器的比较规则。

- 重载==运算符

  ```
  bool operator==(const Person &A, const Person &B) {
      return (A.getAge() == B.getAge());
  }
  这里在重载 == 运算符时，2 个参数必须用 const 修饰。
  ```

  - 可以看到，通过此方式重载的运算符，当 std::equal_to<key> 函数对象类中直接比较 2 个 Person 类对象时，实际上是在比较这 2 个对象的 age 成员变量是否相等。换句话说，此时的 std::equal_to<key> 规则的含义为：只要 2 个 Person对象的 age 成员变量相等，就认为这 2 个 Person 对象是相等的。

  - 重载 == 运算符之后，就能以如下方式创建 myset 容器：

    ```
    std::unordered_set<Person, hash_fun> myset{ {"zhangsan", 40},{"zhangsan", 40},{"lisi", 40},{"lisi", 30} };
    ```

    - 虽然这里给 myset 容器初始化了 4 个 Person 对象，但由于比较规则以各个类对象的 age 值为准，myset 容器会认为前 3 个 Person 对象是相等的，因此最终 myset 容器只会存储 {"zhangsan", 40} 和 {"lisi", 30}。

- 函数对象类自定义比较规则

  - 除此之外，还可以完全舍弃 std::equal_to<key>，以函数对象类的方式自定义一个比较规则。比如：

    ```
    class mycmp {
    public:
        bool operator()(const Person &A, const Person &B) const {
            return (A.getName() == B.getName()) && (A.getAge() == B.getAge());
        }
    };
    ```

  - 在 mycmp 规则的基础上，我们可以像如下这样创建 myset 容器：

    ```
    std::unordered_set<Person, hash_fun, mycmp> myset{ {"zhangsan", 40},{"zhangsan", 40},{"lisi", 40},{"lisi", 30} }
    ```

    - 虽然初始化了 4 个 Person 对象，但 myset 容器根据 mycmp 比较规则，可以识别出前 2 个是相等的，因此最终该容器内部存有 {"zhangsan", 40}、{"lisi", 40} 和 {"lisi", 30} 这 3 个 Person 对象。

### 容器适配器

- 容器适配器是一个封装了**序列容器**的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。

- stack<T>：是一个封装了 deque<T> 容器的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。stack<T> 模板定义在头文件 stack 中。

- queue<T>：是一个封装了 deque<T> 容器的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器。queue<T> 模板定义在头文件 queue 中。

- priority_queue<T>：是一个封装了 vector<T> 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。priority_queue<T> 模板定义在头文件 queue 中。

- 适配器类在基础序列容器的基础上实现了一些自己的操作，显然也可以添加一些自己的操作。它们提供的优势是简化了公共接口，而且提高了代码的可读性。

- 容器适配器详解

  - 其实，容器适配器中的“适配器”，和生活中常见的电源适配器中“适配器”的含义非常接近。我们知道，无论是电脑、手机还是其它电器，充电时都无法直接使用 220V 的交流电，为了方便用户使用，各个电器厂商都会提供一个适用于自己产品的电源线，它可以将 220V 的交流电转换成适合电器使用的低压直流电。从用户的角度看，电源线扮演的角色就是将原本不适用的交流电变得适用，因此其又被称为电源适配器。

  - 再举一个例子，假设一个代码模块 A，它的构成如下所示：

    ```
    class A{
    public:
        void f1(){}
        void f2(){}
        void f3(){}
        void f4(){}
    };
    
    现在我们需要设计一个模板 B，但发现，其实只需要组合一下模块 A 中的 f1()、f2()、f3()，就可以实现模板 B 需要的功能。其中 f1() 单独使用即可，而 f2() 和 f3() 需要组合起来使用，如下所示：
    
    class B{
    private:
        A * a;
    public:
        void g1(){
            a->f1();
        }
        void g2(){
            a->f2();
            a->f3();
        }
    };
    ```

    - 可以看到，就如同是电源适配器将不适用的交流电变得适用一样，模板 B 将不适合直接拿来用的模板 A 变得适用了，因此我们可以将模板 B 称为 B 适配器。

  - 容器适配器也是同样的道理，简单的理解容器适配器，其就是将不适用的序列式容器（包括 vector、deque 和 list）变得适用。容器适配器的底层实现和模板 A、B 的关系是完全相同的，即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。

  - 容器适配器本质上还是容器，只不过此容器模板类的实现，利用了大量其它基础容器模板类中已经写好的成员函数。当然，如果必要的话，容器适配器中也可以自创新的成员函数。

  - 需要注意的是，[STL](http://c.biancheng.net/stl/) 中的容器适配器，其内部使用的基础容器并不是固定的，用户可以在满足特定条件的多个基础容器中自由选择。

- STL 提供了 3 种容器适配器，分别为 stack 栈适配器、queue 队列适配器以及 priority_queue 优先权队列适配器。其中，各适配器所使用的默认基础容器以及可供用户选择的基础容器，如表 1 所示。

  | 容器适配器     | 基础容器筛选条件                                             | 默认使用的基础容器 |
  | -------------- | ------------------------------------------------------------ | ------------------ |
  | stack          | 基础容器需包含以下成员函数：empty()、size()、back()、push_back()、pop_back()，满足条件的基础容器有 vector、deque、list。 | deque              |
  | queue          | 基础容器需包含以下成员函数：empty()、size()、front()、back()、push_back()、pop_front()，满足条件的基础容器有 deque、list。 | deque              |
  | priority_queue | 基础容器需包含以下成员函数：empty()、size()、front()、push_back()、pop_back()，满足条件的基础容器有vector、deque。 | vector             |
  - 不同场景下，由于不同的序列式容器其底层采用的[数据结构](http://c.biancheng.net/data_structure/)不同，因此容器适配器的执行效率也不尽相同。但通常情况下，使用默认的基础容器即可。

##### stack

- stack 适配器的开头端通常称为栈顶。由于数据的存和取只能从栈顶处进行操作，因此对于存取数据，stack 适配器有这样的特性，即每次只能访问适配器中位于最顶端的元素，也只有移除 stack 顶部的元素之后，才能访问位于栈中的元素。

- 栈中存储的元素满足“后进先出（简称LIFO）”的准则，stack 适配器也同样遵循这一准则。

- stack 适配器以模板类 stack<T,Container=deque<T>>（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式

- 创建stack适配器

  - 创建一个不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器：

    ```
    std::stack<int> values;
    ```

  - 上面提到，stack<T,Container=deque<T>> 模板类提供了 2 个参数，通过指定第二个模板类型参数，我们可以使用出 deque 容器外的其它序列式容器，只要该容器支持 empty()、size()、back()、push_back()、pop_back() 这 5 个成员函数即可。

    - 在介绍适配器时提到，序列式容器中同时包含这 5 个成员函数的，有 vector、deque 和 list 这 3 个容器。因此，stack 适配器的基础容器可以是它们 3 个中任何一个。例如，下面展示了如何定义一个使用 list 基础容器的 stack 适配器：

    ```
    std::stack<std::string, std::list<int>> values;
    ```

  - 可以用一个基础容器来初始化 stack 适配器，只要该容器的类型和 stack 底层使用的基础容器类型相同即可

    ```
    std::list<int> values {1, 2, 3};
    std::stack<int,std::list<int>> my_stack (values);
    ```

    - 初始化后的 my_stack 适配器中，栈顶元素为 3，而不是 1。另外在第 2 行代码中，stack 第 2 个模板参数必须显式指定为 list<int>（必须为 int 类型，和存储类型保持一致），否则 stack 底层将默认使用 deque 容器，也就无法用 lsit 容器的内容来初始化 stack 适配器。

  - 还可以用一个 stack 适配器来初始化另一个 stack 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可

    ```
    std::list<int> values{ 1, 2, 3 };
    std::stack<int, std::list<int>> my_stack1(values);
    std::stack<int, std::list<int>> my_stack=my_stack1;
    //std::stack<int, std::list<int>> my_stack(my_stack1);
    ```

  - 第 3、4 种初始化方法中，my_stack 适配器的数据是经过拷贝得来的，也就是说，操作 my_stack 适配器，并不会对 values 容器以及 my_stack1 适配器有任何影响

- stack 是一类存储机制简单、提供成员函数较少的容器。表 1 列出了 stack 容器支持的全部成员函数。

  | 成员函数                     | 功能                                                         |
  | ---------------------------- | ------------------------------------------------------------ |
  | empty()                      | 当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。 |
  | size()                       | 返回 stack 栈中存储元素的个数。                              |
  | top()                        | 返回一个栈顶元素的引用，类型为 T&。如果栈为空，程序会报错。  |
  | push(const T& val)           | 先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。 |
  | push(T&& obj)                | 以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 |
  | pop()                        | 弹出栈顶元素。                                               |
  | emplace(arg...)              | arg... 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。 |
  | swap(stack<T> & other_stack) | 将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 |

##### queue

- 这种存储结构最大的特点是，最先进入 queue 的元素，也可以最先从 queue 中出来，即用此容器适配器存储数据具有“先进先出（简称 "FIFO" ）”的特点，因此 queue 又称为队列适配器。

- 其实，[STL](http://c.biancheng.net/stl/) queue 容器适配器模拟的就是队列这种存储结构，因此对于任何需要用队列进行处理的序列来说，使用 queue 容器适配器都是好的选择。

- queue 容器适配器以模板类 queue<T,Container=deque<T>>（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式

- queue适配器创建

  - 创建一个空的 queue 容器适配器，其底层使用的基础容器选择默认的 deque 容器：

    ```
    std::queue<int> values;
    ```

  - 也可以手动指定 queue 容器适配器底层采用的基础容器类型。通过学习 《[STL容器适配器详解](http://c.biancheng.net/view/6967.html)》一节我们知道，queue 容器适配器底层容器可以选择 deque 和 list。作为 queue 容器适配器的基础容器，其必须提供 front()、back()、push_back()、pop_front()、empty() 和 size() 这几个成员函数，符合条件的序列式容器仅有 deque 和 list。

    ```
    std::queue<int, std::list<int>> values;
    ```

  - 可以用基础容器来初始化 queue 容器适配器，只要该容器类型和 queue 底层使用的基础容器类型相同即可

    ```
    std::deque<int> values{1,2,3};
    std::queue<int> my_queue(values);
    ```

  - 还可以直接通过 queue 容器适配器来初始化另一个 queue 容器适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可

    ```
    std::deque<int> values{1,2,3};
    std::queue<int> my_queue1(values);
    std::queue<int> my_queue(my_queue1);
    //或者使用
    //std::queue<int> my_queue = my_queue1;
    ```

  - 第 3、4 种初始化方法中 my_queue 容器适配器的数据是经过拷贝得来的，也就是说，操作 my_queue 容器适配器中的数据，并不会对 values 容器以及 my_queue1 容器适配器有任何影响；反过来也是如此。

- queue 容器适配器和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同。表 2 罗列了 queue 容器支持的全部成员函数。

  | 成员函数                    | 功能                                                         |
  | --------------------------- | ------------------------------------------------------------ |
  | empty()                     | 如果 queue 中没有元素的话，返回 true。                       |
  | size()                      | 返回 queue 中元素的个数。                                    |
  | front()                     | 返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 |
  | back()                      | 返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 |
  | push(const T& obj)          | 在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 |
  | emplace()                   | 在 queue 的尾部直接添加一个元素。                            |
  | push(T&& obj)               | 以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 |
  | pop()                       | 删除 queue 中的第一个元素。                                  |
  | swap(queue<T> &other_queue) | 将两个 queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 |
  - 和 stack 一样，queue 也没有迭代器，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。

##### priority_queue

- priority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。

- 但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“First in，Largest out”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。

- priority_queue 容器适配器中存储的元素，优先级是如何评定的呢？很简单，每个 priority_queue 容器适配器在创建时，都制定了一种排序规则。根据此规则，该容器适配器中存储的元素就有了优先级高低之分。举个例子，假设当前有一个 priority_queue 容器适配器，其制定的排序规则是按照元素值从大到小进行排序。根据此规则，自然是 priority_queue 中值最大的元素的优先级最高。

- priority_queue 容器适配器为了保证每次从队头移除的都是当前优先级最高的元素，每当有新元素进入，它都会根据既定的排序规则找到优先级最高的元素，并将其移动到队列的队头；同样，当 priority_queue 从队头移除出一个元素之后，它也会再找到当前优先级最高的元素，并将其移动到队头。基于 priority_queue 的这种特性，因此该容器适配器有被称为优先级队列。

- priority_queue 容器适配器的定义如下：

  ```
  template <typename T,
          typename Container=std::vector<T>,
          typename Compare=std::less<T> >
  class priority_queue{
      //......
  }
  ```

  - typename T：指定存储元素的具体类型；
  - typename Container：指定 priority_queue 底层使用的基础容器，默认使用 vector 容器。作为 priority_queue 容器适配器的底层容器，其必须包含 empty()、size()、front()、push_back()、pop_back() 这几个成员函数，[STL](http://c.biancheng.net/stl/) 序列式容器中只有 vector 和 deque 容器符合条件。list不符合，因为插进去要排序，vector满足是因为我们只需要一端就可以，因为插入进去会排序。
  - typename Compare：指定容器中评定元素优先级所遵循的排序规则，默认使用`std::less<T>`按照元素值从大到小进行排序，还可以使用`std::greater<T>`按照元素值从小到大排序，但更多情况下是使用自定义的排序规则。

- 创建priority_queue适配器

  - priority_queue 容器适配器模板位于`<queue>`头文件中

  - 创建一个空的 priority_queue 容器适配器，第底层采用默认的 vector 容器，排序方式也采用默认的 std::less<T> 方法：

    ```
    std::priority_queue<int> values;
    ```

  - 可以使用普通数组或其它容器中指定范围内的数据，对 priority_queue 容器适配器进行初始化：

    ```
    //使用普通数组
    int values[]{4,1,3,2};
    std::priority_queue<int>copy_values(values,values+4);//{4,2,3,1}
    //使用序列式容器
    std::array<int,4>values{ 4,1,3,2 };
    std::priority_queue<int>copy_values(values.begin(),values.end());//{4,2,3,1}
    也可以使用vector和deque
    ```

  - 可以手动指定 priority_queue 使用的底层容器以及排序规则，比如：

    ```
    int values[]{ 4,1,2,3 };
    std::priority_queue<int, std::deque<int>, std::greater<int> >copy_values(values, values+4);//{1,3,2,4}
    ```

    - 事实上，std::less<T> 和 std::greater<T> 适用的场景是有限的，更多场景中我们会使用自定义的排序规则。

- priority_queue 容器适配器提供了表 2 所示的这些成员函数。

  | 成员函数                       | 功能                                                         |
  | ------------------------------ | ------------------------------------------------------------ |
  | empty()                        | 如果 priority_queue 为空的话，返回 true；反之，返回 false。  |
  | size()                         | 返回 priority_queue 中存储元素的个数。                       |
  | top()                          | 返回 priority_queue 中第一个元素的引用形式。                 |
  | push(const T& obj)             | 根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。 |
  | push(T&& obj)                  | 根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。 |
  | emplace(Args&&... args)        | Args&&... args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。 |
  | pop()                          | 移除 priority_queue 容器适配器中第一个元素。                 |
  | swap(priority_queue<T>& other) | 将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 |

  - 和 queue 一样，priority_queue 也没有迭代器，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。

- priority_queue实现自定义排序

  - 无论 priority_queue 中存储的是基础数据类型（int、double 等），还是 string 类对象或者自定义的类对象，都可以使用函数对象的方式自定义排序规则。

    ```
    //函数对象类
    template <typename T>
    class cmp
    {
    public:
        //重载 () 运算符
        bool operator()(T a, T b)
        {
            return a > b;
        }
    };
    int main()
    {
        int a[] = { 4,2,3,5,6 };
        priority_queue<int,vector<int>,cmp<int> > pq(a,a+5);
        while (!pq.empty())
        {
            cout << pq.top() << " ";
            pq.pop();
        }
    ```

  - 通过重载 < 或者 > 运算符修改 std::less<T> 和 std::greater<T> 的排序规则

    ```
    class node {
    public:
        node(int x = 0, int y = 0) :x(x), y(y) {}
        int x, y;
    };
    //新的排序规则为：先按照 x 值排序，如果 x 相等，则按 y 的值排序
    bool operator < (const node &a, const node &b) {
        if (a.x > b.x) return 1;
        else if (a.x == b.x)
            if (a.y >= b.y) return 1;
        return 0;
    }
    ```

    - 也可以以友元函数或者成员函数的方式重载 > 或者 < 运算符。需要注意的是，以成员函数的方式重载 > 或者 < 运算符时，该成员函数必须声明为 const 类型，且参数也必须为 const 类型，至于参数的传值方式是采用按引用传递还是按值传递，都可以（建议采用按引用传递，效率更高）。

    - 将上面程序改为以成员函数的方式重载 < 运算符：

      ```
      class node {
      public:
          node(int x = 0, int y = 0) :x(x), y(y) {}
          int x, y;
          bool operator < (const node &b) const{
              if ((*this).x > b.x) return 1;
              else if ((*this).x == b.x)
                  if ((*this).y >= b.y) return 1;
              return 0;
          }
      };
      ```

    - 在以友元函数的方式重载 < 或者 > 运算符时，要求参数必须使用 const 修饰。例如，将上面程序改为以友元函数的方式重载 < 运算符

      ```
      class node {
      public:
          node(int x = 0, int y = 0) :x(x), y(y) {}
          int x, y;
          friend bool operator < (const node &a, const node &b);
      };
      //新的排序规则为：先按照 x 值排序，如果 x 相等，则按 y 的值排序
      bool operator < (const node &a, const node &b){
          if (a.x > b.x) return 1;
          else if (a.x == b.x)
              if (a.y >= b.y) return 1;
          return 0;
      }
      ```

  - 以函数对象的方式自定义 priority_queue 的排序规则，适用于任何情况；而以重载 > 或者 < 运算符间接实现 priority_queue 自定义排序的方式，仅适用于 priority_queue 中存储的是结构体变量或者类对象（包括 string 类对象）。

- priority_queue 优先级队列之所以总能保证优先级最高的元素位于队头，最重要的原因是其底层采用堆数据结构存储结构。

### 选择最合适的容器

- C++ STL 标准库（以 C++ 11 为准）提供了以下几种容器供我们选择：
  1. 序列式容器：array、vector、deque、list 和 forward_list；
  2. 关联式容器：map、multimap、set 和 multiset；
  3. 无序关联式容器：unordered_map、unordered_multimap、unordered_set 和 unordered_multiset；
  4. 容器适配器：stack、queue 和 priority_queue。
- 根据容器底层采用的是连续的存储空间，还是分散的存储空间（以链表或者树作为存储结构），还可以将上面容器分为如下两类：
  - 采用连续的存储空间：array、vector、deque；
  - 采用分散的存储空间：list、forward_list 以及所有的关联式容器和哈希容器。
  - 这里将 deque 容器归为使用连续存储空间的这一类，是存在争议的。因为 deque 容器底层采用一段一段的连续空间存储元素，但是各段存储空间之间并不一定是紧挨着的。
- 要想选择出适用于该特定场景的最佳容器，需要综合考虑多种实际因素，例如：
  - 是否需要在容器的指定位置插入新元素？如果需要，则只能选择序列式容器，而关联式容器和哈希容器是不行的；
  - 是否对容器中各元素的存储位置有要求？如果没有，则可以考虑使用哈希容器，反之就要避免使用哈希容器；
  - 是否需要使用指定类型的迭代器？举个例子，如果必须是随机访问迭代器，则只能选择 array、vector、deque；如果必须是双向迭代器，则可以考虑 list 序列式容器以及所有的关联式容器；如果必须是前向迭代器，则可以考虑 forward_list 序列式容器以及所有的哈希容器；
  - 当发生新元素的插入或删除操作时，是否要避免移动容器中的其它元素？如果是，则要避开 array、vector、deque，选择其它容器；
  - 容器中查找元素的效率是否为关键的考虑因素？如果是，则应优先考虑哈希容器。

