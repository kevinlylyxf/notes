#### 变量和数据类型

- 十进制小数转换成 N 进制小数采用“乘 N 取整，顺序排列”法。十进制整数转换为 N 进制整数采用“除 N 取余，逆序排列”法。
- 二进制、八进制和十六进制向十进制转换都非常容易，就是“按权相加”。
- 获取某个数据类型的长度可以使用sizeof操作符。如果后面跟的是变量名称，那么可以省略()，如果跟的是数据类型，就必须带上()。sizeof 是C语言中的操作符，不是函数，所以可以不带().
- 八进制使用时以0开头，十六进制使用时以0x开头
- %hd输出short int类型，%d输出int类型，%ld输出long int类型。
- 在符号位中，用0表示正数，1表示负数，如果不希望设置符号位，可以在数据类型前面加上unsigned关键字。unsigned int时可以省略int。无符号输出十进制的d改为u，其他无变化。
- 八进制和十六进制没有输出有符号位数的格式控制符。八进制输出%ho,%o,%lo,十六进制输出%hx,%x,%lx，x如果是大写的时候，表示以大写字母的形式输出十六进制。有符号正数的最高位是 0”这个巧合才使得 %o 和 %x 输出有符号数时不会出错。如果对一个有符号的负数使用 %o 或者 %x 输出，那么结果就会大相径庭
- 整数在内存中存储和运算是以补码的形式进行的。简化硬件电路是有代价的，这个代价就是有符号数在存储和读取时都要进行转化。数的反码是将原码中除符号位以外的所有位（数值位）取反。负数的补码是其反码加 1。数值溢出问题以数值在内存中实际存储的情况然后按输出情况来转换就可以了。0xffffffff 的数值位的原码为 1111 1111 …… 1111 1111，共 32 位，而 int 类型的数值位只有 31 位，所以最高位的 1 会覆盖符号位，数值位只留下 31 个 1。所以输出时为-1。0xffffffff是正数，原码反码补码都是一样的，直接将32位都放到内存中，如果是负数溢出，负数先转换为补码，然后内存中存储几位就要几位，其余的溢出。输出时按内存中的存储值按规定输出。最高位是符号位就看成符号位，不用管赋值时是什么值。
- 计算机规定，1000 0000 这个特殊的补码就表示 -128。1000 0000不能计算反码，前面那个是符号位。如果直接采用原码存储，那么`0000 0000`和`1000 0000`将分别表示`+0`和`-0`。现在可以举一反三推断出最小值和最大值不是对称的。char的最小值-128，最大值127，其他的也一样。

##### 小数存储

- 小数的长度是固定的，float 始终占用4个字节，double 始终占用8个字节。小数的指数形式：aEn 或 aen
  - %f 以十进制形式输出 float 类型；%lf 以十进制形式输出 double 类型；
  - %e 以指数形式输出 float 类型，输出结果中的 e 小写；%E 以指数形式输出 float 类型，输出结果中的 E 大写；
  - %le 以指数形式输出 double 类型，输出结果中的 e 小写；%lE 以指数形式输出 double 类型，输出结果中的 E 大写。

  - %f 和 %lf 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断。将整数赋值给 float 变量时会变成小数。
  - 小数还有一种更加智能的输出方式，就是使用`%g`。%g 会对比小数的十进制形式和指数形式，以最短的方式来输出小数，让输出结果更加简练。所谓最短，就是输出结果占用最少的字符。
  - %g 默认最多保留六位有效数字，包括整数部分和小数部分；%f 和 %e 默认保留六位小数，只包括小数部分。%g 不会在最后强加 0 来凑够有效数字的位数，而 %f 和 %e 会在最后强加 0 来凑够小数部分的位数。
  - %g 和 %lg 分别用来输出 float 类型和 double 类型，并且当以指数形式输出时，`e`小写。%G 和 %lG 也分别用来输出 float 类型和 double 类型，只是当以指数形式输出时，`E`大写。
  - 一个数字，是有默认类型的：对于整数，默认是 int 类型；对于小数，默认是 double 类型。将一个整数赋值给long类型，整数先转化为long类型，然后在赋值。如果不想让数字使用默认的类型，那么可以给数字加上后缀，手动指明类型：在整数后面紧跟 l 或者 L（不区分大小写）表明该数字是 long 类型；在小数后面紧跟 f 或者 F（不区分大小写）表明该数字是 float 类型。
  - 将一个小数赋值给整数类型，就得把小数部分丢掉，只能取整数部分，这会改变数字本来的值。注意是直接丢掉小数部分，而不是按照四舍五入取近似值。

- C语言标准规定，小数在内存中以科学计数法的形式来存储，具体形式为：

  ```
  flt = (-1)^sign × mantissa × base^exponent
  ```

  - flt 是要表示的小数。
  - sign 用来表示 flt 的正负号，它的取值只能是 0 或 1：取值为 0 表示 flt 是正数，取值为 1 表示 flt 是负数。
  - base 是基数，或者说进制，它的取值大于等于 2（例如，2 表示二进制、10 表示十进制、16 表示十六进制……）。数学中常见的科学计数法是基于十进制的，例如 6.93 × 10^13；计算机中的科学计数法可以基于其它进制，例如 1.001 × 2^7就是基于二进制的，它等价于 1001 0000。
  - mantissa 为尾数，或者说精度，是 base 进制的小数，并且 1 ≤ mantissa ＜ base，这意味着，小数点前面只能有一位数字；
  - exponent 为指数，是一个整数，可正可负，并且为了直观一般采用十进制表示。

- 浮点数的存储：各种编译器都将 base 实现为二进制，基数 base 已经确定是二进制了，就不用在内存中体现出来了。这样只需要在内存中存储符号 sign、尾数 mantissa、指数 exponent 这三个不确定的元素就可以了。
  - 符号的存储：像存储 short、int 等普通整数一样，单独分配出一个位（Bit）来，用 0 表示正数，用 1 表示负数。对于 19.625，这一位的值是 0
  - 尾数的存储：采用二进制形式后，尾数部分的取值范围为 1 ≤ mantissa ＜ 2，这意味着：尾数的整数部分一定为 1，是一个恒定的值，这样就无需在内存中提现出来，可以将其直接截掉，只要把小数点后面的二进制数字放入内存中即可。对于 1.0011101，就是把 0011101 放入内存
  - float 的指数部分占用 8 Bits，能表示从 0~255 的值，取其中间值 127，指数在写入内存前先加上127，读取时再减去127，正数负数就显而易见了。19.625 转换后的指数为 4，4+127 = 131，131 换算成二进制为 1000 0011，这就是 19.626 的指数部分在 float 中的最终存储形式。对于 double，中间值为 2^11-1 -1 = 1023。
  
- 浮点数内存分配：float内存分配：符号位1Bits，指数部分8Bits，尾数部分23Bits。double内存分配：符号位1Bits，指数部分11Bits，尾数部分52Bits.

- 浮点数精度问题：对于十进制小数，整数部分转换成二进制使用“展除法”（就是不断除以 2，直到余数为 0），一个有限位数的整数一定能转换成有限位数的二进制。但是小数部分就不一定了，小数部分转换成二进制使用“乘二取整法”（就是不断乘以 2，直到小数部分为 0），一个有限位数的小数并不一定能转换成有限位数的二进制，只有末位是 5 的小数才有可能转换成有限位数的二进制，其它的小数都不行。 2^23=8388608，一共7位，这意味着最多能有7位[有效数字，但是能绝对能保证的为6位，也即float的精度为6~7位。有效数字指的是十进制小数点后几位。有效数字是6位，所以在输出时以十进制输出就是到小数点后6位。对于 double，同理可得，二进制形式的精度为 52~53 位，十进制形式的精度为 15~16 位。

- 当指数 exp 的所有位都为 1 时，不再作为“正常”的浮点数对待：如果此时尾数 mant 的二进制位都为 0，则表示无穷大，根据符号位判断是正无穷还是负无穷。如果此时尾数 mant 的二进制位不全为 0，则表示 NaN（Not a Number），也即这是一个无效的数字，或者该数字未经初始化。

- 与定点数相比，浮点数在精度方面损失不小，但是在取值范围方面增大很多。牺牲精度，换来取值范围，这就是浮点数的整体思想。

- 在C语言中没有专门的字符串类型，我们只能使用[数组](http://c.biancheng.net/cpp/u/c7/)或者[指针](http://c.biancheng.net/cpp/u/c10/)来间接地存储字符串。

##### 编码问题

- 计算机是以二进制的形式来存储数据的，它只认识 0 和 1 两个数字，我们在屏幕上看到的文字，在存储之前都被转换成了二进制（0和1序列），在显示时也要根据二进制找到对应的字符。特定的文字必然对应着固定的二进制，否则在转换时将发生混乱。那么，怎样将文字与二进制对应起来呢？这就需要有一套规范，计算机公司和软件开发者都必须遵守，这样的一套规范就称为字符集（Character Set）或者字符编码（Character Encoding）。可以将字符集理解成一个很大的表格，它列出了所有字符和二进制的对应关系，计算机显示文字或者存储文字，就是一个查表的过程。字符集中也有相应的字节序和对应的编码，不同的字符编码只是将这个字节序转换成其他更方便的字节序。因为如果字符集中的每个符号的字节序不统一的话，将会很乱。
  
- 字符集和字符编码是不同的，例如Unicode是一个字符集，包含了全世界很多种文字，但是编码规范可以有UTF-8，UTF-16,UTF-32集中，字符集是集合，编码是如何将字符集对应到计算机中，这是两个不同的概念。
  
- Unicode 可以使用的编码方案有三种，分别是：
  
  - UTF-8：一种变长的编码方案，使用 1~6 个字节来存储，可以使用一个字节，兼容ASCII。
  - UTF-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；
  - UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。
  
- 有的编码方式采用 1~n 个字节存储，是变长的，例如 UTF-8、GB2312、GBK 等；如果一个字符使用了这种编码方式，我们就将它称为多字节字符，或者窄字符。

- 有的编码方式是固定长度的，不管字符编号大小，始终采用 n 个字节存储，例如 UTF-32、UTF-16 等；如果一个字符使用了这种编码方式，我们就将它称为宽字符。

- Unicode 字符集可以使用窄字符的方式存储，也可以使用宽字符的方式存储；GB2312、GBK、Shift-JIS 等国家编码一般都使用窄字符的方式存储；ASCII 只有一个字节，无所谓窄字符和宽字符。

- C语言规定，对于汉语、日语、韩语等 ASCII 编码之外的单个字符，也就是专门的字符类型，要使用宽字符的编码方式。在真正实现时，微软编译器（内嵌于 Visual Studio 或者 Visual C++ 中）采用 UTF-16 编码，使用 2 个字节存储一个字符，用 unsigned short 类型就可以容纳。GCC、LLVM/Clang（内嵌于 Xcode 中）采用 UTF-32 编码，使用 4 个字节存储字符，用 unsigned int 类型就可以容纳。

- 上述说明c语言只规定单个字符用宽字符编码方式，但是没有说明字符串也用宽字符方式存储，所以在使用字符串时一般用char类型来存储字符串，其使用UTF-8编码来存储，完全可以正常打印输出中文字符串。

- C语言推出了一种新的类型，叫做 **wchar_t**。w 是 wide 的首字母，t 是 type 的首字符，wchar_t 的意思就是宽字符类型。wchar_t 的长度由编译器决定。微软编译器下长度为2，在GCC、LLVM/Clang下长度为4.wchar_t 其实是用 typedef 关键字定义的一个别名。wchar_t 类型位于 <wchar.h> 头文件中

- 要想使用宽字符的编码方式，就得加上`L`前缀，例如`L'A'`、`L'9'`、`L'中'`、`L'国'`、`L'。'。`加上`L`前缀后，所有的字符都将成为宽字符，占用 2 个字节或者 4 个字节的内存，包括 ASCII 中的英文字符。我们将不加`L`前缀的字符称为窄字符，将加上`L`前缀的字符称为宽字符。窄字符使用 ASCII 编码，宽字符使用 UTF-16 或者 UTF-32 编码。

- 宽字符的输出：putwchar、wprintf(宽字符对应的格式控制字符为%lc)。这两个函数输出宽字符，所以里面的变量要使用宽字符。例如putwchar(L'\n');特殊字符也要变成宽字符。

- 另外，在输出宽字符之前还要使用 setlocale 函数进行本地化设置，告诉程序如何才能正确地处理各个国家的语言文化。linux下setlocale(LC_ALL, "zh_CN");windows下setlocale(LC_ALL, "zh-CN");setlocale 函数位于 <locale.h> 头文件中

- 给字符串加上`L`前缀就变成了宽字符串，它包含的每个字符都是宽字符。对应的格式控制符是`%ls`。

  ```c
  #include <wchar.h>
  #include <locale.h>
  int main(){
      wchar_t web_url[] = L"http://c.biancheng.net";
      wchar_t *web_name = L"C语言中文网";
     
      //将本地环境设置为简体中文
      setlocale(LC_ALL, "zh_CN");
      //使用通用的 wprintf 输出宽字符
      wprintf(L"web_url: %ls \nweb_name: %ls\n", web_url, web_name);
      return 0;
  }
  ```

- char类型的窄字符串可以包含中文。对于窄字符串，C语言并没有规定使用哪一种特定的编码，只要选用的编码能够适应当前的环境即可，所以，窄字符串的编码与操作系统和编译器有关。UTF-8 兼容 ASCII，代码中的大部分字符可以用一个字节保存；另外 UTF-8 基于 Unicode，支持全世界的字符，我们编写的代码可以给全球的程序员使用，真正做到技术无国界。常见的 IDE 或者编辑器，例如 Xcode、Sublime Text、Gedit、Vim 等，在创建源文件时一般也默认使用 UTF-8 编码。对于代码中需要被处理的窄字符串（包含中文），不同的编译器差别还是挺大的。不过可以肯定的是，这些字符始终都使用窄字符（多字节字符）编码。正是由于这些字符使用 UTF-8、GBK 等编码，而不是使用 ASCII 编码，所以它们才能包含中文。

- 总结

  - 对于 char 类型的窄字符，始终使用 ASCII 编码。
  - 对于 wchar_t 类型的宽字符和宽字符串，使用 UTF-16 或者 UTF-32 编码，它们都是基于 Unicode 字符集的。
  - 对于 char 类型的窄字符串，微软编译器使用本地编码，GCC、LLVM/Clang 使用和源文件编码相同的编码。
  
- 源文件使用的字符集被称为编码字符集，也就是写代码的时候使用的字符集；程序中的字符或者字符串使用的字符集被称为运行字符集，也就是程序运行后使用的字符集。源文件需要保存到硬盘，或者在网络上传输，使用的编码要尽量节省存储空间，同时要方便跨国交流，所以一般使用 UTF-8，这就是选择编码字符集的标准。程序中的字符或者字符串，在程序运行后必须被载入到内存，才能进行后续的处理，对于这些字符来说，要尽量选用能够提高处理速度的编码，例如 UTF-16 和 UTF-32 编码就能够快速定位（查找）字符。编码字符集是站在存储和传输的角度，运行字符集是站在处理或者操作的角度，所以它们并不一定相同。

- 我们在VIM中写的CPP文件，其源文件编码使用UTF-8编码，其只是源文件在磁盘上的存储方式，而我们说的窄字符和宽字符一般对应于运行时在内存中的存储方式，两者概念是不一样的。源文件中的UTF-8中L代表宽字符，但是源文件看到L就对于UTF-8中的编码值放到磁盘中，L对应UTF-8中的编码，并不是说用UTF-16存储，因为其是源码。宽窄字符是对于gcc这类编译器编译来说的，gcc看到L就知道这是一个宽字符，其在内存中要占用两个字节，所以在编译时为其分配两个字节。所以L在源文件只是一个符号，但是在gcc编译时看见L就知道这是一个宽字符，然后编译时分配两个字节。在真正实现时，微软编译器（内嵌于 Visual Studio 或者 Visual C++ 中）采用 UTF-16 编码，使用 2 个字节存储一个字符，用 unsigned short 类型就可以容纳。GCC、LLVM/Clang（内嵌于 Xcode 中）采用 UTF-32 编码，使用 4 个字节存储字符，用 unsigned int 类型就可以容纳。

- 区域设置（locale），也称作“本地化策略集”、“本地环境”，是表达程序用户地区方面的软件设定。在linux执行`locale`可以查看当前locale设置。可以将locale理解为一系列环境变量。这些环境变量会对日期格式，数字格式，货币格式，字符处理等多个方面产生影响。修改配置文件/etc/default/locale。

- 为什么要使用宽字符和宽字符串，“你好”对应的Unicode分别为"U+4f60"和"U+597d”，对应的UTF-8编码分别为“0xe4 0xbd 0xa0”和“0xe5 0xa5 0xbd”，strlen()函数只管结尾的0字节而不管字符串里存的是什么，所以len是6，也就是“你好”的UFT-8编码的字节数。`printf("%s\n", s);`相当于将“0xe4 0xbd 0xa0”和“0xe5 0xa5 0xbd”6个字节write到当前终端的设备文件，如果当前终端的驱动程序能识别UTF-8编码就能打印汉字，如果当前字符终端的驱动程序不能识别UTF-8就打印不出汉字。宽字符串在编译后可执行文件中以Unicode保存，wchar_t是宽字符类型。在字符常量或者字符串前加L就表示宽字符常量或者宽字符串。所以len是2。wcslen()和strlen()不同，不是见到0字节就结束而是要遇到UCS编码为0的字符才结束。所以对于你好查出来的len是2，这样符合咱们的习惯，这样对于处理一些中文比较方便，所以在一些场合要使用宽字符，和char类型一样，宽字符串也有类似的宽字符串处理函数，这些函数符合咱们的习惯。一般来说程序在内存计算时通常以宽字符编码，存盘或者网络发送则用多字节编码。

- c语言中提供了多字节字符串和宽字符串相互转换的函数。mbstowcs()将多字节字符串转换为宽字符串。wcstombs()将宽字符串转换为多字节字符串。

- printf这类函数，将内存中的数据写进文件中（设备也是文件），他们在内存中是以宽字符编码的，如果设备不支持UTF-16这类宽字符编码，printf进去解析就会出错，所以要设置本地环境，setlocale(LC_ALL, "zh_CN");这样宽字符在从内存向文件中写入文件时就会按照本地环境写入，例如setlocale设置为中文UTF-8编码，这样在写入时就是解码成UTF-8，这样不仅在设备中能正确解析显示，写入普通文件中也是正确的。如果不设置本地环境系统就按默认的来解析，这样就会出错，写上为了保险。窄字符和窄字符串因为都是UTF-8，这种不用解析就可以正确，所以不用设置。

##### 转义字符

- 在C语言中，一个字符除了可以用它的实体（也就是真正的字符）表示，还可以用编码值表示。这种使用编码值来间接地表示字符的方式称为转义字符（Escape Character）。

- 转义字符以`\`或者`\x`开头，以`\`开头表示后跟八进制形式的编码值，以`\x`开头表示后跟十六进制形式的编码值。对于转义字符来说，只能使用八进制或者十六进制。

- 对于 ASCII 编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能用转义字符的形式来表示。不过，直接使用 ASCII 码记忆不方便，也不容易理解，所以，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下：

  | 转义字符 | 意义                                | ASCII码值（十进制） |
  | -------- | ----------------------------------- | ------------------- |
  | \a       | 响铃(BEL)                           | 007                 |
  | \b       | 退格(BS) ，将当前位置移到前一列     | 008                 |
  | \f       | 换页(FF)，将当前位置移到下页开头    | 012                 |
  | \n       | 换行(LF) ，将当前位置移到下一行开头 | 010                 |
  | \r       | 回车(CR) ，将当前位置移到本行开头   | 013                 |
  | \t       | 水平制表(HT)                        | 009                 |
  | \v       | 垂直制表(VT)                        | 011                 |
  | \\'      | 单引号                              | 039                 |
  | \\"      | 双引号                              | 034                 |
  | \\\      | 反斜杠                              | 092                 |

##### 运算说明

- 对除法的说明：
  - 当除数和被除数都是整数时，运算结果也是整数；如果不能整除，那么就直接丢掉小数部分，只保留整数部分，这跟将小数赋值给整数类型是一个道理。
  - 一旦除数和被除数中有一个是小数，那么运算结果也是小数，并且是 double 类型的小数。

- 取余运算说明：
  - C语言中的取余运算只能针对整数，也就是说，% 的两边都必须是整数，不能出现小数
  - 另外，余数可以是正数也可以是负数，由 % 左边的整数决定：
    - 如果 % 左边是正数，那么余数也是正数；
    - 如果 % 左边是负数，那么余数也是负数。100%12=4，100%-12=4，-100%12=-4，-100%-12=-4 
  - 在 printf 中，% 是格式控制符的开头，是一个特殊的字符，不能直接输出；要想输出 %，必须在它的前面再加一个 %，这个时候 % 就变成了普通的字符，而不是用来表示格式控制符了。
- 有时候我们希望对一个变量进行某种运算，然后再把运算结果赋值给变量本身
  - `a = a + 8`相当于用原来 a 的值（也即12）加上 8，再把运算结果（也即20）赋值给 a，此时 a 的值就变成了 20。a = a + 8`可以简写为`a += 8

##### 自增和自减

- 自增自减完成后，会用新值替换旧值，将新值保存在当前变量中。自增自减的结果必须得有变量来接收，所以自增自减只能针对变量，不能针对数字，例如`10++`就是错误的。
- 需要重点说明的是，++ 在变量前面和后面是有区别的：自增和自减很多用在赋值语句上，如果是前自增表示a先进行+1然后在进行表达式的算数和赋值，后自增表示先进行表达式的算数和赋值然后变量在进行自增。
  - ++ 在前面叫做前自增（例如 ++a）。前自增先进行自增运算，再进行其他操作。
  - ++ 在后面叫做后自增（例如 a++）。后自增先进行其他操作，再进行自增运算。

##### 数据类型转换

- 在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。转换的规则如下：

  - 转换按数据长度增加的方向进行，以保证数值不失真，或者精度不降低。例如，int 和 long 参与运算时，先把 int 类型的数据转成 long 类型后再进行运算。
  - 所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。
  - char 和 short 参与运算时，必须先转换成 int 类型。

- 强制类型转换type_name) expression

  ```c
  (float) a;  //将变量 a 转换为 float 类型
  (int)(x+y);  //把表达式 x+y 的结果转换为 int 整型
  (float) 100;  //将数值 100（默认为int类型）转换为 float 类型
  
  #include <stdio.h>
  int main(){
      int sum = 103;  //总数
      int count = 7;  //数目
      double average;  //平均数
      average = (double) sum / count;
      printf("Average is %lf!\n", average);
      return 0;
  }
  ```

  - sum 和 count 都是 int 类型，如果不进行干预，那么`sum / count`的运算结果也是 int 类型，小数部分将被丢弃；虽然是 average 是 double 类型，可以接收小数部分，但是心有余力不足，小数部分提前就被“阉割”了，它只能接收到整数部分，这就导致除法运算的结果严重失真。
  - 既然 average 是 double 类型，为何不充分利用，尽量提高运算结果的精度呢？为了达到这个目标，我们只要将 sum 或者 count 其中之一转换为 double 类型即可。上面的代码中，我们将 sum 强制转换为 double 类型，这样`sum / count`的结果也将变成 double 类型，就可以保留小数部分了，average 接收到的值也会更加精确。
  - `( )`的优先级高于`/`，对于表达式`(double) sum / count`，会先执行`(double) sum`，将 sum 转换为 double 类型，然后再进行除法运算，这样运算结果也是 double 类型，能够保留小数部分。注意不要写作`(double) (sum / count)`，这样写运算结果将是 3.000000，仍然不能保留小数部分。

- 无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。

#### C语言输入输出

##### printf高级用法

- printf() 格式控制符的完整形式如下：

  ```c
  %[flag][width][.precision]type
  
  type 表示输出类型，比如 %d、%f、%c、%lf，type 就分别对应 d、f、c、lf；再如，%-9d中 type 对应 d。
  
  width 表示最小输出宽度，也就是至少占用几个字符的位置；例如，%-9d中 width 对应 9，表示输出结果最少占用 9 个字符的宽度。当输出结果的宽度不足 width 时，以空格补齐（如果没有指定对齐方式，默认会在左边补齐空格）；当输出结果的宽度超过 width 时，width 不再起作用，按照数据本身的宽度来输出。
  
   .precision 表示输出精度，也就是小数的位数。当小数部分的位数大于 precision 时，会按照四舍五入的原则丢掉多余的数字；当小数部分的位数小于 precision 时，会在后面补 0。
   
   另外，.precision 也可以用于整数和字符串，但是功能却是相反的：记得前面有点(.precosion)
  	用于整数时，.precision 表示最小输出宽度。与 width 不同的是，整数的宽度不足时会在左边补 0，而不是补空格。
  	用于字符串时，.precision 表示最大输出宽度，或者说截取字符串。当字符串的长度大于 precision 时，会截掉多余的字符；当字符串的长度小于 precision 时，.precision 就不再起作用。
  
  标志字符	含  义
  -		-表示左对齐。如果没有，就按照默认的对齐方式，默认一般为右对齐。
  +		用于整数或者小数，表示输出符号（正负号）。如果没有，那么只有负数才会输出符号。
  空格	   用于整数或者小数，输出值为正时冠以空格，为负时冠以负号。
  #		对于八进制（%o）和十六进制（%x / %X）整数，# 表示在输出时添加前缀；八进制的前缀是 0，十六进制的前缀是 0x / 0X。
  		对于小数（%f / %e / %g），# 表示强迫输出小数点。如果没有小数部分，默认是不输出小数点的，加上 # 以后，即使没有小数部分也会带上小数点。
   	 
  ```

##### scanf读取从键盘上输入的数据

- 输入函数一般都是带有回显的，意思是输入的时候会在屏幕上显示，这是系统函数，系统设计的，但是也有不回显的函数以及使用场景，例如上下左右就不用回显，这是系统设计。也有的函数没有缓冲区。

- `%p`是一个新的格式控制符，它表示以十六进制的形式（带小写的前缀）输出数据的地址。如果写作`%P`，那么十六进制的前缀也将变成大写

  ```c
  int a = 11;
  printf("%p\n", &a);  结果为0x7fff096ac81c，以十六进制打印地址。
  printf("%p\n", a);  结果为0xb，以十六进制打印变量的值。
  printf("%d\n", &a);  结果为1329505324，以十进制打印变量的地址。
  printf("%x\n", &a); 结果为c98f2d8c，以十六进制打印地址。
      上面的区别就是以%p打印显示结果会以0x开头，以%x打印不会有0x
  如果打印的是地址的话，后面跟的是地址，如果a是一个指针，直接将a传进去就可以了，不用在取地址了
  ```

  

- scanf() 对输入数据之间的空格的处理比较宽松，并不要求空格数严格对应，多几个少几个无所谓，只要有空格就行。

- scanf在输入数据时内容要和控制符完全对应，否则就会出现错误。本质上讲，用户输入的内容都是字符串，scanf() 完成的是从字符串中提取有效数据的过程。scanf("%d is bigger than %d", &a, &b);在输入时   25 is bigger than 11

- 用户每次按下回车键，程序就会认为完成了一次输入操作，scanf() 开始读取用户输入的内容，并根据格式控制字符串从中提取有效数据，只要用户输入的内容和格式控制字符串匹配，就能够正确提取。scanf是在缓冲区里面读取的内容。

- scanf() 不会跳过不符合要求的数据，遇到不符合要求的数据会读取失败，而不是再继续等待用户输入。

- 字符串的两种定义形式，它们分别是：

  ```c
  char str1[] = "http://c.biancheng.net";
  char *str2 = "C语言中文网";
  ```

  - 这两种形式其实是有区别的，第一种形式的字符串所在的内存既有读取权限又有写入权限，第二种形式的字符串所在的内存只有读取权限，没有写入权限。printf()、puts() 等字符串输出函数只要求字符串有读取权限，而 scanf()、gets() 等字符串输入函数要求字符串有写入权限，所以，第一种形式的字符串既可以用于输出函数又可以用于输入函数，而第二种形式的字符串只能用于输出函数。
  - 另外，对于第一种形式的字符串，在`[ ]`里面要指明字符串的最大长度，如果不指明，也可以根据`=`后面的字符串来自动推算，此处，就是根据`"http://c.biancheng.net"`的长度来推算的。但是在前一个例子中，开始我们只是定义了一个字符串，并没有立即给它赋值，所以没法自动推算，只能手动指明最大长度，这也就是为什么一定要写作`char url[30]`，而不能写作`char url[]`的原因。
  - scanf() 读取数据时需要的是数据的地址，整数、小数、单个字符都要加`&`取地址符，这很容易理解；但是对于此处的 url 字符串，我们并没有加 &，这是因为，字符串的名字会自动转换为字符串的地址，所以不用再多此一举加 & 了。
  - scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串

- scanf() 是从标准输入设备（键盘）读取数据，带有行缓冲区的，这让 scanf() 具有了一些独特的“性格”，例如可以连续输入、可以输入多余的数据等。反过来，scanf() 也出现了一些奇怪的行为，例如，有时候两份数据之间有空格会读取失败，而有时候两份数据之间又必须有空格。

- 空白符在大部分情况下都可以忽略，前面的两个例子就是这样。但是当控制字符串不是以格式控制符 %d、%c、%f 等开头时，空白符就不能忽略了，它会参与匹配过程，如果匹配失败，就意味着 scanf() 读取失败了。第二个 scanf() 的开头并不是格式控制符，而是写死的`b`字符，所以不会忽略换行符，而换行符和`b`又不匹配，怎么办呢？没办法，只能读取失败了。

  ```
  scanf("a=%d", &a);
  scanf("b=%d", &b);
  
  a=99↙
  输入a=99，按下回车键，程序竟然运行结束了，只有第一个 scanf() 成功读取了数据，第二个 scanf() 仿佛没有执行一样，根本没有给用户任何机会去输入数据。这是为什么呢？
  第一个 scanf() 执行完后，将 99 赋值给了 a，缓冲区中只剩下一个换行符\n；到了第二个 scanf()，发现缓冲区中有内容，但是又不符合控制字符串的格式，于是尝试忽略这个空白符。注意，这个时候的空白符是不能忽略的，所以就没有办法了，只能读取失败了。
  换行符也会到缓冲区，只是scanf在一些情况下会忽略。
  在这种情况下可以连续写a=99b=89中间不要有空格。
  ```

- 如果和格式控制符匹配不上就会失败放弃匹配，但是如果下面还有scanf，此时下一个scanf直接在缓冲区里面读，跳过失败的这个scanf。

| 格式控制符   | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| %c           | 读取一个单一的字符                                           |
| %hd、%d、%ld | 读取一个十进制整数，并分别赋值给 short、int、long 类型       |
| %ho、%o、%lo | 读取一个八进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型 |
| %hx、%x、%lx | 读取一个十六进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型 |
| %hu、%u、%lu | 读取一个无符号整数，并分别赋值给 unsigned short、unsigned int、unsigned long 类型 |
| %f、%lf      | 读取一个十进制形式的小数，并分别赋值给 float、double 类型    |
| %e、%le      | 读取一个指数形式的小数，并分别赋值给 float、double 类型      |
| %g、%lg      | 既可以读取一个十进制形式的小数，也可以读取一个指数形式的小数，并分别赋值给 float、double 类型 |
| %s           | 读取一个字符串（以空白符为结束）                             |
|              |                                                              |

##### 从键盘输入字符和字符串

- 最容易理解的字符输入函数是 getchar()，它就是`scanf("%c", c)`的替代品，除了更加简洁，没有其它优势了；或者说，getchar() 就是 scanf() 的一个简化版本。从缓冲区中读取一个字符   char c = getchar();
- gets() 是有缓冲区的，每次按下回车键，就代表当前输入结束了，gets() 开始从缓冲区中读取内容，这一点和 scanf() 是一样的。gets() 和 scanf() 的主要区别是：
  - scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。
  - gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。

##### 缓冲区

- 缓冲区（Buffer）又称为缓存（Cache），是内存空间的一部分。也就是说，计算机在内存中预留了一定的存储空间，用来暂时保存输入或输出的数据，这部分预留的空间就叫做缓冲区（缓存）。
- 根据数据刷新（也可以称为清空缓冲区，就是将缓冲区中的数据“倒出”）的时机，可以分为全缓冲、行缓冲、不带缓冲
- 全缓冲：在这种情况下，当缓冲区被填满以后才进行真正的输入输出操作。缓冲区的大小都有限制的，比如 1KB、4MB 等，数据量达到最大值时就清空缓冲区。全缓冲的典型代表是对硬盘文件的读写。在实际开发中，将数据写入文件后，打开文件并不能立即看到内容，只有清空缓冲区，或者关闭文件，或者关闭程序后，才能在文件中看到内容。这种现象，就是缓冲区在作怪。
- 行缓冲：在这种情况下，当在输入或者输出的过程中遇到换行符时，才执行真正的输入输出操作。行缓冲的典型代表就是标准输入设备（也即键盘）和标准输出设备（也即显示器）。printf() 带有行缓冲区，`"C语言中文网"`这几个字符要先放入缓冲区中，而不是立即显示到屏幕上。放入缓冲区以后，程序又暂停了 5 秒，然后执行第二个 printf()，又将`"http://c.biancheng.net\n"`放入了缓冲区。注意最后的换行符`\n`，它会使得缓冲区刷新，将缓冲区中的所有内容都输出到显示器上，所以我们才看到两个 printf() 一起输出。对于 scanf()，不管用户输入多少内容，只要不按下回车键，就不进行真正的读取。这是因为 scanf() 是带有行缓冲的，用户输入的内容会先放入缓冲区，直到用户按下回车键，产生换行符`\n`，才会刷新缓冲区，进行真正的读取。
- 不带缓冲：不带缓冲区，数据就没有地方缓存，必须立即进行输入输出。错误信息输出函数 perror() 也没有缓冲区。错误信息必须刻不容缓、立即、马上显示出来，缓冲区将会增加捕获错误的时间，这是毫无理由的。
- 输入设备：scanf()、getchar()、gets() 就是从输入设备（键盘）上读取内容。对于输入设备，没有缓冲区将导致非常奇怪的行为，比如，我们本来想输入一个整数 947，没有缓冲区的话，输入 9 就立即读取了，根本没有机会输入 47，所以，没有输入缓冲区是不能接受的。Windows、Linux、Mac OS 在实现时都给输入设备带上了行缓冲，所以 scanf()、getchar()、gets() 在每个平台下的表现都一致。但是在某些特殊情况下，我们又希望程序能够立即响应用户按键，例如在游戏中，用户按下方向键人物要立即转向，而且越快越好，这肯定就不能带有缓冲区了。Windows 下特有的 getche() 和 getch() 就是为这种特殊需求而设计的，它们都不带缓冲区。
- 输出设备：printf()、puts()、putchar() 就是向输出设备（显示器）上显示内容。对于输出设备，有没有缓冲区其实影响没有那么大，顶多是晚一会看到内容，不会有功能性的障碍，所以 Windows 和 Linux、Mac OS 采用了不同的方案：
  - Windows 平台下，输出设备是不带缓冲区的；
  - Linux 和 Mac OS 平台下，输出设备带有行缓冲区。
- 所谓刷新缓冲区，就是将缓冲区中的内容送达到目的地。缓冲区的刷新遵循以下的规则：
  - 不管是行缓冲还是全缓冲，缓冲区满时会自动刷新；
  - 行缓冲遇到换行符`\n`时会刷新；
  - 关闭文件时会刷新缓冲区；
  - 程序关闭时一般也会刷新缓冲区，这个是由标准库来保障的；
  - 使用特定的函数也可以手动刷新缓冲区

##### 清空缓冲区

- 在输入输出之前清空（刷新）缓冲区：

  - 对于输出操作，清空缓冲区会使得缓冲区中的所有数据立即显示到屏幕上；很明显，这些数据没有地方存放了，只能输出了。
  - 对于输入操作，清空缓冲区就是丢弃残留字符，让程序直接等待用户输入，避免引发奇怪的行为。

- 清空输出缓冲区：fflush(stdout);所有平台通用

- 清空输入缓冲区：没有一种既简洁明了又适用于所有平台的清空输入缓冲区的方案。只有一种很蹩脚的方案能适用于所有平台，那就是将输入缓冲区中的数据都读取出来，但是却不使用。

  - getchar()清空缓冲区，getchar() 是带有缓冲区的，每次从缓冲区中读取一个字符，包括空格、制表符、换行符等空白符，只要我们让 getchar() 不停地读取，直到读完缓冲区中的所有字符，就能达到清空缓冲区的效果。

    ```c
    while((c = getchar()) != '\n' && c != EOF);
    //该代码不停地使用 getchar() 获取缓冲区中的字符，直到遇见换行符\n或者到达文件结尾才停止。
    scanf("a=%d", &a);
    while((c = getchar()) != '\n' && c != EOF); //在下次读取前清空缓冲区
    scanf("b=%d", &b);  //按下第一个回车键后，只有第一个 scanf() 读取成功了，第二个 scanf() 并没有开始读取，等我们再次输入并按下回车键后，第二个 scanf() 才开始读取，这就符合我们的操作习惯了。如果没有清空缓冲区的语句，按下第一个回车键后，两个 scanf() 都读取了，只是第二个 scanf() 读取失败了
    ```

  - scanf清空缓冲区：scanf() 还有一种高级用法，就是使用类似于正则表达式的通配符，这样它就可以读取所有的字符了，包括空格、换行符、制表符等空白符，不会再忽略它们了。并且，scanf() 还允许把读取到的数据直接丢弃，不用赋值给变量。

    ```
    scanf("%*[^\n]"); scanf("%*c");
    第一个 scanf() 将逐个读取缓冲区中\n之前的其它字符，% 后面的 * 表示将读取的这些字符丢弃，遇到\n字符时便停止读取。此时，缓冲区中尚有一个\n遗留，第二个 scanf() 再将这个\n读取并丢弃，这里的星号和第一个 scanf() 的星号作用相同。由于所有从键盘的输入都是以回车结束的，而回车会产生一个\n字符，所以将\n连同它之前的字符全部读取并丢弃之后，也就相当于清除了输入缓冲区。
    ```

- 其他清空输入缓冲区的方法：fflush(stdin)，但是不太通用，最新的gcc是支持的。

- scanf还有一些高级用法，例如控制读入数据和字符串的长度，匹配特定的字符，丢弃读到的字符，用的时候在看。

  - scanf() 允许我们在`%[ ]`中直接指定某些不能匹配的字符，具体方法就是在不匹配的字符前面加上`^`，匹配和不匹配某些字符不用加%s，只用[]就可以表示匹配字符，知道不符合的就停止。
    - `%[^\n]`表示匹配除换行符以外的所有字符，遇到换行符就停止读取；这样可以得到空格，和gets函数相同
    - `%[^0-9]`表示匹配除十进制数字以外的所有字符，遇到十进制数字就停止读取。

#### 数组

- 数组（Array）就是一些列具有相同类型的数据的集合，这些数据在内存中依次挨着存放，彼此之间没有缝隙。
- C语言数组属于构造数据类型。一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类型。因此按数组元素的类型不同，数组又可分为数值数组、字符数组、指针数组、结构数组等各种类别。
- 矩阵共有 16 个整数，我们为每个整数定义了一个变量，也就是 16 个变量。那么，为了减少变量的数量，让开发更有效率，能不能为多个数据定义一个变量呢？比如，把每一行的整数放在一个变量里面，或者把 16 个整数全部都放在一个变量里面。答案当然是肯定的，办法就是使用数组（Array）。
- 「数组内存是连续的」这一点很重要，所以我使用了一个大标题来强调。连续的内存为[指针](http://c.biancheng.net/c/80/)操作（通过指针来访问数组元素）和内存处理（整块内存的复制、写入等）提供了便利，这使得数组可以作为缓存（临时存储数据的一块内存）使用。
- 二维数组可以看作是由一维数组嵌套而成的；如果一个数组的每个元素又是一个数组，那么它就是二维数组。当然，前提是各个元素的类型必须相同。根据这样的分析，一个二维数组也可以分解为多个一维数组，C语言允许这种分解。例如，二维数组`a[3][4]`可分解为三个一维数组，它们的数组名分别为 a[0]、a[1]、a[2]。这三个一维数组可以直接拿来使用。这三个一维数组都有 4 个元素。
- 数组就是一堆相同数据的集合用了一个变量名，例如int a[3],这时只是上述功能，但是在字符数组中就有差距了，字符数组可以像普通数组那样使用，char a[3],a[1] = 'c',这样使用，这是简单用法，c语言中没有专门存储字符串的类型，只能用字符数组来存储，字符数组存储字符串看上面，但是字符串要以\0作为结束标志来让各种函数容易处理，这样字符数组就成为了字符串，在字符数组中如果要表示字符串，就必须有一个字符来存储\0，这样就带来了一些问题，如果没有\0就会出现各种错误。只要理清字符数组存储字符串就可以了，其余的都是一堆相同数据的集合，公用一个变量名。

##### 字符数组和字符串

- 用来存放字符的数组称为字符数组，字符数组实际上是一系列字符的集合，也就是字符串（String）。在C语言中，没有专门的字符串变量，没有string类型，通常就用一个字符数组来存放一个字符串。
- C语言规定，可以将字符串直接赋值给字符数组，char str[30] = "c.biancheng.net";
- 给字符数组赋值时，我们通常使用这种写法，将字符串一次性地赋值（可以指明数组长度，也可以不指明），而不是一个字符一个字符地赋值。这里需要留意一个坑，字符数组只有在定义时才能将整个字符串一次性地赋值给它，一旦定义完了，就只能一个字符一个字符地赋值了。例如char str[20] ;这样只是定义，以后赋值只能一个一个字符的赋值，可以在定义时赋值，例如上面。
- 在C语言中，字符串总是以`'\0'`作为结尾，所以`'\0'`也被称为字符串结束标志，或者字符串结束符。`'\0'`是 ASCII 码表中的第 0 个字符，英文称为 NUL，中文称为“空字符”。该字符既不能显示，也没有控制功能，输出该字符不会有任何效果，它在C语言中唯一的作用就是作为字符串结束标志。C语言在处理字符串时，会从前往后逐个扫描字符，一旦遇到`'\0'`就认为到达了字符串的末尾，就结束处理。`'\0'`至关重要，没有`'\0'`就意味着永远也到达不了字符串的结尾。由`" "`包围的字符串会自动在末尾添加`'\0'`。例如，`"abc123"`从表面看起来只包含了 6 个字符，其实不然，C语言会在最后隐式地添加一个`'\0'`，这个过程是在后台默默地进行的，所以我们感受不到。
- 需要注意的是，逐个字符地给数组赋值并不会自动添加`'\0'`，当用字符数组存储字符串时，要特别注意`'\0'`，要为`'\0'`留个位置；这意味着，字符数组的长度至少要比字符串的长度大 1。
- 有些时候，程序的逻辑要求我们必须逐个字符地为数组赋值，这个时候就很容易遗忘字符串结束标志`'\0'`
- printf() 输出字符串时，会从第 0 个元素开始往后检索，直到遇见`'\0'`才停止，然后把`'\0'`前面的字符全部输出，这就是 printf() 输出字符串的原理。
- \0的ASCII值为0，所以在字符数组初始化的时候将所有的数组元素赋值为0，即使后面忘了手动加\0也不会出错。
- 字符串长度，就是字符串包含了多少个字符（不包括最后的结束符`'\0'`），在C语言中，我们使用`string.h`头文件中的 strlen() 函数来求字符串的长度

#### 函数

- 函数不能嵌套定义，也就是说，不能在一个函数中定义另外一个函数，必须在所有函数之外定义另外一个函数。main() 也是一个函数定义，也不能在 main() 函数内部定义新函数。

- 原则上讲，实参的类型和数目要与形参保持一致。如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型，例如将 int 类型的实参传递给 float 类型的形参就会发生自动类型转换。

- 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。

- return 语句是提前结束函数的唯一办法。return 后面可以跟一份数据，表示将这份数据返回到函数外面；return 后面也可以不跟任何数据，表示什么也不返回，仅仅用来结束函数。

- 函数内部的局部变量和函数外部的全局变量同名时，在当前函数这个局部作用域中，全局变量会被“屏蔽”，不再起作用。也就是说，在函数内部使用的是局部变量，而不是全局变量。变量的使用遵循就近原则，如果在当前的局部作用域中找到了同名变量，就不会再去更大的全局作用域中查找。另外，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。

- 在程序占用的整个内存中，有一块内存区域叫做栈（Stack），它是专门用来给函数分配内存的，每次调用函数，都会将相关数据压入栈中，包括局部变量、局部数组、形参、寄存器、冗余数据等。栈是针对线程来说的，每个线程都拥有一个栈，如果一个程序包含了多个线程，那么它就拥有多个栈。目前我们编写的程序都是单线程的，所以不必考虑多线程的情况。每次调用函数都会在栈上分配内存，函数调用结束后再释放这一部分内存，内存的分配和释放都是需要时间的。

  ```c
  //反转（逆置）字符串
  char *reverse(char *str) {
      int len = strlen(str);
      if (len > 1) {
          char ctemp = str[0];
          str[0] = str[len - 1];
          str[len - 1] = '\0';  //最后一个字符在下次递归时不再处理
          reverse(str + 1);  //递归调用
          str[len - 1] = ctemp;
      } //每一次函数调用都是一个栈，所以临时变量ctemp在每个栈上不会被覆盖。
  
  ```

#### 指针

- 字符串就是地址，地址就是字符串，在%s输出字符串时，可以只写上字符串，也可以只写字符串地址，不用&
- 所谓指针，也就是内存的地址；所谓指针变量，也就是保存了内存地址的变量。
- 我们将内存中字节的编号称为地址（Address）或[指针](http://c.biancheng.net/c/80/)（Pointer）。地址从 0 开始依次增加，对于 32 位环境，程序能够使用的内存为 4GB，最小的地址为 0，最大的地址为 0XFFFFFFFF。
- C语言用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU 使用。
- 数据和代码都以二进制的形式存储在内存中，计算机无法从格式上区分某块内存到底存储的是数据还是代码。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。
- CPU 只能通过地址来取得内存中的代码和数据，程序在执行过程中会告知 CPU 要执行的代码以及要读写的数据的地址。如果程序不小心出错，或者开发者有意为之，在 CPU 要写入数据时给它一个代码区域的地址，就会发生内存访问错误。这种内存访问错误会被硬件和操作系统拦截，强制程序崩溃，程序员没有挽救的机会。
- CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。
- 变量名和函数名为我们提供了方便，让我们在编写代码的过程中可以使用易于阅读和理解的英文字符串，不用直接面对二进制地址，那场景简直让人崩溃。需要注意的是，虽然变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符，但在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址。
- 数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为指针变量。
- 在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量。
- `*`是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带`*`。而给 p1、p2 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上`*`，后边可以像使用普通变量一样来使用指针变量。也就是说，定义指针变量时必须带`*`，给指针变量赋值时不能带`*`。
- `*`在不同的场景下有不同的作用：`*`可以用在指针变量的定义中，表明这是一个指针变量，以和普通变量区分开；使用指针变量时在前面加`*`表示获取指针指向的数据，或者说表示的是指针指向的数据本身。
- 指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等。数组中的所有元素在内存中是连续排列的，如果一个指针指向了数组中的某个元素，那么加 1 就表示指向下一个元素，减 1 就表示指向上一个元素，这样指针的加减运算就具有了现实的意义
- 一般只对数组进行指针运算p++，对普通变量一般不进行运算，因为会出错。对数组的指针++表示指向下一个数组元素，数组元素占用几个字节就跳几个字节。另外需要说明的是，不能对指针变量进行乘法、除法、取余等其他运算，除了会发生语法错误，也没有实际的含义。

##### 数组指针(指向数组的指针)

- 数组名可以认为是一个指针，它指向数组的第 0 个元素。在C语言中，我们将第 0 个元素的地址称为数组的首地址。sizeof(arr) 会获得整个数组所占用的字节数，sizeof(int) 会获得一个数组元素所占用的字节数，它们相除的结果就是数组包含的元素个数，也即数组长度。`*(arr+i)`这个表达式，arr 是数组名，指向数组的第 0 个元素，表示数组首地址， arr+i 指向数组的第 i 个元素，*(arr+i) 表示取第 i 个元素的数据，它等价于 arr[i]。

- 定义指向数组的指针

  ```c
  int arr[] = { 99, 15, 100, 888, 252 };
  int *p = arr;
  
  arr 本身就是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以int *p = arr;也可以写作int *p = &arr[0];。也就是说，arr、p、&arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。
  数组指针指向的是数组中的一个具体元素，而不是整个数组，所以数组指针的类型和数组元素的类型有关，上面的例子中，p 指向的数组元素是 int 类型，所以 p 的类型必须也是`int *`。
  反过来想，p 并不知道它指向的是一个数组，p 只知道它指向的是一个整数
  数组在内存中只是数组元素的简单排列，没有开始和结束标志，在求数组的长度时不能使用sizeof(p) / sizeof(int)，因为 p 只是一个指向 int 类型的指针，编译器并不知道它指向的到底是一个整数还是一系列整数（数组），所以 sizeof(p) 求得的是 p 这个指针变量本身所占用的字节数，而不是整个数组占用的字节数。
  也就是说，根据数组指针不能逆推出整个数组元素的个数，以及数组从哪里开始、到哪里结束等信息。不像字符串，数组本身也没有特定的结束标志，如果不知道数组的长度，那么就无法遍历整个数组。
  sizeof数组名和sizeof数组指针是不一样的，所以使用时要注意
  
  另外sizeof是占用的字节数，例如char path[512] = "/root"，虽然其只用了五个字节，但是sizeof是path占用的字节数，是512，如果要得到字符串的长度要用strlen(path),这样查出来结果是5，在用snprintf这种函数拷贝时，在用字符长度时要用strlen() + 1
  ```

- 引入数组指针后，我们就有两种方案来访问数组元素了
  - 使用下标：也就是采用 arr[i] 的形式访问数组元素。如果 p 是指向数组 arr 的指针，那么也可以使用 p[i] 来访问数组元素，它等价于 arr[i]。
  - 使用指针：也就是使用 *(p+i) 的形式访问数组元素。另外数组名本身也是指针，也可以使用 *(arr+i) 来访问数组元素，它等价于 *(p+i)。
  - 不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。不同的是，数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素。
  - *p++ 应该理解为 *(p++)，每次循环都会改变 p 的值（p++ 使得 p 自身的值增加），以使 p 指向下一个数组元素。该语句不能写为 *arr++，因为 arr 是常量，而 arr++ 会改变它的值，这显然是错误的。但是可以使用\*(arr+i)

##### 字符串指针

- 除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串

  ```c
  char *str = "http://c.biancheng.net";
  
  char *str;
  str = "http://c.biancheng.net";
  //字符串中的所有字符在内存中是连续排列的，str 指向的是字符串的第 0 个字符；我们通常将第 0  个字符的地址称为字符串的首地址。字符串中每个字符的类型都是char，所以 str 的类型也必须是char *。
  ```

- 它们都可以使用`%s`输出整个字符串，都可以使用`*`或`[ ]`获取单个字符

- 它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。

- 将第二种形式的字符串称为字符串常量，意思很明显，常量只能读取不能写入

  ```c
  #include <stdio.h>
  int main(){
      char *str = "Hello World!";
      str = "I love C!";  //正确
      str[3] = 'P';  //错误
      return 0;
  }//第4行代码是正确的，可以更改指针变量本身的指向；第5行代码是错误的，不能修改字符串中的字符。
  ```

- 在编程过程中如果只涉及到对字符串的读取，那么字符数组和字符串常量都能够满足要求；如果有写入（修改）操作，那么只能使用字符数组，不能使用字符串常量。

- 字符数组的访问形式

  ```c
  char str[20] = "c.biancheng.net";
  char c1 = str[4];
  char c3 = *(str+4);//访问的都是第五个元素，因为数组元素是从0开始的，所以str[4]表示第五个，str指向第一个元素，str+4表示从第一个往后移4个也是第五个
  ```

##### 指针变量作为函数参数

- 在C语言中，函数的参数不仅可以是整数、小数、字符等具体的数据，还可以是指向它们的[指针](http://c.biancheng.net/c/80/)。用指针变量作函数参数可以将函数外部的地址传递到函数内部，使得在函数内部可以操作函数外部的数据，并且这些数据不会随着函数的结束而被销毁。
- 像数组、字符串、动态分配的内存等都是一系列数据的集合，没有办法通过一个参数全部传入函数内部，只能传递它们的指针，在函数内部通过指针来影响这些数据集合。
- 在定义指针数组形参时，不管是`int intArr[6]`还是`int intArr[]`都不会创建一个数组出来，编译器也不会为它们分配内存，实际的数组是不存在的，它们最终还是会转换为`int *intArr`这样的指针。这就意味着，两种形式都不能将数组的所有元素“一股脑”传递进来，大家还得规规矩矩使用数组指针。
- `int intArr[6]`这种形式只能说明函数期望用户传递的数组有 6 个元素，并不意味着数组只能有 6 个元素，真正传递的数组可以有少于或多于 6 个的元素。
- 需要强调的是，不管使用哪种方式传递数组，都不能在函数内部求得数组长度，因为 intArr 仅仅是一个指针，而不是真正的数组，所以必须要额外增加一个参数来传递数组长度。
- 参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。对于像 int、float、char 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行内存拷贝有可能是一个漫长的过程，会严重拖慢程序的效率，为了防止技艺不佳的程序员写出低效的代码，C语言没有从语法上支持数据集合的直接赋值。

##### 指针作为函数返回值

- C语言允许函数的返回值是一个指针（地址），我们将这样的函数称为指针函数
- 用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。
- 前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。

##### 二级指针

- 二级指针作为函数参数的作用:在函数外部定义一个指针p，在函数内给指针赋值，函数结束后对指针p生效，那么我们就需要二级指针。

- 编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 p，编译器使 p = q(但是&p != &q,也就是他们并不在同一块内存地址，只是他们的内容一样，都是a的地址)。如果函数体内的程序修改了p的内容(比如在这里它指向b)。在本例中，p申请了新的内存，只是把 p所指的内存地址改变了(变成了b的地址,但是q指向的内存地址没有影响)，所以在这里并不影响函数外的指针q。

- 指针作为函数参数传进来也是生成了一个指针副本，只是这个副本和外面的指针指向同一块地址，在函数内对指针做的变化不会对函数外的指针指向产生影响。

- 指针作为参数虽然不能改变指向，但是可以改变指向内存的数据内容，例如，不能在函数内让p从a指向b，但是我们可以在函数内改变a的内容，让a从1变为2，这样通过指针可以影响内存数据的内容，但是不能改变指针指向。

- 二级指针就是这个原理，我不改变你的指向，但是我用二级指针改变一级指针里面的内容。

  ```c
  void func(int **p)
  	*p = &b
  ```

  

- 我们代码中以二级指针作为参数比较常见的是，定义了一个指针MyClass *ptr=NULL，在函数内对指针赋值*ptr=malloc(...)，函数结束后指针依然有效.这个时候就必须要用二级指针作为参数func(MyClass **p,...)

##### 空指针NULL以及void指针

- 建议对没有初始化的指针赋值为 NULL，char *str = NULL

- NULL 是“零值、等于零”的意思，在C语言中表示空指针。从表面上理解，空指针是不指向任何数据的指针，是无效指针，程序使用它不会产生效果。

  ```c
   char *str = NULL;
   gets(str);//str是空指针，gets不会对空指针进行操作，这条语句没用，不会等用户输入
  ```

- `void *`表示一个有效指针，它确实指向实实在在的数据，只是数据的类型尚未确定，在后续使用过程中一般要进行强制类型转换。

- C语言动态内存分配函数 malloc() 的返回值就是`void *`类型，在使用时要进行强制类型转换

  ```c
   char *str = (char *)malloc(sizeof(char) * 30);
  ```

##### 数组和指针

- 数组和指针不等价的一个典型案例就是求数组的长度，这个时候只能使用数组名，不能使用数组指针。数组是一系列数据的集合，没有开始和结束标志，p 仅仅是一个指向 int 类型的指针，编译器不知道它指向的是一个整数还是一堆整数，对 p 使用 sizeof 求得的是指针变量本身的长度。也就是说，编译器并没有把 p 和数组关联起来，p 仅仅是一个指针变量，不管它指向哪里，sizeof 求得的永远是它本身所占用的字节数。
- 数组名的本意是表示一组数据的集合，它和普通变量一样，都用来指代一块内存，但在使用过程中，数组名有时候会转换为指向数据集合的指针（地址），而不是表示数据集合本身，这在前面的例子中已经被多次证实。数据集合包含了多份数据，直接使用一个集合没有明确的含义，将数组名转换为指向数组的指针后，可以很容易地访问其中的任何一份数据，使用时的语义更加明确。
- C语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、sizeof 或 & 的操作数时，它才表示整个数组本身，在其他的表达式中，数组名会被转换为指向第 0 个元素的指针（地址）。

##### 指针数组

- 如果一个数组中的所有元素保存的都是[指针](http://c.biancheng.net/c/80/)，那么我们就称它为指针数组。

  ```c
  dataType *arrayName[length];
  [ ]的优先级高于*，该定义形式应该理解为
  dataType *(arrayName[length]);
  括号里面说明arrayName是一个数组，包含了length个元素，括号外面说明每个元素的类型为dataType *
  ```

- 定义指向指针数组的指针：

  ```c
  int *arr[3] = {&a, &b, &c};
  int **parr = arr;
  arr 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针
  parr 是指向数组 arr 的指针，确切地说是指向 arr 第 0 个元素的指针，它的定义形式应该理解为int *(*parr)，括号中的*表示 parr 是一个指针，括号外面的int *表示 parr 指向的数据的类型。arr 第 0 个元素的类型为 int *，所以在定义 parr 时要加两个 *。
  arr[i] 表示获取第 i 个元素的值，该元素是一个指针，还需要在前面增加一个 * 才能取得它指向的数据，也即 *arr[i] 的形式。
  parr+i 表示第 i 个元素的地址，*(parr+i) 表示获取第 i 个元素的值（该元素是一个指针），**(parr+i) 表示获取第 i 个元素指向的数据。
  ```

##### 二维数组指针

- C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。

- C语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 a[0] 包含 a\[0][0-3]

- 为了更好的理解指针和二维数组的关系，我们先来定义一个指向 a 的指针变量 p

  ```c
  int (*p)[4] = a;
  括号中的*表明 p 是一个指针，它指向一个数组，数组的类型为int [4]，这正是 a 所包含的每个一维数组的类型。
  []的优先级高于*，( )是必须要加的，如果赤裸裸地写作int *p[4]，那么应该理解为int *(p[4])，p 就成了一个指针数组，而不是二维数组指针
  对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关，p 指向的数据类型是int [4]，那么p+1就前进 4×4 = 16 个字节，p-1就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，p+1会使得指针指向二维数组的下一行，p-1会使得指针指向数组的上一行。
  数组名 a 在表达式中也会被转换为和 p 等价的指针！
  ```

- 使用指针 p 来访问二维数组中的每个元素:

  - `p`指向数组 a 的开头，也即第 0 行；`p+1`前进一行，指向第 1 行。
  - `*(p+1)`表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素
  - `*(p+1)+1`表示第 1 行第 1 个元素的地址，`*(p+1)`单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；就像一维数组的名字，在定义时或者和 sizeof、& 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。
  - `*(*(p+1)+1)`表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。

- 使用指针遍历二维数组

  ```c
  int main(){
      int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};
      int(*p)[4];
      int i,j;
      p=a;
      for(i=0; i<3; i++){
          for(j=0; j<4; j++) printf("%2d  ",*(*(p+i)+j));
          printf("\n");
      }
      return 0;
  }
  ```

##### 函数指针（指向函数的指针）

- 一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个[指针](http://c.biancheng.net/c/80/)变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。

- 函数指针定义

  ```c
  returnType (*pointerName)(param list);
  returnType 为函数返回值类型，pointerName 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。
  ()的优先级高于*，第一个括号不能省略，如果写作returnType *pointerName(param list);就成了函数原型，它表明函数的返回值类型为returnType *。
  ```

- 指针实现对函数的调用

  ```c
  int max(int a, int b){
      return a>b ? a : b;
  }
  int main(){
      int x, y, maxval;
      //定义函数指针
      int (*pmax)(int, int) = max;  //也可以写作int (*pmax)(int a, int b)
      printf("Input two numbers:");
      scanf("%d %d", &x, &y);
      maxval = (*pmax)(x, y);
      printf("Max value: %d\n", maxval);
      return 0;
  }//上面的pmax其实就是一个指针，可以那样初始化时赋值，也可以pmax = max,这样赋值，因为函数名代表函数的入口地址
  ```
  
  - max的函数名与pmax函数指针都是一样的，即都是函数指针，max函数名是一个函数指针常量，pmax是函数指针变量。
  - 函数名调用如果都得如(*pmax)(10，20)这样，那书写与读起来都是不方便和不习惯的。所以C语言的设计者们才会设计成又可允许pmax(10,20)这种形式地调用（这样方便多了，并与数学中的函数形式一样）。
  - 赋值时，可以写成pmax=&max形式，也可以写成pmax=max。
  - 函数指针变量也可以存入一个数组内。数组的声明方法：int (*fArray[10]) ( int );
  
- typedef定义一个函数指针类型

  ```c
  typedef int (* OnCommandPtr)(PARAMETER_ARRAY &parameters, unsigned int * pAction);
  
  typedef struct __COMMAND_ITEM
  {
  	const char * cnt;
  	OnCommandPtr command; 
  	const char * help;
  	unsigned char belongUser; // -- 0x01 0x02 0x04
  }COMMAND_ITEM;
  ```

  - 这样在定义函数指针时可以直接使用typedef定义的类型，就不用写那么长了

  - 函数指针作为函数的时候时，也不能写那么长，也是使用typedef定义的类型

    ```c
    typedef void(*FunType)(int);
    void callFun(FunType fp,int x);
    ```

- 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。

  - 回调函数机制：
    1、定义一个函数（普通函数即可）；
    2、将此函数的地址注册给调用者；
    3、特定的事件或条件发生时，调用者使用函数指针调用回调函数。

    ```c
    #include <stdio.h>
    typedef int(*callback)(int,int);
    
    int add(int a,int b,callback p){
        return (*p)(a,b);
    }
    
    int add(int a,int b){
        return a+b;
    }
    int main(int argc,char *args[]){
        int res = add(4,2,add);
        printf("%d\n",res);
        return 0;
    }
    
    
    #include <stdio.h>
    typedef int (*callBack)(const void *buffer,size_t size,char *p_out);
    
    void callFunc(callBack consume_bytes, char *p_out) {
        printf("callFunc\n");
        const void *buffer = NULL;
        consume_bytes(buffer,0,p_out); //传入值可以随便填
    }
    
    int callBackFunc(const void *buffer, size_t size, char *p_out){
        printf("callBackFunc\n");
        memset(p_out,0x00,sizeof(char)*100);
        strcpy(p_out,"encoderCallback:this is string.");
        return 1;
    }
    
    int main(int argc,char *args[]){
        char p_out[100];
        callFunc(callBackFunc,p_out);
        printf("%s\n",p_out);
        return 0;
    }
    ```

  - 回调函数在使用时是把函数指针传进来，在回调函数中我们要使用函数指针来调用函数，其中函数指针调用的函数就会传入参数，这个参数就可以是回调函数中除函数指针外其他的参数，也可以是在回调函数中定义的变量，

  - signal中就是使用的回调函数，函数指针就是使用的第一个参数的信号值。因为其具体实现不知道，我觉得应该是signal里面调用了这个函数指针，在回调函数里面传进去的就是第一个参数信号值。

#### 结构体

- 定义结构体时大括号后面的分号不能少struct stu{};

  - 右花括号 } 能代表结尾的就不需要分号

  - ```
    while() 
    {
        //////////
    }  
    在while循环，for循环中，右花括号}，就代表了这个循环结束了，不需要分号辅助
    do 
    { 
         //////////
    }while(); 
    执行语句后，再判断是否执行下一次循环，这里的右花括号}不代表结尾，需要分号辅助
    ```

  - ```
    在结构体的定义中，有这么一种情况
    struct  student
    {
        int age;
        char name[20];
        char sex;
    } yangsir;
    在结构体的定义完成之后 ，可以立马定义一个变量，所以遇到右花括号不一定就是结尾，以分号结尾，辅助编译器不出错
    ```

  - 比较官方的说法是语句、定义不需要分号结尾，声明需要分号结尾。

  - c++中的类也是这样，类定义后可以直接定义一个变量，所以跟结构体一样

- struct stu stu1, stu2;定义了两个变量 stu1 和 stu2，它们都是 stu 类型，都由 5 个成员组成。注意关键字`struct`不能少。

- 也可以在定义结构体的同时定义结构体变量：struct stu{}stu1,stu2;

- 如果只需要 stu1、stu2 两个变量，后面不需要再使用结构体名定义其他变量，那么在定义时也可以不给出结构体名struct{}stu1,stu2;这样做书写简单，但是因为没有结构体名，后面就没法用该结构体定义新的变量。

- 除了可以对成员进行逐一赋值，也可以在定义时整体赋值struct stu{}stu1,stu2 = { "Tom", 12, 18, 'A', 136.5 };不过整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值，这和数组的赋值非常类似。

  ```c
  typedef struct __ERROR_INFO
  {
  	unsigned int error;
  	char desc[256];
  }ERROR_INFO;
  
  static ERROR_INFO g_error_info[] = {
  	{__BUS_ERROR_INVALID_SRC_NODE, "invalid node"},
  	{__BUS_ERROR_INVALID_TOPIC, "invalid topic"},
  	{__BUS_ERROR_INVALID_TOPIC_SESSION, "invalid topic session"},
  	{__BUS_ERROR_FAILED_TO_TOPIC_OWNER, "failed to bind topic"},
  	{__BUS_ERROR_FAILED_GET_MSG, "failed to read message"},
  	{__BUS_ERROR_NODE_ALREADY_EXIST, "node is already exist"},
  	{__BUS_ERROR_NODE_NOT_EXIST, "node is not exist"},
  	{__BUS_ERROR_TOPIC_ALREADY_EXIST, "topic is already exist"},
  	{__BUS_ERROR_TOPIC_NOT_EXIST, "topic is not exist"},
  	{__BUS_ERROR_FAILED_ALLOC, "failed to allocate memory"},
  	{__BUS_ERROR_FAILED_CONNECT, "failed to connect"},
  	{__BUS_ERROR_FAILED_SEND_MSG, "failed to send message"},
  	{__BUS_ERROR_FAILED_RECV_MSG, "failed to receive message"},
  	{__BUS_ERROR_FAILED_SEND_TIMEOUT, "send timeout"},
  	{__BUS_ERROR_FAILED_RECV_TIMEOUT, "receive timeout"},
  	{__BUS_ERROR_FAILED_MSG_MISMATCH, "mismatch message"},
  	{__BUS_ERROR_MISMATCH_LOOP_OBJECT_TYPE, "loop with mismatch object type"},
  	{__BUS_ERROR_DATA_FORMAT, "data format error"},
  };
  ```

  - 上面这种初始化结构体数组的形式是正确的，上面说的只能对成员逐一赋值说的是先用ERROR_INFO定义一个结构体，但是没有定义，然后在后面使用的时候在在{}赋值，这是错误的，但是我们可以在定义结构的时候直接用{}初始化这个结构体变量
  - 上面程序中的这种赋值方法是正确的，结构体数组这是在定义的时候初始化，而且里面的结构体也是在直接定义的时候初始化，这相当于直接定义了n个结构体，并且在定义的时候初始化

  - 结构体里面套结构体初始化方法

    ```c
    struct teacher{
        char *name;
        int age;
        struct address addr;
    };
    
    //先定义结构体变量，再进行定义结构体数组
    struct teacher teacher_one = {"zhangsan",20,{"china","shanghai"}};
    struct teacher teacher_two = {"lisi",25,{"china","hefei"}};
    struct teacher teachers_one [] = {teacher_one,teacher_two};
    
    //在定义结构体数组的时候，直接进行结构体数组的初始化工作
    struct teacher  teachers_two [] = {{"wangwu",30,{"china","tianjin"}},{"zhaoliu",40,		 {"china","jiaozuo"}},{"tianqi",50,{"china","shenzhen"}}};
    
    ```

    

  

- 结构体数组：是指数组中的每个元素都是一个结构体。在实际应用中C语言结构体数组常被用来表示一个拥有相同数据结构的群体，比如一个班的学生、一个车间的职工等。struct stu{}class[5];表示一个班级有五个学生

  - 结构体数组在定义的同时也可以初始化，例如：

    ```c
    struct stu{
        char *name;  //姓名
        int num;  //学号
        int age;  //年龄
        char group;  //所在小组 
        float score;  //成绩
    }class[5] = {
        {"Li ping", 5, 18, 'C', 145.0},
        {"Zhang ping", 4, 19, 'A', 130.5},
        {"He fang", 1, 18, 'A', 148.5},
        {"Cheng ling", 2, 17, 'F', 139.0},
        {"Wang ming", 3, 17, 'B', 144.5}
    };
    ```

    

- 结构体指针：当一个指针变量指向结构体时，我们就称它为结构体指针。

  ```c
  struct 结构体名 *变量名;
  struct stu *pstu = &stu1;
  结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加&
  ```

  - 获取结构体成员

    ```
    (*pointer).memberName
    pointer->memberName
    第一种写法中，.的优先级高于*，(*pointer)两边的括号不能少。如果去掉括号写作*pointer.memberName，那么就等效于*(pointer.memberName)，这样意义就完全不对了。
    第二种写法中，->是一个新的运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接取得结构体成员；这也是->在C语言中的唯一用途。
    ```

  - [结构体数组](http://c.biancheng.net/view/245.html)指针的使用。

    ```
    #include <stdio.h>
    struct stu{
        char *name;  //姓名
        int num;  //学号
        int age;  //年龄
        char group;  //所在小组
        float score;  //成绩
    }stus[] = {
        {"Zhou ping", 5, 18, 'C', 145.0},
        {"Zhang ping", 4, 19, 'A', 130.5},
        {"Liu fang", 1, 18, 'A', 148.5},
        {"Cheng ling", 2, 17, 'F', 139.0},
        {"Wang ming", 3, 17, 'B', 144.5}
    }, *ps;
    int main(){
        //求数组长度
        int len = sizeof(stus) / sizeof(struct stu);
        printf("Name\t\tNum\tAge\tGroup\tScore\t\n");
        for(ps=stus; ps<stus+len; ps++){
            printf("%s\t%d\t%d\t%c\t%.1f\n", ps->name, ps->num, ps->age, ps->group, ps->score);
        }
        return 0;
    }
    
    Name            Num     Age     Group   Score
    Zhou ping       5       18      C       145.0
    Zhang ping      4       19      A       130.5
    Liu fang        1       18      A       148.5
    Cheng ling      2       17      F       139.0
    Wang ming       3       17      B       144.5
    ```

  - 结构体变量名代表的是整个集合本身，作为函数参数时传递的整个集合，也就是所有成员，而不是像数组一样被编译器转换成一个指针。如果结构体成员较多，尤其是成员为数组时，传送的时间和空间开销会很大，影响程序的运行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。

    ```c
    计算全班学生的总成绩、平均成绩和以及 140 分以下的人数。
    #include <stdio.h>
    struct stu{
        char *name;  //姓名
        int num;  //学号
        int age;  //年龄
        char group;  //所在小组
        float score;  //成绩
    }stus[] = {
        {"Li ping", 5, 18, 'C', 145.0},
        {"Zhang ping", 4, 19, 'A', 130.5},
        {"He fang", 1, 18, 'A', 148.5},
        {"Cheng ling", 2, 17, 'F', 139.0},
        {"Wang ming", 3, 17, 'B', 144.5}
    };
    void average(struct stu *ps, int len);
    int main(){
        int len = sizeof(stus) / sizeof(struct stu);
        average(stus, len);
        return 0;
    }
    void average(struct stu *ps, int len){
        int i, num_140 = 0;
        float average, sum = 0;
        for(i=0; i<len; i++){
            sum += (ps + i) -> score;
            if((ps + i)->score < 140) num_140++;
        }
        printf("sum=%.2f\naverage=%.2f\nnum_140=%d\n", sum, sum/5, num_140);
    }
    
    sum=707.50
    average=141.50
    num_140=2
    ```

    

- 枚举类型：在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用，比如一个星期只有七天，一年只有十二个月，一个班每周有六门课程等。`#define`命令虽然能解决问题，但也带来了不小的副作用，导致宏名过多，代码松散，看起来总有点不舒服。C语言提供了一种枚举（Enum）类型，能够列出所有可能的取值，并给它们取一个名字。

  - 枚举类型的定义形式为：

    ```
    enum typeName{ valueName1, valueName2, valueName3, ...... };
    enum是一个新的关键字，专门用来定义枚举类型，这也是它在C语言中的唯一用途；typeName是枚举类型的名字；valueName1, valueName2, valueName3, ......是每个值对应的名字的列表。注意最后的;不能少。
    enum week{ Mon, Tues, Wed, Thurs, Fri, Sat, Sun };
    可以看到，我们仅仅给出了名字，却没有给出名字对应的值，这是因为枚举值默认从 0 开始，往后逐个加 1（递增）；也就是说，week 中的 Mon、Tues ...... Sun 对应的值分别为 0、1 ...... 6。
    我们也可以给每个名字都指定一个值：enum week{ Mon = 1, Tues = 2, Wed = 3, Thurs = 4, Fri = 5, Sat = 6, Sun = 7 };
    更为简单的方法是只给第一个名字指定值：enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };这样枚举值就从 1 开始递增，跟上面的写法是等效的。
    ```

  - 枚举是一种类型，通过它可以定义枚举变量：enum week a, b, c;有了枚举变量，就可以把列表中的值赋给它：enum week a = Mon, b = Wed, c = Sat;

  - 也可以在定义枚举类型的同时定义变量：enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } a, b, c;

  - 枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。

  - 枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。

  - Mon、Tues、Wed 这些名字都被替换成了对应的数字。这意味着，Mon、Tues、Wed 等都不是变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用`&`取得它们的地址。这就是枚举的本质。

  - 我们在《[C语言switch case语句](http://c.biancheng.net/view/1808.html)》一节中讲过，case 关键字后面必须是一个整数，或者是结果为整数的表达式，但不能包含任何变量，正是由于 Mon、Tues、Wed 这些名字最终会被替换成一个整数，所以它们才能放在 case 后面。

##### union

- 结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。

- 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

- 共用体也是一种自定义类型，可以通过它来创建变量

  ```c
  union data{
      int n;
      char ch;
      double f;
  };
  union data a, b, c;
  
  
  union data{
      int n;
      char ch;
      double f;
  } a, b, c;
  
  如果不再定义新的变量，也可以将共用体的名字省略
  union{
      int n;
      char ch;
      double f;
  } a, b, c;
  ```

  ```c
  #include <stdio.h>
  union data{
      int n;
      char ch;
      short m;
  };
  int main(){
      union data a;
      printf("%d, %d\n", sizeof(a), sizeof(union data) );
      a.n = 0x40;
      printf("%X, %c, %hX\n", a.n, a.ch, a.m);
      a.ch = '9';
      printf("%X, %c, %hX\n", a.n, a.ch, a.m);
      a.m = 0x2059;
      printf("%X, %c, %hX\n", a.n, a.ch, a.m);
      a.n = 0x3E25AD54;
      printf("%X, %c, %hX\n", a.n, a.ch, a.m);
     
      return 0;
  }
  
  4, 4
  40, @, 40
  39, 9, 39
  2059, Y, 2059
  3E25AD54, T, AD54
  ```

  - 这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。

- 要想理解上面的输出结果，弄清成员之间究竟是如何相互影响的，就得了解各个成员在内存中的分布。以上面的 data 为例，各个成员在内存中的分布如下：

  ![](http://c.biancheng.net/uploads/allimg/190118/152553G12-0.jpg)

  - 成员 n、ch、m 在内存中“对齐”到一头，对 ch 赋值修改的是前一个字节，对 m 赋值修改的是前两个字节，对 n 赋值修改的是全部字节。也就是说，ch、m 会影响到 n 的一部分数据，而 n 会影响到 ch、m 的全部数据。
  - 为什么不同的机器会有不同的分布情况呢？这跟机器的存储模式有关，我们将在VIP教程《[大端小端以及判别方式](http://c.biancheng.net/view/vip_2036.html)》一节中展开探讨。

- 共用体的应用

  - 共用体在一般的编程中应用较少，在单片机中应用较多。对于 PC 机，经常使用到的一个实例是： 现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：

  | Name        | Num  | Sex  | Profession | Score / Course |
  | ----------- | ---- | ---- | ---------- | -------------- |
  | HanXiaoXiao | 501  | f    | s          | 89.5           |
  | YanWeiMin   | 1011 | m    | t          | math           |
  | LiuZhenTao  | 109  | f    | t          | English        |
  | ZhaoFeiYan  | 982  | m    | s          | 95.0           |

  - f 和 m 分别表示女性和男性，s 表示学生，t 表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。

  - 如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前 4 个成员变量是一样的，第 5 个成员变量可能是 score 或者 course。当第 4 个成员变量的值是 s 的时候，第 5 个成员变量就是 score；当第 4 个成员变量的值是 t 的时候，第 5 个成员变量就是 course。

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #define TOTAL 4  //人员总数
    struct{
        char name[20];
        int num;
        char sex;
        char profession;
        union{
            float score;
            char course[20];
        } sc;
    } bodys[TOTAL];
    int main(){
        int i;
        //输入人员信息
        for(i=0; i<TOTAL; i++){
            printf("Input info: ");
            scanf("%s %d %c %c", bodys[i].name, &(bodys[i].num), &(bodys[i].sex), &(bodys[i].profession));
            if(bodys[i].profession == 's'){  //如果是学生
                scanf("%f", &bodys[i].sc.score);
            }else{  //如果是老师
                scanf("%s", bodys[i].sc.course);
            }
            fflush(stdin);
        }
        //输出人员信息
        printf("\nName\t\tNum\tSex\tProfession\tScore / Course\n");
        for(i=0; i<TOTAL; i++){
            if(bodys[i].profession == 's'){  //如果是学生
                printf("%s\t%d\t%c\t%c\t\t%f\n", bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.score);
            }else{  //如果是老师
                printf("%s\t%d\t%c\t%c\t\t%s\n", bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.course);
            }
        }
        return 0;
    }
    
    Input info: HanXiaoXiao 501 f s 89.5↙
    Input info: YanWeiMin 1011 m t math↙
    Input info: LiuZhenTao 109 f t English↙
    Input info: ZhaoFeiYan 982 m s 95.0↙
    
    Name            Num     Sex     Profession      Score / Course
    HanXiaoXiao     501     f       s               89.500000
    YanWeiMin       1011    m       t               math
    LiuZhenTao      109     f       t               English
    ZhaoFeiYan      982     m       s               95.000000
    ```

    

##### 大端小端模式

- 大端和小端是指数据在内存中的存储模式，它由 CPU 决定：
  1) 大端模式（Big-endian）是指将数据的低位（比如 1234 中的 34 就是低位）放在内存的高地址上，而数据的高位（比如 1234 中的 12 就是高位）放在内存的低地址上。这种存储模式有点儿类似于把数据当作字符串顺序处理，地址由小到大增加，而数据从高位往低位存放。

  2) 小端模式（Little-endian）是指将数据的低位放在内存的低地址上，而数据的高位放在内存的高地址上。这种存储模式将地址的高低和数据的大小结合起来，高地址存放数值较大的部分，低地址存放数值较小的部分，这和我们的思维习惯是一致，比较容易理解。

- 只有int long这种占用几个字节的在进行传输时要注意字节序的问题，否则拿到的数据就是错误的。char类型这种不用，一次也就处理一个字节，所以一个读一个，但是int类型一次读4个字节，所以会产生这种问题。字符串也是一个一个字节处理的，所以不用特殊处理，只有这种多字节的数据类型才会。

- 结构体这种不能统一转换为网络字节序，里面的数据每一个都要单独转换，因为数据是按照字节来读取的。统一的转换不能代表所有的内部数据的字节序转换。

- 计算机中的数据是以字节（Byte）为单位存储的，每个字节都有不同的地址。现代 CPU 的位数（可以理解为一次能处理的数据的位数）都超过了 8 位（一个字节），PC机、服务器的 CPU 基本都是 64 位的，嵌入式系统或单片机系统仍然在使用 32 位和 16 位的 CPU。

  对于一次能处理多个字节的CPU，必然存在着如何安排多个字节的问题，也就是大端和小端模式。以 int 类型的 0x12345678 为例，它占用 4 个字节，如果是小端模式（Little-endian），那么在内存中的分布情况为（假设从地址 0x 4000 开始存放）：

  | 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
  | -------- | ------ | ------ | ------ | ------ |
  | 存放内容 | 0x78   | 0x56   | 0x34   | 0x12   |


  如果是大端模式（Big-endian），那么分布情况正好相反：

| 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
| -------- | ------ | ------ | ------ | ------ |
| 存放内容 | 0x12   | 0x34   | 0x56   | 0x78   |

##### 位域

- 有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做位域的[数据结构](http://c.biancheng.net/data_structure/)。

- 在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（Bit），这就是位域。

  ```
  struct bs{
      unsigned m;
      unsigned n: 4;
      unsigned char ch: 6;
  };
  ```

  - `:`后面的数字用来限定成员变量占用的位数。成员 m 没有限制，根据数据类型即可推算出它占用 4 个字节（Byte）的内存。成员 n、ch 被`:`后面的数字限制，不能再根据数据类型计算长度，它们分别占用 4、6 位（Bit）的内存。

  - n、ch 的取值范围非常有限，数据稍微大些就会发生溢出

    ```
    int main(){
        struct bs{
            unsigned m;
            unsigned n: 4;
            unsigned char ch: 6;
        } a = { 0xad, 0xE, '$'};
        //第一次输出
        printf("%#x, %#x, %c\n", a.m, a.n, a.ch);
        //更改值后再次输出
        a.m = 0xb8901c;
        a.n = 0x2d;
        a.ch = 'z';
        printf("%#x, %#x, %c\n", a.m, a.n, a.ch);
    
    0xad, 0xe, $
    0xb8901c, 0xd, :
    ```

  - 对于 n 和 ch，第一次输出的数据是完整的，第二次输出的数据是残缺的。第一次输出时，n、ch 的值分别是 0xE、0x24（'$' 对应的 ASCII 码为 0x24），换算成二进制是 1110、10 0100，都没有超出限定的位数，能够正常输出。第二次输出时，n、ch 的值变为 0x2d、0x7a（'z' 对应的 ASCII 码为 0x7a），换算成二进制分别是 10 1101、111 1010，都超出了限定的位数。超出部分被直接截去，剩下 1101、11 1010，换算成十六进制为 0xd、0x3a（0x3a 对应的字符是 :）。

- C语言标准规定，位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度，`:`后面的数字不能超过这个长度。例如上面的 bs，n 的类型是 unsigned int，长度为 4 个字节，共计 32 位，那么 n 后面的数字就不能超过 32；ch 的类型是 unsigned char，长度为 1 个字节，共计 8 位，那么 ch 后面的数字就不能超过 8。

- 我们可以这样认为，位域技术就是在成员变量所占用的内存中选出一部分位宽来存储数据。

- C语言标准还规定，只有有限的几种数据类型可以用于位域。在 ANSI C 中，这几种数据类型是 int、signed int 和 unsigned int（int 默认就是 signed int）；到了 C99，_Bool 也被支持了。但编译器在具体实现时都进行了扩展，额外支持了 char、signed char、unsigned char 以及 enum 类型，所以上面的代码虽然不符合C语言标准，但它依然能够被编译器支持。

- 位域的存储：

  - C语言标准并没有规定位域的具体存储方式，不同的编译器有不同的实现，但它们都尽量压缩存储空间。位域的具体存储规则如下：

  - 当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof 大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。

    ```
    int main(){
        struct bs{
            unsigned m: 6;
            unsigned n: 12;
            unsigned p: 4;
        };
        printf("%d\n", sizeof(struct bs));
        
    运行结果4
    ```

    - m、n、p 的类型都是 unsigned int，sizeof 的结果为 4 个字节（Byte），也即 32 个位（Bit）。m、n、p 的位宽之和为 6+12+4 = 22，小于 32，所以它们会挨着存储，中间没有缝隙。sizeof(struct bs) 的大小之所以为 4，而不是 3，是因为要将内存对齐到 4 个字节，以便提高存取效率
    - 如果将成员 m 的位宽改为 22，那么输出结果将会是 8，因为 22+12 = 34，大于 32，n 会从新的位置开始存储，相对 m 的偏移量是 sizeof(unsigned int)，也即 4 个字节。
    - 如果再将成员 p 的位宽也改为 22，那么输出结果将会是 12，三个成员都不会挨着存储。

  - 当相邻成员的类型不同时，不同的编译器有不同的实现方案，[GCC](http://c.biancheng.net/gcc/) 会压缩存储，而 VC/VS 不会。

    ```
    int main(){
        struct bs{
            unsigned m: 12;
            unsigned char ch: 4;
            unsigned p: 4;
        };
        printf("%d\n", sizeof(struct bs));
    ```

    - 在 GCC 下的运行结果为 4，三个成员挨着存储；在 VC/VS 下的运行结果为 12，三个成员按照各自的类型存储（与不指定位宽时的存储方式相同）。
    - m 、ch、p 的长度分别是 4、1、4 个字节，共计占用 9 个字节内存，为什么在 VC/VS 下的输出结果却是 12 呢？这个疑问将在《[C语言和内存](http://c.biancheng.net/c/140/)》专题的《[C语言内存对齐，提高寻址效率](http://c.biancheng.net/view/vip_2093.html)》一节中为您解开。

  - 如果成员之间穿插着非位域成员，那么不会进行压缩。

    ```
    struct bs{
        unsigned m: 12;
        unsigned ch;
        unsigned p: 4;
    };
    ```

    - 在各个编译器下 sizeof 的结果都是 12。

- 通过上面的分析，我们发现位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用`&`获取位域成员的地址是没有意义的，C语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号。

- 无名位域，位域成员可以没有名称，只给出数据类型和位宽

  ```
  struct bs{
      int m: 12;
      int  : 20;  //该位域成员不能使用
      int n: 4;
  };
  ```

  - 无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。
  - 上面的例子中，如果没有位宽为 20 的无名成员，m、n 将会挨着存储，sizeof(struct bs) 的结果为 4；有了这 20 位作为填充，m、n 将分开存储，sizeof(struct bs) 的结果为 8。

##### 位运算

- C语言提供了六种位运算符，位运算是按数据在内存中的实际存储情况来进行运算的。
- 按位与&，按位与运算通常用来对某些位清 0，或者保留某些位。
- 按位或|，按位或运算可以用来将某些位置 1，或者保留某些位。
- 按位异或^，参与`^`运算两个二进制位不同时，结果为 1，相同时结果为 0，按位异或运算可以用来将某些二进制位反转。例如要把 n 的高 16 位反转，保留低 16 位，可以进行n ^ 0XFFFF0000运算
- 取反运算~，
- 左移运算<<，左移运算符`<<`用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补0。9<<3，表示9左移3位。如果数据较小，被丢弃的高位不包含 1，那么左移 n 位相当于乘以 2 的 n 次方。
- 右移运算>>，右移运算符`>>`用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。如果被丢弃的低位不包含 1，那么右移 n 位相当于除以 2 的 n 次方（但被移除的位中经常会包含 1）。
- 对称加密算法，加密和解密使用同一个密钥。
- 如果加密和解密的密钥不同，则称为非对称加密算法。在非对称算法中，加密的密钥称为公钥，解密的密钥称为私钥，只知道公钥是无法解密的，还必须知道私钥。

#### 重要知识点

##### typedef

- 使用关键字 **typedef** 可以为类型起一个新的别名。typedef 的用法一般为：

  ```c
  typedef  oldName  newName;
  ```

- 给数组定义别名：

  ```c
  typedef char ARRAY20[20];
  表示 ARRAY20 是类型char [20]的别名。它是一个长度为 20 的数组类型。接着可以用 ARRAY20 定义数组：
      ARRAY20 a1, a2, s1, s2;
  它等价于：
  char a1[20], a2[20], s1[20], s2[20];
  注意，数组也是有类型的。例如char a1[20];定义了一个数组 a1，它的类型就是 char [20]
  ```

- 为结构体定义别名

  ```c
  typedef struct stu{}STU;
  ```

- 为指针类型定义别名

  ```c
  typedef int (*PTR_TO_ARR)[4];
  表示 PTR_TO_ARR 是类型int * [4]的别名，它是一个二维数组指针类型。接着可以使用 PTR_TO_ARR 定义二维数组指针：
  PTR_TO_ARR p1, p2;
  ```

- 为函数指针定义别名：

  ```c
  typedef int (*PTR_TO_FUNC)(int, int);
  PTR_TO_FUNC pfunc;
  ```

- 需要强调的是，typedef 是赋予现有类型一个新的名字，而不是创建新的类型。为了“见名知意”，请尽量使用含义明确的标识符，并且尽量大写。
- 在连续定义几个变量的时候，typedef 能够保证定义的所有变量均为同一类型，而 #define 则无法保证

##### const

- 有时候我们希望定义这样一种变量，它的值不能被改变，在整个作用域中都保持固定，可以使用`const`关键字对变量加以限定

  ```c
  const int MaxNum = 100; 
  这样 MaxNum 的值就不能被修改了，任何对 MaxNum 赋值的行为都将引发错误
      MaxNum = 90;  //错误，试图向 const 变量写入数据
  ```

- 由于常量一旦被创建后其值就不能再改变，所以常量必须在定义的同时赋值（初始化），后面的任何赋值行为都将引发错误。一如既往，初始化常量可以使用任意形式的表达式，可以使用函数，变量初始化。

- const和指针：

  ```c
  const int *p1;
  int const *p2;//这种写法和第一种含义相同，一般情况下用第一种。
  int * const p3;
  在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。
  const 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。
  ```

- const和函数形参：在C语言中，单独定义 const 变量没有明显的优势，完全可以使用`#define`命令代替。const 通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 const 来限制。

  ```c
  size_t strlen ( const char * str );
  int strcmp ( const char * str1, const char * str2 );
  char * strcat ( char * destination, const char * source );
  char * strcpy ( char * destination, const char * source );
  int system (const char* command);
  int puts ( const char * str );
  int printf ( const char * format, ... );//一些函数的原型
  ```

- const和非const类型转换：当一个指针变量 str1 被 const 限制时，并且类似`const char *str1`这种形式，说明指针指向的数据不能被修改；如果将 str1 赋值给另外一个未被 const 修饰的指针变量 str2，就有可能发生危险。因为通过 str1 不能修改数据，而赋值后通过 str2 能够修改数据了，意义发生了转变，所以编译器不提倡这种行为，会给出错误或警告。也就是说，`const char *`和`char *`是不同的类型，不能将`const char *`类型的数据赋值给`char *`类型的变量。但反过来是可以的，编译器允许将`char *`类型的数据赋值给`const char *`类型的变量。这种限制很容易理解，`char *`指向的数据有读取和写入权限，而`const char *`指向的数据只有读取权限，降低数据的权限不会带来任何问题，但提升数据的权限就有可能发生危险。C语言标准库中很多函数的参数都被 const 限制了，但我们在以前的编码过程中并没有注意这个问题，经常将非 const 类型的数据传递给 const 类型的形参，这样做从未引发任何副作用，原因就是上面讲到的，将非 const 类型转换为 const 类型是允许的。

##### c语言随机数

- 在C语言中，我们一般使用 <stdlib.h> 头文件中的 rand() 函数来生成随机数，int rand(void);rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。RAND_MAX 是 <stdlib.h> 头文件中的一个宏，它用来指明 rand() 所能返回的随机数的最大值。C语言标准并没有规定 RAND_MAX 的具体数值，只是规定它的值至少为 32767。在实际编程中，我们也不需要知道 RAND_MAX 的具体值，把它当做一个很大的数来对待即可。

- 随机数的本质：rand() 函数产生的随机数是伪随机数，是根据一个数值按照某个公式推算出来的，这个数值我们称之为“种子”。种子和随机数之间的关系是一种正态分布。种子在每次启动计算机时是随机的，但是一旦计算机启动以后它就不再变化了；也就是说，每次启动计算机以后，种子就是定值了，所以根据公式推算出来的结果（也就是生成的随机数）就是固定的。

- 重新播种：我们可以通过 srand() 函数来重新“播种”，这样种子就会发生改变

  ```c
  void srand (unsigned int seed);
  它需要一个 unsigned int 类型的参数。在实际开发中，我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同。
  使用 <time.h> 头文件中的 time() 函数即可得到当前的时间（精确到秒）
  srand((unsigned)time(NULL));
  ```

- 用取模的方法产生一定范围内的随机数：

  ```c
  int a = rand() % 10;    //产生0~9的随机数，注意10会被整除
  int a = rand() % 51 + 13;    //产生13~63的随机数
  ```

- 连续生成随机数时需要注意：for 循环运行速度非常快，在一秒之内就运行完成了，而 time() 函数得到的时间只能精确到秒，所以每次循环得到的时间都是一样的，这样一来，种子也就是一样的，随机数也就一样了。

#### 预处理命令

- 以#开头的命令为预处理命令，编译器会将预处理的结果保存到和源文件同名的`.i`文件中

- 在头文件中定义定义函数和全局变量，这种认知是原则性的错误！不管是标准头文件，还是自定义头文件，都只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误。

- #define可以只定义宏名，例如头文件保护中只定义宏名，ifdef和ifndef用的也是类似的。在Makefile中我们可以通过宏定义来控制源程序的编译。只要在Makefile中的CFLAGS中通过选项-D来指定预定义的宏即可。此时作用在预编译阶段，在源文件中可以根据宏名来使用函数。

- \#define 叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。

  ```c
  #define  宏名  字符串   //#表示这是一条预处理命令，所有的预处理命令都以 # 开头。宏名是标识符的一种，命名规则和变量相同。字符串可以是数字、表达式、if 语句、函数等。这里所说的字符串是一般意义上的字符序列，不要和C语言中的字符串等同，它不需要双引号。
  ```

  - 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单粗暴的替换。字符串中可以含任何字符，它可以是常数、表达式、if 语句、函数等，预处理程序对它不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现。
  - 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。
  - 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用`#undef`命令。
  - 代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替
  - 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。
  - 可用宏定义表示数据类型，使书写方便。`#define UINT unsigned int`
  - 注意宏定义和typedef连续定义时的区别，PIN a，b ；在这种情况下，两种不一样，typedef是数据类型可以直接用，宏定义会出现错误。

- C语言允许宏带有参数。在宏定义中的参数称为“形式参数”，在宏调用中的参数称为“实际参数”，这点和函数有些类似。对带参数的宏，在展开过程中不仅要进行字符串替换，还要用实参去替换形参。

  ```c
  #define 宏名(形参列表) 字符串
  #define M(y) y*y+3*y  //宏定义
  // TODO:
  k=M(5);  //宏调用
  
  #define MAX(a,b) (a>b) ? a : b
  ```

  - 带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现。
  - 在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。这一点和函数是不同的：在函数中，形参和实参是两个不同的变量，都有自己的作用域，调用时要把实参的值传递给形参；而在带参数的宏中，只是符号的替换，不存在值传递的问题。
  - 宏定义只是替换，函数调用时要把实参表达式的值求出来在传递给形参。例如#define SQ(y) (y)*(y)，调用时SQ(a+1)，如果是函数会将a+1的值求出来在传递给形参，但是宏定义是将a+1直接替换y，不会去计算。

- 带参数的宏和函数很相似，但有本质上的区别：宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。而函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。

  - 例如在计算平方值时，用函数计算

    ```c
    int SQ(int y){
      return ((y)*(y));
    }
    ```

    函数调用SQ(i++)，i从一到5，这样函数会计算5次

  - 用宏计算平方值时`#define SQ(y) ((y)*(y))`SQ(i++)，这样i从1到5只计算三次，因为每一次i++都要替换y，在一次计算中有两次i++
  - 带参数的宏也可以用来定义多个语句，在宏调用时，把这些语句又替换到源程序中，\#define SSSV(s1, s2, s3, v) s1 = length * width; s2 = length * height; s3 = width * height; v = width * length * height;

- 在宏定义中，有时还会用到`#`和`##`两个符号，它们能够对宏参数进行操作。

  - `#`用来将宏参数转换为字符串，也就是在宏参数的开头和末尾添加引号。

    ```c
    #define STR(s) #s
    
    printf("%s", STR(c.biancheng.net));
    printf("%s", STR("c.biancheng.net"));
    
    printf("%s", "c.biancheng.net");
    printf("%s", "\"c.biancheng.net\"");   //宏参数s变为字符串，在替换时加上引号
    ```

  - `##`称为连接符，用来将宏参数或其他的串连接起来。

    ```c
    #define CON1(a, b) a##e##b
    #define CON2(a, b) a##b##00
    
    printf("%f\n", CON1(8.5, 2));
    printf("%d\n", CON2(12, 34));
    
    printf("%f\n", 8.5e2);
    printf("%d\n", 123400);
    ```

- ANSI C 规定了以下几个预定义宏，它们在各个编译器下都可以使用：
  - \__LINE__：表示当前源代码的行号；
  - \__FILE__：表示当前源文件的名称；
  - \__DATE__：表示当前的编译日期；
  - \__TIME__：表示当前的编译时间；
  - \__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；
  - __cplusplus：当编写C++程序时该标识符被定义。

##### 条件编译

- Windows 有专有的宏`_WIN32`，Linux 有专有的宏`__linux__`

- #if用法的一般格式为：

  ```c
  #if 整型常量表达式1
      程序段1
  #elif 整型常量表达式2
      程序段2
  #elif 整型常量表达式3
      程序段3
  #else
      程序段4  //#elif 和 #else 也可以省略
  #endif    //需要注意的是，#if 命令要求判断条件为“整型常量表达式”，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行。这是 #if 和 if 的一个重要区别。
   
  //#if后面跟的是表达式，makefile编译程序时利用-D选项表示-D后面的宏被定义过，这样#ifdef 宏名就能找到这个宏，我们还可以加上宏，并且可以设置宏的值，这样我们就可以使用#if判断这个宏值，根据宏值来确定不同的格式
  //#define定义的是宏，宏有两种，一种是没有值的，例如#define定义的头保护，宏还可以有值，例如我们定义的宏替换，这个宏在代码里面就是具体的替换，我们还可以使用#if判断这个宏值
          
  CC=gcc
  version=0.0.2
  release_number=2
   
  all: test
   
  test: test.c
  	$(CC) -o $@ $^ -DDEBUG_PRINT -D VERSION='"$(version)"' -D RELEASE_NUMBER=$(release_number)
   
  .PHONY: clean
   
  clean:
  	rm test
  ```

- #indef用法的一般格式

  ```c
  #ifdef  宏名   //如果当前的宏已被定义过，则对“程序段1”进行编译，否则对“程序段2”进行编译。
      程序段1
  #else
      程序段2
  #endif  //可以省略#else
  ```

  VS/VC 有两种编译模式，Debug 和 Release。在学习过程中，我们通常使用 Debug 模式，这样便于程序的调试；而最终发布的程序，要使用 Release 模式，这样编译器会进行很多优化，提高程序运行效率，删除冗余信息。

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  int main(){
      #ifdef _DEBUG
          printf("正在使用 Debug 模式编译程序...\n");
      #else
          printf("正在使用 Release 模式编译程序...\n");
      #endif
      system("pause");
      return 0;
  }  当以 Debug 模式编译程序时，宏 _DEBUG 会被定义，预处器会保留第 5 行代码，删除第 7 行代码。反之会删除第 5 行，保留第 7 行。
  ```

- \#ifndef 用法的一般格式为：

  ```c
  #ifndef 宏名
      程序段1 
  #else 
      程序段2 
  #endif  // 与 #ifdef 相比，仅仅是将 #ifdef 改为了 #ifndef。它的意思是，如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与 #ifdef 的功能正好相反。
  ```

- \#if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的。

##### #error

- \#error 指令用于在编译期间产生错误信息，并阻止程序的编译

  ```c
  #error error_message
  ```

- 例如，我们的程序针对 Linux 编写，不保证兼容 Windows

  ```c
  #ifdef WIN32
  #error This programme cannot compile at Windows Platform
  #endif
  ```

- 报错信息不需要加引号`" "`，如果加上，引号会被一起输出。

- 当我们希望以 C++ 的方式来编译程序时

  ```c
  #ifndef __cplusplus
  #error 当前程序必须以C++方式编译
  #endif
  ```

  



#### 文件操作

- 在操作系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。在C语言中硬件设备可以看成文件，有些输入输出函数不需要你指明到底读写哪个文件，系统已经为它们设置了默认的文件，当然你也可以更改，例如让 printf 向磁盘上的文件输出数据。

  | 文件   | 硬件设备                                                     |
  | ------ | ------------------------------------------------------------ |
  | stdin  | 标准输入文件，一般指键盘；scanf()、getchar() 等函数默认从 stdin 获取输入。 |
  | stdout | 标准输出文件，一般指显示器；printf()、putchar() 等函数默认向 stdout 输出数据。 |
  | stderr | 标准错误文件，一般指显示器；perror() 等函数默认向 stderr 输出数据（后续会讲到）。 |
  | stdprn | 标准打印文件，一般指打印机。                                 |

- FILE *fopen(char *filename, char *mode);

  | 打开方式 | 说明                                                         |
  | -------- | ------------------------------------------------------------ |
  | "r"      | 以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。 |
  | "w"      | 以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。 |
  | "a"      | 以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。 |
  | "r+"     | 以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。 |
  | "w+"     | 以“写入/更新”方式打开文件，相当于`w`和`r+`叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。 |
  | "a+"     | 以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。 |

  | 打开方式 | 说明                              |
  | -------- | --------------------------------- |
  | "t"      | 文本文件。如果不写，默认为`"t"`。 |
  | "b"      | 二进制文件。                      |

  调用 fopen() 函数时必须指明读写权限，但是可以不指明读写方式（此时默认为`"t"`）。读写用r+，不用rw

  读写权限和读写方式可以组合使用，但是必须将读写方式放在读写权限的中间或者尾部（换句话说，不能将读写方式放在读写权限的开头）。例如：

  - 将读写方式放在读写权限的末尾："rb"、"wt"、"ab"、"r+b"、"w+t"、"a+t"
  - 将读写方式放在读写权限的中间："rb+"、"wt+"、"ab+"

- int fclose(FILE* fp);文件正常关闭时，fclose() 的返回值为0，如果返回非零值则表示有错误发生。

##### 源文件和程序中的字节问题

- 在写xml项目时遇到的问题，在xml中要定义四个字节代表xml的文件大小，以前的思考是一个数字在文件中就要占用一个字节，这四个字节只能表示四位数字，例如数字1在文件中存储就要占用一个字节，其转换为ASCII编码然后存在磁盘中，这涉及到编码的问题和源文件字符集和运行态字符集的问题。但是我们在程序中int占用四个字节，其可以表示的数据范围很大，所以在将程序中的数据写进文件中时不会以数字直接存储，在内存中数据的存储方式会直接写进文件中，占用的字节大小一样，这样在将文件中的数据读入程序中时直接使用fread读取四个字节到变量的地址就可以了。例如定义变量int num，使用fread函数fread(&num, 1, 4, FILE* fp)，这样就将这四个数据赋值到num中，num就是我们想要的值。以前的想法是int a = 123456，将int a写进文件中就要占用6个字节，其实不然，int a在内存中并不是这样存储的，其存储情况前面有介绍。我们使用fwrite函数fwrite(&a, 1, 4, FILE* fp)，这样将a以其在内存中的存储形式写进文件中，到时候读取时直接读取出来就可以。我们定义四个字节表示大小是为了在程序中容易使用，而不是为了数据在文件中显示，例如1234在内存中的存储肯定不会是1234这种结果，所以写进文件中也不可能是这种显示形式。这种定义不是为了显示用的，而是为了定义，为了最后的数据处理使用的。
- 我们在写程序时使用int a = 1234这种定义，这种只是在源文件中显示的，只是一种我们写代码的一种表示形式，所有的这些最后都要编译器进行编译，然后在内存中运行。所以编译器在看到1234时就会分配四个字节给变量a，而且1234也会转变为在内存中的形式在内存中运行。而我们在在程序中向一个文件写数据时，其实就是将内存中的数据写进文件，而不是源文件那种表示形式。我们的数据在内存中是会变化的，但是我们的普通字符ABC这种是不会变量的，在内存中存储和文件中存储都是UTF-8编码格式。
- 在字符数组初始化时将所有的值赋值为0的原因是，\0的ASCII编码是0，表示什么也不干。数组在内存中存储也是按照ASCII编码来存储的，所以字符串数组使用时就会看到定义为0的char其实就是\0。字符赋值为0，char str[] = {0}，这只是在源文件中我们看到的，其在内存中存储就是按照ASCII编码来存储的。所有的数据存储都是字符编码，而我们能看到我们想看到的字符是因为我们的显示器有解码的功能，将我们想看到的字符显示出来。编译器就是将我们的源码编译成在内存中的格式，例如上面的字符数组定义，我们虽然看到的是这样，但是这是源文件，而要真正运行需要在内存中，所以编译器看到这句话就在内存中申请空间，每个空间上都是按照编码来存储的。只是在字符数组中赋值为0才会这样将0看作为\0，在其他数组中0就是0，不会看成别的。
- 在内存中的所有的存储也都是按照字符编码来存储的，例如字符A在内存中和在磁盘中存储一样，都是占用1个字节，但是为什么我们的显示器能输出字符A，那是因为printf在输出时是像显示器输出，而我们的显示器具有解码功能，所以正常显示了。
- 在内存中一般就是代码和数据，其中代码会转变为机器码0101011011这种形式存在内存中，而数据就是根据需要的字节数按照存储方法存储，整数和小数的存储方法是不一样的。在内存中只有地址，没有变量名，变量名是我们在源文件中写的，为了方便我们写代码，最后编译器都转换为地址了。
- 十进制和十六进制的区别，十进制在文件中和在内存中存储的不一样，因为字符在内存中是按二进制存储的。但是十六进制就是按照二进制格式编码的，所以在内存中也是一样存储的，但是我们看到十六进制并不能一眼看出来是多少，需要进行转化，但是十六进制的方式是为了赋值时的方便，在内存中和文件中存储的方式都是一样的。虽然我们将一个十六进制数赋值给一个unsigned int，但是我们在输出的时候可以控制输出格式，按照十进制或者十六进制输出。同一个数例如17，以十进制数就是17，以十六进制数就是0x11，但是他们在内存中存储的方式是一样的。以十六进制数赋值就是为了看到在内存中的存储格式。
- 例如sm4加密格式中4bytes  magic "ENCF"赋值到unsigned int magic，加密格式中magic是unsigned int类型的，占用四个字节，而ENCF是字符，不能将字符赋值给unsigned int类型。但是在文件中我们又需要定义这样，在解密文件时，看到ENCF就开始解密，所以我们可以将ENCF每个字符对应的ASCII值组合在一起，每一个字符占用一个字节，四个字符占用四个字节，所以将magic设置为0x454E4346，这样在程序中解密文件时，将magic读到一个unsigned int类型变量中，如果和上面的值相等就开始解密，不相等就不解密。
- 在写数据时好好利用fseek函数来实现偏移。

##### 字符形式读取文件

- int fgetc (FILE *fp);fgetc 是 file get char 的缩写，意思是从指定的文件中读取一个字符。fgetc() 读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回`EOF`。EOF 是 end of file 的缩写，表示文件末尾，是在 stdio.h 中定义的宏，它的值是一个负数，往往是 -1。fgetc() 的返回值类型之所以为 int，就是为了容纳这个负数（char不能是负数）。

- 在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用 fgetc() 函数后，该指针会向后移动一个字节，所以可以连续多次使用 fgetc() 读取多个字符。注意：这个文件内部的位置指针与C语言中的指针不是一回事。位置指针仅仅是一个标志，表示文件读写到的位置，也就是读写到第几个字节，它不表示地址。文件每读写一次，位置指针就会移动一次，它不需要你在程序中定义和赋值，而是由系统自动设置，对用户是隐藏的。

- EOF 本来表示文件末尾，意味着读取结束，但是很多函数在读取出错时也返回 EOF，那么当返回 EOF 时，到底是文件读取完毕了还是读取出错了？我们可以借助 stdio.h 中的两个函数来判断，分别是 feof() 和 ferror()。

  - ```
    int feof ( FILE * fp );feof() 函数用来判断文件内部指针是否指向了文件末尾，当指向文件末尾时返回非零值，否则返回零值。
    ```

  - ```
    int ferror ( FILE *fp );ferror() 函数用来判断文件操作是否出错。出错时返回非零值，否则返回零值。文件出错是非常少见的情况
    ```

- int fputc ( int ch, FILE *fp );fputc 是 file output char 的所以，意思是向指定的文件中写入一个字符。fputc() 写入成功时返回写入的字符，失败时返回 EOF，返回值类型为 int 也是为了容纳这个负数。

- getchar是读入函数的一种。它从标准输入里读取下一个字符，相当于getc(stdin)。返回类型为int型，为用户输入的ASCII码或EOF。

##### 字符串形式读写文件

- ```
  char *fgets ( char *str, int n, FILE *fp );
  ```

  - fgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中。
  - str 为字符数组，n 为要读取的字符数目，fp 为文件指针。
  - 返回值：读取成功时返回字符数组首地址，也即 str；读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 NULL。
  - 读取到的字符串会在末尾自动添加 '\0'，n 个字符也包括 '\0'。也就是说，实际只读取到了 n-1 个字符，如果希望读取 100 个字符，n 的值应该为 101。
  - 需要重点说明的是，在读取到 n-1 个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。这就意味着，不管 n 的值多大，fgets() 最多只能读取一行数据，不能跨行。在C语言中，没有按行读取文件的函数，我们可以借助 fgets()，将 n 的值设置地足够大，每次就可以读取到一行数据。
  - fgets() 遇到换行时，会将换行符一并读取到当前字符串。该示例的输出结果之所以和 demo.txt 保持一致，该换行的地方换行，就是因为 fgets() 能够读取到换行符。而 gets() 不一样，它会忽略换行符。

- ```
  int fputs( char *str, FILE *fp );
  ```

  - fputs() 函数用来向指定的文件写入一个字符串
  - str 为要写入的字符串，fp 为文件指针。写入成功返回非负数，失败返回 EOF。

##### 数据块形式读写文件

- fgets() 有局限性，每次最多只能从文件中读取一行内容，因为 fgets() 遇到换行符就结束读取。如果希望读取多行内容，需要使用 fread() 函数；相应地写入函数为 fwrite()。

- ```
  size_t fread ( void *ptr, size_t size, size_t count, FILE *fp );
  ```

  - fread() 函数用来从指定文件中读取块数据。所谓块数据，也就是若干个字节的数据，可以是一个字符，可以是一个字符串，可以是多行数据，并没有什么限制。

- ```
  size_t fwrite ( void * ptr, size_t size, size_t count, FILE *fp );
  ```

  - fwrite() 函数用来向文件中写入块数据
  - ptr 为内存区块的[指针](http://c.biancheng.net/c/80/)，它可以是数组、变量、结构体等。fread() 中的 ptr 用来存放读取到的数据，fwrite() 中的 ptr 用来存放要写入的数据。
  - size：表示每个数据块的字节数。
  - count：表示要读写的数据块的块数。
  - fp：表示文件指针。
  - 理论上，每次读写 size*count 个字节的数据。
  - size_t 是在 stdio.h 和 stdlib.h 头文件中使用 typedef 定义的数据类型，表示无符号整数，也即非负数，常用来表示数量。

- 返回值：返回成功读写的块数，也即 count。如果返回值小于 count：
  - 对于 fwrite() 来说，肯定发生了写入错误，可以用 ferror() 函数检测。
  - 对于 fread() 来说，可能读到了文件末尾，可能发生了错误，可以用 ferror() 或 feof() 检测。
- 数据写入完毕后，位置指针在文件的末尾，要想读取数据，必须将文件指针移动到文件开头，这就是`rewind(fp);`的作用。

##### 格式化读写文件

- fscanf() 和 fprintf() 函数与前面使用的 scanf() 和 printf() 功能相似，都是格式化读写函数，两者的区别在于 fscanf() 和 fprintf() 的读写对象不是键盘和显示器，而是磁盘文件。

- ```
  int fscanf ( FILE *fp, char * format, ... );
  int fprintf ( FILE *fp, char * format, ... );
  ```

  - fp 为文件[指针](http://c.biancheng.net/c/80/)，format 为格式控制字符串，... 表示参数列表。与 scanf() 和 printf() 相比，它们仅仅多了一个 fp 参数。
  - fprintf() 返回成功写入的字符的个数，失败则返回负数。fscanf() 返回参数列表中被成功赋值的参数个数。
  - 如果将 fp 设置为 stdin，那么 fscanf() 函数将会从键盘读取数据，与 scanf 的作用相同；设置为 stdout，那么 fprintf() 函数将会向显示器输出内容，与 printf 的作用相同。
  - 输出和输入按照格式来。用 fprintf() 和 fscanf() 函数读写配置文件、日志文件会非常方便，不但程序能够识别，用户也可以看懂，可以手动修改。
  - 可以设置结构体，然后从配置文件中把数据读取出来，放到结构体里面。这样实现了数据到数据结构。

##### FILE结构体以及缓冲区

- 不同编译器 stdio.h 头文件中对 FILE 的定义略有差异，这里以标准C举例说明：

  ```c
  typedef struct _iobuf {
      int cnt;  // 剩余的字符，如果是输入缓冲区，那么就表示缓冲区中还有多少个字符未被读取
      char *ptr;  // 下一个要被读取的字符的地址
      char *base;  // 缓冲区基地址
      int flag;  // 读写状态标志位
      int fd;  // 文件描述符
      // 其他成员
  } FILE;
  ```

- 我们知道，当我们从键盘输入数据的时候，数据并不是直接被我们得到，而是放在了缓冲区中，然后我们从缓冲区中得到我们想要的数据 。如果我们通过[setbuf()](http://c.biancheng.net/cpp/html/265.html)或[setvbuf()](http://c.biancheng.net/cpp/html/268.html)函数将缓冲区设置10个字节的大小，而我们从键盘输入了20个字节大小的数据，这样我们输入的前10个数据会放在缓冲区中，因为我们设置的缓冲区的大小只能够装下10个字节大小的数据，装不下20个字节大小的数据。那么剩下的那10个字节大小的数据怎么办呢？暂时放在了输入流中。

- 缓冲区里面存得是读写得数据，并不是一些命令，只是要存进去或者读取出来得一些数据。

- 在上面我们向缓冲区中放入了10个字节大小的数据，FILE结构体中的 cnt 变为了10 ，说明此时缓冲区中有10个字节大小的数据可以读，同时我们假设缓冲区的基地址也就是 base 是0x00428e60 ，它是不变的 ，而此时 ptr 的值也为0x00428e60 ，表示从0x00428e60这个位置开始读取数据，当我们从缓冲区中读取5个数据的时候，cnt 变为了5 ，表示缓冲区还有5个数据可以读，ptr 则变为了0x0042e865表示下次应该从这个位置开始读取缓冲区中的数据 ，如果接下来我们再读取5个数据的时候，cnt 则变为了0 ，表示缓冲区中已经没有任何数据了，ptr 变为了0x0042869表示下次应该从这个位置开始从缓冲区中读取数据，但是此时缓冲区中已经没有任何数据了，所以要将输入流中的剩下的那10个数据放进来，这样缓冲区中又有了10个数据，此时 cnt 变为了10 ，注意了刚才我们讲到 ptr 的值是0x00428e69 ，而当缓冲区中重新放进来数据的时候这个 ptr 的值变为了0x00428e60 ，这是因为当缓冲区中没有任何数据的时候要将 ptr 这个值进行一下刷新，使其指向缓冲区的基地址也就是0x0042e860这个值！因为下次要从这个位置开始读取数据！

- 在这里有点需要说明：当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。

- 带缓冲区文件操作：高级标准文件I/O操作，将会在用户空间中自动为正在使用的文件开辟内存缓冲区。ANSI标准C库函数 是建立在底层的系统调用之上，即C函数库文件访问函数的实现中使用了低级文件I/O系统调用，ANSI标准C库中的文件处理函数为了减少使用系统调用的次数，提高效率，采用缓冲机制，这样，可以在磁盘文件进行操作时，可以一次从文件中读出大量的数据到缓冲区中，以后对这部分的访问就不需要再使用系统调用了，即需要少量的CPU状态切换，提高了效率。

- 非缓冲区文件操作：低级文件I/O操作，读写文件时，不会开辟对文件操作的缓冲区，直接通过系统调用对磁盘进行操作(读、写等)，当然用于可以在自己的程序中为每个文件设定缓冲区。非缓冲的文件操作访问方式，每次对文件进行一次读写操作时，都需要使用读写系统调用来处理此操作，即需要执行一次系统调用，执行一次系统调用将涉及到CPU状态的切换，即从用户空间切换到内核空间，实现进程上下文的切换，这将损耗一定的CPU时间，频繁的磁盘访问对程序的执行效率造成很大的影响。

- 非缓冲IO操作数据流向路径：数据->内核缓冲区->磁盘  带缓冲IO操作数据流向路径：数据->流缓冲区->内核缓冲区->磁盘。无缓存只不过是指在用户层没有缓存，但对于内核来说，还是进行了缓存。

- 读缓冲： 一些程序在读取文件时，会先申请**一块内存数组**，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。（用较小的次数填满buffer）。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。缓冲区就可以理解为内存数组，在当前进程中开辟一段虚拟内存空间，并且映射到物理内存中，实际上存储在物理内存中。设置读缓冲就是当切换换到内核态时系统内核一次从文件中读取一块数据放到缓冲区中，以后的程序要读取这个文件的数据直接从读缓冲里面读取，当读缓冲区的数据都读走了，就像流一样都空了，此时会触发一次读取操作，此时用户态切换到内核态，读取一块数据到缓冲区中，重复上述过程。

- 写缓冲：写缓冲就是在往文件里面写数据时，不直接写进硬盘，而是往文件写缓冲里面写，当文件写缓冲满了之后，此时出发一次写操作，此时用户态切换到内核态，将数据写进硬盘，此时写缓冲为空，数据接着写入，如此重复。

- [用户缓冲区和内核缓冲区]: https://www.cnblogs.com/BlueBlueSea/p/14807245.html

  - 内核也有缓冲区，在进行IO时此时从内核缓冲区到用户缓冲区可以区分各种IO模型
  - 阻塞IO：在准备阶段即同步阻塞，应用进程调用I/O操作时阻塞，只有等待要操作的数据准备好，并从内核缓冲区复制到应用进程的缓冲区中才返回。
  - 非阻塞IO：当应用进程要调用的I/O操作会导致该进程进入阻塞状态时，该I/O调用返回一个错误，一般情况下，应用进程需要利用轮询的方式来检测某个操作是否就绪。数据就绪后，实际的I/O操作会等待数据复制到应用进程的缓冲区中以后才返回。
  - 所谓非阻塞方式non-block，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高。所以阻塞和非阻塞主要是对一些系统函数来说的，有的函数是阻塞的，有的函数是非阻塞的。我们在man 一些函数时，函数说明就会写道是阻塞的还是非阻塞的。这些函数都是系统函数，内核设计时就设计了很多种情况来给函数返回值来使用，根据情况的不同返回值不同，所以这些是内核设计的，我们只需要使用就可以了。在非阻塞的时候，如果准备好返回一个值，例如读取文件时，没有准备好返回一个值，我们根据这个值可以判断没有准备好，我们可以执行程序中其他语句，然后过一段时间在来查询读取文件是否成功。根据某个函数输入文件名得到的结果来判断。这样就可以提高cpu效率。

- 缓冲类型
  
  - 全缓冲区：这种缓冲方式要求填满整个缓冲区后才进行I/O系统调用操作。对于磁盘文件的操作通常使用全缓冲的方式访问。第一次执行I/O操作时，ANSI标准的文件管理函数通过调用malloc函数获得需要使用的缓冲区，默认大小为8192。
  - 行缓冲区：在这种情况下，当在输入和输出中遇到换行符时，标准I/O库函数将会执行系统调用操作。当所操作的流涉及一个终端时（例如标准输入和标准输出），使用行缓冲方式。因为标准I/O库每行的缓冲区长度是固定的，所以只要填满了缓冲区，即使还没有遇到换行符，也会执行I/O系统调用操作，默认行缓冲区的大小为1024。
  - 无缓冲区是指标准I/O库不对字符进行缓存，直接调用系统调用。标准出错流stderr通常是不带缓冲区的，这使得出错信息能够尽快地显示出来。
  - 对于任何一个给定的流，可以调用setbuf()和setvbuf()函数更改其缓冲区类型。
  
- 清空缓冲区fflush

  - fflush()用于清空文件缓冲区，如果文件是以写的方式打开 的，则把缓冲区内容写入文件
  - fclose也会清空文件缓冲区，但是如果在关闭之前就使用了文件，要强制写入一下

##### 随机读写文件

- ```
  void rewind ( FILE *fp );
  ```

  - rewind() 用来将位置指针移动到文件开头

- ```
  int fseek ( FILE *fp, long offset, int origin );
  成功返回0，否则返回其他值
  ```
  
  - fseek() 用来将位置指针移动到任意位置
  
  -  offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。
  
  - origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为文件开头、当前位置和文件末尾，每个位置都用对应的常量来表示：
  
  - 值得说明的是，fseek() 一般用于二进制文件，在文本文件中由于要进行转换，计算的位置有时会出错。
  
  - 在移动位置指针之后，就可以用前面介绍的任何一种读写函数进行读写了。由于是二进制文件，因此常用 fread() 和 fwrite() 读写。
  
  - fseek可以用于结构体向后移动，其中offset为sizeof结构体，这样就可以向后移动一个结构体数据大小
  
    | 起始点   | 常量名   | 常量值 |
    | -------- | -------- | ------ |
    | 文件开头 | SEEK_SET | 0      |
    | 当前位置 | SEEK_CUR | 1      |
    | 文件末尾 | SEEK_END | 2      |

##### 文件复制功能

- 实现文件复制的主要思路是：开辟一个缓冲区，不断从原文件中读取内容到缓冲区，每读取完一次就将缓冲区中的内容写入到新建的文件，直到把原文件的内容读取完。

- 这里有两个关键的问题需要解决：
  - 开辟多大的缓冲区合适？缓冲区过小会造成读写次数的增加，过大也不能明显提高效率。目前大部分磁盘的扇区都是4K对齐的，如果读写的数据不是4K的整数倍，就会跨扇区读取，降低效率，所以我们开辟4K的缓冲区。
  - 缓冲区中的数据是没有结束标志的，如果缓冲区填充不满，如何确定写入的字节数？最好的办法就是每次读取都能返回读取到的字节数。
  
- fread返回成功读写的块数，该值小于等于 count。如果我们让参数 size 等于1，那么返回的就是读取的字节数。注意：fopen()一定要以二进制的形式打开文件，不能以文本形式打开，否则系统会对文件进行一些处理，如果是文本文件，像.txt等，可能没有问题，但如果是其他格式的文件，像.mp4, .rmvb, .jpg等，复制后就会出错，无法读取。

  ```c
  int copyFile(char *fileRead, char *fileWrite){
      FILE *fpRead;  // 指向要复制的文件
      FILE *fpWrite;  // 指向复制后的文件
      int bufferLen = 1024*4;  // 缓冲区长度
      char *buffer = (char*)malloc(bufferLen);  // 开辟缓存
      int readCount;  // 实际读取的字节数
      if( (fpRead=fopen(fileRead, "rb")) == NULL || (fpWrite=fopen(fileWrite, "wb")) == NULL ){
          printf("Cannot open file, press any key to exit!\n");
          getch();
          exit(1);
      }
      // 不断从fileRead读取内容，放在缓冲区，再将缓冲区的内容写入fileWrite
      while( (readCount=fread(buffer, 1, bufferLen, fpRead)) > 0 ){
          fwrite(buffer, readCount, 1, fpWrite);
      }
      free(buffer);
      fclose(fpRead);
      fclose(fpWrite);
      return 1;
  }
  ```

  

##### 获取文件大小

- ```
  long int ftell ( FILE * fp );
  ```

  - ftell() 函数用来获取文件内部指针（位置指针）距离文件开头的字节数
  - 先使用 fseek() 将文件内部指针定位到文件末尾，再使用 ftell() 返回内部指针距离文件开头的字节数，这个返回值就等于文件的大小。

- 获取到文件大小后还需要恢复文件内部指针

  ```c
  long fsize(FILE *fp){   //自己写得函数得到文件大小，恢复文件指针
      long n;
      fpos_t fpos;  //当前位置
      fgetpos(fp, &fpos);  //获取当前位置
      fseek(fp, 0, SEEK_END);
      n = ftell(fp);
      fsetpos(fp,&fpos);  //恢复之前的位置
      return n;
  }
  ```

##### 插入删除更改文件内容

- 顺序文件的存储结构决定了它能够高效读取内容，但不能够随意插入、删除和修改内容。例如在文件开头插入100个字节的数据，那么原来文件的所有内容都要向后移动100个字节，这不仅是非常低效的操作，而且还可能覆盖其他文件。因此C语言没有提供插入、删除、修改文件内容的函数，要想实现这些功能，只能自己编写函数。

- 以插入数据为例，假设原来文件的大小为 1000 字节，现在要求在500字节处插入用户输入的字符串，那么可以这样来实现：
  - 创建一个临时文件，将后面500字节的内容复制到临时文件；
  -  将原来文件的内部指针调整到500字节处，写入字符串；
  - 再将临时文件中的内容写入到原来的文件（假设字符串的长度为100，那么此时文件内部指针在600字节处）。
  - 如果是在文件末尾，就非常简单了，直接用 fwrite() 写入即可。

- 删除数据时，也是类似的思路。假设原来文件大小为1000字节，名称为 demo.mp4，现在要求在500字节处往后删除100字节的数据，那么可以这样来实现：
  -  创建一个临时文件，先将前500字节的数据复制到临时文件，再将600字节之后的所有内容复制到临时文件；
  -  删除原来的文件，并创建一个新文件，命名为 demo.mp4；
  - 将临时文件中的所有数据复制到 demo.mp4。

- 修改数据时，如果新数据和旧数据长度相同，那么设置好内部指针，直接写入即可；如果新数据比旧数据长，相当于增加新内容，思路和插入数据类似；如果新数据比旧数据短，相当于减少内容，思路和删除数据类似。实际开发中，我们往往会保持新旧数据长度一致，以减少编程的工作量，所以我们不再讨论新旧数据长度不同的情况。

  ```c
  /**   改函数可以将原文件任意位置的任意长度的内容复制到目标文件的任意位置，非常灵活。
   * 文件复制函数
   * @param  fSource       要复制的原文件
   * @param  offsetSource  原文件的位置偏移（相对文件开头），也就是从哪里开始复制
   * @param  len           要复制的内容长度，小于0表示复制offsetSource后边的所有内容
   * @param  fTarget       目标文件，也就是将文件复制到哪里
   * @param  offsetTarget  目标文件的位置偏移，也就是复制到目标文件的什么位置
   * @return  成功复制的字节数
  **/
  long fcopy(FILE *fSource, long offsetSource, long len, FILE *fTarget, long offsetTarget){
      int bufferLen = 1024*4;  // 缓冲区长度
      char *buffer = (char*)malloc(bufferLen);  // 开辟缓存
      int readCount;  // 每次调用fread()读取的字节数
      long nBytes = 0;  //总共复制了多少个字节
      int n = 0;  //需要调用多少次fread()函数
      int i;  //循环控制变量
      fseek(fSource, offsetSource, SEEK_SET);
      fseek(fTarget, offsetTarget, SEEK_SET);
      if(len<0){  //复制所有内容
          while( (readCount=fread(buffer, 1, bufferLen, fSource)) > 0 ){
              nBytes += readCount;
              fwrite(buffer, readCount, 1, fTarget);
          }
      }else{  //复制len个字节的内容
          n = (int)ceil((double)((double)len/bufferLen));
          for(i=1; i<=n; i++){
              if(len-nBytes < bufferLen){ bufferLen = len-nBytes; }
              readCount = fread(buffer, 1, bufferLen, fSource);
              fwrite(buffer, readCount, 1, fTarget);
              nBytes += readCount;
          }
      }
      fflush(fTarget);
      free(buffer);
      return nBytes;
  }
  ```

  ```c
  /**
   * 向文件中插入内容
   * @param  fp      要插入内容的文件
   * @param  buffer  缓冲区，也就是要插入的内容
   * @param  offset  偏移量（相对文件开头），也就是从哪里开始插入
   * @param  len     要插入的内容长度
   * @return  成功插入的字节数
  **/
  int finsert(FILE *fp, long offset, void *buffer, int len){
      long fileSize = fsize(fp);
      FILE *fpTemp;  //临时文件
      if(offset>fileSize || offset<0 || len<0){  //插入错误
          return -1;
      }
      if(offset == fileSize){  //在文件末尾插入
          fseek(fp, offset, SEEK_SET);
          if(!fwrite(buffer, len, 1, fp)){
              return -1;
          }
      }
      if(offset < fileSize){  //从开头或者中间位置插入
          fpTemp = tmpfile();
          fcopy(fp, 0, offset, fpTemp, 0);
          fwrite(buffer, len, 1, fpTemp);
          fcopy(fp, offset, -1, fpTemp, offset+len);
          freopen(FILENAME, "wb+", fp );
          fcopy(fpTemp, 0, -1, fp, 0);
          fclose(fpTemp);
      }
     
      return 0;
  }
  ```

#### c语言内存

- 内存的管理秉持着谁申请谁释放，就算我申请了这份空间，别人要用的话也要将这部分东西拷走，放到他自己的空间中，他在他那部分空间上直接做操作，而不能在我申请的这部分空间上做操作，这样保证了数据的准确性，即使别人释放了我们这边也有相同的数据，也相当于一个规范，一种商量协定的，我们也可以自己申请的空间交给别人，让别人释放，但是这样会有风险，这样就不是谁申请谁释放了，如果别人申请空间，把这部分拷走，就是他申请的空间由他释放。这样就是谁申请谁释放了，这样维护内存比较清晰。

##### cpu讲解

![](http://c.biancheng.net/uploads/allimg/190122/10410L420-0.jpg)

- 运算单元是CPU的大脑，负责加减乘除、比较、位移等运算工作，每种运算都有对应的电路支持，速度很快。
- 寄存器（Register）是CPU内部非常小、非常快速的存储部件，它的容量很有限，对于32位的CPU，每个寄存器一般能存储32位（4个字节）的数据，对于64位的CPU，每个寄存器一般能存储64位（8个字节）的数据。为了完成各种复杂的功能，现代CPU都内置了几十个甚至上百个的寄存器，嵌入式系统功能单一，寄存器数量较少。我们经常听说多少位的CPU，指的就是寄存器的的位数
- 寄存器在程序的执行过程中至关重要，不可或缺，它们可以用来完成数学运算、控制循环次数、控制程序的执行流程、标记CPU运行状态等。例如，EIP（Extern Instruction Pointer ）寄存器的值是下一条指令的地址，CPU执行完当前指令后，会根据 EIP 的值找到下一条指令，改变 EIP 的值，就会改变程序的执行流程；CR3 寄存器保存着当前进程页目录的物理地址，切换进程就会改变 CR3 的值，EBP、ESP 寄存器用来指向栈的底部和顶部，函数调用会改变 EBP 和 ESP 的值
- 虽然内存的读取速度已经很快了，但是和CPU比起来，还是有很大差距的，不是一个数量级的，如果每次都从内存中读取数据，会严重拖慢CPU的运行速度，CPU经常处于等待状态，无事可做。在CPU内部设置一个缓存，可以将使用频繁的数据暂时读取到缓存，需要同一地址上的数据时，就不用大老远地再去访问内存，直接从缓存中读取即可。
- 对于32位环境，理论上程序可以拥有 4GB 的虚拟地址空间，我们在C语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。

##### 内存对齐

- CPU 通过地址总线来访问内存，一次能处理几个字节的数据，就命令地址总线读取几个字节的数据。32 位的 CPU 一次可以处理4个字节的数据，那么每次就从内存读取4个字节的数据；少了浪费主频，多了没有用。64位的处理器也是这个道理，每次读取8个字节。

- 以32位的CPU为例，实际寻址的步长为4个字节，也就是只对编号为 4 的倍数的内存寻址，例如 0、4、8、12、1000 等，而不会对编号为 1、3、11、1001 的内存寻址

- 对于程序来说，一个变量最好位于一个寻址步长的范围内，这样一次就可以读取到变量的值；如果跨步长存储，就需要读取两次，然后再拼接数据，效率显然降低了。

- 将一个数据尽量放在一个步长之内，避免跨步长存储，这称为内存对齐。在32位编译模式下，默认以4字节对齐；在64位编译模式下，默认以8字节对齐。

- 为了提高存取效率，编译器会自动进行内存对齐

  ```c
  struct{
      int a;
      char b;
      int c;
  }t={ 10, 'C', 20 };
  如果不考虑内存对齐，结构体变量 t 所占内存应该为 4+1+4 = 9 个字节。考虑到内存对齐，虽然成员 b 只占用1个字节，但它所在的寻址步长内还剩下 3 个字节的空间，放不下一个 int 型的变量了，所以要把成员 c 放到下一个寻址步长。剩下的这3个字节，作为内存填充浪费掉了
  编译器之所以要内存对齐，是为了更加高效的存取成员 c，而代价就是浪费了3个字节的空间。
  ```

- 除了结构体，变量也会进行内存对齐，int m,char c,int n;他们的地址都是4的整数倍，并相互挨着，内存对齐，char c占用了4个字节

##### c语言内存布局

- 对于32位环境，理论上程序可以拥有 4GB 的虚拟地址空间，我们在C语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。但是，在这 4GB 的地址空间中，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间（Kernel Space）。Windows 在默认情况下会将高地址的 2GB 空间分配给内核（也可以配置为1GB），而 Linux 默认情况下会将高地址的 1GB 空间分配给内核。也就是说，应用程序只能使用剩下的 2GB 或 3GB 的地址空间，称为用户空间（User Space）。

- Linux下32位环境的用户空间内存分布情况

- <img src="http://c.biancheng.net/uploads/allimg/190122/104P51I1-0.jpg" alt="img" style="zoom:50%;" />

  | 内存分区                 | 说明                                                         |
  | ------------------------ | ------------------------------------------------------------ |
  | 程序代码区 (code)        | 存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。 |
  | 常量区 (constant)        | 存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。 |
  | 全局数据区 (global data) | 存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。 |
  | 堆区 (heap)              | 一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。[malloc()](http://c.biancheng.net/cpp/html/137.html)、[calloc()](http://c.biancheng.net/cpp/html/134.html)、[free()](http://c.biancheng.net/cpp/html/135.html) 等函数操作的就是这块内存，这也是本章要讲解的重点。  注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。 |
  | 动态链接库               | 用于在程序运行期间加载和卸载动态链接库。                     |
  | 栈区 (stack)             | 存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。 |

- 常量区：存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。

- 全局数据区： 存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。

- 程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在。

- 常量区和全局数据区有时也被合称为静态数据区，意思是这段内存专门用来保存数据，在程序运行期间一直存在。

- 常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。

- 函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。

  ```c
  #include <stdio.h>
  
  char *str1 = "c.biancheng.net";  //字符串在常量区，str1在全局数据区
  int n;  //全局数据区
  
  char* func(){
      char *str = "C语言中文网";  //字符串在常量区，str在栈区
      return str;
  }
  
  int main(){
      int a;  //栈区
      char *str2 = "01234";  //字符串在常量区，str2在栈区
      char  arr[20] = "56789";  //字符串和arr都在栈区
      char *pstr = func();  //栈区
      int b;  //栈区
  
      printf("str1: %#X\npstr: %#X\nstr2: %#X\n", str1, pstr, str2);
      puts("--------------");
      printf("&str1: %#X\n   &n: %#X\n", &str1, &n);
      puts("--------------");
      printf("  &a: %#X\n arr: %#X\n  &b: %#X\n", &a, arr, &b);
      puts("--------------");
      printf("n: %d\na :%d\nb: %d\n", n, a, b);
      puts("--------------");
      printf("%s\n", pstr);
  
      return 0;
  }
  
  str1: 0X400710
  pstr: 0X400720
  str2: 0X400731
  --------------
  &str1: 0X601040
     &n: 0X60104C
  --------------
   &a: 0X19D0728C
  arr: 0X19D07270
   &b: 0X19D0726C
  --------------
  n: 0
  a: -858993460
  b: -858993460
  --------------
  C语言中文网
  ```

  - 全局变量的内存在编译时就已经分配好了，它的默认初始值是 0（它所占用的每一个字节都是0值），局部变量的内存在函数调用时分配，它默认初始值是不确定的，由编译器决定，一般是垃圾值，这在《[用一个实例来深入剖析函数进栈出栈的过程](http://c.biancheng.net/view/vip_2103.html)》中会详细讲解。
  - 函数 func() 中的局部字符串常量`"C语言中文网"`也被存储到常量区，不会随着 func() 的运行结束而销毁，所以最后依然能够输出。
  - 字符数组 arr[20] 在栈区分配内存，字符串`"56789"`就保存在这块内存中，而不是在常量区，大家要注意区分。

- 64位环境的用户空间内存分布

  ![](http://c.biancheng.net/uploads/allimg/190122/104P549E-1.jpg)

  - 上图中，用户空间地址的47位是0，所以高16位也是0，换算成十六进制形式，最高的四个数都是0；内核空间地址的47位是1，所以高16位也是1，换算成十六进制形式，最高的四个数都是1。这样中间的一部分地址正好空出来，也就是图中的“未定义区域”，这部分内存无论如何也访问不到。
  - 在64位环境下，虚拟地址虽然占用64位，但只有最低48位有效。这里需要补充的一点是，任何虚拟地址的48位至63位必须与47位一致。

##### 用户模式和内核模式

- 首先我们要解释一个概念——进程（Process）。简单来说，一个可执行程序就是一个进程，前面我们使用C语言编译生成的程序，运行后就是一个进程。进程最显著的特点就是拥有独立的地址空间。
- 前面我们在讲解地址空间时，一直说“程序的地址空间”，这其实是不严谨的，应该说“进程的地址空间”。一个进程对应一个地址空间，而一个程序可能会创建多个进程。
- 所以现在有进程间 通信这个概念，一个程序可能会产生几个进程，每个进程都拥有独立的地址空间。
- 内核空间存放的是操作系统内核代码和数据，是被所有程序共享的，在程序中修改内核空间中的数据不仅会影响操作系统本身的稳定性，还会影响其他程序，这是非常危险的行为，所以操作系统禁止用户程序直接访问内核空间。要想访问内核空间，必须借助操作系统提供的 API 函数，执行内核提供的代码，让内核自己来访问，这样才能保证内核空间的数据不会被随意修改，才能保证操作系统本身和其他程序的稳定性。用户程序调用系统 API 函数称为系统调用（System Call）；发生系统调用时会暂停用户程序，转而执行内核代码（内核也是程序），访问内核空间，这称为内核模式（Kernel Mode）。用户空间保存的是应用程序的代码和数据，是程序私有的，其他程序一般无法访问。当执行应用程序自己的代码时，称为用户模式（User Mode）。
- 计算机会经常在内核模式和用户模式之间切换：
  - 当运行在用户模式的应用程序需要输入输出、申请内存等比较底层的操作时，就必须调用操作系统提供的 API 函数，从而进入内核模式；
  - 操作完成后，继续执行应用程序的代码，就又回到了用户模式。
- 总结：用户模式就是执行应用程序代码，访问用户空间；内核模式就是执行内核代码，访问内核空间（当然也有权限访问用户空间）。
- 为什么要区分两种模式
  - 我们知道，内核最主要的任务是管理硬件，包括显示器、键盘、鼠标、内存、硬盘等，并且内核也提供了接口（也就是函数），供上层程序使用。当程序要进行输入输出、分配内存、响应鼠标等与硬件有关的操作时，必须要使用内核提供的接口。但是用户程序是非常不安全的，内核对用户程序也是充分不信任的，当程序调用内核接口时，内核要做各种校验，以防止出错。
- 为什么内核和用户程序要共用地址空间
  - 既然内核也是一个应用程序，为何不让它拥有独立的4GB地址空间，而是要和用户程序共享、占用有限的内存呢？
  - 让内核拥有完全独立的地址空间，就是让内核处于一个独立的进程中，这样每次进行系统调用都需要切换进程。切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效，这将导致内存的访问在一段时间内相当低效。
  - 而让内核和用户程序共享地址空间，发生系统调用时进行的是模式切换，模式切换仅仅需要寄存器进栈出栈，不会导致缓存失效；现代CPU也都提供了快速进出内核模式的指令，与进程切换比起来，效率大大提高了。

##### 栈

- 程序的虚拟地址空间分为多个区域，栈（Stack）是其中地址较高的一个区域。栈（Stack）可以存放函数参数、局部变量、局部数组等作用范围在函数内部的数据，它的用途就是完成函数的调用。

- 栈内存由系统自动分配和释放：发生函数调用时就为函数运行时用到的数据分配内存，函数调用结束后就将之前分配的内存全部销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部。

- 在计算机中，栈可以理解为一个特殊的容器，用户可以将数据依次放入栈中，然后再将数据按照相反的顺序从栈中取出。也就是说，先放入的数据最后才能取出，而最后放入的数据必须先取出。这称为先进后出（First In Last Out）原则。

  ![](http://c.biancheng.net/uploads/allimg/190122/1051302C3-0.jpg)

  - 放入数据常称为入栈或压栈（Push），取出数据常称为出栈或弹出（Pop）
  - 可以发现，栈底始终不动，出栈入栈只是在移动栈顶，当栈中没有数据时，栈顶和栈底重合。
  - 从本质上来讲，栈是一段连续的内存，需要同时记录栈底和栈顶，才能对当前的栈进行定位。在现代计算机中，通常使用`ebp`寄存器指向栈底，而使用`esp`寄存器指向栈顶。随着数据的进栈出栈，esp 的值会不断变化，进栈时 esp 的值减小，出栈时 esp 的值增大。ebp 是 Extend Base Pointer 的缩写，通常用来指向栈底；esp 是 Extend Stack Pointer 的缩写，通常用来指向栈顶。
  - 栈是一整块空间，每一个函数调用都会有一个栈帧，ebp和esp都是对于一个栈帧来说的，并不是对于整个栈空间来说的，所以我们函数调用时只会根据esp和ebp限制在当前的栈帧，不会访问到另一个栈帧中。所以main函数是一个栈帧，main里面调用的函数是另一个栈帧，所以在main里面设置的变量在其调用的函数里面访问不到，其不是一个栈帧，所以在main函数里面定义的变量其调用的函数要使用时，除非以参数的形式传进去或者将变量设置为全局的。

- 对每个程序来说，栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误。

- 一个程序可以包含多个线程，每个线程都有自己的栈，严格来说，栈的最大值是针对线程来说的，而不是针对程序。

##### 一个函数在栈上是怎样的

- 函数的调用和栈是分不开的，没有栈就没有函数调用，本节就来讲解函数在栈上是如何被调用的。

- 当发生函数调用时，会将函数运行需要的信息全部压入栈中，这常常被称为栈帧（Stack Frame）或活动记录（Activate Record）。栈帧一般包括以下几个方面的内容：

  -  函数的返回地址，也就是函数执行完成后从哪里开始继续执行后面的代码
  - 参数和局部变量。有些编译器，或者编译器在开启优化选项的情况下，会通过寄存器来传递参数，而不是将参数压入栈中，我们暂时不考虑这种情况。
  - 编译器自动生成的临时数据。例如，当函数返回值的长度较大（比如占用40个字节）时，会先将返回值压入栈中，然后再交给函数调用者。
    - 当返回值的长度较小（char、int、long 等）时，不会被压入栈中，而是先将返回值放入寄存器，再传递给函数调用者。
  - 一些需要保存的寄存器，例如 ebp、ebx、esi、edi 等。之所以要保存寄存器的值，是为了在函数退出时能够恢复到函数调用之前的场景，继续执行上层函数。

- 函数调用实例

  ![](http://c.biancheng.net/uploads/allimg/190122/105232B10-0.jpg)
  - 上图是在Windows下使用VS2010 Debug模式编译时一个函数所使用的栈内存，可以发现，理论上 ebp 寄存器应该指向栈底，但在实际应用中，它却指向了old ebp。在寄存器名字前面添加“old”，表示函数调用之前该寄存器的值。
  - 当发生函数调用时：
    - 实参、返回地址、ebp 寄存器首先入栈；
    - 然后再分配一块内存供局部变量、返回值等使用，这块内存一般比较大，足以容纳所有数据，并且会有冗余；
    - 最后将其他寄存器的值压入栈中。

- 关于数据的定位

  - 由于 esp 的值会随着数据的入栈而不断变化，要想根据 esp 找到参数、局部变量等数据是比较困难的，所以在实现上是根据 ebp 来定位栈内数据的。ebp 的值是固定的，数据相对 ebp 的偏移也是固定的，ebp 的值加上偏移量就是数据的地址。

    ```
    void func(int a, int b){
        float f = 28.5;
        int n = 100;
        //TODO:
    }
    
    func(15, 92);
    ```

    ![](http://c.biancheng.net/uploads/allimg/190122/10523260c-1.jpg)

  - 这里我们假设两个局部变量挨着，并且第一个变量和 old ebp 也挨着（实际上它们之间有4个字节的空白），如此，第一个参数的地址是 ebp+12，第二个参数的地址是 ebp+8，第一个局部变量的地址是 ebp-4，第二个局部变量的地址是 ebp-8。

##### 一个实例剖析函数进栈出栈的过程

```
void func(int a, int b){
    int p =12, q = 345;
}
int main(){
    func(90, 26);
    return 0;
}
```

- 函数使用默认的调用惯例 cdecl，即参数从右到左入栈，由调用方负责将参数出栈。函数的进栈出栈过程如下图所示：

  ![](http://c.biancheng.net/uploads/allimg/190122/10553TG3-0.jpg)

- 步骤①到⑥是函数进栈过程：
  1) main() 是主函数，也需要进栈，如步骤①所示。

  2) 在步骤②中，执行语句`func(90, 26);`，先将实参 90、26 压入栈中，再将返回地址压入栈中，这些工作都由 main() 函数（调用方）完成。这个时候 ebp 的值并没有变，仅仅是改变 esp 的指向。

  3) 到了步骤③，就开始执行 func() 的函数体了。首先将原来 ebp 寄存器的值压入栈中（也即图中的 old ebp），并将 esp 的值赋给 ebp，这样 ebp 就从 main() 函数的栈底指向了 func() 函数的栈底，完成了函数栈的切换。由于此时 esp 和ebp 的值相等，所以它们也就指向了同一个位置。

  4) 为局部变量、返回值等预留足够的内存，如步骤④所示。由于栈内存在函数调用之前就已经分配好了，所以这里并不是真的分配内存，而是将 esp 的值减去一个整数，例如 esp - 0XC0，就是预留 0XC0 字节的内存。

  5) 将 ebp、esi、edi 寄存器的值依次压入栈中。

  6) 将局部变量的值放入预留好的内存中。注意，第一个变量和 old ebp 之间有4个字节的空白，变量之间也有若干字节的空白。

  为什么要留出这么多的空白，岂不是浪费内存吗？这是因为我们使用Debug模式生成程序，留出多余的内存，方便加入调试信息；以Release模式生成程序时，内存将会变得更加紧凑，空白也被消除。

  至此，func() 函数的活动记录就构造完成了。可以发现，在函数的实际调用过程中，形参是不存在的，不会占用内存空间，内存中只有实参，而且是在执行函数体代码之前、由调用方压入栈中的。

- 未初始化的局部变量为什么是垃圾值，为局部变量分配内存时，仅仅是将 esp 的值减去一个整数，预留出足够的空白内存，不同的编译器在不同的模式下会对这片空白内存进行不同的处理，可能会初始化为一个固定的值，也可能不进行初始化。

- 步骤⑦到⑨是函数 func() 出栈过程：
  7) 函数 func() 执行完成后开始出栈，首先将 edi、esi、ebx 寄存器的值出栈。

  8) 将局部变量、返回值等数据出栈时，直接将 ebp 的值赋给 esp，这样 ebp 和 esp 就指向了同一个位置。

  9) 接下来将 old ebp 出栈，并赋值给现在的 ebp，此时 ebp 就指向了 func() 调用之前的位置，即 main() 活动记录的 old ebp 位置，如步骤⑨所示。

  这一步很关键，保证了还原到函数调用之前的情况，这也是每次调用函数时都必须将 old ebp 压入栈中的原因。

  最后根据返回地址找到下一条指令的位置，并将返回地址和实参都出栈，此时 esp 就指向了 main() 活动记录的栈顶， 这意味着 func() 完全出栈了，栈被还原到了 func() 被调用之前的情况。

- 遗留的错误认知，经过上面的分析可以发现，函数出栈只是在增加 esp 寄存器的值，使它指向上一个数据，并没有销毁之前的数据。前面我们讲局部变量在函数运行结束后立即被销毁其实是错误的，这只是为了让大家更容易理解，对局部变量的作用范围有一个清晰的认识。栈上的数据只有在后续函数继续入栈时才能被覆盖掉，这就意味着，只要时机合适，在函数外部依然能够取得局部变量的值。

  ```
  #include <stdio.h>
  int *p;
  void func(int m, int n){
      int a = 18, b = 100;
      p = &a;
  }
  int main(){
      int n;
      func(10, 20);
      n = *p;
      printf("n = %d\n", n);
      return 0;
  }
  
  n = 18
  ```

  - 在 func() 中，将局部变量 a 的地址赋给 p，在 main() 函数中调用 func()，函数刚刚调用结束，还没有其他函数入栈，局部变量 a 所在的内存没有被覆盖掉，所以通过语句`n = *p;`能够取得它的值。
  - 

##### 堆

- free(p) 并不能改变指针 p 的值，p 依然指向以前的内存，为了防止再次使用该内存，建议将 p 的值手动置为 NULL。
- void* malloc (size_t size);分配内存在动态存储区（堆区），手动分配，手动释放，申请时空间可能有也可能没有，需要自行判断，由于返回的是void*，建议手动强制类型转换。

##### 野指针以及非法内存操作

- 野指针：如果一个指针指向的内存没有访问权限，或者指向一块已经释放掉的内存，那么就无法对该指针进行操作，这样的指针称为野指针（Wild Pointer）。

- 指向没有访问权限的内存

  ```
  #include <stdio.h>
  int main(){
      char *str;
      gets(str);
      puts(str);
      return 0;
  }
  ```

  - 在GCC下运行，输入一个字符串后会提示`段错误（Segment Fault）`
  - 这是因为，str 是局部变量，它的值是不确定的，是随机的，不知道指向哪块内存。一般情况下，这块内存要么没有访问权限，要么还没有分配，当 gets() 函数试图将读取到的字符串写入这块内存时，必然会发生错误。
  - 当然，如果足够幸运的话，str 也可能恰好指向一段分配好的、并且有读写权限的内存，程序就运行成功了，但这是小概率事件，一般不会发生。

- 指向释放的内存

  ```
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  int main(){
      char *str = (char*)malloc(20*sizeof(char));
      strcpy(str, "C语言中文网");
      puts(str);
      free(str);
      if(str){
          puts(str);
      }
      return 0;
  }
  ```

  - 运行程序，第一次输出`C语言中文网`，第二次输出的是乱码或者什么也不输出。这是因为，freed() 只是释放掉了动态分配的内存，但并未改变 str 的值，str 的值不是 NULL，它仍然指向被释放掉的内存，所以会执行 if 语句里面的 puts() 函数。但由于此时的内存已经被释放掉了，原来的字符串已经不在了，所以输出的数据是未知的。

  - 这就提醒我们，使用 free() 释放内存的同时要将指针置为`NULL`，否则下次就无法判断指向的内存是否有效。

  - 还有一种情况是函数外部指针指向函数内部的变量、数组等

    ```
    #include <stdio.h>
    void func(char **pp);
    int main(){
        char *pstr;
        func(&pstr);
        puts(pstr);
        return 0;
    }
    void func(char **pp){
        char arr[] = "C语言中文网";
        *pp = arr;
    }
    ```

    - arr 数组在栈上分配内存，字符串`"C语言中文网"`就存储在这里，func() 函数运行结束后，这块内存被释放掉，但是函数外部的 pstr 仍然指向这里，所以执行`puts(pstr);`时，输出结果是未知的。

- 要想规避野指针，就要养成良好的编程习惯：
  - 指针变量如果暂时不需要赋值，一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。
  - 当指针指向的内存被释放掉时，要将指针的值设置为 NULL，因为 free() 只是释放掉了内存，并为改变指针的值。

##### 内存泄漏

- 内存泄漏：使用 malloc()、calloc()、realloc() 动态分配的内存，如果没有指针指向它，就无法进行任何操作，这段内存会一直被程序占用，直到程序运行结束由操作系统回收。

  ```c
  int main(){
      char *p = (char*)malloc(100 * sizeof(char));
      p = (char*)malloc(50 * sizeof(char));
      free(p);
      p = NULL;
      return 0;
  }
  该程序中，第一次分配 100 字节的内存，并将 p 指向它；第二次分配 50 字节的内存，依然使用 p 指向它。
      这就导致了一个问题，第一次分配的 100 字节的内存没有指针指向它了，而且我们也不知道这块内存的地址，所以就再也无法找回了，也没法释放了，这块内存就成了垃圾内存，虽然毫无用处，但依然占用资源，唯一的办法就是等程序运行结束后由操作系统回收。
      这就是内存泄露（Memory Leak），可以理解为程序和内存失去了联系，再也无法对它进行任何操作。
      内存泄漏形象的比喻是“操作系统可提供给所有程序使用的内存空间正在被某个程序榨干”，最终结果是程序运行时间越长，占用内存空间越来越多，最终用尽全部内存空间，整个系统崩溃。
  ```

- free() 函数的用处在于实时地回收内存，如果程序很简单，程序结束之前也不会使用过多的内存，不会降低系统的性能，那么也可以不用写 free() 函数。当程序结束后，操作系统会释放内存。

- 但是如果在开发大型程序时不写 free() 函数，后果是很严重的。这是因为很可能在程序中要重复一万次分配10MB的内存，如果每次进行分配内存后都使用 free() 函数去释放用完的内存空间， 那么这个程序只需要使用10MB内存就可以运行。但是如果不使用 free() 函数，那么程序就要使用100GB 的内存！这其中包括绝大部分的虚拟内存，而由于虚拟内存的操作需要读写磁盘，因此，这样会极大地影响到系统的性能，系统因此可能崩溃。

- 因此，在程序中使用 malloc() 分配内存时都对应地写出一个 free() 函数是一个良好的编程习惯。这不但体现在处理大型程序时的必要性，并能在一定程度上体现程序优美的风格和健壮性。

##### static变量

- static 声明的变量称为静态变量，不管它是全局的还是局部的，都存储在静态数据区（全局变量本来就存储在静态数据区，即使不加 static）。
- 静态数据区的数据在程序启动时就会初始化，直到程序运行结束；对于代码块中的静态局部变量，即使代码块执行结束，也不会销毁。
- 注意：静态数据区的变量只能初始化（定义）一次，以后只能改变它的值，不能再被初始化，即使有这样的语句，也无效。


#### 头文件的编写

###### 强符号和弱符号

- 在C语言中，编译器默认函数和初始化了的全局变量为强符号（Strong Symbol），未初始化的全局变量为弱符号（Weak Symbol）。强符号之所以强，是因为它们拥有确切的数据，变量有值，函数有函数体；弱符号之所以弱，是因为它们还未被初始化，没有确切的数据。
- 链接器会按照如下的规则处理被多次定义的强符号和弱符号：函数和变量最后都是以变量的形式来体现的，函数定义都是强符号，变量根据是否初始化分为强弱。
  - 不允许强符号被多次定义，也即不同的目标文件中不能有同名的强符号；如果有多个强符号，那么链接器会报符号重复定义错误。
  - 如果一个符号在某个目标文件中是强符号，在其他文件中是弱符号，那么选择强符号。
  -  如果一个符号在所有的目标文件中都是弱符号，那么选择其中占用空间最大的一个。
  - 比如目标文件 a.o 定义全局变量 global 为 int 类型，占用4个字节，目标文件 b.o 定义 global 为 double 类型，占用8个字节，那么被链接后，符号 global 占用8个字节。请尽量不要使用多个不同类型的弱符号，否则有时候很难发现程序错误。
- 在 GCC 中，可以通过`__attribute__((weak))`来强制定义任何一个符号为弱符号
- `__attribute__((weak))`只对链接器有效，对编译器不起作用，编译器不区分强符号和弱符号，只要在一个源文件中定义两个相同的符号，不管它们是强是弱，都会报“重复定义”错误。
- 弱符号对于库来说十分有用，我们在开发库时，可以将某些符号定义为弱符号，这样就能够被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的函数，增加了很大的灵活性。
- 强弱符号是定义时，强弱引用是引用时，两者概念不一样，强弱符号中强符号可以覆盖弱符号，而强弱引用只是在引用时，如果是弱引用，找不到符号时不报错。

###### 强引用和弱引用

- 所谓引用（Reference），是指对符号的使用。

  ```c
  int a = 100, b = 200, c;
  c = a + b;   //第一行是符号定义，第二行是符号引用。
  ```

  - 目前我们所看到的符号引用，在所有目标文件被链接成可执行文件时，它们的地址都要被找到，如果没有符号定义，链接器就会报符号未定义错误，这种被称为强引用（Strong Reference）。
  - 与之相对应的还有一种弱引用（Weak Reference），如果符号有定义，就使用它对应的地址，如果没有定义，也不报错。
  - 链接器处理强引用和弱引用的过程几乎是一样的，只是对于未定义的弱引用，链接器不认为它是一个错误，一般默认其为 0（地址为 0），或者是一个特殊的值，以便程序代码能够识别。
  - 在变量声明或函数声明的前面加上`__attribute__((weak))`就会使符号变为弱引用。

  ```c
  //如果不判断，直接使用，如果变量a和函数func都没有定义，此时就会出错，因为是弱引用，两个地址都是0，所以需要判断，如果没有定义，即没有地址时，不访问。
  #include <stdio.h>
  __attribute__((weak)) extern int a;
  __attribute__((weak)) extern void func();
  int main(){
      printf("&a: %d, func: %d\n", &a, func);
      if(&a){
          printf("a = %d\n", a);
      }else{
          printf("a is undefined!\n");
      }
      if(func){
          func();
      }else{
          printf("func() is undefined!\n");
      }
      return 0;
  }  //代码中需要判断的是地址，不是值，所以变量 a 前面需要加&；而函数名本身就表示地址，所以 func 前边不需要&。
  ```

- 弱引用和强引用非常利于程序的模块化开发，我们可以将程序的扩展模块定义为弱引用，当我们将扩展模块和程序链接在一起时，程序就可以正常使用；如果我们去掉了某些模块，那么程序也可以正常链接，只是缺少了某些功能，这使得程序的功能更加容易裁剪和组合。

- 头文件防止重复包含，宏保护

  ```c
  #ifndef _XYZ_H
  #define _XYZ_H
  /* 头文件内容 */
  #endif
  ```

###### static

- 实际开发中，我们通常将不需要被其他模块调用的全局变量或函数用 **static** 关键字来修饰，static 能够将全局变量和函数的作用域限制在当前文件中，在其他文件中无效。当其他文件中有同样的函数名时就不会出错了。因为static修饰的只在当前文件中有效，不会暴露给其他文件。其他文件链接时也不会寻找到这个static修饰的符号。

- static 除了可以修饰全局变量，还可以修饰局部变量，被 static 修饰的变量统称为静态变量（Static Variable）。

- 不管是全局变量还是局部变量，只要被 static 修饰，都会存储在全局数据区（全局变量本来就存储在全局数据区，即使不加 static）。

- 全局数据区的数据在程序启动时就被初始化，一直到程序运行结束才会被操作系统回收内存；对于函数中的静态局部变量，即使函数调用结束，内存也不会销毁。

- 全局数据区的变量只能被初始化（定义）一次，以后只能改变它的值，不能再被初始化，即使有这样的语句，也无效。

  ```c
  #include <stdio.h>
  int func(){
      // 也可以不赋初值 0，静态数据区的变量默认初始化为 0
      static int n = 0;
      n++;
      printf("Function is called %d times.\n", n);
      return n;
  }
  int main(){
      int i, n = 0;
      for(i = 1; i<=5; i++){
          func();
      }
      printf("n = %d\n", n);
      return 0;
  }   //我们在 func() 中定义了一个静态局部变量 n，它存储在全局数据区，func() 函数执行结束不会被销毁，下次调用继续有效。全局数据区的变量只能初始化一次，第一次调用 func() 时已经对 n 进行了初始化，所以再次调用时就不会重复初始化了，也就是说static int result = 0;语句无效。
     //静态局部变量虽然存储在全局数据区，但是它的作用域仅限于函数内部，func() 中的 n 在函数外无效，与 main() 中的 n 不冲突，除了变量名一样，没有任何关系。
  ```

- 静态变量属于静态存储方式，其存储空间为内存中的静态数据区（在 静态存储区内分配存储单元），该区域中的数据在整个程序的运行期间一直占用这些存储空间（在程序整个运行期间都不释放），也可以认为是其内存地址不变，直 到整个程序运行结束（相反，而auto自动变量，即动态局部变量，属于动态存储类别，占动态存储空间，函数调用结束后即释放）。静态变量虽在程序的整个执 行过程中始终存在，但是在它作用域之外不能使用。
- 所有的全局变量都是静态变量，而局部变量只有定义时加上类型修饰符static，才为局部静态变量。
- 静态变量并不是说其就不能改变值，不能改变值的量叫常量。 其拥有的值是可变的 ，而且它会保持最新的值。说其静态，是因为它不会随着函数的调用和退出而发生变化。即上次调用函数的时候，如果我们给静态变量赋予某个值的话，下次函数调用时，这个值保持不变。
- 静态局部变量
  - Static内部变量同auto自动变量（即未加 Static 声明的局部变量）一样，是某个特定函数的局部变量，即只能在定义该变量的函数内使用该变量，2者作用域相同；两者的不同在于：auto自动变量会随着函数 被调用和退出而存在和消失，而static类局部变量不会，它不管其所在的函数是否被调用，都将一直存在；不过，尽管该变量还继续存在，但不能使用它。倘 若再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后留下的值。换言之，Static类型的内部变量是一种只能在某个特定函数中使用，但一 直占据存储空间的变量。
  - 函数体内如果在定义静态变量的同时进行了初始化，则以后程序不再进行初始化操作（出现在函数内部的基本类型的的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。
  - 静态局部变量的初始化表达式必须是一个常量或者常量表达式。即使局部静态变量定义时没有赋初值，系统会自动赋初值0（对数值型变量）或空字符（对字符变量）；静态变量的初始值为0。而对自动变量auto来说，如果不赋初值则它的值将是个不确定的值。
  - 当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。虽然用全局变量也可以达到上述目的，但全局变量有时会造成意外的副作用，因此仍以采用局部静态变量为宜。
  - 局部静态变量占用内存时间较长，并且可读性差，因此，除非必要，尽量避免使用局部静态变量。
- 静态全局变量
  - 全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。
  - 这两者的区别虽在于：
    1、非静态全局变量的作用域是整个源程序 ，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。
    2、静态全局变量则限制了其作用域， 即只在定义该变量的源文件 内有效，在同一源程序的其它源文件(即声明了该变量的CPP文件,或包含该变量声明头文件的CPP文件)中不能使用它。
  - 由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
- 从以上分析可以看出
  把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期。
  把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。
- 设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题。所谓"可重入"（也可以说是可预测的），即：只要输入数据相同就应产生相同的输出。
  -  函数中使用了static变量，因为static变量的特征，这样的函数被称为：带“内部存储器”功能的的函数。
  - 如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量，这种函数中的static变量，使用原则是，能不用尽量不用。
  - 有些时候，在函数中是必须要使用static变量的，比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

#### 多线程编程

- 如果锁是全局的锁的就是全局的数据和变量，如果锁是局部的锁的就是局部的变量，拿到这把锁不会导致全局的变量上锁，只是当前作用域内的局部变量会上锁，和其他作用域内的变量是无关的。类似于在一个类中创建了一个变量，然后创建了一把锁，这把锁锁上的只是在类中创建的这个变量，和其他的变量无关。

  ```
  例如
  int a = 3;
  int b = 5;
  InsertData data;这是声明了一个带锁的类对象
  
  这样这把锁也是锁的类里面定义的变量，对于变量a和变量b，是不会锁住的，因为类本身就是一个作用域，如果要把a和b也锁住，需要在类外面和ab同级的作用域内声明一把锁才行。
  ```

- 多线程锁的理解，每一把锁锁的数据是自己定义的，并不是说加把锁就把当前作用域内所有的数据都加上锁了，正确的理解是lock和unlock之间要访问的当前作用域的数据才会被锁上，其他的并不会加锁

  ```
  class XBusRequestMessage
  {
  protected:
  	HTOPIC m_policyTopic;
  	HTOPIC m_auditorTopic;
  	HTOPIC m_dbTopic;
  	HTOPIC m_shareTopic;
  	HTOPIC m_taskTopic;
  	
  	XMutex m_policyTopicLock;
  	XMutex m_auditorTopicLock;
  	XMutex m_dbTopicLock;
  	XMutex m_shareTopicLock;
  	XMutex m_taskTopicLock;
  public:
  	XBusRequestMessage();
  	virtual ~XBusRequestMessage();
  	
  	// -- msgbus_free_buffer free resp
  	int sendBusPolicy(HBUS bus, const char *sendJson, char ** resp);
  	int sendBusAudit(HBUS bus, char *sendJson);
  	int sendBusAuditQuery(HBUS bus, const char *sendJson, char ** resp);
  	int sendBusDb(HBUS bus, char *sendJson, char ** resp);
  	int sendBusTask(HBUS bus, const char *sendJson, char ** resp);
  	int sendBroadcast(HBUS bus, char *sendJson);
  };
  
  
  int XBusRequestMessage::sendBusPolicy(HBUS bus, const char *sendJson, char ** resp)
  {
  	int retval = -1;
  	int error;
  	int flag;
  	m_policyTopicLock.Lock();
  	if(!m_policyTopic){
  		if(!bus){
  			printf("XBusRequestMessage bus is NULL ...\n");
  			goto DONE;
  		}
  		
  		m_policyTopic = msgbus_open_topic(bus, __TOPIC_NAME_POLICY, &error);
  		if(!m_policyTopic){
  			printf("failed to open topic <%s>:%s\n", __TOPIC_NAME_POLICY, msgbus_get_error_string(error));
  			goto DONE;
  		}
  	}
  	
  	flag = msgbus_topic_send_timeout(m_policyTopic, sendJson, 10, resp);
  	if(0 != flag){
  		printf("failed to send message to topic <%s>(%d):%s\n", __TOPIC_NAME_POLICY, flag, msgbus_get_error_string(flag));
  	}
  	if(__is_broken_error(flag)){
  		if(m_policyTopic){
  			msgbus_close_topic(m_policyTopic);
  			m_policyTopic = NULL;
  		}
  		goto DONE;
  	}
  	
  	retval = 0;
  DONE:
  	m_policyTopicLock.Unlock();
  	return retval;
  }
  ```

  - 此示例就是五个数据五把锁，各锁个的，互不影响，只有操作数据时，加锁，这个之间的数据才会被锁上，其他的并不会锁上

- 注意理解在锁解锁的时候会有一个在内核态唤醒其他线程的过程，这个是内核做的事情，因为试图获取被锁锁定的资源的时候，内核就会把线程加入到一个队列中，如果这个锁被释放，就通知这些队列中的线程，这是内核态的设计及实现

- 我们知道，一个进程指的是一个正在执行的应用程序。线程对应的英文名称为“thread”，它的功能是执行应用程序中的某个具体任务，比如一段程序、一个函数等。

- 每个进程执行前，操作系统都会为其分配所需的资源，包括要执行的程序代码、数据、内存空间、文件资源等。一个进程至少包含 1 个线程，可以包含多个线程，所有线程共享进程的资源，各个线程也可以拥有属于自己的私有资源。

- 进程仅负责为各个线程提供所需的资源，真正执行任务的是线程，而不是进程。

- 所有线程共享的进程资源有：
  - 代码：即应用程序的代码；
  - 数据：包括全局变量、函数内的静态变量、堆空间的数据等；
  - 进程空间：操作系统分配给进程的内存空间；
  - 打开的文件：各个线程打开的文件资源，也可以为所有线程所共享，例如线程 A 打开的文件允许线程 B 进行读写操作。

- 各个线程也可以拥有自己的私有资源，包括寄存器中存储的数据、线程执行所需的局部变量（函数参数）等。

- 当进程中仅包含 1 个执行程序指令的线程时，该线程又称“主线程”，这样的进程称为“单线程进程”。

- 类 UNIX 系统有很多种版本，包括 Linux、FreeBSD、OpenBSD 等，它们预留的系统调用接口各不相同。但幸运的是，几乎所有的类 UNIX 系统都兼容 POSIX 标准。POSIX 标准全称“**P**ortable **O**perating **S**ystem **I**nterface”，中文译为可移植操作系统接口，最后的字母 X 代指类 UNIX 操作系统。简单地理解，POSIX 标准发布的初衷就是为了统一所有类 UNIX 操作系统的接口，这意味着，只要我们编写的程序严格按照 POSIX 标准调用系统接口，它就可以在任何兼容 POSIX 标准的类 UNIX 系统上运行。POSIX 标准中规范了与多线程相关的系统接口。我们在 Linux 系统上编写多线程程序，只需在程序中引入`<pthread.h>`头文件，调用该文件中包含的函数即可实现多线程编程。

- 第一个多线程程序

  ```c
  #include <stdio.h>
  #include <pthread.h>
  //定义线程要执行的函数，arg 为接收线程传递过来的数据
  void *Thread1(void *arg)
  {
      printf("http://c.biancheng.net\n");
      return "Thread1成功执行";
  }
  //定义线程要执行的函数，arg 为接收线程传递过来的数据
  void* Thread2(void* arg)
  {
      printf("C语言中文网\n");
      return "Thread2成功执行";
  }
  int main()
  {
      int res;
      pthread_t mythread1, mythread2;
      void* thread_result;
      /*创建线程
      &mythread:要创建的线程
      NULL：不修改新建线程的任何属性
      ThreadFun:新建线程要执行的任务
      NULL：不传递给 ThreadFun() 函数任何参数
      返回值 res 为 0 表示线程创建成功，反之则创建失败。
      */
      res = pthread_create(&mythread1, NULL, Thread1, NULL);
      if (res != 0) {
          printf("线程创建失败");
          return 0;
      }
      res = pthread_create(&mythread2, NULL, Thread2, NULL);
      if (res != 0) {
          printf("线程创建失败");
          return 0;
      }
      /*
      等待指定线程执行完毕
      mtThread:指定等待的线程c
      &thead_result:接收 ThreadFun() 函数的返回值，或者接收 pthread_exit() 函数指定的值
      返回值 res 为 0 表示函数执行成功，反之则执行失败。
      */
      res = pthread_join(mythread1, &thread_result);
      //输出线程执行完毕后返回的数据
      printf("%s\n", (char*)thread_result);
     
      res = pthread_join(mythread2, &thread_result);
      printf("%s\n", (char*)thread_result);
      printf("主线程执行完毕");
      return 0;
  }
  
  http://c.biancheng.net
  C语言中文网
  Thread1成功执行
  Thread2成功执行
  主线程执行完毕
  ```

  - 程序中调用了两次 pthread_join() 函数，第 47 行 pthread_join() 函数的功能是令主线程等待 mythread1 线程执行完毕后再执行后续的代码，第 51 行处 pthread_join() 函数的功能是令主线程等待 mythread2 线程执行完毕后在执行后续的代码。

##### 多线程理解

- 进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；

  线程是进程的子任务，是CPU调度和分派的基本单位**，**用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。

- 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）

- 线程是cpu调度和分派的基本，linux下线程其实是一个伪进程，所以每一个线程都是运行在一个cpu核心上的，并不是一个进程占用一个cpu核心，一个cpu核心上按时间片切换线程，这样跟单线程差不多，没有压榨cpu性能，所以多线程是为了压榨cpu性能，一个cpu核心上就能跑一个线程，而这些线程的调度是根据进程来的，进程切换，这些线程就切换。至于怎么切换和多个线程共享同一个进程的资源，这些是操作系统调用的问题，目前还不了解。

##### 创建线程

- ```c
  int pthread_create(pthread_t *thread,
                     const pthread_attr_t *attr,
                     void *(*start_routine) (void *),
                     void *arg);
  ```

  - pthread_t *thread：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程。
  
  - const pthread_attr_t *attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。
  
  - void \*(\*start_routine) (void \*)：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void* 类型。void* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。
    - 这个参数是线程运行函数的起始地址，函数名就代表起始地址，但是函数的返回类型和形参都是void *
    - 此形参是指明线程执行的函数void *ThreadFun(void *arg)，在创建线程时只需要将ThreadFun当做参数传进去就可以。指明线程要执行的函数。
    
  - void *arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。
  
  - 如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：
    - EAGAIN：系统资源不足，无法提供创建线程所需的资源。
    - EINVAL：传递给 pthread_create() 函数的 attr 参数无效。
    - EPERM：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限。
    - 以上这些宏都声明在 <errno.h> 头文件中，如果程序中想使用这些宏，需提前引入此头文件。
    
    ```c
    #include <stdio.h>
    #include <unistd.h>   //调用 sleep() 函数
    #include <pthread.h>  //调用 pthread_create() 函数
    void *ThreadFun(void *arg)
    {
        if (arg == NULL) {
            printf("arg is NULL\n");
        }
        else {
            printf("%s\n", (char*)arg);
        }
        return NULL;
    }
    int main()
    {
        int res;
        char * url = "http://www.biancheng.net";
        //定义两个表示线程的变量（标识符）
        pthread_t myThread1,myThread2;
        //创建 myThread1 线程
        res = pthread_create(&myThread1, NULL, ThreadFun, NULL);
        if (res != 0) {
            printf("线程创建失败");
            return 0;
        }
        sleep(5);  //令主线程等到 myThread1 线程执行完成
        
        //创建 myThread2 线程
        res = pthread_create(&myThread2, NULL, ThreadFun,(void*)url);
        if (res != 0) {
            printf("线程创建失败");
            return 0;
        }
        sleep(5); // 令主线程等到 mythread2 线程执行完成
        return 0;
    }
    
    arg is NULL
    http://www.biancheng.net
    ```
    
    - 程序中共创建了 2 个线程，分别命名为 myThread1 和 myThread2。myThread1 和 myThread2 线程执行的都是 threadFun() 函数，不同之处在于，myThread1 线程没有给 threadFun() 函数传递任何数据，而 myThread2 线程向 threadFun() 函数传递了 "http://www.biancheng.net" 这个字符串。
  
- pthread_create() 函数成功创建的线程会自动执行指定的函数，不需要手动开启。此外，为了确保创建的线程能在主线程之前执行完，程序中调用 sleep() 函数延缓了主线程的执行速度。

- 您可以尝试将程序中的 sleep() 函数全部注释掉，然后重新编译、执行此程序。整个进程会随着主线程执行结束而立即终止，由于主线程执行太快，子线程可能尚未执行完就被强制终止。

##### 中止线程执行

- 多线程程序中，终止线程执行的方式有 3 种，分别是：
  - 线程执行完成后，自行终止；
  - 线程执行过程中遇到了 pthread_exit() 或者 return，也会终止执行；
  - 线程执行过程中，接收到其它线程发送的“终止执行”的信号，然后终止执行。

- 在 C 语言中，return 关键字用于终止函数执行，必要时还能将函数的执行结果反馈给调用者。return 关键字不仅可以用于普通函数，线程函数中也可以使用它。

- `<pthread.h>`头文件中，提供有一个和 return 关键字相同功能的 pthread_exit() 函数。和之前不同，pthread_exit() 函数只适用于线程函数，而不能用于普通函数。

  ```
  void pthread_exit(void *retval);
  ```

  - retval 是`void*`类型的指针，可以指向任何类型的数据，它指向的数据将作为线程退出时的返回值。如果线程不需要返回任何数据，将 retval 参数置为`NULL`即可。
  - retval 指针不能指向函数内部的局部数据（比如局部变量）。换句话说，pthread_exit() 函数不能返回一个指向局部数据的指针，否则很可能使程序运行结果出错甚至崩溃。

  ```c
  #include <stdio.h>
  #include <pthread.h>
  //线程要执行的函数，arg 用来接收线程传递过来的数据
  void *ThreadFun(void *arg)
  {
      //终止线程的执行，将“http://c.biancheng.net”返回
      pthread_exit("http://c.biancheng.net"); //返回的字符串存储在常量区，并非当前线程的私有资源
      printf("*****************");//此语句不会被线程执行
  }
  int main()
  {
      int res;
      //创建一个空指针
      void * thread_result;
      //定义一个表示线程的变量
      pthread_t myThread;
      res = pthread_create(&myThread, NULL, ThreadFun, NULL);
      if (res != 0) {
          printf("线程创建失败");
          return 0;
      }
      //等待 myThread 线程执行完成，并用 thread_result 指针接收该线程的返回值
      res = pthread_join(myThread, &thread_result);
      if (res != 0) {
          printf("等待线程失败");
      }
      printf("%s", (char*)thread_result);
      return 0;
  }
  
  http://c.biancheng.net
  ```

  - myThread 线程并没有执行 ThreadFun() 函数中最后一个 printf() 语句，从侧面验证了 pthread_exit() 函数的功能。此外，我们通过在主线程（main() 函数）调用 pthread_join() 函数，获取到了 myThread 线程返回的数据。

- 既然 return 关键字也适用于线程函数，<pthread.h> 头文件为什么还提供 pthread_exit() 函数，不是多此一举吗？首先，return 语句和 pthread_exit() 函数的含义不同，return 的含义是返回，它不仅可以用于线程执行的函数，普通函数也可以使用；pthread_exit() 函数的含义是线程退出，它专门用于结束某个线程的执行。在主线程（main() 函数）中，return 和 pthread_exit() 函数的区别最明显。举个例子：

  ```
  #include <stdio.h>
  #include <pthread.h>
  void *ThreadFun(void *arg)
  {
      sleep(5);//等待一段时间
      printf("http://c.biancheng.net\n");
  }
  int main()
  {
      int res;
      pthread_t myThread;
      
      res = pthread_create(&myThread, NULL, ThreadFun, NULL);
      if (res != 0) {
          printf("线程创建失败");
          return 0;
      }
      printf("C语言中文网\n");
      return 0;
  }
  
  C语言中文网
  ```

  - 主线程正常执行结束，myThread 线程并没有输出指定的数据。原因很简单，主线程执行速度很快，主线程最后执行的 return 语句不仅会终止主线程执行，还会终止其它子线程执行。也就是说，myThread 线程还没有执行输出语句就被终止了。

  - 将上面程序中，main() 函数中的`return 0;`用如下语句替换：

    ```
    pthread_exit(NULL);
    
    C语言中文网
    http://c.biancheng.net
    ```

  - pthread_exit() 函数只会终止当前线程，不会影响其它线程的执行。所以在main函数中主线程可以使用这个来退出，而其他的线程正常执行完成后退出

  - 总之，如果实际场景中想终止某个子线程，强烈建议大家使用 pthread_exit() 函数。终止主线程时，return 和 pthread_exit() 函数发挥的功能不同，可以根据需要自行选择。

- 多线程程序中，一个线程还可以向另一个线程发送“终止执行”的信号，这时就需要调用 pthread_cancel() 函数。

  ```
  int pthread_cancel(pthread_t thread);
  ```
  
  - 如果 pthread_cancel() 函数成功地发送了 Cancel 信号，返回数字 0，否则返回非零数。对于因“未找到目标线程”导致的信号发送失败，函数返回 ESRCH 宏（定义在`<errno.h>`头文件中，该宏的值为整数 3）。
  
  - pthread_cancel() 函数的功能仅仅是向目标线程发送 Cancel 信号，至于目标线程是否接收该信号，何时响应该信号，全由目标线程决定
  
  - 对于接收 Cancel 信号后结束执行的目标线程，等同于该线程自己执行如下语句：
  
    ```
    pthread_exit(PTHREAD_CANCELED);
    ```
  
    - 也就是说，当一个线程被强制终止执行时，它会返回PTHREAD_CANCELED这个宏
  
- 接下来通过一个样例，给大家演示 pthread_cancel() 函数的用法：

  ```c
  #include <stdio.h>
  #include <pthread.h>
  #include <stdlib.h>     // sleep() 函数
  //线程执行的函数
  void * thread_Fun(void * arg) {
      printf("新建线程开始执行\n");
      sleep(10);
  }
  int main()
  {
      pthread_t myThread;
      void * mess;
      int value;
      int res;
      //创建 myThread 线程
      res = pthread_create(&myThread, NULL, thread_Fun, NULL);
      if (res != 0) {
          printf("线程创建失败\n");
          return 0;
      }
      sleep(1);
      //向 myThread 线程发送 Cancel 信号
      res = pthread_cancel(myThread);
      if (res != 0) {
          printf("终止 myThread 线程失败\n");
          return 0;
      }
      //获取已终止线程的返回值
      res = pthread_join(myThread, &mess);
      if (res != 0) {
          printf("等待线程失败\n");
          return 0;
      }
      //如果线程被强制终止，其返回值为 PTHREAD_CANCELED
      if (mess == PTHREAD_CANCELED) {
          printf("myThread 线程被强制终止\n");
      }
      else {
          printf("error\n");
      }
      return 0;
  }
  
  新建线程开始执行
  myThread 线程被强制终止
  ```

- 实际使用 pthread_cancel() 函数时，很多读者会发现“Cancel 信号成功发送，但目标线程并未立即终止执行”等类似的问题举个例子，在 Linux 环境中执行如下程序：

  ```
  #include <stdio.h>
  #include <pthread.h>
  #include <stdlib.h>
  void * thread_Fun(void * arg) {
      printf("新建线程开始执行\n");
      //插入无限循环的代码，测试 pthread_cancel()函数的有效性
      while(1);
  }
  int main()
  {
      pthread_t myThread;
      void * mess;
      int value;
      int res;
      res = pthread_create(&myThread, NULL, thread_Fun, NULL);
      if (res != 0) {
          printf("线程创建失败\n");
          return 0;
      }
      sleep(1);
      //令 myThread 线程终止执行
      res = pthread_cancel(myThread);
      if (res != 0) {
          printf("终止 myThread 线程失败\n");
          return 0;
      }
      printf("等待 myThread 线程执行结束：\n");
      res = pthread_join(myThread, &mess);
      if (res != 0) {
          printf("等待线程失败\n");
          return 0;
      }
      if (mess == PTHREAD_CANCELED) {
          printf("myThread 线程被强制终止\n");
      }
      else {
          printf("error\n");
      }
      return 0;
  }
  
  新建线程开始执行
  等待 myThread 线程执行结束：
  ```

  - 程序中，主线程（ main() 函数）试图调用 pthread_cancel() 函数终止 myThread 线程执行。从运行结果不难发现，pthread_cancel() 函数成功发送了 Cancel 信号，但目标线程仍在执行。
  - 也就是说，接收到 Cancel 信号的目标线程并没有立即处理该信号，或者说目标线程根本没有理会此信号。解决类似的问题，我们就需要搞清楚目标线程对 Cancel 信号的处理机制。

- 线程对cancel信号的处理

  - 对于默认属性的线程，当有线程借助 pthread_cancel() 函数向它发送 Cancel 信号时，它并不会立即结束执行，而是选择在一个适当的时机结束执行。

  - 所谓适当的时机，POSIX 标准中规定，当线程执行一些特殊的函数时，会响应 Cancel 信号并终止执行，比如常见的 pthread_join()、pthread_testcancel()、sleep()、system() 等，POSIX 标准称此类函数为“cancellation points”（中文可译为“取消点”）。

  - <pthread.h> 头文件还提供有 pthread_setcancelstate() 和 pthread_setcanceltype() 这两个函数，我们可以手动修改目标线程处理 Cancel 信号的方式。

    - ```
      int pthread_setcancelstate( int state , int * oldstate ); 
      ```

      - state 参数有两个可选值，分别是：

      - PTHREAD_CANCEL_ENABLE（默认值）：当前线程会处理其它线程发送的 Cancel 信号；
      - PTHREAD_CANCEL_DISABLE：当前线程不理会其它线程发送的 Cancel 信号，直到线程状态重新调整为 PTHREAD_CANCEL_ENABLE 后，才处理接收到的 Cancel 信号。
      - oldtate 参数用于接收线程先前所遵循的 state 值，通常用于对线程进行重置。如果不需要接收此参数的值，置为 NULL 即可。
      - pthread_setcancelstate() 函数执行成功时，返回数字 0，反之返回非零数。

    - ```
      int pthread_setcanceltype( int type , int * oldtype );
      ```

      - type 参数有两个可选值，分别是：
      - PTHREAD_CANCEL_DEFERRED（默认值）：当线程执行到某个可作为取消点的函数时终止执行；
      - PTHREAD_CANCEL_ASYNCHRONOUS：线程接收到 Cancel 信号后立即结束执行。
      - oldtype 参数用于接收线程先前所遵循的 type 值，如果不需要接收该值，置为 NULL 即可。
      - pthread_setcanceltype() 函数执行成功时，返回数字 0，反之返回非零数。

  ```
  #include <stdio.h>
  #include <pthread.h>
  #include <stdlib.h>
  void * thread_Fun(void * arg) {
      printf("新建线程开始执行\n");
      int res;
      //设置线程为可取消状态
      res = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
      if (res != 0) {
          printf("修改线程可取消状态失败\n");
          return  NULL;
      }
      //设置线程接收到 Cancel 信号后立即结束执行
      res = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
      if (res != 0) {
          printf("修改线程响应 Cancel 信号的方式失败\n");
          return  NULL;
      }
      while (1);
      return NULL;
  }
  int main()
  {
      pthread_t myThread;
      void * mess;
      int value;
      int res;
      res = pthread_create(&myThread, NULL, thread_Fun, NULL);
      if (res != 0) {
          printf("线程创建失败\n");
          return 0;
      }
      sleep(1);
      //向 myThread 线程发送 Cancel 信号
      res = pthread_cancel(myThread);
      if (res != 0) {
          printf("终止 myThread 线程失败\n");
          return 0;
      }
      //等待 myThread 线程执行结束，获取返回值
      res = pthread_join(myThread, &mess);
      if (res != 0) {
          printf("等待线程失败\n");
          return 0;
      }
      if (mess == PTHREAD_CANCELED) {
          printf("myThread 线程被强制终止\n");
      }
      else {
          printf("error\n");
      }
      return 0;
  }
  
  新建线程开始执行
  myThread 线程被强制终止
  ```

  

##### 获取线程函数返回值

- ```c
  int pthread_join(pthread_t thread, void ** retval);
  thread 参数用于指定接收哪个线程的返回值；retval 参数表示接收到的返回值，如果 thread 线程没有返回值，又或者我们不需要接收 thread 线程的返回值，可以将 retval 参数置为 NULL。
  ```

- pthread_join() 函数会一直阻塞调用它的线程，直至目标线程执行结束（接收到目标线程的返回值），阻塞状态才会解除。如果 pthread_join() 函数成功等到了目标线程执行结束（成功获取到目标线程的返回值），返回值为数字 0；反之如果执行失败，函数会根据失败原因返回相应的非零值，每个非零值都对应着不同的宏。
  - EDEADLK：检测到线程发生了死锁。
  - EINVAL：分为两种情况，要么目标线程本身不允许其它线程获取它的返回值，要么事先就已经有线程调用 pthread_join() 函数获取到了目标线程的返回值。
  - ESRCH：找不到指定的 thread 线程。
  - 以上这些宏都声明在 <errno.h> 头文件中
  
- 再次强调，一个线程执行结束的返回值只能由一个 pthread_join() 函数获取，当有多个线程调用 pthread_join() 函数获取同一个线程的执行结果时，哪个线程最先执行 pthread_join() 函数，执行结果就由那个线程获得，其它线程的 pthread_join() 函数都将执行失败。

- 对于一个默认属性的线程 A 来说，线程占用的资源并不会因为执行结束而得到释放。而通过在其它线程中执行`pthread_join(A,NULL);`语句，可以轻松实现“及时释放线程 A 所占资源”的目的。 

  ```
  #include <stdio.h>
  #include <errno.h>   //使用宏 ESRCH
  #include <pthread.h>
  //线程执行的函数
  void *ThreadFun(void *arg)
  {
      pthread_exit("http://c.biancheng.net");
  }
  int main()
  {
      int res;
      void * thread_result;
      pthread_t myThread;
      //创建 myThread 线程
      res = pthread_create(&myThread, NULL, ThreadFun, NULL);
      if (res != 0) {
          printf("线程创建失败");
          return 0;
      }
      //阻塞主线程，等待 myThread 线程执行结束
      res = pthread_join(myThread, &thread_result);
      if (res != 0) {
          printf("1：等待线程失败");
      }
      //输出获取到的 myThread 线程的返回值
      printf("%s\n", (char*)thread_result);
      //尝试再次获取 myThread 线程的返回值
      res = pthread_join(myThread, &thread_result);
      if (res == ESRCH) {
          printf("2：等待线程失败，线程不存在");
      }
      return 0;
  }
  
  http://c.biancheng.net
  2：等待线程失败，线程不存在
  ```

  - 在程序的在主线程（main() 函数）中，我们尝试两次调用 pthread_join() 函数获取 myThread 线程执行结束的返回值。通过执行结果可以看到，第一个 pthread_join() 函数成功执行，而第二个 Pthread_join() 函数执行失败。原因很简单，第一个成功执行的 pthread_join() 函数会使 myThread 线程释放自己占用的资源，myThread 线程也就不复存在，所以第二个 pthread_join() 函数会返回 ESRCH。

##### pthread_detach()

- linux线程执行和windows不同，pthread有两种状态joinable状态和unjoinable状态，如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了pthread_join之后这些资源才会被释放。若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。
- unjoinable属性可以在pthread_create时指定，或在线程创建后在线程中pthread_detach自己, 如pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。或者将线程置为 joinable,然后适时调用pthread_join.
- 其实简单的说就是在线程函数头加上 pthread_detach(pthread_self())的话，线程状态改变，在函数尾部直接 pthread_exit线程就会自动退出。省去了给线程擦屁股的麻烦。

##### 线程同步机制

- 多线程程序中各个线程除了可以使用自己的私有资源（局部变量、函数形参等）外，还可以共享全局变量、静态变量、堆内存、打开的文件等资源。

- 举个例子，编写一个多线程程序模拟“4个售票员共同卖 20 张票”的过程

  ```
  #include<stdio.h>
  #include<stdlib.h>
  #include<pthread.h>
  //全局变量，模拟总的票数
  int ticket_sum = 10;
  //模拟4个售票员一起售卖票的过程
  void *sell_ticket(void *arg){
      int i;
      //4个售票员负责将 10 张票全部卖出
      for (i = 0; i < 10; i++)
      {
          //直至所有票全部卖出，4 个售票员才算完成任务
          if (ticket_sum > 0)
          {
              sleep(1);
              //每个线程代表一个售票员
              printf("%u 卖第 %d 张票\n", pthread_self(), 10 - ticket_sum + 1);
              ticket_sum--;
          }
      }
      return 0;
  }
  int main(){
      int flag;
      int i;
      void *ans;
      //创建 4 个线程，代表 4 个售票员
      pthread_t tids[4];
      for (i = 0; i < 4; i++)
      {
          flag = pthread_create(&tids[i], NULL, &sell_ticket, NULL);
          if (flag != 0) {
              printf("线程创建失败!");
              return 0;
          }
      }
      sleep(10); // 阻塞主线程，等待所有子线程执行结束
      for (i = 0; i < 4; i++)
      {
          flag = pthread_join(tids[i], &ans);
          if (flag != 0) {
              printf("tid=%d 等待失败！", tids[i]);
              return 0;
          }
      }
      return 0;
  }
  
  
  3296569088 卖第 1 张票
  3265099520 卖第 2 张票
  3286079232 卖第 3 张票
  3275589376 卖第 4 张票
  3286079232 卖第 5 张票
  3265099520 卖第 6 张票
  3296569088 卖第 7 张票
  3275589376 卖第 8 张票
  3286079232 卖第 9 张票
  3265099520 卖第 10 张票
  3275589376 卖第 11 张票
  3296569088 卖第 12 张票
  3286079232 卖第 13 张票
  
  程序的执行结果并不唯一，还可能输出如下类似的信息：
  1492682496 卖第 1 张票
  1503172352 卖第 1 张票
  1482192640 卖第 1 张票
  1471702784 卖第 1 张票
  1503172352 卖第 5 张票
  1482192640 卖第 6 张票
  1492682496 卖第 6 张票
  1471702784 卖第 6 张票
  1503172352 卖第 9 张票
  1492682496 卖第 9 张票
  1471702784 卖第 9 张票
  1482192640 卖第 12 张票
  1503172352 卖第 13 张票
  ```

  - 程序中新建了 4 个子线程，每个线程都可以访问 ticket_sum 全局变量，它们共同执行 sell_ticket() 函数，模拟“4个售票员共同售卖 10 张票”的过程。
  - 程序执行过程中，出现了“多个售票员卖出同一张票”以及“4个售票员多卖出 3 张票”的异常情况。造成此类问题的根本原因在于，进程中公有资源的访问权限是完全开放的，各个线程可以随时访问这些资源，程序运行过程中很容易出现“多个线程同时访问某公共资源”的情况。
  - 例如，之所以会出现“多个售票员卖出同一张票”的情况，因为这些线程几乎同一时间访问 ticket_sum 变量，得到的是相同的值。出现“4 个售票员多卖出 3 张票”的原因是：4 个线程访问 ticket_sum 变量得到的都是一个大于 0 的数，每个线程都可以继续执行 if 语句内的代码。由于各个线程先后执行的顺序不同，有的线程先执行`ticket_sum--`操作，导致其它线程计算`10-ticket_sum+1`表达式时，读取到的 ticket_num 变量的值为负数，因此表达式的值会出现大于 10 的情况。

- 所谓线程同步，简单地理解就是：当一个线程访问某公共资源时，其它线程不得访问该资源，它们只能等待此线程访问完成后，再逐个访问该资源。

- Linux 环境中，实现线程同步的常用方法有 4 种，分别称为[互斥锁](http://c.biancheng.net/thread/vip_8615.html)、[信号量](http://c.biancheng.net/thread/vip_8616.html)、[条件变量](http://c.biancheng.net/thread/vip_8617.html)和[读写锁](http://c.biancheng.net/thread/vip_8618.html)。

  - 互斥锁（Mutex）又称互斥量或者互斥体，是最简单也最有效地一种线程同步机制。互斥锁的用法和实际生活中的锁非常类似，当一个线程访问公共资源时，会及时地“锁上”该资源，阻止其它线程访问；访问结束后再进行“解锁”操作，将该资源让给其它线程访问。
  - 信号量又称“信号灯”，主要用于控制同时访问公共资源的线程数量，当线程数量控制在 ≤1 时，该信号量又称二元信号量，功能和互斥锁非常类似；当线程数量控制在 N（≥2）个时，该信号量又称多元信号量，指的是同一时刻最多只能有 N 个线程访问该资源。
  - 条件变量的功能类似于实际生活中的门，门有“打开”和“关闭”两种状态，分别对应条件变量的“成立”状态和“不成立”状态。当条件变量“不成立”时，任何线程都无法访问资源，只能等待条件变量成立；一旦条件变量成立，所有等待的线程都会恢复执行，访问目标资源。为了防止各个线程竞争资源，条件变量总是和互斥锁搭配使用。
  - 多线程程序中，如果大多数线程都是对公共资源执行读取操作，仅有少量的线程对公共资源进行修改，这种情况下可以使用读写锁解决线程同步问题。

##### 互斥锁实现线程同步

- 互斥锁创建为全局的，在所有函数外创建

- 互斥锁实现多线程同步的核心思想是：有线程访问进程空间中的公共资源时，该线程执行“加锁”操作（将资源“锁”起来），阻止其它线程访问。访问完成后，该线程负责完成“解锁”操作，将资源让给其它线程。当有多个线程想访问资源时，谁最先完成“加锁”操作，谁就最先访问资源。

- 当有多个线程想访问“加锁”状态下的公共资源时，它们只能等待资源“解锁”，所有线程会排成一个等待（阻塞）队列。资源解锁后，操作系统会唤醒等待队列中的所有线程，第一个访问资源的线程会率先将资源“锁”起来，其它线程则继续等待。

- 本质上，互斥锁就是一个全局变量，它只有 "lock" 和 "unlock" 两个值，含义分别是：

  - "unlock" 表示当前资源可以访问，第一个访问资源的线程负责将互斥锁的值改为 "lock"，访问完成后再重置为“unlock”；
  - "lock" 表示有线程正在访问资源，其它线程需等待互斥锁的值为 "unlock" 后才能开始访问。

- 加锁是将进程空间中的公共资源全部锁起来，不只是锁一部分。

- 对资源进行“加锁”和“解锁”操作的必须是同一个线程。换句话说，哪个线程对资源执行了“加锁”操作，那么“解锁”操作也必须由该线程负责。

- POSIX 标准规定，用 pthread_mutex_t 类型的变量来表示一个互斥锁，该类型以结构体的形式定义在`<pthread.h>`头文件中

  ```c
  pthread_mutex_t myMutex;
  我们成功地定义了一个名为 myMutex 的互斥锁，但要想使用它，还要进行初始化操作。
  
  初始化 pthread_mutex_t 变量的方式有两种，分别为：
  //1、使用特定的宏
  pthread_mutex_t myMutex = PTHREAD_MUTEX_INITIALIZER;
  //2、调用初始化的函数
  pthread_mutex_t myMutex;
  pthread_mutex_init(&myMutex , NULL);
  ```

- 以上两种初始化方式是完全等价的，PTHREAD_MUTEX_INITIALIZER 宏和 pthread_mutex_init() 函数都定义在 <pthread.h> 头文件中，它们的主要区别在于：

  - pthread_mutex_init() 函数可以自定义互斥锁的属性（具体自定义的方法，这里不再进行讲解）。
  - 对于调用 malloc() 函数分配动态内存的互斥锁，只能以第 2 种方法完成初始化；

- pthread_mutex_init() 函数专门用于初始化互斥锁，语法格式如下：

  ```c
  int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
  mutex 参数表示要初始化的互斥锁；attr 参数用于自定义新建互斥锁的属性，attr 的值为 NULL 时表示以默认属性创建互斥锁。
      pthread_mutex_init() 函数成功完成初始化操作时，返回数字 0；如果初始化失败，函数返回非零数。
      不能对一个已经初始化过的互斥锁再进行初始化操作，否则会导致程序出现无法预料的错误。
  ```

- 对于互斥锁的“加锁”和“解锁”操作，常用的函数有以下 3 种：

  ```c
  int pthread_mutex_lock(pthread_mutex_t* mutex);   //实现加锁
  int pthread_mutex_trylock(pthread_mutex_t* mutex);  //实现加锁
  int pthread_mutex_unlock(pthread_mutex_t* mutex);   //实现解锁
  	参数 mutex 表示我们要操控的互斥锁。函数执行成功时返回数字 0，否则返回非零数。
  pthread_mutex_unlock() 函数用于对指定互斥锁进行“解锁”操作
  pthread_mutex_lock() 和 pthread_mutex_trylock() 函数都用于实现“加锁”操作，不同之处在于当互斥锁已经处于“加锁”状态时：
  	执行 pthread_mutex_lock() 函数会使线程进入等待（阻塞）状态，直至互斥锁得到释放；
  	执行 pthread_mutex_trylock() 函数不会阻塞线程，直接返回非零数（表示加锁失败）。
  ```

- 对于使用动态内存创建的互斥锁，例如：

  ```c
  pthread_mutex_t myMutex = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t));
  pthread_mutex_init(&myMutex , NULL);
  手动释放 myMutex 占用的内存（调用 free() 函数）之前，必须先调用 pthread_mutex_destory() 函数销毁该对象。
  ```

- pthread_mutex_destory() 函数用于销毁创建好的互斥锁，语法格式如下：

  ```c
  int pthread_mutex_destroy(pthread_mutex_t *mutex);
  参数 mutex 表示要销毁的互斥锁。如果函数成功销毁指定的互斥锁，返回数字 0，反之返回非零数。
  ```

- 注意，对于用 PTHREAD_MUTEX_INITIALIZER 或者 pthread_mutex_init() 函数直接初始化的互斥锁，无需调用 pthread_mutex_destory() 函数手动销毁。

  ```
  #include<stdio.h>
  #include<stdlib.h>
  #include<pthread.h>
  #include<unistd.h>
  int ticket_sum = 10;
  //创建互斥锁
  pthread_mutex_t myMutex = PTHREAD_MUTEX_INITIALIZER;
  //模拟售票员卖票
  void *sell_ticket(void *arg) {
      //输出当前执行函数的线程 ID
      printf("当前线程ID：%u\n", pthread_self());
      int i;
      int islock = 0;
      for (i = 0; i < 10; i++)
      {
          //当前线程“加锁”
          islock = pthread_mutex_lock(&myMutex);
          //如果“加锁”成功，执行如下代码
          if (islock == 0) {
              //如果票数 >0 ,开始卖票
              if (ticket_sum > 0)
              {
                  sleep(1);
                  printf("%u 卖第 %d 张票\n", pthread_self(), 10 - ticket_sum + 1);
                  ticket_sum--;
              }
              //当前线程模拟完卖票过程，执行“解锁”操作
              pthread_mutex_unlock(&myMutex);
          }
      }
      return 0;
  }
  int main() {
      int flag;
      int i;
      void *ans;
      //创建 4 个线程，模拟 4 个售票员
      pthread_t tids[4];
      for (i = 0; i < 4; i++)
      {
          flag = pthread_create(&tids[i], NULL, &sell_ticket, NULL);
          if (flag != 0) {
              printf("线程创建失败!");
              return 0;
          }
      }
      sleep(10);   //等待 4 个线程执行完成
      for (i = 0; i < 4; i++)
      {
          //阻塞主线程，确认 4 个线程执行完成
          flag = pthread_join(tids[i], &ans);
          if (flag != 0) {
              printf("tid=%d 等待失败！", tids[i]);
              return 0;
          }
      }
      return 0;
  }
  
  当前线程ID：149493504
  当前线程ID：170473216
  当前线程ID：159983360
  当前线程ID：139003648
  149493504 卖第 1 张票
  149493504 卖第 2 张票
  149493504 卖第 3 张票
  139003648 卖第 4 张票
  139003648 卖第 5 张票
  139003648 卖第 6 张票
  139003648 卖第 7 张票
  139003648 卖第 8 张票
  159983360 卖第 9 张票
  159983360 卖第 10 张票
  ```


##### 信号量和互斥锁的区别

- 信号量可以初始化为0，而互斥锁只有操作后才能上锁
- 初始化为0的信号量的作用为当有接口push进一个deque里面，可以直接post加一，然后等待的线程就可以工作了，在线程里面减一，这样就达到了一个状态，就是初始化的时候线程是不工作的，当push进一个的时候，post加一，通知等待的线程工作，线程wait减一，这样线程工作完进入下一个循环就会停止工作，这样就产生了一个工作流，初始化为0，加一个线程工作一下，不加的话线程一直在等待。

##### 信号量实现线程同步

- 和互斥锁类似，信号量本质也是一个全局变量。不同之处在于，互斥锁的值只有 2 个（加锁 "lock" 和解锁 "unlock"），而信号量的值可以根据实际场景的需要自行设置（取值范围为 ≥0）。更重要的是，信号量还支持做“加 1”或者 “减 1”运算，且修改值的过程以“原子操作”的方式实现。

- 原子操作是指当多个线程试图修改同一个信号量的值时，各线程修改值的过程不会互相干扰。例如信号量的初始值为 1，此时有 2 个线程试图对信号量做“加 1”操作，则信号量的值最终一定是 3，而不会是其它的值。反之若不以“原子操作”方式修改信号量的值，那么最终的计算结果还可能是 2（两个线程同时读取到的值为 1，各自在其基础上加 1，得到的结果即为 2）。

- 多线程程序中，使用信号量需遵守以下几条规则：

  1. 信号量的值不能小于 0；
  2. 有线程访问资源时，信号量执行“减 1”操作，访问完成后再执行“加 1”操作；
  3. 当信号量的值为 0 时，想访问资源的线程必须等待，直至信号量的值大于 0，等待的线程才能开始访问。

- 根据初始值的不同，信号量可以细分为 2 类，分别为二进制信号量和计数信号量：

  - 二进制信号量：指初始值为 1 的信号量，此类信号量只有 1 和 0 两个值，通常用来替代互斥锁实现线程同步；
  - 计数信号量：指初始值大于 1 的信号量，当进程中存在多个线程，但某公共资源允许同时访问的线程数量是有限的（出现了“狼多肉少”的情况），这时就可以用计数信号量来限制同时访问资源的线程数量。

- POSIX 标准中，信号量用 sem_t 类型的变量表示，该类型定义在`<semaphore.h>`头文件中。例如，下面代码定义了名为 mySem 的信号量：

  ```c
  #include <semaphore.h>
  sem_t mySem;
  ```

- sem_init() 函数专门用来初始化信号量，语法格式如下：

  ```c
  int sem_init(sem_t *sem, int pshared, unsigned int value);
  各个参数的含义分别为：
  sem：表示要初始化的目标信号量；
  pshared：表示该信号量是否可以和其他进程共享，pshared 值为 0 时表示不共享，值为 1 时表示共享；
  value：设置信号量的初始值。
  当 sem_init() 成功完成初始化操作时，返回值为 0，否则返回 -1。
  ```

- 对于初始化了的信号量，我们可以借助 <semaphore.h> 头文件提供的一些函数操作它，比如：

  ```c
  int sem_post(sem_t* sem);
  int sem_wait(sem_t* sem);
  int sem_trywait(sem_t* sem);
  int sem_destroy(sem_t* sem); 
  ```

  - 参数 sem 都表示要操作的目标信号量。各个函数的功能如下：
    - sem_post() 函数的功能是：将信号量的值“加 1”，同时唤醒其它等待访问资源的线程；
    - 当信号量的值大于 0 时，sem_wait() 函数会对信号量做“减 1”操作；当信号量的值为 0 时，sem_wait() 函数会阻塞当前线程，直至有线程执行 sem_post() 函数（使信号量的值大于 0），暂停的线程才会继续执行；
    - sem_trywait() 函数的功能和 sem_wait() 函数类似，唯一的不同在于，当信号量的值为 0 时，sem_trywait() 函数并不会阻塞当前线程，而是立即返回 -1；
    - sem_destory() 函数用于手动销毁信号量。
    - 以上函数执行成功时，返回值均为 0 ；如果执行失败，返回值均为 -1。
  
  ```
  int sem_getvalue(sem_t* sem, int* val)
  ```
  
  - 函数功能：获取当前信号量的值，通过val输出参数返回，如果当前信号量已经上锁（即同步对象不可用），那么返回值为0，或为负数，其绝对值就是等待该信号量解锁的线程数。信号量上锁意味着当前的信号量为0，如果不为0就可以将这个信号量的值返回到val中
  - 返回值：若成功则返回0，出错则返回-1
  - 就是简单
  
- 二进制信号量常用于代替互斥锁解决线程同步问题，接下来我们使用二进制信号量模拟“4 个售票员卖 10 张票”的过程：

  ```
  #include<stdio.h>
  #include<stdlib.h>
  #include<pthread.h>
  #include<semaphore.h>
  #include<unistd.h>
  //创建信号量
  sem_t mySem;
  //设置总票数
  int ticket_sum = 10;
  //模拟买票过程
  void *sell_ticket(void *arg) {
      printf("当前线程ID：%u\n", pthread_self());
      int i;
      int flag;
      for (i = 0; i < 10; i++)
      {
          //完成信号量"减 1"操作，否则暂停执行
          flag = sem_wait(&mySem);
          if (flag == 0) {
              if (ticket_sum > 0)
              {
                  sleep(1);
                  printf("%u 卖第 %d 张票\n", pthread_self(), 10 - ticket_sum + 1);
                  ticket_sum--;
              }
              //执行“加1”操作
              sem_post(&mySem);
              sleep(1);
          }
      }
      return 0;
  }
  int main() {
      int flag;
      int i;
      void *ans;
      //创建 4 个线程
      pthread_t tids[4];
      //初始化信号量
      flag = sem_init(&mySem, 0, 1);
      if (flag != 0) {
          printf("初始化信号量失败\n");
      }
      for (i = 0; i < 4; i++)
      {
          flag = pthread_create(&tids[i], NULL, &sell_ticket, NULL);
          if (flag != 0) {
              printf("线程创建失败!");
              return 0;
          }
      }
      sleep(10);
      for (i = 0; i < 4; i++)
      {
          flag = pthread_join(tids[i], &ans);
          if (flag != 0) {
              printf("tid=%d 等待失败！", tids[i]);
              return 0;
          }
      }
      //执行结束前，销毁信号量
      sem_destroy(&mySem);
      return 0;
  }
  
  当前线程ID：1199965952
  当前线程ID：1189476096
  当前线程ID：1168496384
  当前线程ID：1178986240
  1199965952 卖第 1 张票
  1189476096 卖第 2 张票
  1199965952 卖第 3 张票
  1178986240 卖第 4 张票
  1168496384 卖第 5 张票
  1189476096 卖第 6 张票
  1199965952 卖第 7 张票
  1178986240 卖第 8 张票
  1168496384 卖第 9 张票
  1189476096 卖第 10 张票
  ```

  - 程序中信号量的初始值为 1，当有多个线程想执行 19~25 行代码时，第一个执行 sem_wait() 函数的线程可以继续执行，同时信号量的值会由 1 变为 0，其它线程只能等待信号量的值由 0 变为 1 后，才能继续执行。

- 假设某银行只开设了 2 个窗口，但有 5 个人需要办理业务。如果我们使用多线程程序模拟办理业务的过程，可以借助计数信号量实现。

  ```
  #include <stdio.h>
  #include<pthread.h>
  #include<stdlib.h>
  #include<semaphore.h>
  //设置办理业务的人数
  int num = 5;
  //创建信号量
  sem_t sem;
  //模拟办理业务的过程
  void *get_service(void *arg)
  {
      int id = *((int*)arg);
      //信号量成功“减 1”后才能继续执行
      if (sem_wait(&sem) == 0)
      {
          printf("---customer%d 正在办理业务\n", id);
          sleep(2);
          printf("---customer%d 已办完业务\n", id);
          //信号量“加 1”
          sem_post(&sem);
      }
      return 0;
  }
  int main()
  {
      int flag,i,j;
      //创建 5 个线程代表 5 个人
      pthread_t customer[5];
      //初始化信号量
      sem_init(&sem, 0, 2);
      for (i = 0; i < num; i++)
      {
          flag = pthread_create(&customer[i], NULL, get_service, &i);
          if (flag != 0)
          {
              printf("线程创建失败!\n");
              return 0;
          }
          else {
              printf("customer%d 来办理业务\n",i);
          }
          sleep(1);
      }
      for (j = 0; j < num; j++)
      {
          flag = pthread_join(customer[j], NULL);
          if (flag != 0) {
              printf("tid=%d 等待失败！", customer[i]);
              return 0;
          }
      }
      sem_destroy(&sem);
      return 0;
  }
  
  customer0 来办理业务
  ---customer0 正在办理业务
  customer1 来办理业务
  ---customer1 正在办理业务
  ---customer0 已办完业务
  customer2 来办理业务
  ---customer2 正在办理业务
  ---customer1 已办完业务
  customer3 来办理业务
  ---customer3 正在办理业务
  ---customer2 已办完业务
  customer4 来办理业务
  ---customer4 正在办理业务
  ---customer3 已办完业务
  ---customer4 已办完业务
  ```

  - 程序中，sem 信号量的初始化为 2，因此该信号量属于计数信号量。借助 sem 信号量，第 14~21 行的代码段最多只能有 2 个线程同时访问。

##### 条件变量实现线程同步

- 和互斥锁、信号量类似，条件变量本质也是一个全局变量，它的功能是阻塞线程，直至接收到“条件成立”的信号后，被阻塞的线程才能继续执行。

- 假设一个进程中包含多个线程，这些线程共享变量 x，我们希望某个（或某些）线程等待 "x==10' 条件成立后再执行后续的代码

  ```
  void* threadFun(void * args){
      while(x != 10){
          sleep(5);
      }
      // 待条件成立后，执行后续的代码
  }
  ```

  - 直观上看，while 循环确实能够阻塞线程，但这种方法存在严重的效率问题。当线程因条件不成立进入等待状态时，如果此时恰好有另一个线程将 x 的值改为 10，该线程必须等待 5 秒后才能继续执行。如果我们将等待时间缩短（或者直接将 sleep(5) 注释掉），线程将反复判断 x 的值是否等于 10，它可能会一直霸占着 CPU 资源，导致其它线程无法执行，x 变量的值会出现“长时间不改变”的情况。
  - 针对类似的场景，我们推荐您用条件变量来实现。和互斥锁、信号量类似，条件变量本质也是一个全局变量，它的功能是阻塞线程，直至接收到“条件成立”的信号后，被阻塞的线程才能继续执行。

- 一个条件变量可以阻塞多个线程，这些线程会组成一个等待队列。当条件成立时，条件变量可以解除线程的“被阻塞状态”。也就是说，条件变量可以完成以下两项操作：

  - 阻塞线程，直至接收到“条件成立”的信号；
  - 向等待队列中的一个或所有线程发送“条件成立”的信号，解除它们的“被阻塞”状态。

- 为了避免多线程之间发生“抢夺资源”的问题，条件变量在使用过程中必须和一个互斥锁搭配使用。

- POSIX 标准中，条件变量用 pthread_cond_t 类型的变量表示，此类型定义在`<pthread.h>`头文件中。

  ```c
  pthread_cond_t myCond;
  ```

- 初始化条件变量的方式有两种，一种是直接将 PTHREAD_COND_INITIALIZER 赋值给条件变量

  ```c
  pthread_cond_t myCond = PTHREAD_COND_INITIALIZER;
  ```

- 还可以借助 pthread_cond_init() 函数初始化条件变量，语法格式如下：

  ```c
  int pthread_cond_init(pthread_cond_t * cond, const pthread_condattr_t * attr);
  参数 cond 用于指明要初始化的条件变量；参数 attr 用于自定义条件变量的属性，通常我们将它赋值为 NULL，表示以系统默认的属性完成初始化操作。
  pthread_cond_init() 函数初始化成功时返回数字 0，反之函数返回非零数。
  当 attr 参数为 NULL 时，以上两种初始化方式完全等价。
  ```

- 当条件不成立时，条件变量可以阻塞当前线程，所有被阻塞的线程会构成一个等待队列。阻塞线程可以借助以下两个函数实现：

  ```c
  int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex);
  int pthread_cond_timedwait(pthread_cond_t* cond, pthread_mutex_t* mutex, const struct timespec* abstime); 
  cond 参数表示已初始化好的条件变量；mutex 参数表示与条件变量配合使用的互斥锁；abstime 参数表示阻塞线程的时间。
  abstime 参数指的是绝对时间，例如您打算阻塞线程 5 秒钟，那么首先要得到当前系统的时间，然后再加上 5 秒，最终得到的时间才是传递的实参值。
  ```
  
  - 调用两个函数之前，我们必须先创建好一个互斥锁并完成“加锁”操作，然后才能作为实参传递给 mutex 参数。两个函数会完成以下两项工作：
    - 阻塞线程，直至接收到“条件成立”的信号；
    - 当线程被添加到等待队列上时，将互斥锁“解锁”。
  - 也就是说，函数尚未接收到“条件成立”的信号之前，它将一直阻塞线程执行。注意，当函数接收到“条件成立”的信号后，它并不会立即结束对线程的阻塞，而是先完成对互斥锁的“加锁”操作，然后才解除阻塞。
  - 两个函数都以“原子操作”的方式完成“阻塞线程+解锁”或者“重新加锁+解除阻塞”这两个过程。所谓“原子操作”，即当有多个线程执行相同的某个过程时，虽然它们都会访问互斥锁和条件变量，但之间不会相互干扰。
  - 以上两个函数都能用来阻塞线程，它们的区别在于：pthread_cond_wait() 函数可以永久阻塞线程，直到条件变量成立的那一刻；pthread_cond_timedwait() 函数只能在 abstime 参数指定的时间内阻塞线程，超出时限后，该函数将重新对互斥锁执行“加锁”操作，并解除对线程的阻塞，函数的返回值为 ETIMEDOUT。
  - 如果函数成功接收到了“条件成立”的信号，重新对互斥锁完成了“加锁”并使线程继续执行，函数返回数字 0，反之则返回非零数。
  - POSIX 标准规定，pthread_cond_wait() 和 pthread_cond_timedwait() 函数是可以作为“取消点”的函数。当线程接收到“强制终止执行”的信号后，执行到这两个函数时，线程就会终止执行。有关强制终止执行线程和“取消点”的具体含义，您可以阅读《[线程间相互终止执行，这个坑千万别踩！](http://c.biancheng.net/thread/vip_8613.html)》一文。
  
- 解除线程的阻塞状态，对于被 pthread_cond_wait() 或 pthread_cond_timedwait() 函数阻塞的线程，我们可以借助如下两个函数向它们发送“条件成立”的信号，解除它们的“被阻塞”状态：

  ```c
  int pthread_cond_signal(pthread_cond_t* cond);
  int pthread_cond_broadcast(pthread_cond_t* cond);
  cond 参数表示初始化好的条件变量。当函数成功解除线程的“被阻塞”状态时，返回数字 0，反之返回非零数。
  ```

  - 两个函数都能解除线程的“被阻塞”状态，区别在于：
  - pthread_cond_signal() 函数至少解除一个线程的“被阻塞”状态，如果等待队列中包含多个线程，优先解除哪个线程将由操作系统的线程调度程序决定；
  - pthread_cond_broadcast() 函数可以解除等待队列中所有线程的“被阻塞”状态。
  - 由于互斥锁的存在，解除阻塞后的线程也不一定能立即执行。当互斥锁处于“加锁”状态时，解除阻塞状态的所有线程会组成等待互斥锁资源的队列，等待互斥锁“解锁”。

- 销毁条件变量，对于初始化好的条件变量，我们可以调用 pthread_cond_destory() 函数销毁它。

  ```
  int pthread_cond_destroy(pthread_cond_t *cond);
  ```

  - cond 参数表示要销毁的条件变量。如果函数成功销毁 cond 参数指定的条件变量，返回数字 0，反之返回非零数。
  - 值得一提的是，销毁后的条件变量还可以调用 pthread_cond_init() 函数重新初始化后使用。

  ```c
  //初始化互斥锁
  pthread_mutex_t myMutex = PTHREAD_MUTEX_INITIALIZER;
  //初始化条件变量
  pthread_cond_t myCond = PTHREAD_COND_INITIALIZER;
  //设置全局变量
  int x = 0;
  //线程执行的函数
  void * waitForTrue(void *args) {
      int res;
      //条件变量阻塞线程之前，先对互斥锁执行“加锁”操作
      res = pthread_mutex_lock(&myMutex);
      if (res != 0) {
          printf("waitForTrue 加锁失败\n");
          return NULL;
      }
      printf("------等待 x 的值为 10\n");
      if (pthread_cond_wait(&myCond, &myMutex) == 0) {
          printf("x = %d\n", x);
      }
      //最终将互斥锁解锁
      pthread_mutex_unlock(&myMutex);
      return NULL;
  }
  //线程执行的函数
  void * doneForTrue(void *args) {
      int res;
      while (x != 10) {
          //对互斥锁执行“加锁”操作
          res = pthread_mutex_lock(&myMutex);
          if (res == 0) {
              x++;
              printf("doneForTrue：x = %d\n", x);
              sleep(1);
              //对互斥锁“解锁”
              pthread_mutex_unlock(&myMutex);
          }
      }
      //发送“条件成立”的信号，解除 mythread1 线程的“被阻塞”状态
      res = pthread_cond_signal(&myCond);
      if (res != 0) {
          printf("解除阻塞失败\n");
      }
      return NULL;
  }
  int main() {
      int res;
      pthread_t mythread1, mythread2;
      res = pthread_create(&mythread1, NULL, waitForTrue, NULL);
      if (res != 0) {
          printf("mythread1线程创建失败\n");
          return 0;
      }
      res = pthread_create(&mythread2, NULL, doneForTrue, NULL);
      if (res != 0) {
          printf("mythread2线程创建失败\n");
          return 0;
      }
      //等待 mythread1 线程执行完成
      res = pthread_join(mythread1, NULL);
      if (res != 0) {
          printf("1：等待线程失败\n");
      }
      //等待 mythread2 线程执行完成
      res = pthread_join(mythread2, NULL);
      if (res != 0) {
          printf("2：等待线程失败\n");
      }
      //销毁条件变量
      pthread_cond_destroy(&myCond);
      return 0;
  }
  
  ------等待 x 的值为 10
  doneForTrue：x = 1
  doneForTrue：x = 2
  doneForTrue：x = 3
  doneForTrue：x = 4
  doneForTrue：x = 5
  doneForTrue：x = 6
  doneForTrue：x = 7
  doneForTrue：x = 8
  doneForTrue：x = 9
  doneForTrue：x = 10
  x = 10
  
  基本思想就是在一个线程函数里面阻塞着等着另一个线程发来的信号，另一个线程里面执行程序，当结果达到时发送信号。
  ```

##### 读写锁实现线程同步

- 多线程程序中，如果仅有少数线程会对共享数据进行修改，多数线程只是读取共享数据的值，就适合用读写锁解决“线程间抢夺资源”的问题。
- 读写锁的核心思想是：将线程访问共享数据时发出的请求分为两种，分别是：
  - 读请求：只读取共享数据，不做任何修改；
  - 写请求：存在修改共享数据的行为。
- 当有多个线程发出读请求时，这些线程可以同时执行，也就是说，共享数据的值可以同时被多个发出读请求的线程获取；当有多个线程发出写请求时，这些线程只能一个一个地执行（同步执行）。此外，当发出读请求的线程正在执行时，发出写请求的线程必须等待前者执行完后才能开始执行；当发出写请求的线程正在执行时，发出读请求的线程也必须等待前者执行完后才能开始执行。

- 本质上，读写锁就是一个全局变量，发出读请求和写请求的线程都可以访问它。为了区别线程发出的请求类别，当读写锁被发出读请求的线程占用时，我们称它为“读锁”；当读写锁被发出写请求的线程占用时，称它为“写锁”。

  | 当前读写锁的状态 | 线程发出“读”请求 | 线程发出“写”请求 |
  | ---------------- | ---------------- | ---------------- |
  | 无锁             | 允许占用         | 允许占用         |
  | 读锁             | 允许占用         | 阻塞线程执行     |
  | 写锁             | 阻塞线程执行     | 阻塞线程执行     |

- 从上表可以看出，不同状态下的读写锁会以不同的方式处理发出读请求或写请求的线程：

  - 当读写锁未被任何线程占用时，发出读请求和写请求的线程都可以占用它。注意，由于读请求和写请求的线程不能同时执行，读写锁默认会优先分配给发出读请求的线程。
  - 当读写锁的状态为“读锁”时，表明当前执行的是发出读请求的线程（可能有多个）。此时如果又有线程发出读请求，该线程不会被阻塞，但如果有线程发出写请求，它就会被阻塞，直到读写锁状态改为“无锁”。
  - 当读写锁状态为“写锁”时，表明当前执行的是发出写请求的线程（只能有 1 个）。此时无论其它线程发出的是读请求还是写请求，都必须等待读写锁状态改为“无锁”后才能执行。
  - 总的来说，对于进程空间中的共享资源，读写锁允许发出“读”请求的线程共享资源，发出“写”请求的线程必须独占资源，进而实现线程同步。

- POSIX 标准中，读写锁用 pthread_rwlock_t 类型的变量表示，此类型定义在`<pthread.h>`头文件中

  ```c
  pthread_rwlock_t myRWLock;
  ```

- 初始化读写锁的方法有两种

  ```c
  一种是直接将 PTHREAD_RWLOCK_INITIALIZER 宏赋值给读写锁变量，例如：
  pthread_rwlock_t myRWLock = PTHREAD_RWLOCK_INITIALIZER;
  还可以借助 pthread_rwlock_init() 函数初始化读写锁，此函数的语法格式为：
  int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
  rwlock 参数用于指定要初始化的读写锁变量；attr 参数用于自定义读写锁变量的属性，置为 NULL 时表示以默认属性初始化读写锁。
  当 pthread_rwlock_init() 函数初始化成功时，返回数字 0，反之返回非零数。
  当 attr 参数为 NULL 时，以上两种初始化方式完全等价。
  ```

- 线程发出读锁请求

  ```c
  int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);
  int pthread_rwlock_tryrdlock(pthread_rwlock_t* rwlock);
  
  其中，rwlock 参数指的是初始化好的读写锁。
  两个函数如果能成功获得读锁，函数返回数字 0，反之返回非零数。
  ```

  - 当读写锁处于“无锁”或者“读锁”状态时，以上两个函数都能成功获得读锁；当读写锁处于“写锁”状态时：
    - pthread_rwlock_rdlock() 函数会阻塞当前线程，直至读写锁被释放；
    - pthread_rwlock_tryrdlock() 函数不会阻塞当前线程，直接返回 EBUSY。

- 线程发出写锁请求

  ```c
  int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);
  int pthread_rwlock_trywrlock(pthread_rwlock_t* rwlock); 
  
  rwlock 参数指的是初始化好的读写锁。
  函数如果能成功获得写锁，函数返回数字 0，反之返回非零数。
  ```

  - 当读写锁处于“无锁”状态时，两个函数都能成功获得写锁；当读写锁处于“读锁”或“写锁”状态时：
    - pthread_rwlock_wrlock() 函数将阻塞线程，直至读写锁被释放；
    - pthread_rwlock_trywrlock() 函数不会阻塞线程，直接返回 EBUSY。

- 释放读写锁，无论是处于“无锁”、“读锁”还是“写锁”的读写锁，都可以使用如下函数释放读写锁：

  ```c
  int pthread_rwlock_unlock (pthread_rwlock_t* rwlock);
  ```

  - 当函数成功释放读写锁时，返回数字 0，反之则返回非零数。注意，由于多个线程可以同时获得“读锁”状态下的读写锁，这种情况下一个线程释放读写锁后，读写锁仍处于“读锁”状态，直至所有线程都释放读写锁，读写锁的状态才为“无锁”状态。

- 销毁读写锁

  ```c
  当读写锁不再使用时，我们可以借助如下函数将它销毁：
  int pthread_rwlock_destroy(pthread_rwlock_t* rwlock);
  参数 rwlock 表示要销毁的目标读写锁。
  
  如果函数成功销毁指定的读写锁，返回数字 0，反之则返回非零数。
  ```

  ```c
  #include <pthread.h>
  #include <stdio.h>
  #include <unistd.h>
  int x = 0;
  //创建读写锁变量
  pthread_rwlock_t myrwlock;
  void* read_thread(void* args){
      printf("------%u read_thread ready\n",pthread_self());
      while (1)
      {
          sleep(1);
          //请求读锁
          pthread_rwlock_rdlock(&myrwlock);
          printf("read_thread: %u,x=%d\n", pthread_self(), x);
          sleep(1);
          //释放读写锁
          pthread_rwlock_unlock(&myrwlock);
      }
      return NULL;
  }
  void* write_thread(void* param)
  {
      printf("------%u write_thread ready!\n",pthread_self());
      while (1)
      {
          sleep(1);
          // 请求写锁
          pthread_rwlock_wrlock(&myrwlock);
          ++x;
          printf("write_thread: %u,x=%d\n", pthread_self(), x);
          sleep(1);
          //释放读写锁
          pthread_rwlock_unlock(&myrwlock);
      }
      return NULL;
  }
  int main()
  {
      int i;
      //初始化读写锁
      pthread_rwlock_init(&myrwlock, NULL);
      //创建 3 个读 x 变量的线程
      pthread_t readThread[3];
      for (i = 0; i < 3; ++i)
      {
          pthread_create(&readThread[i], NULL, read_thread, NULL);
      }
      //创建 1 个修改 x 变量的线程
      pthread_t writeThread;
      pthread_create(&writeThread, NULL, write_thread, NULL);
      //等待各个线程执行完成
      pthread_join(writeThread, NULL);
      for (int i = 0; i < 3; ++i)
      {
          pthread_join(readThread[i], NULL);
      }
      //销毁读写锁
      pthread_rwlock_destroy(&myrwlock);
      return 0;
  }
  
  ------1134741248 read_thread ready
  ------1113761536 read_thread ready
  ------1103271680 write_thread ready!
  ------1124251392 read_thread ready
  read_thread: 1124251392,x=0
  read_thread: 1113761536,x=0
  read_thread: 1134741248,x=0
  write_thread: 1103271680,x=1
  read_thread: 1134741248,x=1
  read_thread: 1124251392,x=1
  read_thread: 1113761536,x=1
  write_thread: 1103271680,x=2
  read_thread: 1124251392,x=2
  read_thread: 1113761536,x=2
  read_thread: 1134741248,x=2
  ```
  
  - 过执行结果不难看到，3 个读取 x 变量的线程总是能够同时获取到 x 变量的值，因为它们能够同时获得“读锁”并同时执行。

##### 线程死锁

- 线程死锁指的是线程需要使用的公共资源一直被其它线程占用，导致该线程一直处于“阻塞”状态，无法继续执行。举个例子，用互斥锁实现线程同步的过程中，初学者经常忘记为“加锁”的线程及时“解锁”，这种情况下就会发生死锁（实例一）：

  ```
  #include<stdio.h>
  #include<pthread.h>
  //创建并初始化互斥锁
  pthread_mutex_t myMutex = PTHREAD_MUTEX_INITIALIZER;
  void *thread_func(void *arg) {
      int islock;
      //为线程加锁   
      islock = pthread_mutex_lock(&myMutex);
      if (islock == 0) {
          printf("线程 %u 已加锁\n", pthread_self());
      }
      return 0;
  }
  int main() {
      int flag;
      int i;
      //创建 4 个线程
      pthread_t tids[4];
      for (i = 0; i < 4; i++)
      {
          flag = pthread_create(&tids[i], NULL, thread_func, NULL);
          if (flag == 0) {
              printf("线程 %u 创建完成\n",tids[i]);
          }
      }
      for(i = 0; i<4;i++){
          pthread_join(tids[i], NULL);
          printf("线程 %u 执行完成\n",tids[i]);
      }
      return 0;
  }
  
  线程 3135751936 创建完成
  线程 3125262080 创建完成
  线程 3114772224 创建完成
  线程 3135751936 已加锁
  线程 3104282368 创建完成
  线程 3135751936 执行完成
                                             <-- 其它 3 个线程发生了死锁
  ```

- 再举一个例子（实例二）：

  ```c
  #include <stdio.h>
  #include <pthread.h>
  #include <unistd.h>
  pthread_mutex_t mutex;
  pthread_mutex_t mutex2;
  void *func1(void *args)
  {
      pthread_mutex_lock(&mutex);
      printf("t1 成功申请 mytex 锁\n");
      sleep(2);
      pthread_mutex_lock(&mutex2);
      printf("t1 成功申请 mytex2 锁\n");
      printf("%u is running\n",pthread_self());
      pthread_mutex_unlock(&mutex);
      printf("------%u done\n",pthread_self());      
  }
  void *func2(void *args)
  { 
      pthread_mutex_lock(&mutex2);
      printf("t2 成功申请 mytex2 锁\n");
      sleep(2);
      pthread_mutex_lock(&mutex);
      printf("t2 成功申请 mytex 锁\n");
      printf("%u is running\n",pthread_self()); 
      pthread_mutex_unlock(&mutex);
      printf("------%u done\n",pthread_self());
  }
  int main()
  {
      int ret;
      pthread_t t1;
      pthread_t t2;
      pthread_mutex_init(&mutex,NULL);
      pthread_mutex_init(&mutex2,NULL);
      ret = pthread_create(&t1, NULL, func1, NULL);
      if(ret != 0){
             printf("create t1 fail\n");
      }
      ret = pthread_create(&t2, NULL, func2, NULL);
      if(ret != 0){
             printf("create t2 fail\n");
      }
    
      pthread_join(t1,NULL);
      pthread_join(t2,NULL);
      pthread_mutex_destroy(&mutex);
      pthread_mutex_destroy(&mutex2);
      return 0;
  }
  
  t1 成功申请 mytex 锁
  t2 成功申请 mytex2 锁
                                            <-- t1 和 t2 都发生了死锁
  ```

  - 程序中创建了 mutex 和 mutex2 两个互斥锁，线程 t1 和 t2 同时执行。从执行结果可以看到，t1 成功申请了 mutex 锁，t2 成功申请了 mutex2 锁，t1 一直等待 t2 释放 mutex2 锁，而 t2 一直等待 t1 释放 mutex 锁，两个线程都因等待对方释放资源产生了死锁。
  - 总的来说，当进程空间中的某公共资源不允许多个线程同时访问时，某线程访问公共资源后不及时释放资源，就很可能产生线程死锁。

- 使用互斥锁、信号量、条件变量和读写锁实现线程同步时，要注意以下几点：
  - 占用互斥锁的线程，执行完成前必须及时解锁；
  - 通过 sem_wait() 函数占用信号量资源的线程，执行完成前必须调用 sem_post() 函数及时释放；
  - 当线程因 pthread_cond_wait() 函数被阻塞时，一定要保证有其它线程唤醒此线程；
  - 无论线程占用的是读锁还是写锁，都必须及时解锁。
  - 注意，函数中可以设置多种结束执行的路径，但无论线程选择哪个路径结束执行，都要保证能够将占用的资源释放掉。
  
- POSIX 标准中，很多阻塞线程执行的函数都提供有 tryxxx() 和 timexxx() 两个版本，例如 pthread_mutex_lock() 和 pthread_mutex_trylock()、sem_wait() 和 sem_trywait()、pthread_cond_wait() 和 pthread_cond_timedwait() 等，它们可以完成同样的功能，但 tryxxx() 版本的函数不会阻塞线程，timexxx() 版本的函数不会一直阻塞线程。实际开发中，建议您优先选择 tryxxx() 或者 timexxx() 版本的函数，可以大大降低线程产生死锁的概率。

- 多线程程序中，多个线程请求资源的顺序最好保持一致。实例二中，线程 t1 先请求 mutex 锁然后再请求 mutex2 锁，而 t2 则是先请求 mutex2 锁然后再请求 mutex 锁，这就是典型的因“请求资源顺序不一致”导致发生了线程死锁的情况。

##### 全局锁与局部锁

- 声明一个全局互斥锁就是保护全局的一些东西，声明一个局部互斥锁就是保护一些局部的东西，互斥锁的本质就是当程序执行的时候，如果保护的是全局的东西就看一下这把全局锁有没有被锁住，如果保护的是局部的东西就看一下这把局部锁有没有被锁住。在全局锁里面的表现是线程里面一直在加锁，所以锁定的是一些全局的东西。在局部锁里面表现是函数里面在加锁，所以锁住的是一些局部的东西。最主要的就是要理解，不管什么情况下，当程序运行的时候，如果我们有一把锁锁住了一些东西，不管是全局的还是局部的，在访问的时候就看一下这把锁有没有锁住，如果锁住了就不往下执行了，如果没有锁住就执行。

- 有线程访问进程空间中的公共资源时，该线程执行“加锁”操作（将资源“锁”起来），阻止其它线程访问。访问完成后，该线程负责完成“解锁”操作，将资源让给其它线程。当有多个线程想访问资源时，谁最先完成“加锁”操作，谁就最先访问资源。

- 当有多个线程想访问“加锁”状态下的公共资源时，它们只能等待资源“解锁”，所有线程会排成一个等待（阻塞）队列。资源解锁后，操作系统会唤醒等待队列中的所有线程，第一个访问资源的线程会率先将资源“锁”起来，其它线程则继续等待。

- 以上的说法表示如果不访问被锁的资源时，其线程就不会被阻塞，线程会一直执行，如果访问的东西有被锁的资源时，当前线程就会阻塞。这个用在局部是同样的道理，如果局部的变量被锁住，当有函数访问的时候，函数就会阻塞，等着解锁，如果访问的东西不是锁管理的，就不会阻塞。

  ```
  class XBusMessage
  {
  protected:
  	HTOPIC m_dbTopic;
  	XMutex m_dbTopicLock;
  public:
  	XBusMessage();
  	virtual ~XBusMessage();
  	
  	// -- msgbus_free_buffer free resp
  	int sendBusDb(char *sendJson, char ** resp);
  };
  
  int XBusMessage::sendBusDb(char *sendJson, char ** resp)
  {
  	int retval = -1;
  	int error;
  	int flag;
  	m_dbTopicLock.Lock();
  	if(!m_dbTopic){
  		HBUS bus;
  		bus = XPolicySystem::system().getBusHandle();
  		if(!bus){
  			printf("XBusMessage getBusHandle error...\n");
  			goto DONE;
  		}
  		m_dbTopic = msgbus_open_topic(bus, __TOPIC_NAME_DATABASE, &error);
  		if(!m_dbTopic){
  			printf("failed to open topic <%s>:%s\n", __TOPIC_NAME_DATABASE, msgbus_get_error_string(error));
  			goto DONE;
  		}
  	}
  	
  	flag = msgbus_topic_send_timeout(m_dbTopic, sendJson, 10, resp);
  	if(0 != flag){
  		printf("failed to send message to topic <%s>(%d):%s\n", __TOPIC_NAME_DATABASE, flag, msgbus_get_error_string(flag));
  	}
  	if(__is_broken_error(flag)){
  		if(m_dbTopic){
  			msgbus_close_topic(m_dbTopic);
  			m_dbTopic = NULL;
  		}
  		goto DONE;
  	}
  	
  	retval = 0;
  DONE:
  	m_dbTopicLock.Unlock();
  	return retval;
  }
  ```

  ```
  class XMutex
  {
  protected:
  	#ifdef WIN32
  		HANDLE m_mutex;
  	#else	
  		pthread_mutex_t m_mutex;
  	#endif	
  public:
  	XMutex();
  	virtual ~XMutex();
  	void Lock() const;
  	void Unlock() const;
  };
  
  class XJsonDataProcess
  {
  protected:
  	XBusMessage m_busMessage;
  	XDbDataProcess m_dbData;
  public:
  	char * jsonDataProcess(const char * json);
  	
  	char * riskCommandProcess(cJSON * request);
  
  
  char * XJsonDataProcess::queryRiskCommand(cJSON * request){
  	char * sql_data = NULL, * data = NULL, * json_resp = NULL;
  	::std::stringstream stm;
  	cJSON * infoItem = NULL, * command_keyword = NULL;
  	infoItem = cJSON_GetObjectItem(request, "info");
  	if(!infoItem){
  		printf("json data error\n");
  		goto DONE;
  	}
  	command_keyword = cJSON_GetObjectItem(infoItem, "command_keyword");
  	if(!command_keyword){
  		printf("json info data error\n");
  		goto DONE;
  	}
  	stm << "select guid, command, level, stop_type, desc from mg_risk_command where command like '%" << command_keyword->valuestring << "%'";
  	sql_data = createSqlJson(2, stm.str().c_str());
  	if(sql_data){
  		if(0 != m_busMessage.sendBusDb(sql_data, &json_resp)){
  			printf("sendBusDb failed...\n");
  			goto DONE;
  		}else{
  			printf("json_resp:%s\n", json_resp);
  		}
  	}else {
  		goto DONE;
  	}
  	if(json_resp){
  		data = m_dbData.riskCommandQuery(json_resp);
  	}
  DONE:
  	if(json_resp){
  		msgbus_free_buffer(json_resp);
  	}
  
  	if(sql_data){
  		free(sql_data);
  	}
  	return data;
  }
  ```

  - Xmutex是一个互斥锁类，里面声明了一个互斥锁，由于这个互斥锁在类里面，而且是XMutex m_dbTopicLock;在类里面声明的，表示是一个局部互斥锁，其锁定的东西是和其在同一个作用域的变量HTOPIC m_dbTopic;当类里面的函数sendBusDb想使用m_dbTopic时会看一看这把锁，如果没有被锁住，其就执行，如果被锁住，当前函数就会阻塞，等着解锁。
  - XJsonDataProcess类里面声明了一个XBusMessage类实例，我们想要访问里面的函数时，因为里面有一个局部互斥锁，我们就会看看这把锁，这样就避免了如果一个会话运行到m_dbTopic = msgbus_open_topic(bus, __TOPIC_NAME_DATABASE, &error)之前，里一个会话也进来，其看到if(!m_dbTopic)，m_dbTopic还是空的，其会接着进来打开topic，这样两个会话打开了这个topic，都会往里面写东西，最后其他的挂在总线上的微服务收到的就会出错。如果我们加一把局部锁，锁住m_dbTopic，如果第一个会话进来给这把锁加锁，第二个会话进来，看到这把锁锁住了，就会停止执行后面的代码。这样就保证了互斥性
  - 只有上面的那种情况会出错，如果m_dbTopic被赋值后，就不会进入那部分了，直接msgbus_topic_send_timeout，每一个send都会创建resp二级指针，这样接收回来的就不会出错。上面的这种想法是错误的，虽然每一次send都会创建二级指针内存，但是如果好几个会话都给一个topic发东西，很快的话，微服务收到的就会出错，不知道解析到哪里，这样返回来的也会出错，所以锁住m_dbTopic最好，这样收到的和返回的都不会出错。一个会话进这个函数加锁，执行完解锁，其他的会话在这期间是进不来的

##### 自旋锁

- 互斥锁简介

  - 互斥锁属于sleep-waiting类型锁。Linux Kernel 2.6.x稳定版开始，Linux的互斥锁都是futex (Fast Usermode Mutex)锁。
  - Futex是一个在Linux上实现锁定和构建高级抽象锁如信号量和POSIX互斥的基本工具。
  - Futex是由用户空间的一个对齐的整型变量和附在其上的内核空间等待队列构成。多进程或多线程绝大多数情况下对位于用户空间的futex的整型变量进行操作(汇编语言调用CPU提供的原子操作指令来增加或减少)，而其它情况下则需要通过代价较大的系统调用来对位于内核空间的等待队列进行操作(如唤醒等待的进程/线程或将当前进程/线程放入等待队列)。除了多个线程同时竞争锁的少数情况外，基于futex的lock操作是不需要进行代价昂贵的系统调用操作的。
  - Futex核心思想是通过将大多数情况下非同时竞争lock的操作放到在用户空间执行，而不是代价昂贵的内核系统调用方式来执行，从而提高了效率。
  - 互斥锁禁止多个线程同时进入受保护的代码临界区（critical section）。在任意时刻，只有一个线程被允许进入代码保护区。互斥锁实际上是count=1情况下的semaphore。

- 互斥锁缺点

  - 等待互斥锁会消耗时间，等待延迟会损害系统的可伸缩性
  - 优先级倒置。低优先级的线程可以获得互斥锁，因此会阻碍需要同一互斥锁的高优先级线程
  - 锁护送（lock convoying）。如果持有互斥锁的线程分配的时间片结束，线程被取消调度，则等待同一互斥锁的其它线程需要等待更长时间。

- 自旋锁简介

  - 自旋锁（spin lock）属于busy-waiting类型锁。在多处理器环境中，自旋锁最多只能被一个可执行线程持有。如果一个可执行线程试图获得一个被其它线程持有的自旋锁，那么线程就会一直进行忙等待，自旋（空转），等待自旋锁重新可用。如果自旋锁未被争用，请求锁的执行线程便立刻得到自旋锁，继续执行。
  - 多处理器操作系统中某些资源是有限的，不同线程需要互斥访问，因此需要引入锁概念，只有获取锁的线程才能够对资源进行访问。多线程的核心是CPU的时间分片，同一时刻只能有一个线程获取到锁。对于没有获取到锁的线程通常有两种处理方式：自旋锁，没有获取到锁的线程会一直循环等待判断资源是否已经释放锁，不用将线程阻塞起来；互斥锁，把未获取到锁的线程阻塞起来，等待重新调度请求。
  - 自旋锁（spin lock）是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。
  - 获取锁的线程一直处于活跃状态，但并没有执行任何有效的任务，使用自旋锁会造成busy-waiting。

- 自旋锁特点

  - 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快
  - 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁时需要从内核态恢复，导致线程在用户态与内核态之间来回切换，严重影响锁的性能。

- 自旋锁原理

  - 自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，只需要等一等(自旋)，等到持有锁的线程释放锁后即可获取，避免用户进程和内核切换的消耗。
  - 自旋锁避免了操作系统进程调度和线程切换，通常适用在时间极短的情况，因此操作系统的内核经常使用自旋锁。但如果长时间上锁，自旋锁会非常耗费性能。线程持有锁时间越长，则持有锁的线程被 OS调度程序中断的风险越大。如果发生中断情况，那么其它线程将保持旋转状态(反复尝试获取锁)，而持有锁的线程并不打算释放锁，导致结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。
  - 自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能，因此可以给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。

- 自旋锁API

  ```
  #include <pthread.h>
  
  int pthread_spin_destroy(pthread_spinlock_t *lock);
  int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
  
  int pthread_spin_lock(pthread_spinlock_t *lock);
  int pthread_spin_trylock(pthread_spinlock_t *lock);
  int pthread_spin_unlock(pthread_spinlock_t *lock);
  ```

- 自旋锁与互斥锁

  - spinlock不会使线程状态发生切换，mutex在获取不到锁的时候会选择sleep。
  - spinlock优点：没有耗时的系统调用，一直处于用户态，执行速度快。
  - spinlock缺点：一直占用CPU，而且在执行过程中还会锁bus总线，锁总线时其它处理器不能使用总线。
  - mutex获取锁分为两阶段，第一阶段在用户态采用spinlock锁总线的方式获取一次锁，如果成功立即返回；否则进入第二阶段，调用系统的futex锁去sleep，当锁可用后被唤醒，继续竞争锁。
  - mutex优点：不会忙等，得不到锁会sleep。
  - mutex缺点：sleep时会陷入到内核态，需要昂贵的系统调用。

- 自旋锁缺点

  - 不正确的使用会引发死锁，事实上这不仅仅是自旋锁的问题，所有的同步互斥解决方法不正确使用都会引发这个问题。但在自旋锁中最常见的情况是递归使用一个自旋锁，即如果一个已经拥有某个自旋锁的CPU 想第二次获得这个自旋锁，则该CPU 将死锁。此外，如果进程获得自旋锁之后再阻塞，也有可能导致死锁的发生。`copy_from_user()`、`copy_to_user()`和`kmalloc()`等函数都有可能引起阻塞，因此在自旋锁的占用期间不能调用这些函数

- 使用注意事项

  - 自旋锁是不可递归的
  - 线程获取自旋锁之前，要禁止当前处理器上的中断。
    - 上述第二点有这样一种情况，当一个线程获取了自旋锁以后，在临界区中被中断处理程序打断，中断处理程序正好也要获取这个锁，而造成中断处理程序和当前线程互相等待的死锁。


##### 自定义线程属性

- POSIX 标准中，线程的属性用 pthread_attr_t 类型的变量表示

  ```
  #include <pthread.h>
  pthread_attr_t myAttr;
  ```

  - 用此变量前，必须调用 pthread_attr_init() 函数进行初始化

    ```
    int pthread_attr_init(pthread_attr_t * attr);
    
    函数执行成功时，返回数字 0，反之返回非零数。
    ```

    - 通过调用 pthread_attr_init() 函数，myAttr 变量就拥有了系统默认的线程属性。在此基础上，我们可以根据需要对 myAttr 变量的属性值进行修改。

- pthread_attr_t 是一种结构体类型，内部包含多种线程属性：

  ```
  typedef struct
  {
         int __detachstate;
         int __schedpolicy;
         struct sched_param __schedparam;
         int __inheritsched;
         int __scope;
         size_t __guardsize;
         int __stackaddr_set;
         void* __stackaddr;
         size_t __stacksize;
  } pthread_attr_t;
  ```

  - \__detachstate

    - 我们知道，默认属性的线程在执行完目标函数后，占用的私有资源并不会立即释放，要么执行完 pthread_join() 函数后释放，要么整个进程执行结束后释放。某些场景中，我们并不需要接收线程执行结束后的返回值，如果想让线程执行完后立即释放占用的私有资源，就可以通过修改 __detachstate 属性值来实现。

    - __detachstate 属性值用于指定线程终止执行的时机，该属性的值有两个，分别是：

      - PTHREAD_CREATE_JOINABLE（默认值）：线程执行完函数后不会自行释放资源；
      - PTHREAD_CREATE_DETACHED：线程执行完函数后，会自行终止并释放占用的资源。

    - 关于 __detachstate 属性，<pthread.h> 头文件中提供了 2 个与它相关的函数，分别是：

      ```
      int pthread_attr_getdetachstate(const pthread_attr_t * attr,int * detachstate);
      int pthread_attr_setdetachstate(pthread_attr_t *sttr，int detachstate);
      ```

      - pthread_attr_getdetachstate() 函数用于获取 \__detachstate 属性的值，detachstate 指针用于接收`__detachstate` 属性的值；pthread_attr_setdetachstate() 函数用于修改 `__detachstate` 属性的值，detachstate 整形变量即为新的 __detachstate 属性值。两个函数执行成功时返回数字 0，反之返回非零数。

    - 此外，<pthread.h> 头文件还提供有 pthread_detach() 函数，可以直接将目标线程的 __detachstate 属性改为 PTHREAD_CREATE_DETACHED，语法格式如下：

      ```
      int pthread_detach(pthread_t thread);
      ```

  - 后面还有很多，包括修改栈的大小，设置线程的优先级

##### 原子操作

- 原子本意是不可再分的粒子，因此在操作系统中用此名字来命名最基本的操作单一，即如果一个线程执行原子操作，要么完全执行完，要么完全没有开始执行，期间不会被任何别的线程打断

- 原子操作依赖于硬件处理器实现，早在单处理器时代，原子操作被认为是单条指令；而在我们今天越来越复杂的多核CPU时代，即使是运行单条指令也不能保证它不会被干扰，因为多核CPU不可避免的共享总线，而一条指令或许就伴随着访存操作等。

- **在x86平台上，CPU提供三种独立的原子锁机制：原子保证操作、加LOCK指令前缀和缓存一致性协议。**其中原子保证操作一般用于基础内存事务，比方说一个字节的读写或者对于边界对齐是字节、字、双字、四字等读写都可以保证是原子操作。加LOCK指令前缀主要是一种总线锁，其原始实现是当前CPU拉低总线电平锁住总线，而后不断完善性能已有了新的方式代替，但实现的功能还是一样。而缓存一致性协议，又被称为是MESI协议，由于我们CPU有自己的cache缓存，而存在内存中的数据可能会被多个CPU利用，所以需要一种防止多个处理器同时修改相同内存地址的方式。

  - 关于cache的MESI协议可以参考任何计算机体系结构教材。这里需要特别提到一个指令**CMPXCHG，它的语义是实现比较并交换操作数（CAS，Compare And Set）**。CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下旧值有没有发生变化，如果没有发生变化，才交换新值，发生了变化则不交换。这是很多无锁设计的基础，下一章节会详细讲述DPDK中无锁队列的设计。

- 在Linux内核中，提供了两组原子操作的接口：一组是针对整数的操作；一组是针对位运算的操作。

  - 针对整数的原子操作通常只处理atomic_t类型的数据，没有C语言中的int型，该类型可以被认为是一个24位的数据，通常用于实现计数器。而且原子整数操作往往是内联函数，通过内嵌汇编实现。另一方面如果某个函数是原子的，它也通常被定义为一个宏。
  - 原子位操作通常是实现原子地翻转、清空、设置某一地址处n位的值。

- 在Linux2.6.18之后，系统便删除了 `<asm/atomic.h>`和 `<asm/bitops.h>`， `<alsa/iatomic.h>`，在Linux操作系统下GCC提供了内置的原子操作函数`__sync_*`，更方便程序员调用。

  - 现在atomic.h在Linux的内核头文件中，即便能搜索到，但依旧不在gcc默认搜索路径下(`/usr/include，/usr/local/include，/usr/lib/gcc-lib/i386-linux/x.xx.x/include`)，即使像下面这样强行指定路径，还是会出现编译错误。

    ```
    #include</usr/src/linux-headers-4.4.0-98/include/asm-generic/atomic.h> 
    或在编译时提供编译路径
     -I /usr/src/linux-headers-4.4.0-98/include/asm-generic依旧会出现问题
    ```

- gcc从4.1.2提供了`__sync_*`系列的built-in函数，用于提供加减和逻辑运算的原子操作。可以对1,2,4或8字节长度的数值类型或指针进行原子操作，其声明如下

  ```
  type __sync_fetch_and_add (type *ptr, type value, ...)
  type __sync_fetch_and_sub (type *ptr, type value, ...)
  type __sync_fetch_and_or (type *ptr, type value, ...)
  type __sync_fetch_and_and (type *ptr, type value, ...)
  type __sync_fetch_and_xor (type *ptr, type value, ...)
  type __sync_fetch_and_nand (type *ptr, type value, ...)
  
  
  type __sync_add_and_fetch (type *ptr, type value, ...)
  type __sync_sub_and_fetch (type *ptr, type value, ...)
  type __sync_or_and_fetch (type *ptr, type value, ...)
  type __sync_and_and_fetch (type *ptr, type value, ...)
  type __sync_xor_and_fetch (type *ptr, type value, ...)
  type __sync_nand_and_fetch (type *ptr, type value, ...)
  ```

  - 故而现在如果要使得`atomic.h`的旧版本代码可以运行在当下较新的Linux版本下，需要在相应的代码文件前面设置宏替换旧版本的atomic_*系列函数

    ```
      	#define atomic_inc(x) __sync_fetch_and_add((x),1)  
        #define atomic_dec(x) __sync_fetch_and_sub((x),1)  
        #define atomic_add(x,y) __sync_fetch_and_add((x),(y))  
        #define atomic_sub(x,y) __sync_fetch_and_sub((x),(y))  
    ```

- 内存屏障问题
  - 在处理器和编译优化经过了几十年的发展，已经为了获取更高的性能变得非常复杂，一些时候甚至编写C语言程序的程序员自己也不知道哪条语句会被先执行。那是因为在O2甚至O3的优化下，循环展开、写入折叠、乱序执行将CPU性能发挥到极致，但是也带来了一些问题，只有弱序类型的程序才可以获取这样更高的性能。**而需要保序的程序，不能保证一些指令会在特定指令之前执行完。**
  - 为了解决这一问题而引入了内存屏障的概念，虽然分为三种：读写屏障、读屏障和写屏障。但其实现上都是调用__sync_synchronize()，而内核中该函数对应着的正是MFENCE这个序列化加载和存储操作汇编指令。**此序列化确保：在全局范围内，MFENCE前后的任何加载和存储操作以MFENCE为界限，严格保序。**

#### 网络编程

##### socket套接字

- socket 的原意是“插座”，在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。

- 我们把插头插到插座上就能从电网获得电力供应，同样，为了与远程计算机进行数据传输，需要连接到因特网，而 socket 就是用来连接到因特网的工具。

- socket 的典型应用就是 Web 服务器和浏览器：浏览器获取用户输入的 URL，向服务器发起请求，服务器分析接收到的 URL，将对应的网页内容返回给浏览器，浏览器再经过解析和渲染，就将文字、图片、视频等元素呈现给用户。

- open 是系统调用返回的是文件句柄，文件的句柄是文件在文件描述副表里的索引，fopen是C的库函数，返回的是一个指向文件结构的指针。 fopen是ANSIC标准中的C语言库函数，在不同的系统中应该调用不同的内核api. linux中的系统函数是open，fopen是其封装函数，个人观点。

  ```c
  int open(const char *pathname, int flags);
  int open(const char *pathname, int flags, mode_t mode);
  FILE *fopen(const char *path, const char *mode);
  ```

- 为了表示和区分已经打开的文件，UNIX/Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。例如：

  - 通常用 0 来表示标准输入文件（stdin），它对应的硬件设备就是键盘；
  - 通常用 1 来表示标准输出文件（stdout），它对应的硬件设备就是显示器。

- UNIX/Linux 程序在执行任何形式的 I/O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。

- 网络连接也是一个文件，它也有文件描述符！

- 我们可以通过 socket() 函数来创建一个网络连接，或者说打开一个网络文件，socket() 的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：

  - 用 read() 读取从远程计算机传来的数据；
  - 用 write() 向远程计算机写入数据。

##### socket类型

###### 流格式套接字（SOCK_STREAM）

- 流格式套接字（Stream Sockets）也叫“面向连接的套接字”，在代码中使用 SOCK_STREAM 表示。

- SOCK_STREAM 是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送。
- SOCK_STREAM 有以下几个特征：
  - 数据在传输过程中不会消失；
  - 数据是按照顺序传输的；
  - 数据的发送和接收不是同步的（有的教程也称“不存在数据边界”）。
- 为什么流格式套接字可以达到高质量的数据传输呢？这是因为它使用了 TCP 协议（The Transmission Control Protocol，传输控制协议），TCP 协议会控制你的数据按照顺序到达并且没有错误。
- 你也许见过 TCP，是因为你经常听说“TCP/IP”。TCP 用来确保数据的正确性，IP（Internet Protocol，网络协议）用来控制数据如何从源头到达目的地，也就是常说的“路由”。
- 数据的发送和接收不同步的理解：假设传送带传送的是水果，接收者需要凑齐 100 个后才能装袋，但是传送带可能把这 100 个水果分批传送，比如第一批传送 20 个，第二批传送 50 个，第三批传送 30 个。接收者不需要和传送带保持同步，只要根据自己的节奏来装袋即可，不用管传送带传送了几批，也不用每到一批就装袋一次，可以等到凑够了 100 个水果再装袋。
  - 流格式套接字的内部有一个缓冲区（也就是字符数组），通过 socket 传输的数据将保存到这个缓冲区。接收端在收到数据后并不一定立即读取，只要数据不超过缓冲区的容量，接收端有可能在缓冲区被填满以后一次性地读取，也可能分成好几次读取。
  - 也就是说，不管数据分几次传送过来，接收端只需要根据自己的要求读取，不用非得在数据到达时立即读取。传送端有自己的节奏，接收端也有自己的节奏，它们是不一致的。

###### 数据报格式套接字（SOCK_DGRAM）

- 数据报格式套接字（Datagram Sockets）也叫“无连接的套接字”，在代码中使用 SOCK_DGRAM 表示。
- 计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。
- 因为数据报套接字所做的校验工作少，所以在传输效率方面比流格式套接字要高。
- 可以将 SOCK_DGRAM 比喻成高速移动的摩托车快递，它有以下特征：
  - 强调快速传输而非传输顺序；
  - 传输的数据可能丢失也可能损毁；
  - 限制每次传输的数据大小；
  - 数据的发送和接收是同步的（有的教程也称“存在数据边界”）。
- 数据报套接字也使用 IP 协议作路由，但是它不使用 TCP 协议，而是使用 UDP 协议（User Datagram Protocol，用户数据报协议）。
- QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 来传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。
- SOCK_DGRAM 没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。

##### 面向连接和无连接的套接字区别

- 从字面上理解，面向连接好像有一条管道，它连接发送端和接收端，数据包都通过这条管道来传输。当然，两台计算机在通信之前必须先搭建好管道。
- 无连接好像没头苍蝇乱撞，数据包从发送端到接收端并没有固定的线路，爱怎么走就怎么走，只要能到达就行。每个数据包都比较自私，不和别人分享自己的线路，但是，大家最终都能殊途同归，到达接收端。
- 对于无连接的套接字，每个数据包可以选择不同的路径，比如第一个数据包选择路径④，第二个数据包选择路径①，第三个数据包选择路径②……当然，它们也可以选择相同的路径，那也只不过是巧合而已。
- 每个数据包之间都是独立的，各走各的路，谁也不影响谁，除了迷路的或者发生意外的数据包，最后都能到达 H6。但是，到达的顺序是不确定的，比如：
  - 第一个数据包选择了一条比较长的路径（比如路径⑤），第三个数据包选择了一条比较短的路径（比如路径①），虽然第一个数据包很早就出发了，但是走的路比较远，最终还是晚于第三个数据包达到。
  - 第一个数据包选择了一条比较短的路径（比如路径①），第三个数据包选择了一条比较长的路径（比如路径⑤），按理说第一个数据包应该先到达，但是非常不幸，第一个数据包走的路比较拥堵，这条路上的数据量非常大，路由器处理得很慢，所以它还是晚于第三个数据包达到了。
- 还有一些意外情况会发生，比如：
  - 第一个数据包选择了路径①，但是路由器C突然断电了，那它就到不了 H6 了。
  - 第三个数据包选择了路径②，虽然路不远，但是太拥堵，以至于它等待的时间太长，路由器把它丢弃了。
- 总之，对于无连接的套接字，数据包在传输过程中会发生各种不测，也会发生各种奇迹。H1 只负责把数据包发出，至于它什么时候到达，先到达还是后到达，有没有成功到达，H1 都不管了；H6 也没有选择的权利，只能被动接收，收到什么算什么，爱用不用。
- 无连接套接字遵循的是「尽最大努力交付」的原则，就是尽力而为，实在做不到了也没办法。无连接套接字提供的没有质量保证的服务。
- 面向连接的套接字在正式通信之前要先确定一条路径，没有特殊情况的话，以后就固定地使用这条路径来传递数据包了。当然，路径被破坏的话，比如某个路由器断电了，那么会重新建立路径。
- 这条路径是由路由器维护的，路径上的所有路由器都要存储该路径的信息（实际上只需要存储上游和下游的两个路由器的位置就行），所以路由器是有开销的。
- H1 和 H6 通信完毕后，要断开连接，销毁路径，这个时候路由器也会把之前存储的路径信息擦除。
- 为了保证数据包准确、顺序地到达，发送端在发送数据包以后，必须得到接收端的确认才发送下一个数据包；如果数据包发出去了，一段时间以后仍然没有得到接收端的回应，那么发送端会重新再发送一次，直到得到接收端的回应。这样一来，发送端发送的所有数据包都能到达接收端，并且是按照顺序到达的。
- 发送端发送一个数据包，如何得到接收端的确认呢？很简单，为每一个数据包分配一个 ID，接收端接收到数据包以后，再给发送端返回一个数据包，告诉发送端我接收到了 ID 为 xxx 的数据包。
- 面向连接的套接字会比无连接的套接字多出很多数据包，因为发送端每发送一个数据包，接收端就会返回一个数据包。此外，建立连接和断开连接的过程也会传递很多数据包。
- 不但是数量多了，每个数据包也变大了：除了源端口和目的端口，面向连接的套接字还包括序号、确认信号、数据偏移、控制标志（通常说的 URG、ACK、PSH、RST、SYN、FIN）、窗口、校验和、紧急指针、选项等信息；而无连接的套接字则只包含长度和校验和信息。

##### OSI网络模型

- OSI 是 Open System Interconnection 的缩写，译为“开放式系统互联”。

- OSI 模型把网络通信的工作分为 7 层，从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

- OSI 只是存在于概念和理论上的一种模型，它的缺点是分层太多，增加了网络工作的复杂性，所以没有大规模应用。后来人们对 OSI 进行了简化，合并了一些层，最终只保留了 4 层，从下到上分别是接口层、网络层、传输层和应用层，这就是大名鼎鼎的 TCP/IP 模型。

  ![](http://c.biancheng.net/uploads/allimg/190124/1-1Z1241445324H.jpg)

- 我们所说的 [socket](http://c.biancheng.net/socket/) 编程，是站在传输层的基础上，所以可以使用 TCP/UDP 协议，但是不能干「访问网页」这样的事情，因为访问网页所需要的 http 协议位于应用层。

- IP地址

  - IP地址是 Internet Protocol Address 的缩写，译为“网际协议地址”。
  - 目前大部分软件使用 IPv4 地址，但 IPv6 也正在被人们接受，尤其是在教育网中，已经大量使用。
  - 一台计算机可以拥有一个独立的 IP 地址，一个局域网也可以拥有一个独立的 IP 地址（对外就好像只有一台计算机）。对于目前广泛使用 IPv4 地址，它的资源是非常有限的，一台计算机一个 IP 地址是不现实的，往往是一个局域网才拥有一个 IP 地址。
  - 在因特网上进行通信时，必须要知道对方的 IP 地址。实际上数据包中已经附带了 IP 地址，把数据包发送给路由器以后，路由器会根据 IP 地址找到对方的地里位置，完成一次数据的传递。路由器有非常高效和智能的算法，很快就会找到目标计算机。

- MAC地址

  - 现实的情况是，一个局域网往往才能拥有一个独立的 IP；换句话说，IP 地址只能定位到一个局域网，无法定位到具体的一台计算机
  - 其实，真正能唯一标识一台计算机的是 MAC 地址，每个网卡的 MAC 地址在全世界都是独一无二的。计算机出厂时，MAC 地址已经被写死到网卡里面了（当然通过某些“奇巧淫技”也是可以修改的）。局域网中的路由器/交换机会记录每台计算机的 MAC 地址。
  - 数据包中除了会附带对方的 IP 地址，还会附带对方的 MAC 地址，当数据包达到局域网以后，路由器/交换机会根据数据包中的 MAC 地址找到对应的计算机，然后把数据包转交给它，这样就完成了数据的传递。

- 端口号

  - 有了 IP 地址和 MAC 地址，虽然可以找到目标计算机，但仍然不能进行通信。一台计算机可以同时提供多种网络服务，例如 Web 服务（网站）、FTP 服务（文件传输服务）、SMTP 服务（邮箱服务）等，仅有 IP 地址和 MAC 地址，计算机虽然可以正确接收到数据包，但是却不知道要将数据包交给哪个网络程序来处理，所以通信失败。
  - 为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如，Web 服务的端口号是 80，FTP 服务的端口号是 21，SMTP 服务的端口号是 25。
  - 端口（Port）是一个虚拟的、逻辑上的概念。可以将端口理解为一道门，数据通过这道门流入流出，每道门有不同的编号，就是端口号。

##### socket函数创建套接字

```c
int socket(int af, int type, int protocol);
```

- af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。可以man手册查看AF地址，其不止有这两个，AF_UNIX代表本地的地址
- 你也可以使用 PF 前缀，PF 是“Protocol Family”的简写，它和 AF 是一样的。例如，PF_INET 等价于 AF_INET，PF_INET6 等价于 AF_INET6。
- type 为数据传输方式/套接字类型，常用的有 SOCK_STREAM（流格式套接字/面向连接的套接字） 和 SOCK_DGRAM（数据报套接字/无连接的套接字）
- protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。0表示默认协议。
- 正如大家所想，一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。一般没有这种情况，一般最后一个参数写0使用默认协议就可以。

##### bind和connect函数

- [socket](http://c.biancheng.net/socket/)() 函数用来创建套接字，确定套接字的各种属性，然后服务器端要用 bind() 函数将套接字与特定的 IP 地址和端口绑定起来，只有这样，流经该 IP 地址和端口的数据才能交给套接字处理。类似地，客户端也要用 connect() 函数建立连接。

- bind函数

  ```
  int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
  ```

  - sockfd 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。

  ```c
  struct sockaddr_in{
      sa_family_t     sin_family;   //地址族（Address Family），也就是地址类型
      uint16_t        sin_port;     //16位的端口号
      struct in_addr  sin_addr;     //32位IP地址
      char            sin_zero[8];  //不使用，一般用0填充
  };
  
  struct in_addr{
      in_addr_t  s_addr;  //32位的IP地址
  };
  ```

  - sin_family 和 socket() 的第一个参数的含义相同，取值也要保持一致。

  - sin_prot 为端口号。uint16_t 的长度为两个字节，理论上端口号的取值范围为 0~65536，但 0~1023 的端口一般由系统分配给特定的服务程序，例如 Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在 1024~65536 之间分配端口号。端口号需要用 htons() 函数转换

  - sin_zero[8] 是多余的8个字节，没有用，一般使用 memset() 函数填充为 0。上面的代码中，先用 memset() 将结构体的全部字节填充为 0，再给前3个成员赋值，剩下的 sin_zero 自然就是 0 了。

  - sockaddr_in 的第3个成员是 in_addr 类型的结构体，该结构体只包含一个成员

  - in_addr_t 在头文件 <netinet/in.h> 中定义，等价于 unsigned long，长度为4个字节。也就是说，s_addr 是一个整数，而IP地址是一个字符串，所以需要 inet_addr() 函数进行转换。

    ```c
    unsigned long ip = inet_addr("127.0.0.1");
    ```

- bind实例

  ```c
  //创建套接字
  int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  //创建sockaddr_in结构体变量
  struct sockaddr_in serv_addr;
  memset(&serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充
  serv_addr.sin_family = AF_INET;  //使用IPv4地址
  serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //具体的IP地址
  serv_addr.sin_port = htons(1234);  //端口
  //将套接字和IP、端口绑定
  bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
  ```

- sockaddr 和 sockaddr_in 的长度相同，都是16字节，只是将IP地址和端口号合并到一起，用一个成员 sa_data 表示。要想给 sa_data 赋值，必须同时指明IP地址和端口号，例如”127.0.0.1:80“，遗憾的是，没有相关函数将这个字符串转换成需要的形式，也就很难给 sockaddr 类型的变量赋值，所以使用 sockaddr_in 来代替。这两个结构体的长度相同，强制转换类型时不会丢失字节，也没有多余的字节。

- 可以认为，sockaddr 是一种通用的结构体，可以用来保存多种类型的IP地址和端口号，而 sockaddr_in 是专门用来保存 IPv4 地址的结构体。另外还有 sockaddr_in6，用来保存 IPv6 地址

  ```c
  struct sockaddr_in6 { 
      sa_family_t sin6_family;  //(2)地址类型，取值为AF_INET6
      in_port_t sin6_port;  //(2)16位端口号
      uint32_t sin6_flowinfo;  //(4)IPv6流信息
      struct in6_addr sin6_addr;  //(4)具体的IPv6地址
      uint32_t sin6_scope_id;  //(4)接口范围ID
  };
  ```

- 这些结构体都是16个字节，前面那个IPv4后面的是空也是为了保持字节数相等，转换类型时不会丢失信息。

  ```
  int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
  ```

- connect函数和bind函数参数一样，使用方法一样，只是connect是在客户端使用的。

##### listen和accept函数

- 对于服务器端程序，使用 bind() 绑定套接字后，还需要使用 listen() 函数让套接字进入被动监听状态，再调用 accept() 函数，就可以随时响应客户端的请求了。

  ```c
  int listen(int sockfd, int backlog);
  ```

- sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。

- 所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。

- 当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准。如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。

- listen() 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 accept() 函数。

  ```c
  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
  ```

- accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，大家注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。

- 最后需要说明的是：listen() 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()。accept() 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。

##### write和read函数

- Linux 不区分套接字文件和普通文件，使用 write() 可以向套接字中写入数据，使用 read() 可以从套接字中读取数据。

- 两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。

  ```c
  ssize_t write(int fd, const void *buf, size_t count);
  ssize_t read(int fd, void *buf, size_t count);
  ```

- count参数为字节数，不一定是buf的长度，我们也可以指定从buf中读取count个字节和写入count个字节。如果为buf大小可以用sizeof求出。

##### send和recv函数

- windows下使用send和recv函数来向套接字读写数据，linux下也同样有这两个函数来实现套接字通信功能，这样保持不同平台一样。

  ```c++
  ssize_t send(int sockfd, const void *buf, size_t len, int flags);
  ssize_t recv(int sockfd, void *buf, size_t len, int flags);
  ```

  - flags一般为0，这样就和write和read功能差不多了。

##### socket缓冲区以及阻塞模式

- 每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。

- write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。

- TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。

- read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。

  ![](http://c.biancheng.net/uploads/allimg/190219/1149355056-0.jpg)

- 这些I/O缓冲区特性可整理如下：

  - I/O缓冲区在每个TCP套接字中单独存在；
  - I/O缓冲区在创建套接字时自动生成；
  - 即使关闭套接字也会继续传送输出缓冲区中遗留的数据；
  - 关闭套接字将丢失输入缓冲区中的数据。
  - 输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取

  ```c
  int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
  int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
  具体查看man手册
  ```

- 对于TCP套接字（默认情况下），当使用 write()/send() 发送数据时：
  1) 首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据。

  2) 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。

  3) 如果要写入的数据大于缓冲区的最大长度，那么将分批写入。

  4) 直到所有数据被写入缓冲区 write()/send() 才能返回。

- 当使用 read()/recv() 读取数据时：
  1) 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。

  2) 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()/recv() 函数再次读取。

  3) 直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。

- TCP套接字默认情况下是阻塞模式，也是最常用的。当然你也可以更改为非阻塞模式。

- 阻塞和非阻塞的本质

  - 阻塞：阻塞的本质是，进程因为资源等待而主动让出CPU，进程从运行队列删除，幷加入到等待队列，然后等待资源。等超时或数据资源到来则唤醒进程继续执行，若有数据可读那就把数据拷贝给进程，无数据可读但超时了则返回进程继续执行后面的逻辑。
  - 非阻塞：本质是应用进程掌控读取数据的节奏，通过轮训的方式查询数据是否可读，进程始终占用着CPU，能比较好地满足高性能进程需求，执行效率高（数据没到位，进程可以继续处理其他业务，无需阻塞其他业务进行）。

- 数据的“粘包”问题，客户端发送的多个数据包被当做一个数据包接收。也称数据的无边界性，read()/recv() 函数不知道数据包的开始或结束标志（实际上也没有任何开始或结束标志），只把它们当做连续的数据流来处理。

##### 关闭套接字问题

- close() / closesocket() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字，与C语言中的 fclose() 类似。应用程序关闭套接字后，与该套接字相关的连接和缓存也失去了意义，TCP协议会自动触发关闭连接的操作。

- shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() / closesocket() 将套接字从内存清除。

- 调用 close()/closesocket() 关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来了。

- 默认情况下，close()/closesocket() 会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()/closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会。

  ```c
  int shutdown(int sock, int howto);  //Linux
  int shutdown(SOCKET s, int howto);  //Windowsc
  
  shutdown是只关闭一个连接，并不是双向的都关闭
  ```

- howto 在 Linux 下有以下取值：

  - SHUT_RD：断开输入流。套接字无法接收数据（即使输入缓冲区收到数据也被抹去），无法调用输入相关函数。
  - SHUT_WR：断开输出流。套接字无法发送数据，但如果输出缓冲区中还有未传输的数据，则将传递到目标主机。
  - SHUT_RDWR：同时断开 I/O 流。相当于分两次调用 shutdown()，其中一次以 SHUT_RD 为参数，另一次以 SHUT_WR 为参数。

##### socket编程实现文件传输

- 我们来完成 socket 文件传输程序，这是一个非常实用的例子。要实现的功能为：client 从 server 下载一个文件并保存到本地。

- 文件大小不确定，有可能比缓冲区大很多，调用一次 write()/send() 函数不能完成文件内容的发送。接收数据时也会遇到同样的情况。要解决这个问题，可以使用 while 循环

  ```c
  //Server 代码
  int nCount;
  while( (nCount = fread(buffer, 1, BUF_SIZE, fp)) > 0 ){
      send(sock, buffer, nCount, 0);
  }
  //Client 代码
  int nCount;
  while( (nCount = recv(clntSock, buffer, BUF_SIZE, 0)) > 0 ){
      fwrite(buffer, nCount, 1, fp);
  }
  ```

- 对于 Server 端的代码，当读取到文件末尾，fread() 会返回 0，结束循环。

- 对于 Client 端代码，有一个关键的问题，就是文件传输完毕后让 recv() 返回 0，结束 while 循环。读取完缓冲区中的数据 recv() 并不会返回 0，而是被阻塞，直到缓冲区中再次有数据。

  - 最简单的结束 while 循环的方法当然是文件接收完毕后让 recv() 函数返回 0，那么，如何让 recv() 返回 0 呢？recv() 返回 0 的唯一时机就是收到FIN包时。
  - FIN 包表示数据传输完毕，计算机收到 FIN 包后就知道对方不会再向自己传输数据，当调用 read()/recv() 函数时，如果缓冲区中没有数据，就会返回 0，表示读到了”socket文件的末尾“。
  - 这里我们调用 shutdown() 来发送FIN包：server 端直接调用 close()/closesocket() 会使输出缓冲区中的数据失效，文件内容很有可能没有传输完毕连接就断开了，而调用 shutdown() 会等待输出缓冲区中的数据传输完毕。

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <winsock2.h>
  #pragma comment (lib, "ws2_32.lib")  //加载 ws2_32.dll
  #define BUF_SIZE 1024
  int main(){
      //先检查文件是否存在
      char *filename = "D:\\send.avi";  //文件名
      FILE *fp = fopen(filename, "rb");  //以二进制方式打开文件
      if(fp == NULL){
          printf("Cannot open file, press any key to exit!\n");
          system("pause");
          exit(0);
      }
      WSADATA wsaData;
      WSAStartup( MAKEWORD(2, 2), &wsaData);
      SOCKET servSock = socket(AF_INET, SOCK_STREAM, 0);
      struct sockaddr_in sockAddr;
      memset(&sockAddr, 0, sizeof(sockAddr));
      sockAddr.sin_family = PF_INET;
      sockAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
      sockAddr.sin_port = htons(1234);
      bind(servSock, (SOCKADDR*)&sockAddr, sizeof(SOCKADDR));
      listen(servSock, 20);
      SOCKADDR clntAddr;
      int nSize = sizeof(SOCKADDR);
      SOCKET clntSock = accept(servSock, (SOCKADDR*)&clntAddr, &nSize);
      //循环发送数据，直到文件结尾
      char buffer[BUF_SIZE] = {0};  //缓冲区
      int nCount;
      while( (nCount = fread(buffer, 1, BUF_SIZE, fp)) > 0 ){
          send(clntSock, buffer, nCount, 0);
      }
      shutdown(clntSock, SD_SEND);  //文件读取完毕，断开输出流，向客户端发送FIN包
      recv(clntSock, buffer, BUF_SIZE, 0);  //阻塞，等待客户端接收完毕
      fclose(fp);
      closesocket(clntSock);
      closesocket(servSock);
      WSACleanup();
      system("pause");
      return 0;
  }
  ```

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <WinSock2.h>
  #pragma comment(lib, "ws2_32.lib")
  #define BUF_SIZE 1024
  int main(){
      //先输入文件名，看文件是否能创建成功
      char filename[100] = {0};  //文件名
      printf("Input filename to save: ");
      gets(filename);
      FILE *fp = fopen(filename, "wb");  //以二进制方式打开（创建）文件
      if(fp == NULL){
          printf("Cannot open file, press any key to exit!\n");
          system("pause");
          exit(0);
      }
      WSADATA wsaData;
      WSAStartup(MAKEWORD(2, 2), &wsaData);
      SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
      struct sockaddr_in sockAddr;
      memset(&sockAddr, 0, sizeof(sockAddr));
      sockAddr.sin_family = PF_INET;
      sockAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
      sockAddr.sin_port = htons(1234);
      connect(sock, (SOCKADDR*)&sockAddr, sizeof(SOCKADDR));
      //循环接收数据，直到文件传输完毕
      char buffer[BUF_SIZE] = {0};  //文件缓冲区
      int nCount;
      while( (nCount = recv(sock, buffer, BUF_SIZE, 0)) > 0 ){
          fwrite(buffer, nCount, 1, fp);
      }
      puts("File transfer success!");
      //文件接收完毕后直接关闭套接字，无需调用shutdown()
      fclose(fp);
      closesocket(sock);
      WSACleanup();
      system("pause");
      return 0;
  }
  ```

- server.cpp 第42行代码，recv() 并没有接收到 client 端的数据，当 client 端调用 closesocket() 后，server 端会收到FIN包，recv() 就会返回，后面的代码继续执行。

##### socket编程中使用域名

- 客户端中直接使用 IP 地址会有很大的弊端，一旦 IP 地址变化（IP 地址会经常变动），客户端软件就会出现错误。

- 而使用域名会方便很多，注册后的域名只要每年续费就永远属于自己的，更换 IP 地址时修改域名解析即可，不会影响软件的正常使用。

- 域名仅仅是 IP 地址的一个助记符，目的是方便记忆，通过域名并不能找到目标计算机，通信之前必须要将域名转换成 IP 地址。gethostbyname() 函数可以完成这种转换

  ```c
  struct hostent *gethostbyname(const char *hostname);
  hostname 为主机名，也就是域名。使用该函数时，只要传递域名字符串，就会返回域名对应的 IP 地址。返回的地址信息会装入 hostent 结构体
  struct hostent{
      char *h_name;  //official name
      char **h_aliases;  //alias list
      int  h_addrtype;  //host address type
      int  h_length;  //address lenght
      char **h_addr_list;  //address list
  }
  ```

  - h_name：官方域名（Official domain name）。官方域名代表某一主页，但实际上一些著名公司的域名并未用官方域名注册。
  - h_aliases：别名，可以通过多个域名访问同一主机。同一 IP 地址可以绑定多个域名，因此除了当前域名还可以指定其他域名。
  - h_addrtype：gethostbyname() 不仅支持 IPv4，还支持 IPv6，可以通过此成员获取IP地址的地址族（地址类型）信息，IPv4 对应 AF_INET，IPv6 对应 AF_INET6。
  - h_length：保存IP地址长度。IPv4 的长度为 4 个字节，IPv6 的长度为 16 个字节。
  - h_addr_list：这是最重要的成员。通过该成员以整数形式保存域名对应的 IP 地址。对于用户较多的服务器，可能会分配多个 IP 地址给同一域名，利用多个服务器进行均衡负载。

  ```c
  in_addr_t inet_addr(const char *cp);
  char *inet_ntoa(struct in_addr in);
  ```

  - inet_addr()的功能是将一个点分十进制的IP转换成一个长整数型数（u_long类型）
  - inet_ntoa()功能是将网络地址转换成“.”点隔的字符串格式。

##### UDP的编程

- UDP中的服务器端和客户端没有连接，UDP 不像 TCP，无需在连接状态下交换数据，因此基于 UDP 的服务器端和客户端也无需经过连接过程。也就是说，不必调用 listen() 和 accept() 函数。UDP 中只有创建套接字的过程和数据交换的过程。

- UDP中的服务器端和客户端均只需一个套接字，TCP 中，套接字是一对一的关系。如要向 10 个客户端提供服务，那么除了负责监听的套接字外，还需要创建 10 套接字。但在 UDP 中，不管是服务器端还是客户端都只需要 1 个套接字。之前解释 UDP 原理的时候举了邮寄包裹的例子，负责邮寄包裹的快递公司可以比喻为 UDP 套接字，只要有 1 个快递公司，就可以通过它向任意地址邮寄包裹。同样，只需 1 个 UDP 套接字就可以向任意主机传送数据。

- 基于UDP的接受和发送函数，创建好 TCP 套接字后，传输数据时无需再添加地址信息，因为 TCP 套接字将保持与对方套接字的连接。换言之，TCP 套接字知道目标地址信息。但 UDP 套接字不会保持连接状态，每次传输数据都要添加目标地址信息，这相当于在邮寄包裹前填写收件人地址。

  - 发送数据使用 sendto() 函数：

    ```c
    ssize_t sendto(int sock, void *buf, size_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen);  //Linux
    int sendto(SOCKET sock, const char *buf, int nbytes, int flags, const struct sockadr *to, int addrlen);  //Windows
    ```

  - Linux 和 Windows 下的 sendto() 函数类似，下面是详细参数说明：

    - sock：用于传输 UDP 数据的套接字；
    - buf：保存待传输数据的缓冲区地址；
    - nbytes：带传输数据的长度（以字节计）；
    - flags：可选项参数，若没有可传递 0；
    - to：存有目标地址信息的 sockaddr 结构体变量的地址；
    - addrlen：传递给参数 to 的地址值结构体变量的长度。

  - 接收数据使用 recvfrom() 函数：

    ```c
    ssize_t recvfrom(int sock, void *buf, size_t nbytes, int flags, struct sockadr *from, socklen_t *addrlen);  //Linux
    int recvfrom(SOCKET sock, char *buf, int nbytes, int flags, const struct sockaddr *from, int *addrlen);  //Windows
    ```

  - 由于 UDP 数据的发送端不定，所以 recvfrom() 函数定义为可接收发送端信息的形式，具体参数如下：

    - sock：用于接收 UDP 数据的套接字；
    - buf：保存接收数据的缓冲区地址；
    - nbytes：可接收的最大字节数（不能超过 buf 缓冲区的大小）；
    - flags：可选项参数，若没有可传递 0；
    - from：存有发送端地址信息的 sockaddr 结构体变量的地址；
    - addrlen：保存参数 from 的结构体变量长度的变量地址值。

- UDP 不同于 TCP，不存在请求连接和受理过程，因此在某种意义上无法明确区分服务器端和客户端

