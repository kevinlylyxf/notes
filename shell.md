#### shell脚本

- shell变量
   - Bash shell默认情况下不会区分变量类型，即是将整数和小数赋值给变量，也会被视为字符串，可以使用declare关键字显示定义变量的类型，一般情况下没有这个需求
   - 三种定义变量的方式，variable=value,variable='value',variable="value",variable是变量名，value是赋给变量的值，如果value不包含任何空白符(空格、Tab缩进)，可以不用引号，单引号引起来的是什么就输出什么，不希望解析变量命令。双引号引起来的输出时会先解析里面的变量和命令。不被引号包围的字符串不能出现空格，否则空格后边的字符串会作为其他便利情或者命令解析。
   - 赋值号=周围不能有空格
   - 使用变量，在变量名前面加$符号，变量名字前面有没有{}都可以，加括号是为了帮助解释器识别变量的边界，良好的编程习惯
   - 将命令的结果赋值给变量 variable=`command`,variable=$(command),第一种方式用反引号包围起来，第二种方式用$()包围起来更常用。例如log=$(cat log.txt),echo $log
   - 只读变量 readonly variable，删除变量unset，unset不能删除只读变量
- shell变量的作用范围
   - shell函数中定义的变量默认是全局变量，它和在函数外定义的变量一样的效果
   - 局部变量定义时加上local
   - 全局变量的作用范围是当前的shell进程，不是当前的shell脚本文件，例如在当前shell进程中定义a=99,有一个a.sh脚本，里面有echo $a,此时运行脚本会输出99，说明在shell进程中全局变量的作用域
   - 环境变量，使用export命令将全局变量导出，那么它的子进程也可以使用了，没有关系的两个进程不可以使用。进入子进程直接输入bash命令就行，exit退出
- shell命令替换
   - shell命令替换是指将命令的输出结果赋值给某个变量。
   - 可以使用；使用多个命令例如$(cd `dirname $0`;pwd)，$0是文件名,dirname就是获取当前文件路径的上一级路径，例如dirname /usr/bin,结果为/usr,dirname stdio.h,结果为.一个点，即表示当前目录,dirname /home/lyl/a/test.sh,结果为/home/lyl/a.后续如果要用的话直接cd进去，pwd显示当前路径，用命令替换给变量。这样就得到了路径名。文件名和路径不一样。这样操作下来其实就是用一个变量代替了路径名称，用的时候直接cd进去，就直接到了工作目录。
   - %格式控制符，以什么格式显示时间date +%s，显示的是秒为单位，date +"%Y-%m-%d",以年月日的格式显示
   - 如果被替换的命令的输出内容包括很多行，在输出变量的时候应该将变量用双引号包围，lsl=$(ls -l), echo "$lsl",此时会分行显示，如果没有双引号系统会用默认的空格来填充，换行符就没有用了，连续的空白符会被压缩成一个。
   - 反引号里面不能嵌套。例如a=$(wc -l $(ls | sed -n '1p'))，反引号不能这么写
- shell特殊变量
   - 在shell中定义函数时不能带参数，调用函数时可以传递参数，传进来的参数在函数内部也使用$n的形式接收。这涉及到给脚本文件传递参数和给函数传递参数，使用的方法都是一样的。一个是在脚本里面一个在shell里面
   - $0 当前脚本的文件名
   - $n 传递给脚本或函数的参数个数
   - $# 传递给脚本或函数的参数个数
   - $? 上个命令的退出状态或函数返回值，一般成功为0，失败为1，在函数调用后使用$?可以得到函数返回值。
   - $$ 当前shell进程id，对于shell脚本就是这些脚本所在的进程id
   - $\* 传递给脚本或函数的所有参数
   - $@ 传递给脚本或函数的所有参数
   - 当$\*和$@没有被双引号包围时，他们之间没有任何区别，即将每个参数看作一份数据，彼此之间以空格区分，但是被双引号包围时，$\*会将所有的参数整体上看作一份数据，而不是把每个参数看作一个数据，$@和原来一样。使用echo看不出来，但是用for循环来逐个输出数据，$\*是一份数据$@是n个数据
- shell字符串
   - 获取字符串长度 ${#string_name}
   - shell中字符串拼接，直接放在一起即为拼接
   - shell字符串截取
      - 从左边开始计数${string:start:length} url="c.biancheng.net" echo ${url:2:9} 省略length参数默认截取到字符串末尾
      - 从右边开始计数${string:0-start:length} 0-是固定写法表示从右边计数
      - 从指定字符开始截取 ${string#\*chars}使用#可以截取指定字符(或子字符串)右边的所有字符，即删除左边的，取右边的字符。*表示忽略左边的所有字符直到指定chars，如果不需要忽略chars左边的字符，可以不写\*，但是chars需要从头写起，上述写法是遇到第一个匹配的字符就结束了，如果希望直到最后一个指定字符，可以使用##,${string##\*chars
```shell
str="---aa+++aa@@@"
echo ${str#*aa}   #结果为 +++aa@@@
echo ${str##*aa}  #结果为 @@@
```
      - 使用%截取指定字符或字符串左边的所有字符，即取左边的删除右边的，从右往左查找。因为要截取chars左边的字符，忽略chars右边的字符，所以\*应该位于chars的右侧，其他方面%和#用法相同，%是从右往左查找。${string%chars\*}
- shell数组
   - 只支持一维数组，并不要求数组元素的类型必须相同
   - 数组定义()来表示数组，中间用空格隔开nums=(29 100 13 8)
   - 数组长度不固定，定义之后可以增加元素，nums[4]=50，前面只定义到3
   - 获取数组元素${array_name[index]}，获取完一般放到变量里面，或者直接输出.${nums[\*]}和${nums[@]}是取得数组的所有元素
   - 获取数组长度${#array_name[@]}或者\*,如果某个元素是字符串，可以通过指定下标的方式获得该元素的长度${#arr[2]}
   - 数组的拼接，直接获取所有元素然后在两个数组中间放空格，外面在加上()
   - 删除数组元素 unset arr[1],不加[1]就是删除整个数组
   - 关联数组就是使用字符串作为下标而不是整数，类似于key-value，关联数组必须使用带有-A选项的declare命令创建，其余和普通数组一样
- shell内建命令
   - 使用type命令来确定是否是内建命令，例如type cd,$PATH中的大多数命令都是外部命令
   - alias，如果不带参数可以查看当前环境下所有的alias，使用unalise删除别名。   - echo，默认加上换行，echo -n表示不换行。默认情况下echo不会解析\开头的转义字符，比如\n表示换行,添加参数-e来让echo命令解析转义字符例如echo -e "hello\nworld"会分两行输出
- shell数学计算
   - 在 Bash Shell 中，如果不特别指明，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储
   - shell中要进行数学运算必须使用数学计算命令  (())用于整数计算，效率很高。bc可以进行小数计算
   - ((b=a-15))，在括号里面可以不用加$前缀使用变量，取用结果时$b就行，如果里面没有变量需要$((1+2))。使用(())可以进行逻辑运算，大于小于，与或非之类的。可以在里面同时对多个表达式进行计算。((a=3+5,b=a+10))，如果没有赋值即((3+5,a+10)),以最后一个计算结果为结果
   - bc，echo "scale=4;3\*8/7;last\*5"|bc，通过管道输入到bc计算，scale设置小数点几位数字。
   - test命令或者写成[],test expression,或者[expression],用来检测某个条件是否成立，可以进行数值，字符串和文件三个方面的检测。[]这样写时和expression之间有空格
      - 文件类型相关 -b，判断文件是否存在，并且是否为块设备文件 -d，判断文件是否存在，并且是否为目录文件 -f，判断文件是否存在，并且是否为普通文件。-e，只判断文件
      - 文件权限判断 -r -w -x -u -g -k
      - 文件比较 -nt -ot -ef
      - 数值比较 -eq 相等 -ne 不相等 -gt 大于 -lt 小于 -ge大于等于 -le小于等于
      - 字符串判断 -z 是否为空 -n 是否非空 ==  != \> \< ,这样写防止将>认为成重定向运算符
      - 逻辑判断相关的 -a 与 -o 或 ！非
      - 当你在 test 命令中使用变量时，我强烈建议将变量用双引号""包围起来，这样能避免变量为空值时导致的很多奇葩问题
- [[]] 是shell内置关键字，用来检测某个条件是否成立，test能干的，[[]]也能干且干的更好。[[]]支持正则表达式
   - [[ ]] 对数字的比较仍然不友好，所以我建议，以后大家使用 if 判断条件时，用 (()) 来处理整型数字，用 [[ ]] 来处理字符串或者文件。
   - [[]]支持正则表达式，即支持字符串模糊匹配，而[]不支持模糊匹配。模糊匹配时，模糊匹配项不要加""，否则模糊匹配符也会当作字符处理。
- while while cindition do done
- exit  用来退出当前shell进程并返回一个退出状态，使用$?可以接受这个状态
---
[shell正则表达式分为基本的和扩展的](https://man.linuxde.net/docs/shell_regex.html)
- shell中的cd命令是有继承的，cd之后下一条命令可以直接用cd进来的目录，就不用填写绝对路径了。makefile里面的cd不行，必须得写在一行。而且shell中的变量不能和环境变量重名。
- shell调用函数时只需要写函数名就可以不用(),但是定义函数时需要写上()
- shell脚本是用来执行命令行程序的，所以在命令行能弄的脚本里面都能弄，包括可执行程序。脚本里面可以调用外面的程序来运行。

------

#### Linux常用命令

##### xargs

- Unix 命令都带有参数，有些命令可以接受"标准输入"（stdin）作为参数。

  ```shell
  cat /etc/passwd | grep root
  ```

  上面的代码使用了管道命令（`|`）。管道命令的作用，是将左侧命令（`cat /etc/passwd`）的标准输出转换为标准输入，提供给右侧命令（`grep root`）作为参数。

  因为`grep`命令可以接受标准输入作为参数，所以上面的代码等同于下面的代码。

  ```bash
  grep root /etc/passwd
  ```

  但是，大多数命令都不接受标准输入作为参数，只能直接在命令行输入参数，这导致无法用管道命令传递参数。举例来说，`echo`命令就不接受管道传参。

  ```bash
  echo "hello world" | echo   代码不会有输出。因为管道右侧的echo不接受管道传来的标准输入作为参数。
  ```

- `xargs`命令的作用，是将标准输入转为命令行参数。

  ```bash
  $ echo "hello world" | xargs echo
  hello world    代码将管道左侧的标准输入，转为命令行参数hello world，传给第二个echo命令。
  ```

  `xargs`的作用在于，大多数命令（比如`rm`、`mkdir`、`ls`）与管道一起使用时，都需要`xargs`将标准输入转为命令行参数。

  ```bash
  echo "one two three" | xargs mkdir   代码等同于mkdir one two three。如果不加xargs就会报错，提示mkdir缺少操作参数。
  ```

- xargs一些参数

  - 默认情况下，`xargs`将换行符和空格作为分隔符，把标准输入分解成一个个命令行参数。

    ```bash
    echo "one two three" | xargs mkdir   xargs将one two three分解成三个命令行参数，执行mkdir one two three
    ```

  - `-d`参数可以更改分隔符。

    ```bash
    $ echo -e "a\tb\tc" | xargs -d "\t" echo
    a b c               上面的命令指定制表符\t作为分隔符，所以a\tb\tc就转换成了三个命令行参数。echo命令的-e参数表示解释转义字符。
    ```

  - `-p`参数打印出要执行的命令，询问用户是否要执行。

##### su -

- su和su - 的区别，su不切换当前的家目录，不改变当前环境，跟最开始登录一样。相当于su 到那个用户获得那个用户对文件的权限，而su - 切换用户之后会切换到用户的家目录。其中的-号相当于更新当前的环境，相当于重新登录用户。
- 例如在root下编译内核，提示要用普通用户编译，所以su - yq切换到普通用户，但是又提示权限不够，所以su 得到root权限，但是没有完全切换到root登录。

##### sync

- [用户缓冲区和内核缓冲区]: https://www.cnblogs.com/BlueBlueSea/p/14807245.html

- sync命令是强制把内存中的数据写回硬盘，以免数据的丢失。主要还是和缓冲区有关，理解了缓冲区就理解了sync命令。缓冲区可以在c.md里面查看

- mount挂载之后直接umount文件就会出现错误，因为有一部分数据在缓冲区内没有写入到u盘中，所以在umount之前要执行sync命令。每一个文件都有缓冲区，所以在将文件cp 到/mnt中时，每一个文件都开辟了缓冲区，如果没有强制写入硬盘就会出现有一部分数据在缓冲区中没有写入硬盘中。

##### diff

- diff <变动前的文件> <变动后的文件>

- diff比较的是两个文件的差异，所以是以第一个文件为基础，第二个文件与第一个文件的差异，-表示第二个比第一个少了，+表示第二个比第一个多了。

- diff比较文件差异的时候可能是因为空格数的不同导致的，或者空行导致的，这些不应该显示出来，要不然就太多了，例如在windows上写的代码，拖到linux上，这样比较前后两个文件，所有的行都会显示出来，因为是空格数不同导致的。diff有选项-b会忽略由空格数不同导致的差异。

- diff有三种格式
  - 正常格式（normal diff）
  - 上下文格式（context diff）
  - 合并格式（unified diff）

- 创建两个文件，第一个文件叫做f1，内容是每行一个a，一共7行。第二个文件叫做f2，修改f1而成，第4行变成b，其他不变。

  - 正常格式diff f1 f2

    ```c
    4c4
    < a
    ---
    > b
        
        第一行是一个提示，用来说明变动位置。它分成三个部分：前面的"4"，表示f1的第4行有变化；中间的"c"表示变动的模式是内容改变（change），其他模式还有"增加"（a，代表addition）和"删除"（d，代表deletion）；后面的"4"，表示变动后变成f2的第4行。
        第二行分成两个部分< a,前面的小于号，表示要从f1当中去除该行（也就是第4行），后面的"a"表示该行的内容。
        第三行用来分割f1和f2。
        第四行，类似于第二行,前面的大于号表示f2增加了该行，后面的"b"表示该行的内容。
    ```

  - 上下文格式，它的使用方法是加入c参数（代表context）diff -c f1 f2

    ```shell
       *** f1 2012-08-29 16:45:41.000000000 +0800
    　　--- f2 2012-08-29 16:45:51.000000000 +0800
    　　***************
    　　*** 1,7 ****
    　　 a
    　　 a
    　　 a
    　　!a
    　　 a
    　　 a
    　　 a
    　　--- 1,7 ----
    　　 a
    　　 a
    　　 a
    　　!b
    　　 a
    　　 a
    　　 a
    　　 
    　　 第一部分的两行，显示两个文件的基本情况：文件名和时间信息。"***"表示变动前的文件，"---"表示变动后的文件。
    　　 第二部分是15个星号，将文件的基本情况与变动内容分割开。
    　　 第三部分显示变动前的文件，即f1。这时不仅显示发生变化的第4行，还显示第4行的前面三行和后面三行，因此一共显示7行。所以，前面的"*** 1,7 ****"就表示，从第1行开始连续7行。另外，文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。
    　　 第四部分显示变动后的文件，即f2。
    ```

  - 合并格式，如果两个文件相似度很高，那么上下文格式的diff，将显示大量重复的内容，很浪费空间。1990年，GNU diff率先推出了"合并格式"的diff，将f1和f2的上下文合并在一起显示。它的使用方法是加入u参数（代表unified）。diff -u f1 f2

    ```shell
       --- f1 2012-08-29 16:45:41.000000000 +0800
    　　+++ f2 2012-08-29 16:45:51.000000000 +0800
    　　@@ -1,7 +1,7 @@
    　　 a
    　　 a
    　　 a
    　　-a
    　　+b
    　　 a
    　　 a
    　　 a
    　　 
    　　 它的第一部分，也是文件的基本信息。"---"表示变动前的文件，"+++"表示变动后的文件。
    　　 第二部分，变动的位置用两个@作为起首和结束。前面的"-1,7"分成三个部分：减号表示第一个文件（即f1），"1"表示第1行，"7"表示连续7行。合在一起，就表示下面是第一个文件从第1行开始的连续7行。同样的，"+1,7"表示变动后，成为第二个文件从第1行开始的连续7行。
    　　 第三部分是变动的具体内容。
    　　 除了有变动的那些行以外，也是上下文各显示3行。它将两个文件的上下文，合并显示在一起，所以叫做"合并格式"。每一行最前面的标志位，空表示无变动，减号表示第一个文件删除的行，加号表示第二个文件新增的行。
    ```

- 版本管理系统git，使用的是合并格式diff的变体。

  ```shell
  	diff --git a/f1 b/f1
  　　index 6f8a38c..449b072 100644
  　　--- a/f1
  　　+++ b/f1
  　　@@ -1,7 +1,7 @@
  　　 a
  　　 a
  　　 a
  　　-a
  　　+b
  　　 a
  　　 a
  　　 a
  　　 
  　　 第一行表示结果为git格式的diff。进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。
  　　 第二行表示两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）。
  　　 第三行表示进行比较的两个文件。"---"表示变动前的版本，"+++"表示变动后的版本。
  　　 后面的行都与官方的合并格式diff相同。
  ```

- git add就是暂存区，git commit是版本库，git 只能比较本地的，远程的不能比较，即不能比较本地和远程的diff

  - 比较不同分支之间的差异

    ```shell
    git diff master dev
    上面的命令是以master分支为参照，比较dev分支和master分支之间的差异。注意改变分支的比较顺序，结果会不同，默认不加文件名参数，会比较出所有文件的差异。 比较指定文件的差异可以参照如下命令:
    git diff master dev -- READMD.md index.php
    ```

  - 比较工作区和版本库之间的文件差异

    ```shell
    Git中用一个叫HEAD的指针指向当前分支的最新一次提交，我们可以用以下命令来比较工作区和版本库之间的文件差异
    比较全部文件: git diff HEAD
    比较单个文件: git diff HEAD -- READMD.md
    比较单个文件或者某几个文件，需要加上--
    ```

  - 比较工作区和暂存区之间的文件差异

    - 使用默认的git diff，不加任何参数，默认比较的是工作区和暂存区之间的文件差异。

  - 比较暂存区和版本库之间的文件差异

    - 使用git diff --cached或者git diff --staged来比较暂存区和版本库之间的文件差异，cached和staged都有表示缓存的意思。

##### ln

- 功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。

  ```
  ln [参数][源文件或目录][目标文件或目录]
  ```

  - 源文件是真实存在的文件，目标文件是我们要创建的链接文件
  - -s是创建软连接
  - ls查看文件时前面的是链接文件，后面的是真实的文件libm.so.6 -> libm-2.17.so，->的意思是指向真实的文件

##### ldconfig和ldd

- ldd用来查看程式运行所需的共享库,常用来解决程式因缺少某个库文件而不能运行的一些问题。

  ```shell
  ldd /bin/ls
  linux-vdso.so.1 =>  (0x00007fff69bff000)
  librt.so.1 => /lib64/librt.so.1 (0x00007fd67f147000)
  libacl.so.1 => /lib64/libacl.so.1 (0x00007fd67ef41000)
  libc.so.6 => /lib64/libc.so.6 (0x00007fd67ec01000)
  libpthread.so.0 => /lib64/libpthread.so.0 (0x00007fd67e9e6000)
  /lib64/ld-linux-x86-64.so.2 (0x00007fd67f351000)
  libattr.so.1 => /lib64/libattr.so.1 (0x00007fd67e7e2000)
  
  第一个linux-vdso.so.1是系统用的，这个不用管
  ```

  - 第一列：程序需要依赖什么库
  - 第二列: 系统提供的与程序需要的库所对应的库
  - 第三列：库加载的开始地址
  - 通过对比第一列和第二列，我们可以分析程序需要依赖的库和系统实际提供的，是否相匹配
  - 通过观察第三列，我们可以知道在当前的库中的符号在对应的进程的地址空间中的开始位置

-  ldd不是个可执行程式，而只是个shell脚本； ldd显示可执行模块的dependency的工作原理，其实质是通过ld-linux.so（elf动态库的装载器）来实现的。ld-linux.so模块会先于executable模块程式工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so选择了显示可执行模块的dependency。

- ldconfig

  - `ldconfig`是一个动态库管理命令, 为了让动态库为系统所共享, 须运行该命令

  - `ldconfig`通常在系统启动时运行, 而当用户安装了一个新的动态库时, 就需要手动运行该命令

  - ldconfig作用，在默认搜寻目录(`/lib`和`/usr/lib`)下, 以及动态库配置文件(`/etc/ld.so.conf`和`/etc/ld.so.conf.d/*.conf`)里所列的目录下, 搜索出可共享的动态库(格式如`lib*.so*`), 进而创建出动态装入程序*(ld.so)*所需的连接和缓存文件，缓存文件默认为`/etc/ld.so.cache`, 此文件保存动态库名字列表。简单来说动态装载器ld.so需要/etc/ld.so.cache文件来查看需要的库路径，如果没有在这个缓存文件里面就不会加载，ldconfig会将默认搜寻目录和动态库配置文件中找需要的库，并将其加入到缓存文件中，这样系统就能装在所需要的库。一般安装软件时，会在/etc/ld.so.conf.d目录下生成一个文件，文件以conf为后缀例如mysql.ld.conf，文件里面记录着库存放的路径。这样运行ldconfig就能搜寻到库，放到缓存文件中，然后ld.so就能加载上了。

  - 命令选项

    ```shell
    -p或--print-cache：此选项指示ldconfig打印出当前缓存文件所保存的全部共享库的名字。
    -v或--verbose：用此选项时，ldconfig将显示正在扫描的目录及搜索到的动态连接库，还有它所建立的链接的名字。
    ```

  - 注意事项

    - 往/lib和/usr/lib里面加东西, 是不用修改/etc/ld.so.conf的, 但是完了之后要调一下ldconfig, 不然这个library会找不到
    - 想往上面两个目录以外加东西的时候, 一定要修改/etc/ld.so.conf, 然后再调用ldconfig, 不然也会找不到. 比如安装了一个mysql到/usr/local/mysql, mysql有一大堆library在/usr/local/mysql/lib下面, 这时就需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib, 保存过后ldconfig一下, 新的library才能在程序运行时被找到
    - 如果想在这两个目录以外放lib, 但是又不想在/etc/ld.so.conf中加东西或者是没有权限加东西. 那也可以, 就是export一个全局变量`LD_LIBRARY_PATH`, 然后运行程序的时候就会去这个目录中找library. 一般来讲这只是一种临时的解决方案, 在没有权限或临时需要的时候使用
    - ldconfig做的这些东西都与运行程序时有关, 跟编译时一点关系都没有
    - 总之, 就是不管做了什么关于library的变动后, 最好都ldconfig一下, 不然会出现一些意想不到的结果

##### bin和lib目录详解

- bin目录有/bin,/sbin,/usr/bin,/usr/sbin,/usr/local/bin,/usr/local/sbin
  - `/bin`放置系统的关键程序比如 `ls` `cat` ，对于“关键”的定义，不同的发行版会有不同的理解
  - `/usr/bin` 放置发行版管理的程序，比如 Ubuntu 自带 `md5sum` ，这个 binary 就会在这个目录下
  - `/usr/local/bin` 放置用户自己的程序，比如你编译了一个 gcc，那么 gcc 这个可执行 binary 应该在这个目录下，自己在晚上下载安装的软件一般放在这里
  - 除此之外，还有对应的三个目录 `/sbin` `/usr/sbin` `/usr/local/sbin` ，放置系统管理的程序，比如 `deluser` `chroot` `service` ,`reboot` `shutdown`
  - 这是一种文件的管理方式而已，你甚至可以把自己的 binary 放到 `$HOME/bin` 下。还有，OS X 用 [homebrew](https://brew.sh/) 安装的软件，会放在 `/usr/local/Cellar` 下，然后在 `/usr/local/bin` 创建一个指向相关 bin 目录的符号链接；但是在 Ubuntu 下，会放到 `/usr/bin` 下。
  - 需要知道 `/` `/usr` `/usr/local` 这些都是 prefix，你编译一个软件的之后，要执行 `./configure --prefix=/usr/local` 然后 `make && make install` 。那么 `/usr/local` 就会作为 prefix，库文件就放在 `/usr/local/lib` 下面，配置文件就放在 `/usr/local/etc` 下面，可执行文件（binary）就放在 `/usr/local/bin` 下面。
- lib64，lib目录和bin目录一样，只要有bin目录的地方就有lib目录，用来存放bin程序需要的库。简单说,/lib是内核级的,/usr/lib是系统级的,/usr/local/lib是用户级的。
- /opt这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。而/usr/local里面的程序和库没有统一在一个文件夹里面，这样造成删除的时候困难，使用包管理工具安装的软件一般放在/usr里面。homebrew安装的放在/usr/local/Cellar下面有各个软件的文件夹，apt-get没有单独命名的文件夹，其内容是分散的lib和bin

##### xrandr

- xrandr是一款官方的扩展配置工具。它可以设置屏幕显示的大小、方向、镜像等，包括对多屏的设置。
- xrandr查看屏幕可以设置的分辨率，然后xrandr -s 设置分辨率
