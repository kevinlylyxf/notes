#### shell脚本

- shell变量
   - Bash shell默认情况下不会区分变量类型，即是将整数和小数赋值给变量，也会被视为字符串，可以使用declare关键字显示定义变量的类型，一般情况下没有这个需求
   - 三种定义变量的方式，variable=value,variable='value',variable="value",variable是变量名，value是赋给变量的值，如果value不包含任何空白符(空格、Tab缩进)，可以不用引号，单引号引起来的是什么就输出什么，不希望解析变量命令。双引号引起来的输出时会先解析里面的变量和命令。不被引号包围的字符串不能出现空格，否则空格后边的字符串会作为其他便利情或者命令解析。
   - 赋值号=周围不能有空格
   - 使用变量，在变量名前面加$符号，变量名字前面有没有{}都可以，加括号是为了帮助解释器识别变量的边界，良好的编程习惯
   - 将命令的结果赋值给变量 variable=`command`,variable=$(command),第一种方式用反引号包围起来，第二种方式用$()包围起来更常用。例如log=$(cat log.txt),echo $log
   - 只读变量 readonly variable，删除变量unset，unset不能删除只读变量
- shell变量的作用范围
   - shell函数中定义的变量默认是全局变量，它和在函数外定义的变量一样的效果
   - 局部变量定义时加上local
   - 全局变量的作用范围是当前的shell进程，不是当前的shell脚本文件，例如在当前shell进程中定义a=99,有一个a.sh脚本，里面有echo $a,此时运行脚本会输出99，说明在shell进程中全局变量的作用域
   - 环境变量，使用export命令将全局变量导出，那么它的子进程也可以使用了，没有关系的两个进程不可以使用。进入子进程直接输入bash命令就行，exit退出
- shell命令替换
   - shell命令替换是指将命令的输出结果赋值给某个变量。
   - 可以使用；使用多个命令例如$(cd `dirname $0`;pwd)，$0是文件名,dirname就是获取当前文件路径的上一级路径，例如dirname /usr/bin,结果为/usr,dirname stdio.h,结果为.一个点，即表示当前目录,dirname /home/lyl/a/test.sh,结果为/home/lyl/a.后续如果要用的话直接cd进去，pwd显示当前路径，用命令替换给变量。这样就得到了路径名。文件名和路径不一样。这样操作下来其实就是用一个变量代替了路径名称，用的时候直接cd进去，就直接到了工作目录。
   - %格式控制符，以什么格式显示时间date +%s，显示的是秒为单位，date +"%Y-%m-%d",以年月日的格式显示
   - 如果被替换的命令的输出内容包括很多行，在输出变量的时候应该将变量用双引号包围，lsl=$(ls -l), echo "$lsl",此时会分行显示，如果没有双引号系统会用默认的空格来填充，换行符就没有用了，连续的空白符会被压缩成一个。
   - 反引号里面不能嵌套。例如a=$(wc -l $(ls | sed -n '1p'))，反引号不能这么写
- shell特殊变量
   - 在shell中定义函数时不能带参数，调用函数时可以传递参数，传进来的参数在函数内部也使用$n的形式接收。这涉及到给脚本文件传递参数和给函数传递参数，使用的方法都是一样的。一个是在脚本里面一个在shell里面
   - $0 当前脚本的文件名
   - $n 传递给脚本或函数的参数个数
   - $# 传递给脚本或函数的参数个数
   - $? 上个命令的退出状态或函数返回值，一般成功为0，失败为1，在函数调用后使用$?可以得到函数返回值。
   - $$ 当前shell进程id，对于shell脚本就是这些脚本所在的进程id
   - $\* 传递给脚本或函数的所有参数
   - $@ 传递给脚本或函数的所有参数
   - 当$\*和$@没有被双引号包围时，他们之间没有任何区别，即将每个参数看作一份数据，彼此之间以空格区分，但是被双引号包围时，$\*会将所有的参数整体上看作一份数据，而不是把每个参数看作一个数据，$@和原来一样。使用echo看不出来，但是用for循环来逐个输出数据，$\*是一份数据$@是n个数据
- shell字符串
   - 获取字符串长度 ${#string_name}
   - shell中字符串拼接，直接放在一起即为拼接
   - shell字符串截取
      - 从左边开始计数${string:start:length} url="c.biancheng.net" echo ${url:2:9} 省略length参数默认截取到字符串末尾
      - 从右边开始计数${string:0-start:length} 0-是固定写法表示从右边计数
      - 从指定字符开始截取 ${string#\*chars}使用#可以截取指定字符(或子字符串)右边的所有字符，即删除左边的，取右边的字符。*表示忽略左边的所有字符直到指定chars，如果不需要忽略chars左边的字符，可以不写\*，但是chars需要从头写起，上述写法是遇到第一个匹配的字符就结束了，如果希望直到最后一个指定字符，可以使用##,${string##\*chars
```shell
str="---aa+++aa@@@"
echo ${str#*aa}   #结果为 +++aa@@@
echo ${str##*aa}  #结果为 @@@
```
      - 使用%截取指定字符或字符串左边的所有字符，即取左边的删除右边的，从右往左查找。因为要截取chars左边的字符，忽略chars右边的字符，所以\*应该位于chars的右侧，其他方面%和#用法相同，%是从右往左查找。${string%chars\*}
- shell数组
   - 只支持一维数组，并不要求数组元素的类型必须相同
   - 数组定义()来表示数组，中间用空格隔开nums=(29 100 13 8)
   - 数组长度不固定，定义之后可以增加元素，nums[4]=50，前面只定义到3
   - 获取数组元素${array_name[index]}，获取完一般放到变量里面，或者直接输出.${nums[\*]}和${nums[@]}是取得数组的所有元素
   - 获取数组长度${#array_name[@]}或者\*,如果某个元素是字符串，可以通过指定下标的方式获得该元素的长度${#arr[2]}
   - 数组的拼接，直接获取所有元素然后在两个数组中间放空格，外面在加上()
   - 删除数组元素 unset arr[1],不加[1]就是删除整个数组
   - 关联数组就是使用字符串作为下标而不是整数，类似于key-value，关联数组必须使用带有-A选项的declare命令创建，其余和普通数组一样
- shell内建命令
   - 使用type命令来确定是否是内建命令，例如type cd,$PATH中的大多数命令都是外部命令
   - alias，如果不带参数可以查看当前环境下所有的alias，使用unalise删除别名。   - echo，默认加上换行，echo -n表示不换行。默认情况下echo不会解析\开头的转义字符，比如\n表示换行,添加参数-e来让echo命令解析转义字符例如echo -e "hello\nworld"会分两行输出
- shell数学计算
   - 在 Bash Shell 中，如果不特别指明，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储
   - shell中要进行数学运算必须使用数学计算命令  (())用于整数计算，效率很高。bc可以进行小数计算
   - ((b=a-15))，在括号里面可以不用加$前缀使用变量，取用结果时$b就行，如果里面没有变量需要$((1+2))。使用(())可以进行逻辑运算，大于小于，与或非之类的。可以在里面同时对多个表达式进行计算。((a=3+5,b=a+10))，如果没有赋值即((3+5,a+10)),以最后一个计算结果为结果
   - bc，echo "scale=4;3\*8/7;last\*5"|bc，通过管道输入到bc计算，scale设置小数点几位数字。
   - test命令或者写成[],test expression,或者[expression],用来检测某个条件是否成立，可以进行数值，字符串和文件三个方面的检测。[]这样写时和expression之间有空格
      - 文件类型相关 -b，判断文件是否存在，并且是否为块设备文件 -d，判断文件是否存在，并且是否为目录文件 -f，判断文件是否存在，并且是否为普通文件。-e，只判断文件
      - 文件权限判断 -r -w -x -u -g -k
      - 文件比较 -nt -ot -ef
      - 数值比较 -eq 相等 -ne 不相等 -gt 大于 -lt 小于 -ge大于等于 -le小于等于
      - 字符串判断 -z 是否为空 -n 是否非空 ==  != \> \< ,这样写防止将>认为成重定向运算符
      - 逻辑判断相关的 -a 与 -o 或 ！非
      - 当你在 test 命令中使用变量时，我强烈建议将变量用双引号""包围起来，这样能避免变量为空值时导致的很多奇葩问题
- [[]] 是shell内置关键字，用来检测某个条件是否成立，test能干的，[[]]也能干且干的更好。[[]]支持正则表达式
   - [[ ]] 对数字的比较仍然不友好，所以我建议，以后大家使用 if 判断条件时，用 (()) 来处理整型数字，用 [[ ]] 来处理字符串或者文件。
   - [[]]支持正则表达式，即支持字符串模糊匹配，而[]不支持模糊匹配。模糊匹配时，模糊匹配项不要加""，否则模糊匹配符也会当作字符处理。
- while while cindition do done
- exit  用来退出当前shell进程并返回一个退出状态，使用$?可以接受这个状态
---
[shell正则表达式分为基本的和扩展的](https://man.linuxde.net/docs/shell_regex.html)
- shell中的cd命令是有继承的，cd之后下一条命令可以直接用cd进来的目录，就不用填写绝对路径了。makefile里面的cd不行，必须得写在一行。而且shell中的变量不能和环境变量重名。
- shell调用函数时只需要写函数名就可以不用(),但是定义函数时需要写上()
- shell脚本是用来执行命令行程序的，所以在命令行能弄的脚本里面都能弄，包括可执行程序。脚本里面可以调用外面的程序来运行。

------

#### Linux常用命令

##### xargs

- Unix 命令都带有参数，有些命令可以接受"标准输入"（stdin）作为参数。

  ```shell
  cat /etc/passwd | grep root
  ```

  上面的代码使用了管道命令（`|`）。管道命令的作用，是将左侧命令（`cat /etc/passwd`）的标准输出转换为标准输入，提供给右侧命令（`grep root`）作为参数。

  因为`grep`命令可以接受标准输入作为参数，所以上面的代码等同于下面的代码。

  ```bash
  grep root /etc/passwd
  ```

  但是，大多数命令都不接受标准输入作为参数，只能直接在命令行输入参数，这导致无法用管道命令传递参数。举例来说，`echo`命令就不接受管道传参。

  ```bash
  echo "hello world" | echo   代码不会有输出。因为管道右侧的echo不接受管道传来的标准输入作为参数。
  ```

- `xargs`命令的作用，是将标准输入转为命令行参数。

  ```bash
  $ echo "hello world" | xargs echo
  hello world    代码将管道左侧的标准输入，转为命令行参数hello world，传给第二个echo命令。
  ```

  `xargs`的作用在于，大多数命令（比如`rm`、`mkdir`、`ls`）与管道一起使用时，都需要`xargs`将标准输入转为命令行参数。

  ```bash
  echo "one two three" | xargs mkdir   代码等同于mkdir one two three。如果不加xargs就会报错，提示mkdir缺少操作参数。
  ```

- xargs一些参数

  - 默认情况下，`xargs`将换行符和空格作为分隔符，把标准输入分解成一个个命令行参数。

    ```bash
    echo "one two three" | xargs mkdir   xargs将one two three分解成三个命令行参数，执行mkdir one two three
    ```

  - `-d`参数可以更改分隔符。

    ```bash
    $ echo -e "a\tb\tc" | xargs -d "\t" echo
    a b c               上面的命令指定制表符\t作为分隔符，所以a\tb\tc就转换成了三个命令行参数。echo命令的-e参数表示解释转义字符。
    ```

  - `-p`参数打印出要执行的命令，询问用户是否要执行。

##### su -

- su和su - 的区别，su不切换当前的家目录，不改变当前环境，跟最开始登录一样。相当于su 到那个用户获得那个用户对文件的权限，而su - 切换用户之后会切换到用户的家目录。其中的-号相当于更新当前的环境，相当于重新登录用户。
- 例如在root下编译内核，提示要用普通用户编译，所以su - yq切换到普通用户，但是又提示权限不够，所以su 得到root权限，但是没有完全切换到root登录。

##### sync

- [用户缓冲区和内核缓冲区]: https://www.cnblogs.com/BlueBlueSea/p/14807245.html

- sync命令是强制把内存中的数据写回硬盘，以免数据的丢失。主要还是和缓冲区有关，理解了缓冲区就理解了sync命令。缓冲区可以在c.md里面查看

- mount挂载之后直接umount文件就会出现错误，因为有一部分数据在缓冲区内没有写入到u盘中，所以在umount之前要执行sync命令。每一个文件都有缓冲区，所以在将文件cp 到/mnt中时，每一个文件都开辟了缓冲区，如果没有强制写入硬盘就会出现有一部分数据在缓冲区中没有写入硬盘中。

##### diff

- diff <变动前的文件> <变动后的文件>

- diff比较的是两个文件的差异，所以是以第一个文件为基础，第二个文件与第一个文件的差异，-表示第二个比第一个少了，+表示第二个比第一个多了。

- diff比较文件差异的时候可能是因为空格数的不同导致的，或者空行导致的，这些不应该显示出来，要不然就太多了，例如在windows上写的代码，拖到linux上，这样比较前后两个文件，所有的行都会显示出来，因为是空格数不同导致的。diff有选项-b会忽略由空格数不同导致的差异。

- diff有三种格式
  - 正常格式（normal diff）
  - 上下文格式（context diff）
  - 合并格式（unified diff）

- 创建两个文件，第一个文件叫做f1，内容是每行一个a，一共7行。第二个文件叫做f2，修改f1而成，第4行变成b，其他不变。

  - 正常格式diff f1 f2

    ```c
    4c4
    < a
    ---
    > b
        
        第一行是一个提示，用来说明变动位置。它分成三个部分：前面的"4"，表示f1的第4行有变化；中间的"c"表示变动的模式是内容改变（change），其他模式还有"增加"（a，代表addition）和"删除"（d，代表deletion）；后面的"4"，表示变动后变成f2的第4行。
        第二行分成两个部分< a,前面的小于号，表示要从f1当中去除该行（也就是第4行），后面的"a"表示该行的内容。
        第三行用来分割f1和f2。
        第四行，类似于第二行,前面的大于号表示f2增加了该行，后面的"b"表示该行的内容。
    ```

  - 上下文格式，它的使用方法是加入c参数（代表context）diff -c f1 f2

    ```shell
       *** f1 2012-08-29 16:45:41.000000000 +0800
    　　--- f2 2012-08-29 16:45:51.000000000 +0800
    　　***************
    　　*** 1,7 ****
    　　 a
    　　 a
    　　 a
    　　!a
    　　 a
    　　 a
    　　 a
    　　--- 1,7 ----
    　　 a
    　　 a
    　　 a
    　　!b
    　　 a
    　　 a
    　　 a
    　　 
    　　 第一部分的两行，显示两个文件的基本情况：文件名和时间信息。"***"表示变动前的文件，"---"表示变动后的文件。
    　　 第二部分是15个星号，将文件的基本情况与变动内容分割开。
    　　 第三部分显示变动前的文件，即f1。这时不仅显示发生变化的第4行，还显示第4行的前面三行和后面三行，因此一共显示7行。所以，前面的"*** 1,7 ****"就表示，从第1行开始连续7行。另外，文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。
    　　 第四部分显示变动后的文件，即f2。
    ```

  - 合并格式，如果两个文件相似度很高，那么上下文格式的diff，将显示大量重复的内容，很浪费空间。1990年，GNU diff率先推出了"合并格式"的diff，将f1和f2的上下文合并在一起显示。它的使用方法是加入u参数（代表unified）。diff -u f1 f2

    ```shell
       --- f1 2012-08-29 16:45:41.000000000 +0800
    　　+++ f2 2012-08-29 16:45:51.000000000 +0800
    　　@@ -1,7 +1,7 @@
    　　 a
    　　 a
    　　 a
    　　-a
    　　+b
    　　 a
    　　 a
    　　 a
    　　 
    　　 它的第一部分，也是文件的基本信息。"---"表示变动前的文件，"+++"表示变动后的文件。
    　　 第二部分，变动的位置用两个@作为起首和结束。前面的"-1,7"分成三个部分：减号表示第一个文件（即f1），"1"表示第1行，"7"表示连续7行。合在一起，就表示下面是第一个文件从第1行开始的连续7行。同样的，"+1,7"表示变动后，成为第二个文件从第1行开始的连续7行。
    　　 第三部分是变动的具体内容。
    　　 除了有变动的那些行以外，也是上下文各显示3行。它将两个文件的上下文，合并显示在一起，所以叫做"合并格式"。每一行最前面的标志位，空表示无变动，减号表示第一个文件删除的行，加号表示第二个文件新增的行。
    ```

- 版本管理系统git，使用的是合并格式diff的变体。

  ```
  	diff --git a/f1 b/f1
  　　index 6f8a38c..449b072 100644
  　　--- a/f1
  　　+++ b/f1
  　　@@ -1,7 +1,7 @@
  　　 a
  　　 a
  　　 a
  　　-a
  　　+b
  　　 a
  　　 a
  　　 a
  　　 
  　　 第一行表示结果为git格式的diff。进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。
  　　 第二行表示两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）。
  　　 第三行表示进行比较的两个文件。"---"表示变动前的版本，"+++"表示变动后的版本。
  　　 后面的行都与官方的合并格式diff相同。
  ```

- git add就是暂存区，git commit是版本库，git 只能比较本地的，远程的不能比较，即不能比较本地和远程的diff

  - 比较不同分支之间的差异

    ```
    git diff master dev
    上面的命令是以master分支为参照，比较dev分支和master分支之间的差异。注意改变分支的比较顺序，结果会不同，默认不加文件名参数，会比较出所有文件的差异。 比较指定文件的差异可以参照如下命令:
    git diff master dev -- READMD.md index.php
    ```

  - 比较工作区和版本库之间的文件差异

    ```
    Git中用一个叫HEAD的指针指向当前分支的最新一次提交，我们可以用以下命令来比较工作区和版本库之间的文件差异
    比较全部文件: git diff HEAD
    比较单个文件: git diff HEAD -- READMD.md
    比较单个文件或者某几个文件，需要加上--
    ```

  - 比较工作区和暂存区之间的文件差异

    - 使用默认的git diff，不加任何参数，默认比较的是工作区和暂存区之间的文件差异。

  - 比较暂存区和版本库之间的文件差异

    - 使用git diff --cached或者git diff --staged来比较暂存区和版本库之间的文件差异，cached和staged都有表示缓存的意思。

    
