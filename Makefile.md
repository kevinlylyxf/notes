# Makefile

## Makefile介绍

- clean 不是一个文件，它只不过是一个动作名字，有点像 C 语言中的 lable 一样，其冒号后什么也没有，那么，make 就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在 make 命令后明显得指出这个lable 的名字。这样的方法非常有用，我们可以在一个 makefile 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。
- makefile中使用变量，$(objects)，这种方式来使用变量，makefile变量理解成字符串。其中可以用空格分隔。
- 在makefile中要使用shell 命令必须加shell 例如$( shell pwd),不加的话是空值
- Makefile中-D选项指定预定义宏，这个宏会作用到源文件中，在源文件中直接使用即可。
- make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的 make 会自动识别，并自己推导命令。只要 make 看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果 make找到一个 whatever.o，那么 whatever.c，就会是 whatever.o 的依赖文件。并且 cc -c  whatever.c 也会被推导出来，于是，我们的 makefile 再也不用写得这么复杂。
- 每个 Makefile 中都应该写一个清空目标文件（.o 和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。
- .PHONY : clean   clean :      -rm edit $(objects)      .PHONY 意思表示 clean 是一个“伪目标”。而在 rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。

## Makefile总述

- Makefile 里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。
- 文件指示：其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像 C 语言中的include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译#if 一样；还有就是定义一个多行的命令。

- 在 Makefile 中的命令，必须要以[Tab]键开始。

- 在 Makefile 使用 include 关键字可以把别的 Makefile 包含进来，这很像 C 语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include 的语法是：include filename  

  filename 可以是当前操作系统 Shell 的文件模式（可以保含路径和通配符） 在 include前面可以有一些空字符，但是绝不能是[Tab]键开始。include 和<filename>可以用一个或多个空格隔开。举个例子，你有这样几个 Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了 e.mk 和 f.mk，那么，下面的语句：  

  include foo.make *.mk $(bar)
  等价于：
  include foo.make a.mk b.mk c.mk e.mk f.mk 

  -include filename的作用是无论include过程中出现什么错误，都不要报错继续执行。不管是否找到filename文件

- 环境变量MAKEFILES。如果你的当前环境中定义了环境变量 MAKEFILES，那么，make 会把这个变量中的值做一个类似于 include 的动作。这个变量中的值是其它的 Makefile，用空格分隔。只是，它和 include不同的是，从这个环境变中引入的 Makefile 的“目标”不会起作用，如果环境变量中定义的文件发现错误，make 也会不理。不推荐使用，看到奇怪的错误时可以看看这个环境变量。
- make的工作方式

1. 读入所有的 Makefile。
2. 读入被 include 的其它 Makefile。
3. 初始化文件中的变量。
4. 推导隐晦规则，并分析所有规则。
5. 为所有的目标文件创建依赖关系链。
6. 根据依赖关系，决定哪些目标要重新生成。
7. 执行生成命令。

## 书写规则

- 一般来说，make 会以 UNIX 的标准 Shell，也就是/bin/sh 来执行命令。

- make支持三个通配符，*  ？ [...]，~代表家目录，如果文件名中有通配符，可以使用\来转义。如果要让通配符在变量中展开，也就是让objects的值就是所有[.o]的文件名的集合，可以使用objects := $(wildcard *.o)，其中国wildcard是关键字。objects = *.o这样不对，这样不能展开。如果不使用变量通配符就能直接这么用。

- 文件搜寻：当 make 需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉 make，让 make 在自动去找。

  makefile中特殊变量VPATH。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。VPATH = src:../headers。目录有冒号分隔。

  makefile中关键字vpath(全是小写)。

  vpath pattern directories
  为符合模式pattern的文件指定搜索目录directories。

  vpath pattern
  清除符合模式pattern的文件的搜索目录。

  vpath
  清除所有已被设置好了的文件搜索目录。

  vapth 使用方法中的<pattern>需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。pattern指定了要搜索的文件集，而directories则指定了pattern的文件集的搜索的目录。例如：vpath %.h ../headers。该语句表示，要求 make 在“../headers”目录下搜索所有以“.h”结尾的文件。其中目录可以冒号分隔设置多个。

- 伪目标：为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。

  伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的 Makefile 需要一口气生成若干个可执行文件，但你只想简单地敲一个 make 完事，并且，所有的目标文件都写在一个 Makefile 中，那么你可以使用“伪目标”这个特性：

  all : prog1 prog2 prog3
  .PHONY : all
  prog1 : prog1.o utils.o
  cc -o prog1 prog1.o utils.o
  prog2 : prog2.o
  cc -o prog2 prog2.o
  prog3 : prog3.o sort.o utils.o
  cc -o prog3 prog3.o sort.o utils.o

  Makefile 中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。

  从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。

  .PHONY: cleanall cleanobj cleandiff
  cleanall : cleanobj cleandiff
  rm program
  cleanobj :
  rm *.o
  cleandiff :
  rm *.diff

- 多目标：Makefile 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”这个变量表示着目前规则中所有的目标的集合。
- 静态模式：静态模式可以更加容易地定义多目标的规则。书上看理解，到时候用的时候在说。
- 自动生成依赖性：.d文件，用的时候再去看

## 书写命令

- 命令前面加@表示只显示结果不显示命令本身，即那一串命令不会显示到终端。只显示那个命令的结果。
- 显示命令：通常，make 会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被 make 显示出来。如果 make 执行时，带入 make 参数“-n”或“--just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的 Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。
- 命令执行：如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是 cd 命令，你希望第二条命令得在 cd 之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。
- 命令出错：mkdir保证其一定有一个目录，如果已经有就会出错，所以在前面加一个-来保证出错也继续运行。
- 嵌套执行make
- 定义命令包：如果 Makefile 中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束。

## 使用变量

- 如果要使用$，需要用$$来表示
- 用变量定义变量：:=操作符
- 追加变量值：+=   objects = main.o foo.o bar.o utils.o  ;objects += another.o，前面的要一样，都是objects。如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符
- ?=表示如果变量前面赋过值，就跳过此赋值操作。如果没有赋值则使用此语句赋值，这种情况下和=类似。
- override指示符，表示如果不希望通过make命令行参数来设置变量，可以在变量前面写上override，其不能被覆盖。
- makefile中使用环境变量，外面export之后就可以直接用了，意思是设置了环境变量makefile就可以直接使用，makefile中跟普通变量一样使用。变量是字符串，其+= :=可以使用，但是也可以像脚本里面那样直接放在一起使用$(CC )g++，g++是后面放上去的。
- ar命令最常见的用法是将目标文件打包为静态链接库 ar -ru $@ $^ ranlib $@ ranlib更新静态库的符号索引表。
- -O0-3编译优化选项。
- -Wall显示默认的警告信息。

## 编译过程理解

- -l(L的小写)即能链接动态库也能链接静态库，直接使用库名，将.a .so lib去掉。如果链接路径下同时有.so .a那么优先链接.so

- 静态库就是一堆目标文件.o的集合，在制作静态库时将所有的源文件编译成目标文件(gcc -c)，然后使用ar命令打包成静态库。当制作一个静态库需要链接其他的静态库时，在编译时需要将所有的使用的静态库都要链接上。另一种方法是将所有的静态库制作成一个静态库，新建一个目录，在里面使用ar x命令将所有的目标文件解压出来，然后 ar cr libtc.a *.o , ranlib libtc.a，ranlib命令是更新静态库的符号表，一般是需要的。

- 编译链接就是将所有的源文件编译成目标文件然后生成ELF文件的过程，其中需要一些库包括静态库和动态库，这些库的主要作用是寻找到函数的定义。所有的这些目标文件包含链接的一些库形成的ELF文件，其只有一个main函数，是整个程序的入口处。自己写的源文件生成的目标文件都会到ELF文件里面，统一形成代码段和数据段。在执行时，到main函数入口处，需要哪个数据和函数就跳转过去，这样就可以执行了。file命令可以查看ELF文件是在哪个CPU架构下编译的，不同的CPU架构有不同的指令集，其汇编不一样，包括寻址不一样，所以要区分不同的架构。最终的ELF文件依赖于目标文件，而目标文件依赖于源文件，由源文件到目标文件可以使用隐藏的编译规则进行操作，所以目标和依赖一个是ELF一个是目标文件。源文件由隐藏规则生成目标文件不用写出来。但是由命令行编译时可以直接把每个编译成目标文件然后链接，这样比较麻烦。所以可以使用统一的编译，gcc test.c直接由源文件到ELF，直接生成也是可以的。但是要写很多然后还要链接到库。

- 1.对于 .c和.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）。2.对于 .c和.cpp文件，g++则统一当做cpp文件编译。 3.使用g++编译文件时，**g++会自动链接标准库STL，而gcc不会自动链接STL**。 4.gcc在编译C文件时，可使用的预定义宏是比较少的 5.gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏。6.在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个。

- extern :可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义。在定义处不用使用extern。在当前目录下可以修改extern进来的全局变量的值。如果函数和变量定义在头文件中，#include之后同样可以避免未声明的情况。但是#include进来的会将头文件copy到当前文件中，导致文件很大。如果只使用某一函数或变量只需要extern。但是编译链接的时候要将函数定义的源文件加上。在makefile中依赖一般写目标文件，然后make会使用隐含规则自动编译源文件成目标文件。在编译时可以使用源文件也可以使用目标文件，源文件会先转换为目标问价，然后-o生成可执行文件。例如gcc test.c -o test , gcc test.o -o test。makefile中依赖一般写成变量，变量里面是目标文件，这样删除时好删除。也可以使用隐含规则，就不用一个一个的去生成目标文件了。

- extern另外的用法：如果一个函数没有在头文件里面声明，直接写在了源文件里面定义，这样没有头文件可以引用，就会出现找不到函数的情况，编译时就会出错。但是extern就可以规避这个问题，使用了extern就可以在编译时跳过这个情况，编译就会通过。具体寻找在链接时寻找。

- static：关键字用于全局函数和变量，表示此变量或函数只能在此源文件中使用。用于局部变量时表示此变量在全局区，不会被释放。但是其作用只是在函数调用时其才起作用。

- extern “C” ：主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。比如说你用C 开发了一个DLL 库，为了能够让C ++语言也能够调用你的.so输出(Export)的函数，你需要用extern "C"来强制编译器不要修改你的函数名。每一个源文件都是先编译生成目标文件，目标文件里面有符号表，当写了一个cpp文件，然后里面调用c的函数时，编译器就会为此函数创建一个符号表然后在库里面去找，如果在函数前面不加extern "C"，编译器就会创建cpp的符号表，这样在库里面就找不到相同的符号，就会产生未定义的情况。extern “C”适用编译和链接的情况。前面是链接的情况。在编译时用上是告诉编译器在编译时生成c的符号，这样其他的c源文件就可以直接调用函数了。调用函数其实就是找符号的过程。

  - 在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。

    ```c++
    #ifdef _cplusplus
    extern "C" {
    #endif
    #include "XXX.h"
    #ifdef _cplusplus
    }
    #endif
    ```

    已经写好的c语言函数库，在c++里面被调用时，在写c++的头文件时要写成这样，因为引进来的头文件要告诉编译器编译成c的，这样在使用头文件里声明的函数时就直接是c符号的，否则编译出来的是c++的，这样在最后的链接阶段，c动态库里面是c的符号，而c++里面是c++符号，这样就不能链接，实现不了c++调用c的函数。在编译器进行编译时，每一个源文件都要编译成目标文件(.o)，每一个源文件都是单独编译的，最后将所有的源文件和动态库进行链接，在源文件单独编译时，需要用到的一些函数需要#include进来，或者通过extern 引进来，这样在编译时才不会报错，因为在源文件中使用函数时要在源文件中找到函数的声明，#include和extern进来的都是函数的声明，函数的定义在链接时才用到。所以在c++的头文件里面写成上面那样，在c++源文件里面#include 上面c++的头文件。这样#include进来的c头文件里面声明的函数就会按照c进行编译，(头文件是没有c和c++之分的，都是.h，只有源文件有c和c++之分，上面说的只是一种区分在c++工程中还是c工程中，只要是在头文件中声明extern “C”，然后在c++源文件中#include进来就可以了)，如果没有extern “C”，直接就#include进来，这样c头文件里面声明的一些函数就会按照c++的进行编译，生成c++的符号表，这样链接的时候就会出错。extern “C”包围起来的都是c的符号，不管是声明还是定义。跟extern一样也可以只声明一个函数时extern "C"的，例如extern "C" int add(int a, int b) ，这样就不用将整个头文件里面的函数都引进来了。

  - 有时候我们用c++写的代码，编译成动态库暴露出接口来让c代码调用。这时在c++源文件中定义函数时直接使用extern “C”{}将函数的定义包围起来，这样在编译时函数就编译成为了c符号的，这样c代码调用时直接将头文件#include进来，在链接时直接将库连接上就可以了。应该是在c++头文件中在函数声明时extern “C”包围起来，定义时不用，这样也可以编译为c的符号。
  
- 在将源文件编译成目标文件中我们只需要找到我们需要的函数声明就可以了，如果函数里面有嵌套我们不用管，那是链接的时候的事，源文件到目标文件要编译过就需要找到函数的声明，而最后执行需要链接，所以在Makefile中要写上嵌套的源文件的名称，这样就能完整的执行。例如我们需要用到函数a，但是a里面用到了函数b，但是我们在编译的时候只需要有a的声明就可以，b的不用管，我们只是先让源文件编译成目标文件，最后的链接需要写上完整的定义的源文件即在Makefile中。

## 编译选项

- ld是链接目标文件和动态库成为ELF的工具。但是加载动态库是使用动态链接器ld.so

- 编译时引用头文件区别""<>，<>是系统的头文件，编译器编译时直接到系统指定目录去查找头文件，默认路径为/usr/include，/usr/local/include。""会先到当前目录查找头文件，如果没找到在到系统指定目录查找。当前文件的意思是就是当前源文件所在的目录，不是上一级目录。例如tc_system.cpp的当前目录就是指和其在一起的头文件。如果头文件在上一级目录，例如XShellExecute.h，所以写成../common/XShellExecute.h,写成这样就会直接找到，直接写XShellExecute.h是找不到的，因为没有在当前目录，写成../common/XShellExecute.h意味着../common是他的当前目录。如果不用""，可以写成<XShellExecute.h>，然后使用-I(大写)来设置额外的头文件搜索路径。-I../common。只写到包含的最近一级目录。这样就能找到这个头文件，注意使用-I时只写头文件名称，两种方法都能引用头文件成功。-L表示库文件路径，-l表示库名（去掉lib和.so之后剩下的名称）

- 交叉编译就是使用其他的gcc或者g++代替当前的gcc或者g++来编译目标cpu架构的代码。所以要下载人家开发的编译套件，然后将gcc的程序目录添加到PATH环境变量里面，这样做是为了查找到gcc的程序来编译。然后使用export来添加环境变量，在makefile中使用环境变量中的值来编译。环境变量中的值就是交叉编译中程序的名称。环境变量就是为了找到那个交叉编译gcc程序。

- 变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录（HOME）、邮件存放位置（MAIL）等。环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。好多程序都会用到环境变量。有的程序用到的环境变量名称是固定的，我们只需要在外面设置好环境变量，程序就会按照设置好的环境变量来读取变量。然后根据变量的作用来实现相应的功能。例如SHELL，当执行脚本时就会使用SHELL环境变量的值/bin/bash来运行解释脚本。我们可以改变这个值使用别的shell来工作。例如可以设置MAIL环境变量来设置邮件的存储路径，当我们需要的时候直接就能找到路径，然后进入，这样程序就会很简单寻找到存放目录。makefile中会使用很多预定义环境变量CFLAGS，CXX等，我们可以按照我们设想的来设置环境变量，然后程序就按照我们的设想来工作。这也提供了一种交互。export的作用是设置全局环境变量。我们使用export来设置我们自己的环境变量，在makefile中就可以使用$()来调用这个变量。环境变量就是一种变量，但是有的程序用的环境变量是写死的，其调用固定的变量名称。例如LD_LIBRARY_PATH，这个环境变量就是写死的，我们可以定义这个值来添加动态库路径。但是有的程序里面可以自己使用变量，其不是写死的，例如makefile我们就可以自己调用变量，这个环境变量不是写死的，所以我们可以使用所有的环境变量，但是原有的环境变量我们一般不修改，因为会影响到其他的程序云运行。在使用交叉编译时，我们source脚本之后，就可以刷新当前的环境变量。但是这样是临时的，关机之后就会没有，因为其是在shell中直接export的，要是永久生效就需要写到配置文件中。环境变量就当成普通变量来使用就可以了。

  | 命令变量 | 含义                              |
  | -------- | --------------------------------- |
  | AR       | 函数库的打包程序，默认为"ar"      |
  | AS       | 汇编语言编译程序,默认为"as"       |
  | CC       | C语言编译程序,默认命令是"cc"      |
  | CXX      | C++语言编译程序,默认命令是"g++"   |
  | RM       | 文件删除程序的名称,默认值为 rm –f |
  | ARFLAGS  | 库文件维护程序的选项,无默认值     |
  | ASFLAGS  | 汇编程序的选项,无默认值           |
  | CFLAGS   | C 编译器的选项,无默认值           |
  | CPPFLAGS | C 预编译的选项,无默认值           |
  | CXXFLAGS | C++编译器的选项,无默认值          |

- 上面这些就是编译器预定义变量，其和环境变量一样，都是一种变量。当成变量来使用就可以了。但是这些在env环境变量里面是不显示的，只是在程序里面有用。这些变量我们可以覆盖。例如自己定义CXX来指定自己的编译器版本的名称，然后使用。这个环境变量只是一种名称的替代，真正的查找gcc程序还是需要PATH环境变量。变量本身就是为了方便，如果不用变量，书写就会很麻烦。

## 静态库和动态库的理解

- 静态库就是一堆目标文件的集合，当出现同名的目标文件.o的时候就会一个干掉另一个，不管里面的函数定义如何
- 动态库是标记，只会记录函数的地址，其余的不会，所以在动态库中如果两个目标文件函数功能一样，只是一个文件里面函数少一个，两个目标文件最后生成动态库，其中的函数名称相同的函数地址最后会一样，所以不会造成重定义，也不会有静态库那种一个干掉另一个那种感觉。
