### Makefile

##### 一些理解

- 一个c程序用了a动态库，a动态库又用了b动态库，在编译的时候需要用b动态库吗

  - 当一个C程序依赖于动态库A，而动态库A又依赖于动态库B时，在编译时需要确保链接到所有必要的动态库。因此，你在编译程序时需要同时指定动态库A和动态库B。

    ```
    gcc -o your_program your_program.c -lA -lB
    ```

  - 这里，`-lA` 表示链接动态库A，而 `-lB` 表示链接动态库B。确保动态库B 在编译时是可用的，否则编译器将无法找到相关的符号而产生错误。

  - 请注意，编译器会在系统默认的库路径中查找动态库，如果动态库B不在默认路径中，你可能需要使用 `-L` 选项指定动态库B的路径。

  - 为什么也需要A也需要B，因为在编译链接的时候要找到完整的符号路径(默认路径下的会自己加进去，所以不需要写明)，跟程序实际执行的时候A直接跳转到B不一样。编译的时候就是找符号表的过程，所以要找到完整的符号表，执行的时候是一个地址偏移的过程，只要符号表完整，地址偏移的时候就能加载到动态库，也能偏移到指定的地址。

- gcc默认路径下的动态库，在编译时需要写明吗

  - 通常情况下，GCC会在默认的动态库搜索路径中查找动态库，而你在编译时不需要明确指定这些库的路径。默认的动态库搜索路径包括系统的标准库路径，如 `/lib`、`/usr/lib`、`/lib64`、`/usr/lib64` 等。

  - 如果你使用了标准的库，并且这些库在默认的路径中，你无需显式指定它们，编译器会自动找到它们。例如：

    ```
    gcc -o your_program your_program.c -lm
    ```

  - 上述命令中，`-lm` 表示链接数学库（libm），而编译器会在默认的库路径中找到并链接这个库。

  - 然而，如果你使用的是非标准的库，或者库不在默认路径中，你可能需要使用 `-L` 选项指定库的路径，以及 `-l` 选项来指定库的名称

- gcc编译的默认路径(动态库路径)

  - GCC编译器在默认情况下会在一些标准的系统库路径中查找动态库。这些路径通常包括：

    ```
    /lib
    /usr/lib
    /lib64
    /usr/lib64
    ```

  - 要查看系统上的默认库搜索路径，你可以使用以下命令：

    ```
    gcc -print-search-dirs
    ```

- gcc编译默认的头文件路径

  - GCC编译器默认情况下会在一些标准的系统头文件路径中查找头文件。这些路径通常包括：

    ```
    /usr/include
    /usr/local/include
    /usr/include/{target}
    	{target} 在这里表示目标系统的体系结构，例如 x86_64-linux-gnu	
    ```

  - 这是一般情况下的默认路径，具体的默认路径可能因操作系统而异。如果你的头文件不在这些默认路径中，你可能需要使用 `-I` 选项来指定头文件所在的路径。

##### Makefile介绍

- clean 不是一个文件，它只不过是一个动作名字，有点像 C 语言中的 lable 一样，其冒号后什么也没有，那么，make 就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在 make 命令后明显得指出这个lable 的名字。这样的方法非常有用，我们可以在一个 makefile 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。

  - 看一下下面的伪目标，如果类似于clean这种冒号后什么也没有，如果是第一个目标，即使没有依赖，也会去执行后面的命令，这种冒号后面什么也没有的如果是其他目标的依赖时(冒号前面的是其他目标的依赖)，也会执行后面的命令。
  - 如果不是第一个目标(冒号后面什么也没有的这种目标)，我们可以在命令行中 make + label来执行后面的命令，这样执行，即使目标没有依赖，也可以执行后面的命令。

- makefile中使用变量，$(objects)，这种方式来使用变量，makefile变量理解成字符串。其中可以用空格分隔。

- 在makefile中要使用shell 命令必须加shell 例如$( shell pwd),不加的话是空值
  - 这样做是要将shell中的命令输出结果赋值给一个变量，然后在用那个变量
  - 如果不用输出结果传给一个变量，直接使用就行了，例如删除文件，直接rm就可以了

- Makefile中-D选项指定预定义宏，这个宏会作用到源文件中，在源文件中直接使用即可。

- make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的 make 会自动识别，并自己推导命令。只要 make 看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果 make找到一个 whatever.o，那么 whatever.c，就会是 whatever.o 的依赖文件。并且 cc -c  whatever.c 也会被推导出来，于是，我们的 makefile 再也不用写得这么复杂。

- 每个 Makefile 中都应该写一个清空目标文件（.o 和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。

- 伪目标

  ```
  .PHONY : clean   
  clean :      
  	-rm edit $(objects) 
  ```

  -  .PHONY 意思表示 clean 是一个“伪目标”。而在 rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。

##### Makefile总述

- Makefile 里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。
- 文件指示：其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像 C 语言中的include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译#if 一样；还有就是定义一个多行的命令。

- 在 Makefile 中的命令，必须要以[Tab]键开始。

- 在 Makefile 使用 include 关键字可以把别的 Makefile 包含进来，这很像 C 语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include 的语法是：`include filename`  

  - filename 可以是当前操作系统 Shell 的文件模式（可以包含路径和通配符） 在 include前面可以有一些空字符，但是绝不能是[Tab]键开始。include 和<filename>可以用一个或多个空格隔开。举个例子，你有这样几个 Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了 e.mk 和 f.mk，那么，下面的语句：  

    ```
    include foo.make *.mk $(bar)
    等价于：
    include foo.make a.mk b.mk c.mk e.mk f.mk 
    
    -include filename的作用是无论include过程中出现什么错误，都不要报错继续执行。不管是否找到filename文件
    ```

- 环境变量MAKEFILES。如果你的当前环境中定义了环境变量 MAKEFILES，那么，make 会把这个变量中的值做一个类似于 include 的动作。这个变量中的值是其它的 Makefile，用空格分隔。只是，它和 include不同的是，从这个环境变中引入的 Makefile 的“目标”不会起作用，如果环境变量中定义的文件发现错误，make 也会不理。不推荐使用，看到奇怪的错误时可以看看这个环境变量。
- make的工作方式

  ```
  1. 读入所有的 Makefile。
  2. 读入被 include 的其它 Makefile。
  3. 初始化文件中的变量。
  4. 推导隐晦规则，并分析所有规则。
  5. 为所有的目标文件创建依赖关系链。
  6. 根据依赖关系，决定哪些目标要重新生成。
  7. 执行生成命令。
  ```

##### 书写规则

- 一般来说，make 会以 UNIX 的标准 Shell，也就是/bin/sh 来执行命令。

- make支持三个通配符，*  ？ [...]，~代表家目录，如果文件名中有通配符，可以使用\来转义。如果要让通配符在变量中展开，也就是让objects的值就是所有[.o]的文件名的集合，可以使用objects := $(wildcard *.o)，其中wildcard是关键字。objects = *.o这样不对，这样不能展开。如果不使用变量通配符就能直接这么用。
  - 不使用通配符可以直接这样用说的是不使用通配符可以直接用=赋值， `objects=a.o b.o c.o`


- 文件搜寻：当 make 需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉 make，让 make 在自动去找。

  makefile中特殊变量VPATH。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。

  ```
  VPATH = src:../headers。目录有冒号分隔。
  
  makefile中关键字vpath(全是小写)。
  
  vpath pattern directories
  为符合模式pattern的文件指定搜索目录directories。
  
  vpath pattern
  清除符合模式pattern的文件的搜索目录。
  
  vpath
  清除所有已被设置好了的文件搜索目录。
  ```

  - vapth 使用方法中的<pattern>需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。pattern指定了要搜索的文件集，而directories则指定了pattern的文件集的搜索的目录。例如：vpath %.h ../headers。该语句表示，要求 make 在“../headers”目录下搜索所有以“.h”结尾的文件。其中目录可以冒号分隔设置多个。

- 伪目标：为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。

  - 伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的 Makefile 需要一口气生成若干个可执行文件，但你只想简单地敲一个 make 完事，并且，所有的目标文件都写在一个 Makefile 中，那么你可以使用“伪目标”这个特性：

    ```
    all : prog1 prog2 prog3
    .PHONY : all
    prog1 : prog1.o utils.o
    cc -o prog1 prog1.o utils.o
    prog2 : prog2.o
    cc -o prog2 prog2.o
    prog3 : prog3.o sort.o utils.o
    cc -o prog3 prog3.o sort.o utils.o
    ```

  - Makefile 中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。
  
  - 声明all为伪目标的语句放在all前面也可以，放在all后面也可以，all为第一个目标，其实不声明也可以，但是一般如果这样写的话，都将声明all为伪目标的语句放在后面，即像上面那样写，而且all必须为第一个目标。如果不是第一个目标，基本都在前面先声明目标为伪目标。这只是约定写法，其实后面的不是第一个目标，声明为伪目标也可以写在目标语句后面。
  
    ```
    .PHONY : all
    all : prog1 prog2 prog3
    prog1 : prog1.o utils.o
    cc -o prog1 prog1.o utils.o
    prog2 : prog2.o
    cc -o prog2 prog2.o
    prog3 : prog3.o sort.o utils.o
    cc -o prog3 prog3.o sort.o utils.o
    ```
  
  
    - 综上所述，声明目标为伪目标，写在文件中任何一个地方都可以，极端情况，都写在文件末尾，相对应的也可以用做伪目标。只是上面的写法为约定写法。
  


  - 从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。

    ```
    .PHONY: cleanall cleanobj cleandiff
    cleanall : cleanobj cleandiff
    	rm program
    cleanobj :
    	rm *.o
    cleandiff :
    	rm *.diff
    ```

- 多目标：Makefile 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”这个变量表示着目前规则中所有的目标的集合。
- 静态模式：静态模式可以更加容易地定义多目标的规则。书上看理解，到时候用的时候在说。
- 自动生成依赖性：.d文件，用的时候再去看
- makefile中$(MAKE)使用：


  - make 定义了很多默认变量，${MAKE} 就是预设的 make 这个命令的名称（或者路径）

  - make -p 可以查看所有预定义的变量的当前值，从中可以看到MAKE


    - 例如可以查看预定义的CXX和CC的值

      ```
      make -p | grep CXX
      LINK.cc = $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)
      COMPILE.cc = $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
      CXX = c++
      可以看到CXX用的是c++程序
      
      make -p | grep cc
      CC = cc
      LINK.S = $(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)
      LINK.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)
      LINK.s = $(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)
      COMPILE.S = $(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c
      COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
      ```

    - 通过上面也可以看到make -p可以查看预定义的隐含规则



##### 书写命令

- 命令前面加@表示只显示结果不显示命令本身，即那一串命令不会显示到终端。只显示那个命令的结果。
- 显示命令：通常，make 会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被 make 显示出来。如果 make 执行时，带入 make 参数“-n”或“--just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的 Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。
- 命令执行：如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是 cd 命令，你希望第二条命令得在 cd 之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。
- 命令出错：mkdir保证其一定有一个目录，如果已经有就会出错，所以在前面加一个-来保证出错也继续运行。
- 嵌套执行make
- 定义命令包：如果 Makefile 中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束。

##### 使用变量

- 如果要使用$，需要用$$来表示
- 简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。
- 递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。
- 追加变量值：+=   objects = main.o foo.o bar.o utils.o  ;objects += another.o，前面的要一样，都是objects。如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符
- ?=表示如果变量前面赋过值，就跳过此赋值操作。如果没有赋值则使用此语句赋值，这种情况下和=类似。
- override指示符，表示如果不希望通过make命令行参数来设置变量，可以在变量前面写上override，其不能被覆盖。
- makefile中使用环境变量，外面export之后就可以直接用了，意思是设置了环境变量makefile就可以直接使用，makefile中跟普通变量一样使用。变量是字符串，其+= :=可以使用，但是也可以像脚本里面那样直接放在一起使用$(CC )g++，g++是后面放上去的。
- ar命令最常见的用法是将目标文件打包为静态链接库 ar -ru $@ $^ ranlib $@ ranlib更新静态库的符号索引表。
- -O0-3编译优化选项。
- -Wall显示默认的警告信息。

##### 编译过程理解

- -l(L的小写)即能链接动态库也能链接静态库，直接使用库名，将.a .so lib去掉。如果链接路径下同时有.so .a那么优先链接.so

- 静态库就是一堆目标文件.o的集合，在制作静态库时将所有的源文件编译成目标文件(gcc -c)，然后使用ar命令打包成静态库。当制作一个静态库需要链接其他的静态库时，在编译时需要将所有的使用的静态库都要链接上。另一种方法是将所有的静态库制作成一个静态库，新建一个目录，在里面使用ar x命令将所有的目标文件解压出来，然后 ar cr libtc.a *.o , ranlib libtc.a，ranlib命令是更新静态库的符号表，一般是需要的。

- 编译链接就是将所有的源文件编译成目标文件然后生成ELF文件的过程，其中需要一些库包括静态库和动态库，这些库的主要作用是寻找到函数的定义。所有的这些目标文件包含链接的一些库形成的ELF文件，其只有一个main函数，是整个程序的入口处。自己写的源文件生成的目标文件都会到ELF文件里面，统一形成代码段和数据段。在执行时，到main函数入口处，需要哪个数据和函数就跳转过去，这样就可以执行了。file命令可以查看ELF文件是在哪个CPU架构下编译的，不同的CPU架构有不同的指令集，其汇编不一样，包括寻址不一样，所以要区分不同的架构。最终的ELF文件依赖于目标文件，而目标文件依赖于源文件，由源文件到目标文件可以使用隐藏的编译规则进行操作，所以目标和依赖一个是ELF一个是目标文件。源文件由隐藏规则生成目标文件不用写出来。但是由命令行编译时可以直接把每个编译成目标文件然后链接，这样比较麻烦。所以可以使用统一的编译，gcc test.c直接由源文件到ELF，直接生成也是可以的。但是要写很多然后还要链接到库。

- `-c`选项是`gcc`的一个编译选项，它的作用是告诉编译器只进行编译而不进行链接，生成目标文件而不是可执行文件。具体而言，使用`-c`选项时，`gcc`将会执行以下步骤：

  - 预处理（Preprocessing）：处理源文件中的预处理指令，如`#include`和`#define`。
  - 编译（Compilation）：将预处理后的源文件翻译成汇编语言。
  - 汇编（Assembling）：将汇编代码翻译成机器代码，并生成目标文件（通常是以`.o`或`.obj`为扩展名的文件）。
  - 但是，`-c`选项并不包括链接（Linking）步骤。链接步骤会将多个目标文件或库文件组合在一起，生成最终的可执行文件。因此，如果只想生成目标文件而不需要生成可执行文件，可以使用`-c`选项，这在大型项目中的编译过程中很常见，特别是当源代码被修改，但只有部分文件需要重新编译时。

- 1.对于 .c和.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）。2.对于 .c和.cpp文件，g++则统一当做cpp文件编译。 3.使用g++编译文件时，**g++会自动链接标准库STL，而gcc不会自动链接STL**。 4.gcc在编译C文件时，可使用的预定义宏是比较少的 5.gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏。6.在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个。

- extern :可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义。在定义处不用使用extern。在当前目录下可以修改extern进来的全局变量的值。如果函数和变量定义在头文件中，#include之后同样可以避免未声明的情况。但是#include进来的会将头文件copy到当前文件中，导致文件很大。如果只使用某一函数或变量只需要extern。但是编译链接的时候要将函数定义的源文件加上。在makefile中依赖一般写目标文件，然后make会使用隐含规则自动编译源文件成目标文件。在编译时可以使用源文件也可以使用目标文件，源文件会先转换为目标文件，然后-o生成可执行文件。例如gcc test.c -o test , gcc test.o -o test。makefile中依赖一般写成变量，变量里面是目标文件，这样删除时好删除。也可以使用隐含规则，就不用一个一个的去生成目标文件了。

- extern另外的用法：如果一个函数没有在头文件里面声明，直接写在了源文件里面定义，这样没有头文件可以引用，就会出现找不到函数的情况，编译时就会出错。但是extern就可以规避这个问题，使用了extern就可以在编译时跳过这个情况，编译就会通过。具体寻找在链接时寻找。

- static：关键字用于全局函数和变量，表示此变量或函数只能在此源文件中使用。用于局部变量时表示此变量在全局区，不会被释放。但是其作用只是在函数调用时其才起作用。

- extern “C” ：主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。比如说你用C 开发了一个DLL 库，为了能够让C ++语言也能够调用你的.so输出的函数，在写c++源文件时你需要用extern "C"来强制编译器引入的c函数，按照c的符号表来生成，不要把c的函数生成c++的符号表。如果c头文件中已经用extern "C"定义好了，这样就不用在c++源文件中写了，见下面。每一个源文件都是先编译生成目标文件，目标文件里面有符号表，当写了一个cpp文件，然后里面调用c的函数时，编译器就会为此函数创建一个符号表然后在库里面去找，如果在函数前面不加extern "C"，编译器就会创建cpp的符号表，这样在库里面就找不到相同的符号，就会产生未定义的情况。extern “C”适用编译和链接的情况。前面是链接的情况。在编译时用上是告诉编译器在编译时生成c的符号，这样其他的c源文件就可以直接调用函数了。调用函数其实就是找符号的过程。

  - 在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。

    ```c++
    #ifdef _cplusplus
    extern "C" {
    #endif
    #include "XXX.h"
    #ifdef _cplusplus
    }
    #endif
    ```

  - 已经写好的c语言函数库，在c++里面被调用时，在写c++的头文件时要写成这样，因为引进来的头文件要告诉编译器编译成c的，这样在使用头文件里声明的函数时就直接是c符号的，否则编译出来的是c++的，这样在最后的链接阶段，c动态库里面是c的符号，而c++里面是c++符号，这样就不能链接，实现不了c++调用c的函数。在编译器进行编译时，每一个源文件都要编译成目标文件(.o)，每一个源文件都是单独编译的，最后将所有的源文件和动态库进行链接，在源文件单独编译时，需要用到的一些函数需要#include进来，或者通过extern 引进来，这样在编译时才不会报错，因为在源文件中使用函数时要在源文件中找到函数的声明，#include和extern进来的都是函数的声明，函数的定义在链接时才用到。所以在c++的头文件里面写成上面那样，在c++源文件里面#include 上面c++的头文件。这样#include进来的c头文件里面声明的函数就会按照c进行编译，(头文件是没有c和c++之分的，都是.h，只有源文件有c和c++之分，上面说的只是一种区分在c++工程中还是c工程中，只要是在头文件中声明extern “C”，然后在c++源文件中#include进来就可以了)，如果没有extern “C”，直接就#include进来，这样c头文件里面声明的一些函数就会按照c++的进行编译，生成c++的符号表，这样链接的时候就会出错。extern “C”包围起来的都是c的符号，不管是声明还是定义。跟extern一样也可以只声明一个函数时extern "C"的，例如extern "C" int add(int a, int b) ，这样就不用将整个头文件里面的函数都引进来了。

  - 系统提供的头文件一般都有下面两种定义
  
    ```
    /usr/include/sys/cdefs.h中有如下定义
    
    /* C++ needs to know that types and declarations are C, not C++.  */                                                    
    #ifdef __cplusplus                                                                             
    # define __BEGIN_DECLS extern "C" {                                                                                    
    # define __END_DECLS   }                                                                                        
    #else                                                                                           
    # define __BEGIN_DECLS                                                                   
    # define __END_DECLS                                                                               
    #endif   
    
    注意stdio.h并没有直接include cdefs.h头文件，但是我们可以看到stdio.h引用的其他的头文件中间接的引用了cdefs.h，这样也可以。因为头文件会全部展开的，包括头文件里面引用的头文件。
    ```
  
  - 所以在标准的头文件中，基本都有`__BEGIN_DECLS和__END_DECLS`，代表混合编程。标准库是用c写的，所以可以用这个。但是我们写的c++程序调用其他的c函数时，如果其他的文件有表示extern "C"的时候，例如上面或者上上面的那种指示，就不用在写extern "C"了，如果我们引用的函数头文件没有写，这时候我们在c++程序里面引用头文件的时候就要自己写上。
  
  - 基本上头文件都要写上。我们自己写的程序头文件如果想要让c程序调用也想让c++调用，都要写上这个。如果不用c程序调用，就不用写了。
  
  - 只需要将函数声明用extern ''C"包围起来就可以。这样就会知道这个函数是c的。所以只需要将头文件用extern C包围起来就可以，如果引用的头文件已经写了extern C，这时候我们就不用写了，因为include会将文件原封不动的放到当前文件下。如果引用的文件没有用extern C包围起来，这时候我们就要自己在c++程序头文件用extern C包一下。
  
  - 为什么要这样写，原因为，如果是c++程序，这时候宏`__cplusplus`被定义了，所以被extern "C"包围的函数声明就都是c程序的，c++程序在编译的时候用到的c函数就会按照c程序来编译，这时候链接的时候符号表就能对应上。如果不写extern "C"的时候，c++就会将所有的函数都当成是c++的，但是我们链接的库是c的，所以符号表对应不上，这时候就会错误。如果是c程序，因为extern "C"是c++程序特有的，这时候就不应该有extern "C"，如果有的话就会报错，所以c程序没有宏`__cplusplus`，这时候就没有extern "C"语句了，这样就是纯c的程序了。
  
- 在将源文件编译成目标文件中我们只需要找到我们需要的函数声明就可以了，如果函数里面有嵌套我们不用管，那是链接的时候的事，源文件到目标文件要编译过就需要找到函数的声明，而最后执行需要链接，所以在Makefile中要写上嵌套的源文件的名称，这样就能完整的执行。例如我们需要用到函数a，但是a里面用到了函数b，但是我们在编译的时候只需要有a的声明就可以，b的不用管，我们只是先让源文件编译成目标文件，最后的链接需要写上完整的定义的源文件在Makefile中。

##### 编译选项

- ld是链接目标文件和动态库成为ELF的工具。但是加载动态库时使用动态链接器ld.so

- 编译时引用头文件区别""<>，<>是系统的头文件，编译器编译时直接到系统指定目录去查找头文件，默认路径为/usr/include，/usr/local/include。""会先到当前目录查找头文件，如果没找到在到系统指定目录查找。当前文件的意思是就是当前源文件所在的目录，不是上一级目录。例如tc_system.cpp的当前目录就是指和其在一起的头文件。如果头文件在上一级目录，例如XShellExecute.h，所以写成../common/XShellExecute.h,写成这样就会直接找到，直接写XShellExecute.h是找不到的，因为没有在当前目录，写成../common/XShellExecute.h意味着../common是他的当前目录。如果不用""，可以写成<XShellExecute.h>，然后使用-I(大写)来设置额外的头文件搜索路径。-I../common。只写到包含的最近一级目录。这样就能找到这个头文件，注意使用-I时只写头文件名称，两种方法都能引用头文件成功。-L表示库文件路径，-l表示库名（去掉lib和.so之后剩下的名称）

- 交叉编译就是使用其他的gcc或者g++代替当前的gcc或者g++来编译目标cpu架构的代码。所以要下载人家开发的编译套件，然后将gcc的程序目录添加到PATH环境变量里面，这样做是为了查找到gcc的程序来编译。然后使用export来添加环境变量，在makefile中使用环境变量中的值来编译。环境变量中的值就是交叉编译中程序的名称。环境变量就是为了找到那个交叉编译gcc程序。

- 变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录（HOME）、邮件存放位置（MAIL）等。环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。好多程序都会用到环境变量。有的程序用到的环境变量名称是固定的，我们只需要在外面设置好环境变量，程序就会按照设置好的环境变量来读取变量。然后根据变量的作用来实现相应的功能。例如SHELL，当执行脚本时就会使用SHELL环境变量的值/bin/bash来运行解释脚本。我们可以改变这个值使用别的shell来工作。例如可以设置MAIL环境变量来设置邮件的存储路径，当我们需要的时候直接就能找到路径，然后进入，这样程序就会很简单寻找到存放目录。makefile中会使用很多预定义环境变量CFLAGS，CXX等，我们可以按照我们设想的来设置环境变量，然后程序就按照我们的设想来工作。这也提供了一种交互。export的作用是设置全局环境变量。我们使用export来设置我们自己的环境变量，在makefile中就可以使用$()来调用这个变量。环境变量就是一种变量，但是有的程序用的环境变量是写死的，其调用固定的变量名称。例如LD_LIBRARY_PATH，这个环境变量就是写死的，我们可以定义这个值来添加动态库路径。但是有的程序里面可以自己使用变量，其不是写死的，例如makefile我们就可以自己调用变量，这个环境变量不是写死的，所以我们可以使用所有的环境变量，但是原有的环境变量我们一般不修改，因为会影响到其他的程序运行。在使用交叉编译时，我们source脚本之后，就可以刷新当前的环境变量。但是这样是临时的，关机之后就会没有，因为其是在shell中直接export的，要是永久生效就需要写到配置文件中。环境变量就当成普通变量来使用就可以了。

  | 命令变量 | 含义                              |
  | -------- | --------------------------------- |
  | AR       | 函数库的打包程序，默认为"ar"      |
  | AS       | 汇编语言编译程序,默认为"as"       |
  | CC       | C语言编译程序,默认命令是"cc"      |
  | CXX      | C++语言编译程序,默认命令是"g++"   |
  | RM       | 文件删除程序的名称,默认值为 rm –f |
  | ARFLAGS  | 库文件维护程序的选项,无默认值     |
  | ASFLAGS  | 汇编程序的选项,无默认值           |
  | CFLAGS   | C 编译器的选项,无默认值           |
  | CPPFLAGS | C 预编译的选项,无默认值           |
  | CXXFLAGS | C++编译器的选项,无默认值          |

- 上面这些就是编译器预定义变量，其和环境变量一样，都是一种变量。当成变量来使用就可以了。但是这些在env环境变量里面是不显示的，只是在程序里面有用。这些变量我们可以覆盖。例如自己定义CXX来指定自己的编译器版本的名称，然后使用。这个环境变量只是一种名称的替代，真正的查找gcc程序还是需要PATH环境变量。变量本身就是为了方便，如果不用变量，书写就会很麻烦。

##### 静态库和动态库的理解

- 静态库就是一堆目标文件的集合，当出现同名的目标文件.o的时候就会一个干掉另一个，不管里面的函数定义如何
- 动态库是标记，只会记录函数的地址，其余的不会，所以在动态库中如果两个目标文件函数功能一样，只是一个文件里面函数少一个，两个目标文件最后生成动态库，其中的函数名称相同的函数地址最后会一样，所以不会造成重定义，也不会有静态库那种一个干掉另一个那种感觉。

### C语言中文网

##### 包含规则

- 想要书写一个完整的 Makefile文件，需要了解 Makefile 的相关的书写规则。我们已经知道了 Makefile 描述的是文件编译的相关规则，它的规则主要是两个部分组成，分别是依赖的关系和执行的命令，其结构如下所示：

  ```
  targets : prerequisites
    command
  ```

  - 或者是

  ```
  targets : prerequisites; command
    command
  ```

  - 相关说明如下：
    - targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；
    - prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；
    - command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。

- 注意：我们的目标和依赖文件之间要使用冒号分隔开，命令的开始一定要使用`Tab`键。

- 简单的概括一下Makefile 中的内容，它主要包含有五个部分，分别是：

  - 显式规则
    - 显式规则说明了，如何生成一个或多的的目标文件。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。
  - 隐晦规则
    - 由于我们的 make 命名有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile，这是由 make 命令所支持的。
  - 变量的定义
    - 在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。
  - 文件指示
    - 其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像C语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像C语言中的预编译 #if 一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。
  - 注释
    - Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用“#”字符，这个就像 C/[C++](http://c.biancheng.net/cplus/) 中的“//”一样。如果你要在你的 Makefile 中使用“#”字符，可以用反斜框进行转义，如：“`\#`”。

##### 工作流程

- Makefile 的具体工作流程可以通过例子来看一下：创建一个包含有多个源文件和 Makefile 的目录文件，源文件之间相互关联。在 Makefile 中添加下面的代码：

  ```shell
  main:main.o test1.o test2.o
  	gcc main.o test1.o test2.o -o main
  main.o:main.c test.h
  	gcc -c main.c -o main.o
  test1.o:test1.c test.h
  	gcc -c test1.c -o test1.o
  test2.o:test2.c test.h
  	gcc -c test2.c -o test2.o
  ```

  - 在我们编译项目文件的时候，默认情况下，make 执行的是 Makefile 中的第一规则（Makefile 中出现的第一个依赖关系），此规则的第一目标称之为“最终目标”或者是“终极目标”。
  - 在 shell 命令行执行的 make 命令，就可以得到可执行文件 main 和中间文件 main.o、test1.o 和 test2.o，main 就是我们要生成的最终文件。通过 Makefile 我们可以发现，目标 main"在 Makefile 中是第一个目标，因此它就是 make 的终极目标，当修改过任何 C 文件后，执行 make 将会重建终极目标 main。
  - 它的具体工作顺序是：当在 shell 提示符下输入 make 命令以后。 make 读取当前目录下的 Makefile 文件，并将 Makefile 文件中的第一个目标作为其执行的“终极目标”，开始处理第一个规则（终极目标所在的规则）。在我们的例子中，第一个规则就是目标 "main" 所在的规则。规则描述了 "main" 的依赖关系，并定义了链接 ".o" 文件生成目标 "main" 的命令；make 在执行这个规则所定义的命令之前，首先处理目标 "main" 的所有的依赖文件（例子中的那些 ".o" 文件）的更新规则（以这些 ".o" 文件为目标的规则）。
  - 对这些 ".o" 文件为目标的规则处理有下列三种情况：
    - 目标 ".o" 文件不存在，使用其描述规则创建它；
    - 目标 ".o" 文件存在，目标 ".o" 文件所依赖的 ".c" 源文件 ".h" 文件中的任何一个比目标 ".o" 文件“更新”（在上一次 make 之后被修改）。则根据规则重新编译生成它；
    - 目标 ".o" 文件存在，目标 ".o" 文件比它的任何一个依赖文件（".c" 源文件、".h" 文件）“更新”（它的依赖文件在上一次 make 之后没有被修改），则什么也不做。
  - 通过上面的更新规则我们可以了解到中间文件的作用，也就是编译时生成的 ".o" 文件。作用是检查某个源文件是不是进行过修改，最终目标文件是不是需要重建。我们执行 make 命令时，只有修改过的源文件或者是不存在的目标文件会进行重建，而那些没有改变的文件不用重新编译，这样在很大程度上节省时间，提高编程效率。小的工程项目可能体会不到，项目工程文件越大，效果才越明显。

- 清除工作目录中的过程文件

  - 我们在使用的时候会产生中间文件会让整个文件看起来很乱，所以在编写 Makefile 文件的时候会在末尾加上这样的规则语句：

    ```
    .PHONY:clean
    clean:    
    	rm -rf *.o test
    ```

  - 其中 "*.o" 是执行过程中产生的中间文件，"test" 是最终生成的执行文件。我们可以看到 clean 是独立的，它只是一个伪目标，不是具体的文件。不会与第一个目标文件相关联，所以我们在执行 make 的时候也不会执行下面的命令。在shell 中执行 "make clean" 命令，编译时的中间文件和生成的最终目标文件都会被清除，方便我们下次的使用。

##### 通配符的使用

- Makefile 是可以使用 shell 命令的，所以 shell 支持的通配符在 Makefile 中也是同样适用的。 shell 中使用的通配符有："*"，"?"，"[...]"。具体看一下这些通配符的表示含义和具体的使用方法。

  | 通配符 | 使用说明                           |
  | ------ | ---------------------------------- |
  | *      | 匹配0个或者是任意个字符            |
  | ？     | 匹配任意一个字符                   |
  | []     | 我们可以指定匹配的字符放在 "[]" 中 |

- 如果我们的通配符使用在依赖的规则中的话一定要注意这个问题：不能通过引用变量的方式来使用，如下所示。

  ```
  OBJ=*.c
  test:$(OBJ)
      gcc -o $@ $^
  ```

  - 我们去执行这个命令的时候会出现错误，提示我们没有 "\*.c" 文件，实例中我们相要表示的是当前目录下所有的 ".c" 文件，但是我们在使用的时候并没有展开，而是直接识别成了一个文件。文件名是 "*.c"。

  - 如果我们就是相要通过引用变量的话，我们要使用一个函数 "wildcard"，这个函数在我们引用变量的时候，会帮我们展开。我们把上面的代码修改一下就可以使用了。

    ```
    OBJ=$(wildcard *.c)
    test:$(OBJ)
        gcc -o $@ $^
    ```

    - 这样我们再去使用的时候就可以了。调用函数的时候，会帮我们自动展开函数。

- 还有一个和通配符 "*" 相类似的字符，这个字符是 "%"，也是匹配任意个字符，使用在我们的的规则当中。**即只能用在目标和依赖中不能用在命令中**

  ```
  test:test.o test1.o
      gcc -o $@ $^
  %.o:%.c
      gcc -o $@ $^
  ```

  -  "%.o" 把我们需要的所有的 ".o" 文件组合成为一个列表，从列表中挨个取出的每一个文件，"%" 表示取出来文件的文件名（不包含后缀），然后找到文件中和 "%"名称相同的 ".c" 文件，然后执行下面的命令，直到列表中的文件全部被取出来为止。

- 通配符和%区别

  - 通配符可以使用在命令中

    ```
    clean:
        rm -f *.o
    ```

  - 通配符可以使用在规则中

    ```
    print: *.c
        lpr -p $?
        touch print
    ```

  - 通配符可以使用在变量中

    ```
    objects := $(wildcard *.o)
    ```

  - 而%只能使用在规则和目标中还有vpath中，不能使用在命令中


##### 变量的定义和使用

-  Makefile 文件中定义变量的基本语法如下：变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 `$` 符号，但最好用小括号 `()` 或是大括号 `{}` 把变量给包括起来。如果你要使用真实的 `$` 字符，那么你需要用 `$$` 来表示。

  ```
  变量的名称=值列表
  ```

  - Makefile 中的变量的使用其实非常的简单，因为它并没有像其它语言那样定义变量的时候需要使用数据类型。变量的名称可以由大小写字母、阿拉伯数字和下划线构成。等号左右的空白符没有明确的要求，因为在执行 make 的时候多余的空白符会被自动的删除。至于值列表，既可以是零项，又可以是一项或者是多项。如：

    ```
    VALUE_LIST = one two three
    ```

  - 调用变量的时候可以用 "$(VALUE_LIST)" 或者是 "${VALUE_LIST}" 来替换，这就是变量的引用。实例：

    ```
    OBJ=main.o test.o test1.o test2.o
    test:$(OBJ)
          gcc -o test $(OBJ)
    ```

    - 这就是引用变量后的 Makefile 的编写，比我们之前的编写方式要简单的多。当要添加或者是删除某个依赖文件的时候，我们只需要改变变量 "OBJ" 的值就可以了。

-  知道了如何定义，下面我们来说一下 Makefile 的变量的四种基本赋值方式：

  -  简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。
  -  递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。
  -  条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。
  -  追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。

-  GNU的make工作时的执行步骤如下：（想来其它的make也是类似）

   1. 读入所有的Makefile。
   2. 读入被include的其它Makefile。
   3. 初始化文件中的变量。
   4. 推导隐晦规则，并分析所有规则。
   5. 为所有的目标文件创建依赖关系链。
   6. 根据依赖关系，决定哪些目标要重新生成。
   7. 执行生成命令。

-  1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。

   -  所以会有简单赋值和递归赋值的区别，变量只有在使用的时候才会展开，如果没使用之前递归赋值之后，此时变量就会是递归赋值之后的值，这样就会出错。

-  简单赋值

  ```
  x:=foo
  y:=$(x)b
  x:=new
  test：
        @echo "y=>$(y)"
        @echo "x=>$(x)"
        
  y=>foob
  x=>new
  ```

-  递归赋值

  ```
  x=foo
  y=$(x)b
  x=new
  test：
        @echo "y=>$(y)"
        @echo "x=>$(x)"
        
  y=>newb
  x=>new
  ```

-  条件赋值

  ```
  x:=foo
  y:=$(x)b
  x?=new
  test：
        @echo "y=>$(y)"
        @echo "x=>$(x)"
        
  y=>foob
  x=>foo
  ```

-  追加赋值

  ```
  x:=foo
  y:=$(x)b
  x+=$(y)
  test：
        @echo "y=>$(y)"
        @echo "x=>$(x)"
        
  y=>foob
  x=>foo foob
  ```

- 其实变量在我们的 Makefile 中还是有很多种类的，它们的意义是不相同的。比如我们的环境变量，自动变量，模式指定变量等。


###### 变量中的变量

- 在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。

- 先看第一种方式，也就是简单的使用 `=` 号，在 `=` 左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：

  ```
  foo = $(bar)
  bar = $(ugh)
  ugh = Huh?
  
  all:
      echo $(foo)
  ```

  - 我们执行“make all”将会打出变量 `$(foo)` 的值是 `Huh?` （ `$(foo)` 的值是 `$(bar)` ， `$(bar)` 的值是 `$(ugh)` ， `$(ugh)` 的值是 `Huh?` ）可见，变量是可以使用后面的变量来定义的。

  - 这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：

    ```
    CFLAGS = $(include_dirs) -O
    include_dirs = -Ifoo -Ibar
    ```

  - 当 `CFLAGS` 在命令中被展开时，会是 `-Ifoo -Ibar -O` 。但这种形式也有不好的地方，那就是递归定义，如：

    ```
    CFLAGS = $(CFLAGS) -O
    或者
    A = $(B)
    B = $(A)
    ```

    - 这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。

  - 为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是 `:=` 操作符


###### 高级变量用法

- 这里介绍两种变量的高级使用方法，第一种是变量值的替换。

- 我们可以替换变量中的共有的部分，其格式是 `$(var:a=b)` 或是 `${var:a=b}` ，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。

  ```
  foo := a.o b.o c.o
  bar := $(foo:.o=.c)
  ```

  - 这个示例中，我们先定义了一个 `$(foo)` 变量，而第二行的意思是把 `$(foo)` 中所有以 `.o` 字串“结尾”全部替换成 `.c` ，所以我们的 `$(bar)` 的值就是“a.c b.c c.c”。

- 另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：

  ```
  foo := a.o b.o c.o
  bar := $(foo:%.o=%.c)
  ```

  - 这依赖于被替换字串中的有相同的模式，模式中必须包含一个 `%` 字符，这个例子同样让 `$(bar)` 变量的值为“a.c b.c c.c”。

- 第二种高级用法是——“把变量的值再当成变量”。先看一个例子：

  ```
  x = y
  y = z
  a := $($(x))
  ```

  - 在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）

    - 递归赋值是需要有变量的使用的，例如x=$(y)，如果x=y这种不是递归赋值。

  - 我们还可以使用更多的层次：
  
    ```
    x = y
    y = z
    z = u
    a := $($($(x)))
    ```
  
  - 这里的 `$(a)` 的值是“u”，相关的推导留给读者自己去做吧。

###### 目标变量

- 前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如 `$<` 等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。

- 当然，我也同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。

  ```
  <target ...> : <variable-assignment>;
  
  <target ...> : overide <variable-assignment>
  ```

  - <variable-assignment>;可以是前面讲过的各种赋值表达式，如 `=` 、 `:=` 、 `+=` 或是 `?=` 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。

- 这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：

  ```
  prog : CFLAGS = -g
  prog : prog.o foo.o bar.o
      $(CC) $(CFLAGS) prog.o foo.o bar.o
  
  prog.o : prog.c
      $(CC) $(CFLAGS) prog.c
  
  foo.o : foo.c
      $(CC) $(CFLAGS) foo.c
  
  bar.o : bar.c
      $(CC) $(CFLAGS) bar.c
  ```

  - 在这个示例中，不管全局的 `$(CFLAGS)` 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， `$(CFLAGS)` 的值都是 `-g`

###### 模式变量

- 在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。

- 我们知道，make的“模式”一般是至少含有一个 `%` 的，所以，我们可以以如下方式给所有以 `.o` 结尾的目标定义目标变量：

  ```
  %.o : CFLAGS = -O
  ```

- 同样，模式变量的语法和“目标变量”一样：

  ```
  <pattern ...>; : <variable-assignment>;
  
  <pattern ...>; : override <variable-assignment>;
  ```

##### 自动化变量

- 关于自动化变量可以理解为由 Makefile 自动产生的变量。在模式规则中，规则的目标和依赖的文件名代表了一类的文件。规则的命令是对所有这一类文件的描述。我们在 Makefile 中描述规则时，依赖文件和目标文件是变动的，显然在命令中不能出现具体的文件名称，否则模式规则将失去意义。**表示是命令中使用自动化变量。**

- 那么模式规则命令中该如何表示文件呢？就需要使用“自动化变量”，自动化变量的取值根据执行的规则来决定，取决于执行规则的目标文件和依赖文件。下面是对所有的自动化变量进行的说明：

  | 自动化变量 | 说明                                                         |
  | ---------- | ------------------------------------------------------------ |
  | $@         | 表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。     `$@` 表示目标的集合，就像一个数组， `$@` 依次取出目标，并执于命令。适用于多目标 |
  | $%         | 当目标文件是一个静态库文件时，代表静态库的一个成员名。       |
  | $<         | 规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。 |
  | $?         | 所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件是静态库文件，代表的是库文件（.o 文件）。 |
  | $^         | 代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件。 |
  | $+         | 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。 |
  | $*         | 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。 |

- 实例1

  ```
  test:test.o test1.o test2.o
           gcc -o $@ $^
  test.o:test.c test.h
           gcc -o $@ $<
  test1.o:test1.c test1.h
           gcc -o $@ $<
  test2.o:test2.c test2.h
           gcc -o $@ $<
  ```

  - 这个规则模式中用到了 "$@" 、"$<" 和 "$^" 这三个自动化变量，对比之前写的 Makefile 中的命令，我们可以发现 "$@" 代表的是目标文件test，“$^”代表的是依赖的文件，“$<”代表的是依赖文件中的第一个。我们在执行 make 的时候，make 会自动识别命令中的自动化变量，并自动实现自动化变量中的值的替换，这个类似于编译C语言文件的时候的预处理的作用。

- 实例2

  ```
  lib:test.o test1.o test2.o
      ar r $?
  ```

  - 假如我们要做一个库文件，库文件的制作依赖于这三个文件。当修改了其中的某个依赖文件，在命令行执行 make 命令，库文件 "lib" 就会自动更新。"$?" 表示修改的文件。

- GNU make 中在这些变量中加入字符 "D" 或者 "F" 就形成了一系列变种的自动化变量，这些自动化变量可以对文件的名称进行操作。下面是一些详细的描述：

  | 变量名      | 功能                                                         |
  | ----------- | ------------------------------------------------------------ |
  | $(@D)       | 表示文件的目录部分（不包括斜杠）。如果 "$@" 表示的是 "dir/foo.o" 那么 "$(@D)" 表示的值就是 "dir"。如果 "$@" 不存在斜杠（文件在当前目录下），其值就是 "."。 |
  | $(@F)       | 表示的是文件除目录外的部分（实际的文件名）。如果 "$@" 表示的是 "dir/foo.o"，那么 "$@F" 表示的值为 "dir"。 |
  | $(*D) $(*F) | 分别代表 "茎" 中的目录部分和文件名部分                       |
  | $(%D) $(%F) | 当以 "archive(member)" 形式静态库为目标时，分别表示库文件成员 "member" 名中的目录部分和文件名部分。踏进对这种新型时的目标有效。 |
  | $(<D) $(<F) | 表示第一个依赖文件的目录部分和文件名部分。                   |
  | $(^D) $(^F) | 分别表示所有依赖文件的目录部分和文件部分。                   |
  | $(+D) $(+F) | 分别表示所有的依赖文件的目录部分和文件部分。                 |
  | $(?D) $(?F) | 分别表示更新的依赖文件的目录部分和文件名部分。               |

##### 目标文件搜索（VPATH和vpath）

- 我们都知道一个工程文件中的源文件有很多，并且存放的位置可能不相同（工程中的文件会被放到不同的目录下），所以按照之前的方式去编写 Makefile 会有问题。

- 我们之前列举的例子，所有的源文件基本上都是存放在与 Makefile 相同的目录下。只要依赖的文件存在，并且依赖规则没有问题，执行 make命令整个工程就会按照对我们编写规则去编译，最终会重建目标文件。那如果需要的文件是存在于不同的路径下，在编译的时候要去怎么办呢（不改变工程的结构）？这就用到了 Makefile 中为我们提供的目录搜索文件的功能。

- 常见的搜索的方法的主要有两种：一般搜索`VPATH`和选择搜索`vpath`。乍一看只是大小写的区别，其实两者在本质上也是不同的。

- VPATH 和 vpath 的区别：VPATH 是变量，更具体的说是环境变量，Makefile 中的一种特殊变量，使用时需要指定文件的路径；vpath 是关键字，按照模式搜索，也可以说成是选择搜索。搜索的时候不仅需要加上文件的路径，还需要加上相应限制的条件。

- VPATH使用

  - 在 Makefile 中可以这样写：

    ```
    VPATH := src
    ```

  - 我们可以这样理解，把 src 的值赋值给变量 VPATH，所以在执行 make 的时候会从 src 目录下找我们需要的文件。

  - 当存在多个路径的时候我们可以这样写：

    ```
    VPATH := src car
    ```

    - 或者是

    ```
    VPATH := src:car
    ```

  - 多个路径之间要使用空格或者是冒号隔开，表示在多个路径下搜索文件。搜索的顺序为我们书写时的顺序，拿上面的例子来说，我们应该先搜索 src 目录下的文件，再搜索 car 目录下的文件。

  - 注意：无论你定义了多少路径，make 执行的时候会先搜索当前路径下的文件，当前目录下没有我们要找的文件，才去 VPATH 的路径中去寻找。如果当前目录下有我们要使用的文件，那么 make 就会使用我们当前目录下的文件。

  - 实例

    ```
    VPATH=src car
    test:test.o
        gcc -o $@ $^
    ```

    - 假设 test.c 文件没有在当前的目录而在当前文件的子目录 "src" 或者是 "car" 下，程序执行是没有问题的，但是生成的 test 的文件没有在定义的子目录文件中而是在当前的目录下，当然生成文件路径可以指定。

- vpath使用

  - 学习了 VPATH的使用，我们再来了解一下关键字搜索 vpath 的使用，这种搜索方式一般被称作选择性搜索。使用上的区别我们可以这样理解：VPATH 是搜索路径下所有的文件，而 vpath 更像是添加了限制条件，会过滤出一部分再去寻找。具体用法：

    ```
    1) vpath PATTERN DIRECTORIES 
    2) vpath PATTERN
    3) vpath
    
    ( PATTERN：可以理解为要寻找的条件，DIRECTORIES：寻找的路径 )
    ```

  - 首先是用法一，命令格式如下：

    ```
    vpath test.c src
    ```

    - 可以这样理解，在 src 路径下搜索文件 test.c。多路径的书写规则如下：

    ```
    vpath test.c src car     或者是     vpath test.c src : car
    ```

    - 多路径的用法其实和 VPATH 差不多，都是使用空格或者是冒号分隔开，搜索路径的顺序是先 src 目录，然后是 car 目录。

  - 其次是用法二，命令格式如下：

    ```
    vpath test.c
    ```

    - 用法二的意思是清除符合文件 test.c 的搜索目录。

  - 最后是用法三，命令格式如下：

    ```
    vpath
    ```

    - vpath 单独使的意思是清除所有已被设置的文件搜索路径。

  - 另外在使用 vpath 的时候，搜索的条件中可以包含模式字符“%”，这个符号的作用是匹配一个或者是多个字符，例如“%.c”表示搜索路径下所有的 .c 结尾的文件。如果搜索条件中没有包含“%" ，那么搜索的文件就是具体的文件名称。

- 使用什么样的搜索方法，主要是基于编译器的执行效率。使用 VPATH 的情况是前路径下的文件较少，或者是搜索的文件不能使用通配符表示，这些情况下使用VPATH最好。如果存在某个路径的文件特别的多或者是可以使用通配符表示的时候，就不建议使用 VPATH 这种方法，为什么呢？因为 VPATH 在去搜索文件的时没有限制条件，所以它回去检索这个目录下的所有文件，每一个文件都会进行对比，搜索和我们目录名相同的文件，不仅速度会很慢，而且效率会很低。我们在这种情况下就可以使用 vpath 搜索，它包含搜索条件的限制，搜索的时候只会从我们规定的条件中搜索目标，过滤掉不符合条件的文件，当然查找的时候也会比较的快。

- 如果不使用这种搜索方法，我们可以在写依赖时，直接写上路径，例如

  ```
  common_objs = ../common/xUIClientOps.o
  这个用的是变量表示依赖，最后这个变量值定义的都是依赖
  ```

  - 这样也可以找到对应的源文件.c，然后用隐含规则生成这个.o

###### 路径搜索使用案例

- 为了体验实例的效果的更加明显，我们按照源代码树的布局来放置文件。我们把源代码放置在src目录下，包含的文件文件是：list1.c、list2.c、main.c 文件，我们把头文件包含在 include 的目录下，包含文件 list1.h、list2.h 文件。Makefile 放在这两个目录文件的上一级目录。我们按照之前的方式来编写 Makefile 文件：

  ```
  main:main.o list1.o list2.o
      gcc -o $@ $<
  main.o:main.c
      gcc -o $@ $^
  list1.o:list1.c list1.h
      gcc -o $@ $<
  list2.o:list2.c list2.h
      gcc -o $@ $<
  ```

  - 我们编译执行的 make 时候会发现命令行提示我们：

    ```
    make:*** No rule to make target 'main.c',need by 'main.o'. stop.
    ```

    - 出现错误并且编译停止了，为什么会出现错误呢？我们来看一下出现错误的原因，再去重建最终目标文件 main 的时候我们需要 main.o 文件，但是我们再去重建目标main.o 文件的时候，发现没有找到指定的 main.c 文件，这是错误的根本原因。

  - 这个时候我们就应该添加上路径搜索，我们知道路径搜索的方法有两个：VPATH 和 vpath。我们先来使用一下 VPATH，使用方式很简单，我们只需要在上述的文件开头加上这样一句话：

    ```
    VPATH=src include
    ```

  - 再去执行 make 就不会出现错误。所以 Makefile 中的最终写法是这样的：

    ```
    VPATH=src include
    main:main.o list1.o list2.o
        gcc -o $@ $<
    main.o:main.c
        gcc -o $@ $^
    list1.o:list1.c list1.h
        gcc -o $@ $<
    list2.o:list2.c list2.h
        gcc -o $@ $<
    ```

  - 我们使用 vpath 的话同样可以解决这样的问题，只需要把上述代码中的 VPATH 所在行的代码改写成：

    ```
    vpath %.c src
    vpath %.h include
    main:main.o list1.o list2.o
        gcc -o $@ $<
    main.o:main.c
        gcc -o $@ $^
    list1.o:list1.c list1.h
        gcc -o $@ $<
    list2.o:list2.c list2.h
        gcc -o $@ $<
    ```

##### 隐含规则

```
test:test.o
    gcc -o test test.o
test.o:test.c
```

- 我们可以在 Makefile 中这样写来编译 test.c 源文件，相比较之前少写了重建 test.o 的命令。但是执行 make，发现依然重建了 test 和 test.o 文件，运行结果却没有改变。这其实就是隐含规则的作用。在某些时候其实不需要给出重建目标文件的命令，有的甚至可以不需要给出规则。实例：

  ```
  test:test.o
      gcc -o test test.o
  ```

  - 运行的结果是相同的。
  - 注意：隐含条件只能省略中间目标文件重建的命令和规则，但是最终目标的命令和规则不能省略。

- 隐含规则的具体的工作流程：make 执行过程中找到的隐含规则，提供了此目标的基本依赖关系。确定目标的依赖文件和重建目标需要使用的命令行。隐含规则所提供的依赖文件只是一个基本的（在C语言中，通常他们之间的对应关系是：test.o 对应的是 test.c 文件）。当需要增加这个文件的依赖文件的时候要在 Makefile 中使用没有命令行的规则给出。实例：

  ```
  test:test.o
      gcc -o test test.o
  test:test1.h
  ```

  - 其实在有些时候隐含规则的使用会出现问题。因为有一个 make 的“隐含规则库”。库中的每一条隐含规则都有相应的优先级顺序，优先级也就会越高，使用时也就会被优先使用。

  - 例如在 Makefile 中添加这行代码：

    ```
    foo.o:foo.p
    ```

    - 我们都知道 .p 文件是 Pascal 程序的源文件，如果书写规则时不加入命令的话，那么 make 会按照隐含的规则来重建目标文件 foo.o。如果当前目录下恰好存在 foo.c 文件的时候，隐含规则会把 foo.c 当做是 foo.o 的依赖文件进行目标文件的重建。因为编译 .c 文件的隐含规则在编译 .p 文件之前，显然优先级也会越高。当 make 找到生成 foo.o 的文件之后，就不会再去寻找下一条规则。如果我们不想使用隐含规则，在使用的时候不仅要声明规则，也要添加上执行的命令。

  - 这里讲的是预先设置的隐含规则。如果不明确的写下规则，那么make 就会自己寻找所需要的规则和命令。当然我们也可以使用 make 选项：`-r`或`-n-builtin-rules`选项来取消所有的预设值的隐含规则。当然即使是指定了“-r”的参数，某些隐含规则还是会生效。因为有很多的隐含规则都是使用了后缀名的规则来定义的，所以只要隐含规则中含有“后缀列表”那么隐含规则就会生效。默认的列表是：

    ```
    .out、.a、.in、.o、.c、.cc、.C、.p、.f、.F、.r、.y、.l、.s、.S、.mod、.sym、.def、
    .h、.info、.dvi、.tex、.texinfo、.texi、.txinfo、.w、.ch、.web、.sh、.elc、.el。
    ```

  - 下面是一些常用的隐含规则：

    - 编译 C 程序
    - 编译 [C++](http://c.biancheng.net/cplus/) 程序
    - 编译 Pascal 程序
    - 编译 Fortran/Ratfor 程序
    - 预处理 Fortran/Ratfor 程序
    - 编译 Modula-2 程序
    - 汇编和需要预处理的汇编程序
    - 链接单一的 object 文件
    - Yacc C 程序
    - Lex C 程序时的隐含规则

  - 上面的编译顺序都是一些常用的编程语言执行隐含规则的顺序，我们在 Makefile 中指定规则时，可以参考这样的列表。当需要编译源文件的时候，考虑是不是需要使用隐含规则。如果不需要，就要把相应的规则和命令全部书写上去。

- 内嵌隐含规则的命令中，所使用的变量都是预定义的。我们将这些变量称为“隐含变量”。这些变量允许修改：可以通过命令行参数传递或者是设置系统环境变量的方式都可以对它进行重新定义。无论使用哪种方式，只要 make 在运行的，这些变量的定义有效。Makefile 的隐含规则都会使用到这些变量。

- 比如我们编译 .c 文件在我们的 Makefile 中就是隐含的规则，默认使用到的编译命令时`cc`，执行的命令时`cc -c`我们可以对用上面的任何一种方式将`CC`定义为`ncc`。这样我们就编译 .c 文件的时候就可以用`ncc`进行编译。

##### 条件判断

- 日常使用 Makefile 编译文件时，可能会遇到需要分条件执行的情况，比如在一个工程文件中，可编译的源文件很多，但是它们的类型是不相同的，所以编译文件使用的编译器也是不同的。手动编译去操作文件显然是不可行的（每个文件编译时需要注意的事项很多），所以 make 为我们提供了条件判断来解决这样的问题。

- 需要解决的问题：要根据判断，分条件执行语句。条件语句的作用：条件语句可以根据一个变量的值来控制 make 执行或者是忽略 Makefile 的特定部分，条件语句可以是两个不同的变量或者是常量和变量之间的比较。

- 注意：条件语句只能用于控制 make 实际执行的 Makefile 文件部分，不能控制规则的 shell 命令执行的过程。

- 下面是条件判断中使用到的一些关键字：

  

  | 关键字 | 功能                                              |
  | ------ | ------------------------------------------------- |
  | ifeq   | 判断参数是否不相等，相等为 true，不相等为 false。 |
  | ifneq  | 判断参数是否不相等，不相等为 true，相等为 false。 |
  | ifdef  | 判断是否有值，有值为 true，没有值为 false。       |
  | ifndef | 判断是否有值，没有值为 true，有值为 false。       |

- 条件判断的使用方式如下：

  ```
  ifeq (ARG1, ARG2)
  ifeq 'ARG1' 'ARG2'
  ifeq "ARG1" "ARG2"
  ifeq "ARG1" 'ARG2'
  ifeq 'ARG1' "ARG2"
  ```

  - 实例

    ```
    libs_for_gcc= -lgnu
    normal_libs=
    foo:$(objects)
    ifeq($(CC),gcc)
        $(CC) -o foo $(objects) $(libs_for_gcc)
    else
        $(CC) -o foo $(objects) $(noemal_libs)
    endif
    ```

  - 条件语句中使用到三个关键字“ifeq”、“else”、“endif”。其中：“ifeq”表示条件语句的开始，并指定一个比较条件（相等）。括号和关键字之间要使用空格分隔，两个参数之间要使用逗号分隔。参数中的变量引用在进行变量值比较的时候被展开。“ifeq”，后面的是条件满足的时候执行的，条件不满足忽略；“else”表示当条件不满足的时候执行的部分，不是所有的条件语句都要执行此部分；“endif”是判断语句结束标志，Makefile 中条件判断的结束都要有。

  - 其实 "ifneq" 和 "ifeq" 的使用方法是完全相同的，只不过是满足条件后执行的语句正好相反。

  - 上面的例子可以换一种更加简介的方式来写：

    ```
    libs_for_gcc= -lgnu
    normal_libs=
    ifeq($(CC),gcc)
        libs=$(libs_for_gcc)
    else
        libs=$(normal_libs)
    endif
    foo:$(objects)
        $(CC) -o foo $(objects) $(libs)
    ```

- ifdef和ifndef使用

  ```
  ifdef VARIABLE-NAME
  ```

  - 它的主要功能是判断变量的值是不是为空，实例：

    ```
    bar =
    foo = $(bar)
    all:
    ifdef foo
        @echo yes
    else
        @echo  no
    endif
    ```

    ```
    foo=
    all:
    ifdef foo
        @echo yes
    else
        @echo  no
    endif
    ```

    - 通过两个实例对比说明：通过打印 "yes" 或 "no" 来演示执行的结果。我们执行 make 可以看到实例 1打印的结果是 "yes" ，实例 2打印的结果是 "no" 。其原因就是在实例 1 中，变量“foo”的定义是“foo = $(bar)”。虽然变量“bar”的值为空，但是“ifdef”的判断结果为真，这种方式判断显然是有不行的，因此当我们需要判断一个变量的值是否为空的时候需要使用“ifeq" 而不是“ifdef”。

  - 注意：在 make 读取 Makefile 文件时计算表达式的值，并根据表达式的值决定判断语句中的哪一个部分作为此 Makefile 所要执行的内容。因此在条件表达式中不能使用自动化变量，自动化变量在规则命令执行时才有效，更不能将一个完整的条件判断语句分卸在两个不同的 Makefile 的文件中。在一个 Makefile 中使用指示符 "include" 包含另一个 Makefile 文件。

##### 伪目标

- 这一个章节我们主要讲的是 Makefile 中的伪目标。所谓的伪目标可以这样来理解，它并不会创建目标文件，只是想去执行这个目标下面的命令。伪目标的存在可以帮助我们找到命令并执行。

- 使用伪目标有两点原因：

  - 避免我们的 Makefile 中定义的只执行的命令的目标和工作目录下的实际文件出现名字冲突。
  - 提高执行 make 时的效率，特别是对于一个大型的工程来说，提高编译的效率也是我们所必需的。

- 我们先来看一下第一种情况的使用。如果需要书写这样一个规则，规则所定义的命令不是去创建文件，而是通过 make 命令明确指定它来执行一些特定的命令。实例：

  ```
  clean:
      rm -rf *.o test
  ```

  - 这里要说明一点的是， `clean` 不是一个文件，它只不过是一个动作名字，有点像c语言中的label一样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个label的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。

    - 如果不用伪目标，而且clean不是第一个目标，我们在执行clean的时候也需要make clean。这样写必须没有依赖，正如上面所说的，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个label的名字

      ```
      test:
      	@echo "test"
      clean:
      	@echo "clean"
      ```

      - clean并不是第一个目标，所以执行的时候直接make不会自动执行命令，所以需要make clean
      - 而test是第一个目标，所以直接执行make，会直接执行命令。
      - 虽然会执行，但是基本上不这么写，因为不可能生成一个目标没有依赖。

  - 规则中 rm 命令不是创建文件 clean 的命令，而是执行删除任务，删除当前目录下的所有的 .o 结尾和文件名为 test 的文件。当工作目录下不存在以 clean 命令的文件时，在 shell 中输入 make clean 命令，命令 rm -rf *.o test 总会被执行 ，这也是我们期望的结果。

  - 如果当前目录下存在文件名为 clean 的文件时情况就会不一样了，当我们在 shell 中执行命令 make clean，由于这个规则没有依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令。因此命令 rm 将不会被执行。为了解决这个问题，删除 clean 文件或者是在 Makefile 中将目标 clean 声明为伪目标。将一个目标声明称伪目标的方法是将它作为特殊的目标`.PHONY`的依赖，如下：

    ```
    .PHONY:clean
    ```

  - 这样 clean 就被声明成一个伪目标，无论当前目录下是否存在 clean 这个文件，当我们执行 make clean 后 rm 都会被执行。而且当一个目标被声明为伪目标之后，make 在执行此规则时不会去试图去查找隐含的关系去创建它。这样同样提高了 make 的执行效率，同时也不用担心目标和文件名重名而使我们的编译失败。

  - 在书写伪目标的时候，需要声明目标是一个伪目标，之后才是伪目标的规则定义。目标 "clean" 的完整书写格式如下：

    ```
    .PHONY:clean
    clean:
        rm -rf *.o test
    ```

- 伪目标的另一种使用的场合是在 make 的并行和递归执行的过程中，此情况下一般会存在一个变量，定义为所有需要 make 的子目录。对多个目录进行 make 的实现，可以在一个规则的命令行中使用 shell 循环来完成。如下：

  ```
  SUBDIRS=foo bar baz
  subdirs:    
  	for dir in $(SUBDIRS);do $(MAKE) -C $$dir;done
  ```

  - 代码表达的意思是当前目录下存在三个子文件目录，每个子目录文件都有相对应的 Makefile 文件，代码中实现的部分是用当前目录下的 Makefile 控制其它子模块中的 Makefile 的运行，但是这种实现方法存在以下几个问题：

    - 当子目录执行 make 出现错误时，make 不会退出。就是说，在对某个目录执行 make 失败以后，会继续对其他的目录进行 make。在最终执行失败的情况下，我们很难根据错误提示定位出具体实在那个目录下执行 make 发生的错误。这样给问题定位造成很大的困难。为了解决问题可以在命令部分加入错误检测，在命令执行的错误后主动退出。不幸的是如果在执行 make 时使用了 "-k" 选项，此方式将失效。
    - 另外一个问题就是使用这种 shell 循环方式时，没有用到 make 对目录的并行处理功能由于规则的命令时一条完整的 shell 命令，不能被并行处理。

  - 有了伪目标之后，我们可以用它来克服以上方式所存在的两个问题，代码展示如下：

    ```
    SUBDIRS=foo bar baz
    .PHONY:subdirs $(SUBDIRS)
    subdirs:$(SUBDIRS)
    $(SUBDIRS):
        $(MAKE) -C $@
    foo:baz
    
    目标也没有没有规则(命令)，直接生成后面的依赖，在生成最终的目标时，没有命令不执行就可以了。如果要编译成可执行文件，最终目标也是第一个目标是需要写命令的，否则生成不了。
    ```
    
    - 上面的实例中有一个没有命令行的规则“foo:baz”，这个规则是用来规定三个子目录的编译顺序。因为在规则中 "baz" 的子目录被当作成了 "foo" 的依赖文件，所以 "baz" 要比 "foo" 子目录更先执行，最后执行 "bar" 子目录的编译。

- 一般情况下，一个伪目标不作为另外一个目标的依赖。这是因为当一个目标文件的依赖包含伪目标时，每一次在执行这个规则伪目标所定义的命令都会被执行（因为它作为规则的依赖，重建规则目标时需要首先重建规则的所有依赖文件）。当一个伪目标没有任何目标（此目标是一个可被创建或者是已存在的文件）的依赖时，我们只能通过 make 的命令来明确的指定它的终极目标，执行它所在规则所定义的命令。例如 make clean。

  - 伪目标作为依赖时，其总是要执行伪目标的命令，什么情况下不执行伪目标的命令，那就是在伪目标不是依赖的时候且不是第一个目标，我们只能在shell命令行执行make clean这种操作来执行伪目标下的命令。

- 伪目标实现多文件编辑

  - 如果在一个文件里想要同时生成多个可执行文件，我们可以借助伪目标来实现。使用方式如下：

    ```
    .PHONY:all
    all:test1 test2 test3
    test1:test1.o
        gcc -o $@ $^
    test2:test2.o
        gcc -o $@ $^
    test3:test3.o
        gcc -o $@ $^
    ```

  - 我们在当前目录下创建了三个源文件，目的是把这三个源文件编译成为三个可执行文件。将重建的规则放到 Makefile 中，约定使用 "all" 的伪目标来作为最终目标，它的依赖文件就是要生成的可执行文件。这样的话只需要一个 make 命令，就会同时生成三个可执行文件。

  - 之所以这样写，是因为伪目标的特性，它总会被执行，所以它依赖的三个文件的目标就不如 "all" 这个目标新，所以，其他的三个目标的规则总是被执行，这也就达到了我们一口气生成多个目标的目的。我们也可以实现单独的编译这三个中的任意一个源文件（我们想去重建 test1，我们可以执行命令`make test1` 来实现 ）。 

  - 伪目标all要写成第一个目标，这样才能行。

  - 而且伪目标后面没有shell命令。如果不指明伪目标也是正确的，例如

    ```
    all : test1 test2 test3                                                                                 
    test1: 
    	@echo "test1"    
    test2:                                                                                                                      @echo "test2"                                                                                            
    test3:                                                                                           
       @echo "test3"
    ```

    - 这样直接执行也是正确的，伪目标只是为了防止当前目录下有一个和all同名的文件。
    - 但是一般的情况下都要写成伪目标，如果不写也应该是正确的。

- 随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：

  ```
  .PHONY : cleanall cleanobj cleandiff
  
  cleanall : cleanobj cleandiff
      rm program
  
  cleanobj :
      rm *.o
  
  cleandiff :
      rm *.diff
  ```

  - “make cleanall”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。

##### 多目标

- Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 `$@` （关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。

  ```
  bigoutput littleoutput : text.g
      generate text.g -$(subst output,,$@) > $@
  ```

- 上述规则等价于：

  ```
  bigoutput : text.g
      generate text.g -big > bigoutput
  littleoutput : text.g
      generate text.g -little > littleoutput
  ```

- 其中， `-$(subst output,,$@)` 中的 `$` 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， `$@` 表示目标的集合，就像一个数组， `$@` 依次取出目标，并执于命令。

##### 静态模式

- 静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：

  ```
  <targets ...> : <target-pattern> : <prereq-patterns ...>
      <commands>
      ...
  ```

  - targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。

  - target-pattern是指明了targets的模式，也就是的目标集模式。

  - prereq-patterns是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。

  - 这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-pattern>定义成 `%.o` ，意思是我们的<target>;集合中都是以 `.o` 结尾的，而如果我们的<prereq-patterns>定义成 `%.c` ，意思是对<target-pattern>所形成的目标集进行二次定义，其计算方法是，取<target-pattern>模式中的 `%` （也就是去掉了 `.o` 这个结尾），并为其加上 `.c` 这个结尾，形成的新集合。

  - 所以，我们的“目标模式”或是“依赖模式”中都应该有 `%` 这个字符，如果你的文件名中有 `%` 那么你可以使用反斜杠 `\` 进行转义，来标明真实的 `%` 字符。

    ```
    objects = foo.o bar.o
    
    all: $(objects)
    
    $(objects): %.o: %.c
        $(CC) -c $(CFLAGS) $< -o $@
    ```

  - 上面的例子中，指明了我们的目标从$object中获取， `%.o` 表明要所有以 `.o` 结尾的目标，也就是 `foo.o bar.o` ，也就是变量 `$object` 集合的模式，而依赖模式 `%.c` 则取模式 `%.o` 的 `%` ，也就是 `foo bar` ，并为其加下 `.c` 的后缀，于是，我们的依赖目标就是 `foo.c bar.c` 。而命令中的 `$<` 和 `$@` 则是自动化变量， `$<` 表示第一个依赖文件， `$@` 表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：

    ```
    foo.o : foo.c
        $(CC) -c $(CFLAGS) foo.c -o foo.o
    bar.o : bar.c
        $(CC) -c $(CFLAGS) bar.c -o bar.o
    ```

  - 试想，如果我们的 `%.o` 有几百个，那么我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会是一个很强大的功能。再看一个例子：

    ```
    files = foo.elc bar.o lose.o
    
    $(filter %.o,$(files)): %.o: %.c
        $(CC) -c $(CFLAGS) $< -o $@
    $(filter %.elc,$(files)): %.elc: %.el
        emacs -f batch-byte-compile $<
    ```

    - (filter %.o,$(files))表示调用Makefile的filter函数，过滤“$files”集，只要其中模式为“%.o”的内容。

##### 自动生成依赖性

- 看一下跟我一起写makefile

##### 常用字符串处理函数

- 学习使用函数之前，先来看一下函数的语法结构。函数的调用和变量的调用很像。引用变量的格式为`$(变量名)`，函数调用的格式如下：

  ```
  $(<function> <arguments>)  或者是   ${<function> <arguments>}
  ```

  - 其中，function 是函数名，arguments 是函数的参数，参数之间要用逗号分隔开。而参数和函数名之间使用空格分开。调用函数的时候要使用字符“$”，后面可以跟小括号也可以使用花括号。这个其实我们并不陌生，我们之前使用过许多的函数，比如说展开通配符的函数 wildcard，以及字符串替换的函数 patsubst ，Makefile 中函数并不是很多。

- 模式字符串替换函数，函数使用格式如下：

  ```
  $(patsubst <pattern>,<replacement>,<text>)
  ```

  - 函数说明：函数功能是查找 text 中的单词是否符合模式 pattern，如果匹配的话，则用 replacement 替换。返回值为替换后的新字符串。实例：

    ```
    OBJ=$(patsubst %.c,%.o,1.c 2.c 3.c)
    all:
        @echo $(OBJ)
    ```

  - 执行 make 命令，我们可以得到的值是 "1.o 2.o 3.o"，这些都是替换后的值。

- 字符串替换函数，函数使用格式如下：

  ```
  $(subst <from>,<to>,<text>)
  ```

  - 函数说明：函数的功能是把字符串中的 form 替换成 to，返回值为替换后的新字符串。实例：

    ```
    OBJ=$(subst ee,EE,feet on the street)
    all:
        @echo $(OBJ)
    ```

  - 执行 make 命令，我们得到的值是“fEEt on the strEEt”。

- 去空格函数，函数使用格式如下：

  ```
  $(strip <string>)
  ```

  - 函数说明：函数的功能是去掉字符串的开头和结尾的字符串，并且将其中的多个连续的空格合并成为一个空格。返回值为去掉空格后的字符串。实例：

    ```
    OBJ=$(strip    a       b c)
    all:
        @echo $(OBJ)
    ```

    - 执行完 make 之后，结果是“a b c”。这个只是除去开头和结尾的空格字符，并且将字符串中的空格合并成为一个空格。

- 查找字符串函数，函数使用格式如下：

  ```
  $(findstring <find>,<in>)
  ```

  - 函数说明：函数的功能是查找 in 中的 find ,如果我们查找的目标字符串存在。返回值为目标字符串，如果不存在就返回空。实例：

    ```
    OBJ=$(findstring a,a b c)
    all:
        @echo $(OBJ)
    ```

    - 执行 make 命令，得到的返回的结果就是 "a"。

- 过滤函数，函数使用格式如下：

  ```
  $(filter <pattern>,<text>)
  ```

  - 函数说明：函数的功能是过滤出 text 中符合模式 pattern 的字符串，可以有多个 pattern 。返回值为过滤后的字符串。实例：

    ```
    OBJ=$(filter %.c %.o,1.c 2.o 3.s)
    all:
        @echo $(OBJ)
    ```

    - 执行 make 命令，我们得到的值是“1.c 2.o”。

- 反过滤函数，函数使用格式如下：

  ```
  $(filter-out <pattern>,<text>)
  ```

  - 函数说明：函数的功能是功能和 filter 函数正好相反，但是用法相同。去除符合模式 pattern 的字符串，保留符合的字符串。返回值是保留的字符串。实例：

    ```
    OBJ=$(filter-out 1.c 2.o ,1.o 2.c 3.s)
    all：
        @echo $(OBJ)
    ```

    - 执行 make 命令，打印的结果是“3.s”。

- 排序函数，函数使用格式如下：

  ```
  $(sort <list>)
  ```

  - 函数说明：函数的功能是将 `<list>`中的单词排序（升序）。返回值为排列后的字符串。实例：

    ```
    OBJ=$(sort foo bar foo lost)
    all:
        @echo $(OBJ)
    ```

    - 执行 make 命令，我们得到的值是“bar foo lost”。
    - 注意：sort会去除重复的字符串。

- 取单词函数，函数使用格式如下：

  ```
  $(word <n>,<text>)
  ```

  - 函数说明：函数的功能是取出函数`<text>`中的第n个单词。返回值为我们取出的第 n 个单词。实例：

    ```
    OBJ=$(word 2,1.c 2.c 3.c)
    all:    
    	@echo $(OBJ)
    ```

    - 执行 make 命令，我们得到的值是“2.c”。

##### 文件名操作函数

- 我们在编写 Makefile 的时候，很多情况下需要对文件名进行操作。例如获取文件的路径，去除文件的路径，取出文件前缀或后缀等等。当遇到这样的问题的时手动修改是不太可能的，因为文件可能会很多，而且 Makefile 中操作文件名可能不止一次。所以 Makefile 给我们提供了相应的函数去实现文件名的操作。

- 注意：下面的每个函数的参数字符串都会被当作或是一个系列的文件名来看待。

- 取目录函数，函数使用格式如下：

  ```
  $(dir <names>)
  ```

  - 函数说明：函数的功能是从文件名序列 names 中取出目录部分，如果没有 names 中没有 "/" ，取出的值为 "./" 。返回值为目录部分，指的是最后一个反斜杠之前的部分。如果没有反斜杠将返回“./”。实例：

  ```
  OBJ=$(dir src/foo.c hacks)
  all:    
  	@echo $(OBJ)
  ```

  - 执行 make 命令，我们可以得到的值是“src/ ./”。提取文件 foo.c 的路径是 "/src" 和文件 hacks 的路径 "./"。

- 取文件函数，函数使用格式如下：

  ```
  $(notdir <names>)
  ```

  - 函数说明：函数的功能是从文件名序列 names 中取出非目录的部分。非目录的部分是最后一个反斜杠之后的部分。返回值为文件非目录的部分。实例：

  ```
  OBJ=$(notdir src/foo.c hacks)
  all:    
  	@echo $(OBJ)
  ```

  - 执行 make 命令，我们可以得到的值是“foo.c hacks”。

- 取后缀名函数，函数使用格式如下：

  ```
  $(suffix <names>)
  ```

  - 函数说明：函数的功能是从文件名序列中 names 中取出各个文件的后缀名。返回值为文件名序列 names 中的后缀序列，如果文件没有后缀名，则返回空字符串。实例：

  ```
  OBJ=$(suffix src/foo.c hacks)
  all:    
  	@echo $(OBJ)
  ```

  - 执行 make 命令，我们得到的值是“.c ”。文件 "hacks" 没有后缀名，所以返回的是空值。

- 取前缀函数，函数使用格式如下：

  ```
  $(basename <names>)
  ```

  - 函数说明：函数的功能是从文件名序列 names 中取出各个文件名的前缀部分。返回值为被取出来的文件的前缀名，如果文件没有前缀名则返回空的字符串。实例：

  ```
  OBJ=$(notdir src/foo.c hacks)
  all:    
  	@echo $(OBJ)
  ```

  - 执行 make 命令，我们可以得到值是“src/foo hacks”。获取的是文件的前缀名，包含文件路径的部分。

- 添加后缀名函数，函数使用格式如下：

  ```
  $(addsuffix <suffix>,<names>)
  ```

  - 函数说明：函数的功能是把后缀 suffix 加到 names 中的每个单词后面。返回值为添加上后缀的文件名序列。实例：

  ```
  OBJ=$(addsuffix .c,src/foo.c hacks)
  all:    
  	@echo $(OBJ)
  ```

  - 执行 make 后我们可以得到“sec/foo.c.c hack.c”。我们可以看到如果文件名存在后缀名，依然会加上。

- 添加前缀名函数，函数使用格式如下：

  ```
  $(addperfix <prefix>,<names>)
  ```

  - 函数说明：函数的功能是把前缀 prefix 加到 names 中的每个单词的前面。返回值为添加上前缀的文件名序列。实例：

  ```
  OBJ=$(addprefix src/, foo.c hacks)
  all:    
  	@echo $(OBJ)
  ```

  - 
    执行 make 命令，我们可以得到值是 "src/foo.c src/hacks" 。我们可以使用这个函数给我们的文件添加路径。


- 链接函数，函数使用格式如下：

  ```
  $(join <list1>,<list2>)
  ```

  - 函数说明：函数功能是把 list2 中的单词对应的拼接到 list1 的后面。如果 list1 的单词要比 list2的多，那么，list1 中多出来的单词将保持原样，如果 list1 中的单词要比 list2 中的单词少，那么 list2 中多出来的单词将保持原样。返回值为拼接好的字符串。实例：

  ```
  OBJ=$(join src car,abc zxc qwe)
  all:    
  	@echo $(OBJ)
  ```

  - 执行 make 命令，我们可以得到的值是“srcabc carzxc qwe”。很显然`<list1>`中的文件名比`<list2>`的少，所以多出来的保持不变。

- 获取匹配模式文件名函数，命令使用格式如下：

  ```
  $(wildcard PATTERN)
  ```

  - 函数说明：函数的功能是列出当前目录下所有符合模式的 PATTERN 格式的文件名。返回值为空格分隔并且存在当前目录下的所有符合模式 PATTERN 的文件名。实例：

  ```
  OBJ=$(wildcard *.c  *.h)
  all:    
  	@echo $(OBJ)
  ```

  - 执行 make 命令，可以得到当前函数下所有的 ".c " 和 ".h" 结尾的文件。这个函数通常跟的通配符 "*" 连用，使用在依赖规则的描述的时候被展开（在这里我们的例子如果没有 wildcard 函数，我们的运行结果也是这样，"echo" 属于 shell 命令，在使用通配符的时通配符自动展开，我们这里只是相要说明一下这个函数在使用时，如果通过引用变量出现在规则中要被使用）。

##### 命令的编写

- 通过上个章节的描述，我们已经知道了 Makefile 的规则是什么，他是由依赖关系规则和命令组成的。所使用的命令是由 shell 命令行组成，他们是一条一条执行的。多个命令之间要使用分号隔开，Makefile 中的任何命令都要以`tab`键开始。多个命令行之间可以有空行和注释行，在执行规则时空行会被自动忽略。
- 通常系统中可能存在不同的 shell 。但是 make 处理 Makefile 过程时，如果没有明确的指定，那么对所有规则中的命令行的解析使用`bin/sh`来完成。执行过程中使用的 shell 决定了规则中的命令的语法和处理机制。当使用默认的`bin/sh`时，命令中出现的字符“#”到行末的内容被认为是注释。当然了“#”可以不在此行的行首，此时“#”之前的内容不会被作为注释处理。

###### 命令回显

- 通常 make 在执行命令行之前会把要是执行的命令行输出到标准输出设备。我们称之为 "回显"，就好像我们在 shell 环境下输入命令执行时一样。如果规则的命令行以字符“@”开始，则 make 在执行的时候就不会显示这个将要被执行的命令。典型的用法是在使用`echo`命令输出一些信息时。

  ```
  OBJ=test main list
  all:
      @echo $(OBJ)
  ```

  - 执行时将会得到`test main list`这条输出信息，如果在执行命令之前没有字符“@”，那么make的输出将是`echo test main list`。
  - 我们在执行 make 时添加上一些参数，可以控制命令行是否输出。当使用 make 的时候机加上参数`-n`或者是`--just-print` ，执行时只显示所要执行的命令，但不会真正的执行这个命令。只有在这种情况下 make 才会打印出所有的 make 需要执行的命令，其中包括了使用的“@”字符开始的命令。这个选项对于我们调试 Makefile 非常的有用，使用这个选项就可以按执行顺序打印出 Makefile 中所需要执行的所有命令。而 make 参数`-s`或者是`--slient`则是禁止所有的执行命令的显示。就好像所有的命令行都使用“@”开始一样。

###### 命令的执行

- 当规则中的目标需要被重建的时候，此规则所定义的命令将会被执行，如果是多行的命令，那么每一行命令将是在一个独立的子 shell 进程中被执行。因此，多命令行之间的执行命令时是相互独立的，相互之间不存在以来。

- 在 Makefile 中书写在同一行中的多个命令属于一个完整的 shell 命令行，书写在独立行的一条命令是一个独立的 shell 命令行。因此：在一个规则的命令中命令行 “cd”改变目录不会对其后面的命令的执行产生影响。就是说之后的命令执行的工作目录不会是之前使用“cd”进入的那个目录。如果达到这个目的，就不能把“cd”和其后面的命令放在两行来书写。而应该把这两个命令放在一行上用分号隔开。这样才是一个完整的 shell 命令行。

  ```
  foo:bar/lose
      cd bar;gobble lose >../foo
  ```

- 如果想把一个完整的shell命令行书写在多行上，需要使用反斜杠 (\)来对处于多行的命令进行连接，表示他们是一个完整的shell命令行。例如上例我们也可以这样书写：

  ```
  foo:bar.lose
      cd bar; \
      gobble lose > ../foo
  ```

  - make 对所有规则的命令的解析使用环境变量“SHELL”所指定的那个程序。在 GNU make 中，默认的程序时 “/bin/sh”。不像其他的绝大多数变量，他们的只可以直接从同名的系统环境变量那里获得。make 的环境变量 “SHELL”没有使用环境变量的定义。因为系统环境变量“SHELL”指定的那个程序被用来作为用户和系统交互的接口程序，他对于不存在直接交互过程的 make 显然不合适。在 make 环境变量中“SHELL”会被重新赋值；他作为一个变量我们也可以在 Makefile 中明确的给它赋值，变量“SHELL“的默认值时“/bin/sh”。

###### 并发执行命令

- GNU make 支持同时执行多条命令。通常情况下，同一时刻只有一个命令在执行，下一个命令只有在当前命令结束之后才能够开始执行。不过可以通过 make 命令行选项 "-j" 或者 "--jobs" 来告诉 make 在同一时刻可以允许多条命令同时执行。
- 如果选项 "-j" 之后存在一个整数，其含义是告诉 make 在同一时刻可以允许同时执行的命令行的数目。这个数字被称为`job slots`。当 "-j" 选项中没有出现数字的时候，那么同一时间执行的命令数目没有要求。使用默认的`job solts`，值为1，表示make将串行的执行规则的命令（同一时刻只能由一条命令被执行）。
- 并行执行命令所带来的问题是显而易见的：
  - 多个同时执行的命令的输出信息将同时被输出到终端。当出现错误时很难根据一大堆凌乱的信息来区分那条命令执行错误。
  - 在同一时刻可能会存在多个命令执行的进程同时读取到标准输入，但是对于白哦准输入设备来说，在同一时刻只能存在一个进程访问它。就是说在某个时间点，make只能保证此刻正在执行的进程中的一个进程读取标准输入流。而其他的进程键的标准输入流将设置为无效。因此在此一时刻多个执行命令的进程中只有一个进程获得标准输入，而其他的需要读取标准输入流的进程由于输入流无效而导致致命的错误。

##### include文件包含

- 这个章节主要讲的是 Makefile 中包含其他的文件。包含其他文件使用的关键字是 "include"，和 C 语言包含头文件的方式相同。

- 当 make 读取到 "include" 关键字的时候，会暂停读取当前的 Makefile，而是去读 "include" 包含的文件，读取结束后再继读取当前的 Makefile 文件。"include" 使用的具体方式如下：

  ```
  include <filenames>
  ```

  - filenames 是 shell 支持的文件名（可以使用通配符表示的文件）。
  - 注意："include" 关键字所在的行首可以包含一个或者是多个的空格（读取的时候空格会被自动的忽略），但是不能使用 Tab 开始，否则会把 "include" 当作式命令来处理。包含的多个文件之间要使用空格分隔开。使用 "include" 包含进来的 Makefile 文件中，如果存在函数或者是变量的引用，它们会在包含的 Makefile 中展开。
  - 尖括号是不需要的

- include 通常使用在以下的场合：

  - 在一个工程文件中，每一个模块都有一个独立的 Makefile 来描述它的重建规则。它们需要定义一组通用的变量定义或者是模式规则。通用的做法是将这些共同使用的变量或者模式规则定义在一个文件中，需要的时候用 "include" 包含这个文件。
  - 当根据源文件自动产生依赖文件时，我们可以将自动产生的依赖关系保存在另一个文件中。然后在 Makefile 中包含这个文件。
  - 注意：如果使用 "include" 包含文件的时候，指定的文件不是文件的绝对路径或者是为当前文件下没有这个文件，make 会根据文件名会在以下几个路径中去找，首先我们在执行 make 命令的时候可以加入选项 "-I" 或 "--include-dir" 后面添加上指定的路径，如果文件存在就会被使用，如果文件不存在将会在其他的几个路径中搜索："usr/gnu/include"、"usr/local/include" 和 "usr/include"。
  - 如果在上面的路径没有找到 "include" 指定的文件，make 将会提示一个文件没有找到的警示提示，但是不会退出，而是继续执行 Makefile 的后续的内容。当完成读取整个 Makefile 后，make 将试图使用规则来创建通过 "include" 指定但不存在的文件。当不能创建的时候，文件将会保存退出。

- 使用时，通常用 "-include" 来代替 "include" 来忽略文件不存在或者是无法创建的错误提示，使用格式如下：

  ```
  -include <filename>
  ```

  - 使用方法和 "include" 的使用方法相同。

- 这两种方式之间的区别：

  - 使用 "include <filenames>" ，make 在处理程序的时候，文件列表中的任意一个文件不存在的时候或者是没有规则去创建这个文件的时候，make 程序将会提示错误并保存退出。
  - 使用 "-include <filenames>"，当包含的文件不存在或者是没有规则去创建它的时候，make 将会继续执行程序，只有真正由于不能完成终极目标重建的时候我们的程序才会提示错误保存退出。

##### 嵌套执行make

- 这个章节主要讲解的是在 Makefile 中嵌套执行 make。我们都知道在一个大的工程文件中，不同的文件按照功能被划分到不同的模块中，也就说很多的源文件被放置在了不同的目录下。每个模块可能都会有自己的编译顺序和规则，如果在一个 Makefile 文件中描述所有模块的编译规则，就会很乱，执行时也会不方便，所以就需要在不同的模块中分别对它们的规则进行描述，也就是每一个模块都编写一个 Makefile 文件，这样不仅方便管理，而且可以迅速发现模块中的问题。这样我们只需要控制其他模块中的 Makefile 就可以实现总体的控制，这就是 make 的嵌套执行。

- 如何来使用呢？举例说明如下：

  ```
  subsystem:    
  	cd subdir && $(MAKE)
  ```

  - 这个例子可以这样来理解，在当前目录下有一个目录文件 subdir 和一个 Makefile 文件，子目录 subdir 文件下还有一个 Makefile 文件，这个文件是用来描述这个子目录文件的编译规则。使用时只需要在最外层的目录中执行 make 命令，当命令执行到上述的规则时，程序会进入到子目录中执行 make。这就是嵌套执行 make，我们把最外层的 Makefile 称为是总控 Makefile。

  - 定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护，可以使用系统定义的，也可以我们自己定义。

  - makefile中$(MAKE)使用：
  
  
    - make 定义了很多默认变量，${MAKE} 就是预设的 make 这个命令的名称（或者路径）
    - make -p 可以查看所有预定义的变量的当前值，从中可以看到MAKE
  
  - 上述的规则也可以换成另外一种写法：
  
    ```
    subsystem    
    	$(MAKE) -C subdir
    ```
  
  - 在 make 的嵌套执行中，我们需要了解一个变量 "CURDIR"，此变量代表 make 的工作目录。当使用 make 的选项 "-C" 的时候，命令就会进入指定的目录中，然后此变量就会被重新赋值。总之，如果在 Makefile 中没有对此变量进行显式的赋值操作，那么它就表示 make 的工作目录。我们也可以在 Makefile 中为这个变量赋一个新的值，当然重新赋值后这个变量将不再代表 make 的工作目录。

###### export的使用

- 使用 make 嵌套执行的时候，变量是否传递也是我们需要注意的。如果需要变量的传递，那么可以这样来使用：

  ```
  export <variable>
  ```

- 在嵌套执行make的时候执行的是其他的makefile，我们可以简单理解为如果没有export的变量其他的makefile里面是不能直接使用的，如果export变量之后，其他的makefile可以使用export的变量，export的变量只能在子目录的makefile中使用，在和export所在makefile平级的目录是不能使用的，当然平级目录的子目录也不能使用。但是我们一般都在总控makefile里面export，也就不存在平级的子目录了。

- 如果不需要那么可以这样来写：

  ```
  unexport <variable>
  ```

  - <variable>是变量的名字，不需要使用 "$" 这个字符。如果所有的变量都需要传递，那么只需要使用 "export" 就可以，不需要添加变量的名字。

- Makefile 中还有两个变量不管是不是使用关键字 "export" 声明，它们总会传递到下层的 Makefile 中。这两个变量分别是 SHELL 和 MAKEFLAGS，特别是 MAKEFLAGS 变量，包含了 make 的参数信息。如果执行总控 Makefile 时，make 命令带有参数或者在上层的 Makefile 中定义了这个变量，那么 MAKEFLAGS 变量的值将会是 make 命令传递的参数，并且会传递到下层的 Makefile 中，这是一个系统级别的环境变量。

- make 命令中有几个参数选项并不传递，它们是:"-C"、"-f"、"-o"、"-h" 和 "-W"。如果我们不想传递 MAKEFLAGS 变量的值，在 Makefile 中可以这样来写：

  ```
  subsystem:
      cd subdir && $(MAKE) MAKEFLAGS=
  ```

- 还有一个在“嵌套执行”中比较有用的参数， `-w` 或是 `--print-directory` 会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用 `make -w` 来执行，那么当进入该目录时，我们会看到:

  ```
  make: Entering directory `/home/hchen/gnu/make'.
  ```

  - 而在完成下层make后离开目录时，我们会看到:

    ```
    make: Leaving directory `/home/hchen/gnu/make'
    ```

  - 当你使用 `-C` 参数来指定make下层Makefile时， `-w` 会被自动打开的。如果参数中有 `-s` （ `--slient` ）或是 `--no-print-directory` ，那么， `-w` 总是失效的。

###### 实例

- Makefile 中 "嵌套执行 make" 大部分是在大的工程项目中使用的，那么我们就通过一个大的项目工程来详细的分析一下如何嵌套执行 make。

- 假设有一个 MP3 player 的应用程序，它可以被划分为若干个组件：用户界面（ui）、编解码器（codec）以及数据管理库（db）。它们分别可以用三个程序库来表示：libui.a、libcodec.a 和 libdb.a。将这些组件紧凑的放到一起就可以组成这个应用程序。具体的文件结构展示为（我们展示的只是目录文件，没有展示详细的源文件）:

  ```
  ├──Makefile         //最外层的Makefile文件，不是目录文件。
  ├──include          //编译的时候需要链接的库文件
  │      ├──codec   //libui.a 库文件所在的目录
  │      ├──db        //libdb.a 库文件所在的目录
  │      ├──ui         //libui.a库文件所在的目录
  ├──lib                   //源文件所在的目录，子目录文件中包含Makefile文件
  │      ├──codec     //编解码器所在的源文件的目录
  │      ├──db           //数据库源文件所在的目录
  │      ├──ui            //用户界面源文件所在目录
  ├──app
  │      ├──player    
  └──doc              //这个工程编译说明    
  ```

- 我们可以看到最外层有一个 Makefile 文件，这就是我们的 "总控Makefile" 文件，我们使用这个 Makefile 调用项目中各个子目录的 Makefile 文件的运行。假设只有我们的 lib 目录下和 app 目录下的各个子目录含有 Makefile 文件。那我们总控的 Makefile 的文件可以这样来写：

  ```
  lib_codec := lib/codec
  lib_db    := lib/db
  lib_ui     := lib/ui
  libraries   := $(lib_codec) $(lib_db) $(lib_ui)
  player    := app/player
  .PHONY : all $(player) $(libraries)
  all : $(player)
  $(player) $(libraries) :
      $(MAKE) -C $@
  ```

- 我们可以看到在 "总控 Makefile" 中，一个规则在工作目标上列出了所有的子目录，它对每一个子目录的 Makefile 调用的代码是：

  ```
  $(player) $(libraries) :
        $(MAKE) -C $@
  ```

  - 在 Makefile 文件中，MAKE 变量应该总是用来调用 make 程序。make 程序一看到 MAKE 变量就会把它设成 make 的实际路径，所以递归调用中的每次调用都会使用同一个执行文件。此外，当命令 --touch(-t)、--just-print(-n) 和 --question(-q) 被使用时，包含 MAKE 变量的每一行都会受到特别的处理。

- 由于这些“工作目标目录”被设成 .PHONY 的依赖文件，所以即使工作目标已经更新，此规则仍旧会进行更新动作。使 --directory(-C) 选项的目的是要让 make 在读取 Makefile 之前先切换到相应的 "工作目录" 。

- 当 make 在建立依存图的时候找不到程序库与 app/player 工作目标之间的依存关系时，这意味着建立任何程序库之前，make 将会先执行 app/player 目录中的 Makefile。显然这将会导致失败的结果，因为应用程序的链接需要程序库。为解决这个问题，我们会提供额外的依存信息：

  ```
  $(player) : $(libraries)
  $(lib_ui) : $(lib_db) $(lib_codec)
  ```

- 我们在此处做了如下的描述：运行 app/player 目录中的 Makefile 之前必须先运行程序库子目录中的 Makefile。此外，编译 lib/ui 目录中的程序代码之前必须先编译 lib/db 和lib/codec 目录中的程序库。这么做可以确保任何自动产生的程序代码，在 lib/ui 目录中的程序代码被编译之前就已经产生出来了。

- 更新必要条件的时候，会引发微妙的次序问题。如同所有的依存关系，更新的次序取决于依存图的分析结果，但是当工作目标的必要条件（依赖文件）出现在同一行时，GNU make 将会从左至右的次序进行更新。例如：

  ```
  all : a b c
  all : d e f
  ```

  - 如果不存在其他的依存关系，这6个必要条件的更新动作可以是任何次序，不过GNU make将会以从左向右的次序来更新出现在同一行的必要条件，这会产生如下的更新次序："a b c d e f" 或 "d e f a b c"。
  - 注意：不要因为之前这么做更新的次序是对的，就以为每次这么做都是对的，而忘了提供完整的依存信息。

- 最后，依存分析可能会产生不同的次序而引发一些问题。所以，如果有一组工作目标需要以特定的次序进行更新时，就必须提供适当的必要条件来实现正确的次序。

- 当我们在最外层执行 make 的时候我们会看到l输出的信息：

  ```
  make -C lib/db
  make[1]: Entering directory ‘/MP3_player/lib/db’
  make[1]:Update db library...
  make[1]: Leaving directory ‘/MP3_player/lib/db’
  make -C lib/codec
  make[1]: Entering directory ‘/MP3_player/lib/codec’
  make[1]:Update codec library...
  make[1]: Leaving directory ‘/MP3_player/lib/codec’
  make -C lib/ui
  make[1]: Entering directory ‘/MP3_player/lib/ui’
  make[1]:Update ui library...
  make[1]: Leaving directory ‘/MP3_player/lib/ui’
  make -C app/player
  make[1]: Entering directory ‘/MP3_player/app/player’
  make[1]:Update player library...
  make[1]: Leaving directory ‘/MP3_player/app/player’
  ```

  - 当 make 发觉它正在递归调用另一个 make 时，他会启 用--print-directory(-w) 选项，这会使得 make 输出 Entering directory(进入目录) 和 Leaving directory(离开目录) 的信息。当 --directory(-C) 选项被使用时，也会启用这个选项。我们还可以看到每一行中，MAKELEVEL 这个 make 变量的值加上方括号之后被一起输出。在这个简单的例子里，每个组件的 Makefile 只会输出组件正在更新的信息，而不会真正的更新组件。
    - 系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。
  - 我们通过这个例子应该可以了解，在 make 的嵌套执行执行的时候的调用子目录的方式，还有子目录再去执行 make 时候的顺序。这是一个很典型的例子，我们的每一个工程文件都可以用上面的结构展示出来，我们只要懂得每一个子目录在被调用时候的顺序，我们就可以很轻松的编写 "总控Makefile" 。

##### 命令的参数和选项

- 我们在在执行 make 命令时，有的时候需要加上一下参数选项来保证我们的程序的执行，其实之前已经遇到过 make 在执行命令的时候需要添加上参数选项，比如只打印命令但不执行使用的参数是 "-n" ，还有只执命令不打印命令的参数选项是 "-s"，包含其它文件的路径参数选项是 "-include"等等。

  | 参数选项                                                     | 功能                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | -b，-m                                                       | 忽略，提供其他版本 make 的兼容性                             |
  | -B，--always-make                                            | 强制重建所有的规则目标，不根据规则的依赖描述决定是否重建目标文件。 |
  | -C DIR，--directory=DIR                                      | 在读取 Makefile 之前，进入到目录 DIR，然后执行 make。当存在多个 "-C" 选项的时候，make 的最终工作目录是第一个目录的相对路径。 |
  | -d                                                           | make 在执行的过程中打印出所有的调试信息，包括 make 认为那些文件需要重建，那些文件需要比较最后的修改时间、比较的结果，重建目标是用的命令，遗憾规则等等。使用 "-d" 选项我们可以看到 make 构造依赖关系链、重建目标过程中的所有的信息。 |
  | --debug[=OPTIONS]                                            | make 执行时输出调试信息，可以使用 "OPTIONS" 控制调试信息的级别。默认是 "OPTIONS=b" ，"OPTIONS" 的可值为以下这些，首字母有效：all、basic、verbose、implicit、jobs、makefile。 |
  | -e，--enveronment -overrides                                 | 使用环境变量定义覆盖 Makefile 中的同名变量定义。             |
  | -f=FILE，--file=FILE， --makefile=FILE                       | 指定文件 "FILE" 为 make 执行的 Makefile 文件                 |
  | -p，--help                                                   | 打印帮助信息。                                               |
  | -i，--ignore-errors                                          | 执行过程中忽略规则命令执行的错误。                           |
  | -I DIR，--include-dir=DIR                                    | 指定包含 Makefile 文件的搜索目录，在Makefile中出现另一个 "include" 文件时，将在 "DIR" 目录下搜索。多个 "-i" 指定目录时，搜索目录按照指定的顺序进行。 |
  | -j [JOBS]，--jobs[=JOBS]                                     | 可指定同时执行的命令数目，爱没有 "-j" 的情况下，执行的命令数目将是系统允许的最大可能数目，存在多个 "-j" 目标时，最后一个目标指定的 JOBS 数有效。 |
  | -k，--keep-going                                             | 执行命令错误时不终止 make 的执行，make 尽最大可能执行所有的命令，直至出现知名的错误才终止。 |
  | -l load，--load-average=[=LOAD]，--max-load[=LOAD]           | 告诉 make 在存在其他任务执行的时候，如果系统负荷超过 "LOAD"，不在启动新的任务。如果没有指定 "LOAD" 的参数 "-l" 选项将取消之前 "-l" 指定的限制。 |
  | -n，--just-print，--dry-run                                  | 只打印执行的命令，但是不执行命令。                           |
  | -o FILE，--old-file=FILE， --assume-old=FILE                 | 指定 "FILE"文件不需要重建，即使是它的依赖已经过期；同时不重建此依赖文件的任何目标。注意：此参数不会通过变量 "MAKEFLAGS" 传递给子目录进程。 |
  | -p，--print-date-base                                        | 命令执行之前，打印出 make 读取的 Makefile 的所有数据，同时打印出 make 的版本信息。如果只需要打印这些数据信息，可以使用 "make -qp" 命令，查看 make 执行之前预设的规则和变量，可使用命令 "make -p -f /dev/null" |
  | -q，-question                                                | 称为 "询问模式" ；不运行任何的命令，并且无输出。make 只返回一个查询状态。返回状态 0 表示没有目标表示重建，返回状态 1 表示存在需要重建的目标，返回状态 2 表示有错误发生。 |
  | -r，--no-builtin-rules                                       | 取消所有的内嵌函数的规则，不过你可以在 Makefile 中使用模式规则来定义规则。同时选项 "-r" 会取消所有后缀规则的隐含后缀列表，同样我们可以在 Makefile 中使用 ".SUFFIXES"，定义我们的后缀名的规则。"-r" 选项不会取消 make 内嵌的隐含变量。 |
  | -R，--no-builtin-variabes                                    | 取消 make 内嵌的隐含变量，不过我们可以在 Makefile 中明确定义某些变量。注意："-R" 和 "-r" 选项同时打开，因为没有了隐含变量，所以隐含规则将失去意义。 |
  | -s，--silent，--quiet                                        | 取消命令执行过程中的打印。                                   |
  | -S，--no-keep-going， --stop                                 | 取消 "-k" 的选项在递归的 make 过程中子 make 通过 "MAKEFLAGS" 变量继承了上层的命令行选项那个。我们可以在子 make 中使用“-S”选项取消上层传递的 "-k" 选项，或者取消系统环境变量 "MAKEFLAGS" 中 "-k"选项。 |
  | -t，--touch                                                  | 和 Linux 的 touch 命令实现功能相同，更新所有的目标文件的时间戳到当前系统时间。防止 make 对所有过时目标文件的重建。 |
  | -v，version                                                  | 查看make的版本信息。                                         |
  | -w，--print-directory                                        | 在 make 进入一个子目录读取 Makefile 之前打印工作目录，这个选项可以帮助我们调试 Makefile，跟踪定位错误。使用 "-C" 选项时默认打开这个选项。 |
  | --no-print-directory                                         | 取消 "-w" 选项。可以是 用在递归的 make 调用的过程中 ，取消 "-C" 参数的默认打开 "-w" 的功能。 |
  | -W FILE，--what-if=FILE， --new-file=FILE， --assume-file=FILE | 设定文件 "FILE" 的时间戳为当前的时间，但不更改文件实际的最后修改时间。此选项主要是为了实现对所有依赖于文件 "FILE" 的目标的强制重建。 |
  | --warn-undefined-variables                                   | 在发现 Makefile 中存在没有定义的变量进行引用时给出告警信息。此功能可以帮助我们在调试一个存在多级嵌套变量引用的复杂 Makefile。但是建议在书写的时候尽量避免超过三级以上的变量嵌套引用。 |

##### 目标类型汇总

- 这个章节主要讲解的是模式规则中的目标。规则中的目标形式是多种多样的，它可以是一个或多个的文件、可以是一个伪目标，这是我们之前讲到过的，也是经常使用的。其实规则目标还可以是其他的类型，下面是对这些类型的详细的说明。

- 强制目标

  - 如果一个目标中没有命令或者是依赖，并且它的目标不是一个存在的文件名，在执行此规则时，目标总会被认为是最新的。就是说：这个规则一旦被执行，make 就认为它的目标已经被更新过。这样的目标在作为一个规则的依赖时，因为依赖总被认为更新过，因此作为依赖在的规则中定义的命令总会被执行。看一个例子：

    ```
    clean:FORCE
        rm $(OBJECTS)
    FORCE:
    ```

  - 这个例子中，目标 "FORCE" 符合上边的条件。它作为目标 "clean" 的依赖，在执行 make 的时候，总被认为更新过。因此 "clean" 所在的规则而在被执行其所定义的那个命令总会被执行。这样的一个目标通常我们将其命名为 "FORCE"。

  - 例子中使用 "FORCE" 目标的效果和将 "clean" 声明为伪目标的效果相同。

- 空目标文件

  - 空目标文件是伪目标的一个变种，此目标所在的规则执行的目的和伪目标相同——通过 make 命令行指定将其作为终极目标来执行此规则所定义的命令。和伪目标不同的是：这个目标可以是一个存在的文件，但文件的具体内容我们并不关心，通常此文件是一个空文件。

  - 空目标文件只是用来记录上一次执行的此规则的命令的时间。在这样的规则中，命令部分都会使用 "touch" 在完成所有的命令之后来更新目标文件的时间戳，记录此规则命令的最后执行时间。make 时通过命令行将此目标作为终极目标，当前目标下如果不存在这个文件，"touch" 会在第一次执行时创建一个的文件。

  - 通常，一个空目标文件应该存在一个或者多个依赖文件。将这个目标作为终极目标，在它所依赖的文件比它更新时，此目标所在的规则的命令行将被执行。就是说如果空目标文件的依赖文件被改变之后，空目标文件所在的规则中定义的命令会被执行。看一个例子：

    ```
    print:foot.c bar.c
        lpr -p $?
        touch print
    ```

    - 执行 "make print" ,当目标文件 "print" 的依赖文件被修改之后，命令 "lpr -p $?" 都会被执行，打印这个被修改的文件。

- 特殊的目标

  | 名称                   | 功能                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | .PHONY:                | 这个目标的所有依赖被作为伪目标。伪目标是这样一个目标：当使用 make 命令行指定此目标时，这个目标所在的规则定义的命令、无论目标文件是否存在都会被无条件执行。 |
  | .SUFFIXES:             | 这个目标的所有依赖指出了一系列在后缀规则中需要检查的后缀名   |
  | .DEFAULT:              | Makefile 中，这个特殊目标所在规则定义的命令，被用在重建那些没有具体规则的目标，就是说一个文件作为某个规则的依赖，却不是另外一个规则的目标时，make 程序无法找到重建此文件的规则，这种情况就执行 ".DEFAULT" 所指定的命令。   一般我们的源文件都会用默认的隐含规则，或者自己定义一个隐含规则，所以源文件不会写在规则的依赖中，一般规则的依赖中只会是一个中间文件.o |
  | .PRECIOUS:             | 这个特殊目标所在的依赖文件在 make 的过程中会被特殊处理：当命令执行的过程中断时，make 不会删除它们。而且如果目标的依赖文件是中间过程文件，同样这些文件不会被删除。 |
  | .INTERMEDIATE:         | 这个特殊目标的依赖文件在 make 执行时被作为中间文件对待。没有任何依赖文件的这个目标没有意义。 |
  | .SECONDARY:            | 这个特殊目标的依赖文件被作为中过程的文件对待。但是这些文件不会被删除。这个目标没有任何依赖文件的含义是：将所有的文件视为中间文件。 |
  | .IGNORE                | 这个目标的依赖文件忽略创建这个文件所执行命令的错误，给此目标指定命令是没有意义的。当此目标没有依赖文件时，将忽略所有命令执行的错误。 |
  | .DELETE_ON_ERROR:      | 如果在 Makefile 中存在特殊的目标 ".DELETE_ON_ERROR" ，make 在执行过程中，荣国规则的命令执行错误，将删除已经被修改的目标文件。 |
  | .LOW_RESOLUTION_TIME:  | 这个目标的依赖文件被 make 认为是低分辨率时间戳文件，给这个目标指定命令是没有意义的。通常的目标都是高分辨率时间戳。 |
  | .SILENT:               | 出现在此目标 ".SILENT" 的依赖文件列表中的文件，make 在创建这些文件时，不打印出此文件所执行的命令。同样，给目标 "SILENT" 指定命令行是没有意义的。 |
  | .EXPORT_ALL_VARIABLES: | 此目标应该作为一个简单的没有依赖的目标，它的功能是将之后的所有变量传递给子 make 进程。 |
  | .NOTPARALLEL:          | Makefile 中如果出现这个特殊目标，则所有的命令按照串行的方式执行，即使是存在 make 的命令行参数 "-j" 。但在递归调用的子make进程中，命令行可以并行执行。此目标不应该有依赖文件，所有出现的依赖文件将会被忽略。 |

  - .DEFAULT实例

    ```
    all:gao
        @echo "final"
    
    .DEFAULT:
    
    	@echo "In default"
    ```

    ```
    由于 gao 是一个前提条件，但是 makefile中没有一个名字为 gao的目的。
    
    所以符合 .DEFAULT 目的的执行条件。
    
    故执行结果为:
    
    In default
    
    final
    
    完毕
    ```

  - 除了上面这种使用，还有另外一种使用就是我们使用make+标签的时候，后面的标签没有定义，此时就直接走.DEFAULT，例如

    ```
    test:main.o                                                                       
       @echo "test"                                                                                        
       g++ -g -o $@ $^                                                                                       
    .DEFAULT:                                                                                      
       @echo "clean"                                                                                     
       rm -rf *.o test
    ```

    - 例如上面有一个main.cpp的文件，直接执行make的时候输出如下

      ```
      g++    -c -o main.o main.cpp
      test
      g++ -g -o test main.o
      ```

      - 第一个是隐含规则编译，然后echo test，最后编译可执行文件。

    - 如果执行make + label ，没有定义的label，都会进到default里面，例如make clean 会走default清空目标文件，make +其他任何的label都会清空目标文件，因为没有定义的label都走到default里面了。

- 多规则目标

  - Makefile 中，一个文件可以作为多个规则的目标。这种情况时，以这个文件为目标的规则的所有依赖文件将会被合并成此目标一个依赖文件列表，当其中的任何一个依赖文件比目标更新时，make 将会执行特定的命令来重建这个目标。

  - 对于一个多规则的目标，重建这个目标的命令只能出现在一个规则中。如果多个规则同时给出重建此目标的命令，make 将使用最后一个规则中所定义的命令，同时提示错误信息。某些情况，需要对相同的目标使用不同的规则中所定义的命令，我们需要使用另一种方式——双冒号规则来实现。

  - 一个仅仅描述依赖关系的描述规则可以用来给出一个或者时多个目标文件的依赖文件。例如，Makefile 中通常存在一个变量，就像我们以前提到的 "objects" ,它定义为所有的需要编译的生成 .o 文件的列表。这些 .o 文件在其源文件中包含的头文件 "config.h" 发生变化之后能够自动的被重建，我们可以使用多目标的方式来书写 Makefile：

    ```
    objects=foo.o bar.o
    foo.o:defs.h
    bar.o:defs.h test.h
    $(objects):config.h
    ```

  - 这样做的好处是：我们可以在源文件增加或者删除了包含的头文件以后不用修改已存在的 Makefile 的规则，只需要增加或者删除某一个 .o 文件依赖的头文件。这种方式很简单也很方便。

  - 我们也可以通过一个变量来增加目标的依赖文件，使用 make 的命令行来指定某一个目标的依赖头文件，例如：

    ```
    extradeps=
    $(objects):$(exteradeps)
    ```

    - 它的意思是：如果我们执 "make exteradeps=foo.h" 那么 "foo.h" 将作为所有的 .o 文件的依赖文件。当然如果只执行 "make" 的话，就没有指定任何文件作为 .o 文件的依赖文件。

##### 控制函数error和warning

- Makefile 中提供了两个控制 make 运行方式的函数。其作用是当 make 执行过程中检测到某些错误时为用户提供消息，并且可以控制 make 执行过程是否继续。这两个函数是 "error" 和 "warning"，我们来详细的介绍一下这两个函数。

```
$(error TEXT...)
```

- 函数说明如下：

  - 函数功能：产生致命错误，并提示 "TEXT..." 信息给用户，并退出 make 的执行。需要说明的是："error" 函数是在函数展开时（函数被调用时）才提示信息并结束 make 进程。因此如果函数出现在命令中或者一个递归的变量定义时，读取 Makefile 时不会出现错误。而只有包含 "error" 函数引用的命令被执行，或者定义中引用此函数的递归变量被展开时，才会提示知名信息 "TEXT..." 同时退出 make。
  - 返回值：空
  - 函数说明："error" 函数一般不出现在直接展开式的变量定义中，否则在 make 读取 Makefile 时将会提示致命错误。

  ```
  ERROR1=1234
  all:
      ifdef ERROR1
      $(error error is $(ERROR1))
      endif     
  ```

  - make 读取解析 Makefile 时，如果所起的变量名是已经定义好的"ERROR1"，make 将会提示致命错误信息 "error is 1234" 并保存退出。

  ```
  ERR=$(error found an error!)
  .PHONY:err
  err:;$(ERR)
  ```

  - 这个例子，在 make 读取 Makefile 时不会出现致命错误。只有目标 "err" 被作为是一个目标被执行时才会出现。

```
$(warning TEXT...)
```

- 函数说明如下：
  - 函数功能：函数 "warning" 类似于函数 "error" ，区别在于它不会导致致命错误（make不退出），而只是提示 "TEXT..."，make 的执行过程继续。
  - 返回值：空
  - 函数说明：用法和 "error" 类似，展开过程相同。

### 后续总结

##### 双冒号规则

- 一个目标可以出现在多个规则中, 但要求所有的规则必须是同一类型: 要么都是普通规则, 要么是双冒号规则. 双冒号规则与单冒号规则是两种明显不同的规则.

- 如果这些相同目标的规则是双冒号的, 则其中任意一条规则相对于另外的同目标规则是独立的:

  - 当一条规则中的目标比该规则中的任何一个依赖旧时, 该规则中的方法就会被执行, 但仅仅限于该规则.
  - 如果该规则中的目标没有依赖, 不管目标存在与否, 该规则的方法总是会被执行, 但也仅仅限于该条规则.
    - 有点类似于伪目标
  - 同目标的双冒号规则彼此之间相互独立, 每一条规则都分开处理, 就像不同目标不同规则被执行一样.这种机制, 能够让相同目标的双冒号规则集合中的任何一条方法执行, 或所有方法都执行, 或所有方法都不执行.

- 注意事项

  - 双冒号规则会按照他们在makefile中出现的顺序来执行, 然而在实际使用中双冒号规则都用在处理顺序无关的的场合.
  - 每一个双冒号规则都要带一个方法, 如果不带的话, 将使用隐含规则.
  - 模式规则带有双冒号时, 将匹配任何满足模式的目标.

- 解决的问题

  - 双冒号规则有点晦涩难懂, 也不常用, 主要用在根据不同的依赖条件来使用不同的方法处理同一个目标.

- 实例

  ```
  Newprog :: foo.c
         $(CC) $(CFLAGS) $< -o $@
  
  Newprog :: bar.c
         $(CC) $(CFLAGS) $< -o $@
  ```

  - 如果“foo.c”文件被修改，执行make以后将根据“foo.c”文件重建目标“Newprog”。而如果“bar.c”被修改那么“Newprog”将根据“bar.c”被重建。回想一下，如果以上两个规则为普通规时出现的情况是什么？（make将会出错并提示错误信息）
  - 当同一个目标出现在多个双冒号规则中时，规则的执行顺序和普通规则的执行顺序一样，按照其在Makefile中的书写顺序执行。
  - GNU make的双冒号规则给我们提供一种根据依赖的更新情况而执行不同的命令来重建同一目标的机制。一般这种需要的情况很少，所以双冒号规则的使用比较罕见。一般双冒号规则都需要定义命令，如果一个双冒号规则没有定义命令，在执行规则时将为其目标自动查找隐含规则。

##### $和$$

- $用的是makefile中的变量，$$用的是规则的命令中定义的shell变量，因为规则中的命令都解析为shell中的语句。所以如果在规则的命令中不是使用makefile的变量，就需要$$来使用shell中的一个$

```
经典示例代码如下所示：
var=3                    # a
target:
       echo $(var)       # b
       var=4             # c
       echo $(var)       # d
       echo $$var        # e
a：定义Makefile中的变量var，值为3
b：打印Makefile中的变量，值为3
c：定义shell命令中的变量var，值为4，Makefile的变量var不受影响
d：打印Makefile中的变量，值为3
e：打印shell命令中的变量。此时var为未定义的变量。

读者可能会奇怪，shell命令中的var明明已经定义了，为什么是未定义呢？
原因：在Makefile的规则命令，如果相互之间没有使用';\'连接起来的话，相互之间是不能共享变量的。
修改示例代码，使用';\'连接shell规则命令行。
var=3                      # a
target:
       echo $(var);\       # b
       var=4;\             # c
       echo $(var);\       # d
       echo $$var
```

- 变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 `$` 符号，但最好用小括号 `()` 或是大括号 `{}` 把变量给包括起来。如果你要使用真实的 `$` 字符，那么你需要用 `$$` 来表示。
- 因为在命令中$$会解释成真实的字符$，相当于在shell中的一个$字符，这时我们就可以用shell中的变量了。如果在命令中还是使用一个$字符，这时还会解释成为Makefile中的变量，这样就不能使用shell变量了。

###### $

- Makefile中的`$`用法和shell中的大体类似，只不过在Makefile中，`$`仅能用于引用Makefile声明的变量，无法引用shell的变量。

- 这里要注意下，使用make命令执行Makefile时并不是shell环境，当执行到Makefile的某个操作时才会执行shell，例：

  ```
  checkstack:
  	$(OBJDUMP) -d vmlinux $$(find . -name '*.ko') | \
  	$(PERL) $(src)/scripts/checkstack.pl $(CHECKSTACK_ARCH)
  
  kernelrelease:
  	@echo "$(KERNELVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))"
  
  kernelversion:
  	@echo $(KERNELVERSION)
  ```

  - makefile中对变量的引用需要使用`$()`这种带括号的方式，否则只会识别`$`后的一个字母
  - 只有执行对应的Makefile命令的shell语句时才会进入shell环境，每行命令独立，每行都是单独的shell，所以上一行定义的shell变量并不适用于下一行。当然如果是使用了`\`来合并行就可以摆脱这个限制了，比如例子中的`checkstack`命令下的shell命令虽然是两行但在同一个shell环境中执行

###### $$

- Makefile命令中的shell语句也并非直接用于shell环境，make会对该语句进行预处理，如果想要引用shell中的变量，就要使用`$`号来把Makefile变量转换成shell变量

- `$$`的用法就是把Makefile引用转化为shell引用，可以理解为此时的`$`是一个转义符，**也可以理解为去掉一个`$`后直接带入shell脚本中**

- 例1

  ```
  LIST = one two three
  all:
  	for i in $(LIST); do \
          echo $i; \
      done
  ```

  - 通过make预处理后转化为shell:

    ```
    for i in one two three; do \
            echo ; \
        done
    
    # 输出为空
    ```

  - 本例中，`$i`和`$(LIST)`会被先当成Makefile变量，`LIST`变量在Makefile中有定义，被转换为了`one two three`，由于`i`变量未在Makefile中定义，所以转化为了空。

- 例2

  ```
  LIST = one two three
  all:
  	for i in $(LIST); do \
          echo $$i; \
      done
  ```

  - 通过make预处理后转化为shell:

    ```
    for i in one two three; do \
            echo $i; \
        done
    
    # 输出为
    # one
    # two
    # three
    ```

  - 例2中，`$$i`命令被make翻译成了shell命令中的`$i`，此时shell脚本可以正常执行，输出正确结果

- 例3

  ```
  help:
  	@echo  '                    (default: $$(INSTALL_MOD_PATH)/lib/firmware)'
  ```

  - 输出结果为(default: $(INSTALL_MOD_PATH)/lib/firmware)
  - Makefile中的`@`符号表示该行shell命令不回显，否则执行时make会把转化后的shell脚本打印一遍
  - `单引号`在shell中表示不执行转义或引用，按照原样字符串输出，此处`$(INSTALL_MOD_PATH)`不会被理解为变量
  - `$$(INSTALL_MOD_PATH)`被翻译成`$(INSTALL_MOD_PATH)`，但由于存在`单引号`，导致shell变量不会被引用

- 例4

  ```makefile
  VERSION = 3
  PATCHLEVEL = 10
  SUBLEVEL = 108
  EXTRAVERSION =
  # kernel 版本号，为四个版本号的组合
  KERNELVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
  # 从shell环境变量中提取shell的执行环境
  CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
  	  else if [ -x /bin/bash ]; then echo /bin/bash; \
  	  else echo sh; fi ; fi)
  # 选取脚本的目录，如果KBUILD_SRC未定义，则选择$(CURDIR)，$(CURDIR)表示当前目录绝对路径
  srctree		:= $(if $(KBUILD_SRC),$(KBUILD_SRC),$(CURDIR))
  KBUILD_VERBOSE = 1
  # 是否在控制台回显，如果有@则不回显
  ifeq ($(KBUILD_VERBOSE),1)
    quiet =
    Q =
  else
    quiet=quiet_
    Q = @
  endif
  
  version:
  	$(Q)echo "$(KERNELVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))" > $@
  
  ```

  - 转化后的shell为：

    ```
    echo "3.10.108$(/bin/bash /root/repo/makefile_test/scripts/setlocalversion /root/repo/makefile_test)" > version
    
    # 假定setlocalversion脚本存在，且会输出一个'+'号，输出结果为：
    # 3.10.108+
    # 该值会被写入version文件
    ```

  - 例4为比较实际的例子，选自linux kernel的makefile中，相关变量的注释已经添加，结合前三个例子应该很好理解


###### 环境变量和定义变量

- Makefile可以直接使用系统环境变量。和使用在makefile中定义的变量用法一样。
  - make运行时的系统环境变量能够在make开始运行时被加载到Makefile文件里，可是假设Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（假设make指定了“-e”參数，那么，系统环境变量将覆盖Makefile中定义的变量）
- 以前的理解，在Makefile中定义一个PATH变量和环境变量重名，此时在makefile中规则的command中可以使用$$来使用环境变量的值，$来使用当前makefile中定义的值。这种理解是错误的，如果这种重名的变量被定义后，只能使用当前的变量，不能使用系统的变量。不能通过$$来使用系统的环境变量
- makefile可以直接使用环境变量，但是我们在规则的command里面定义的变量并不是环境变量，也不是makefile变量，此时就需要$$来获取

###### 实例

```makefile
ifneq (${PROD},)
 check_PROD ?= check_PROD
 PROD_CHECK :=$(filter ${PROD},${PROD_LIST}) #PROD_CHECK => GNAT
 _check_PROD ${check_PROD} ::
	@$${TRACE_TARGET:=:} "-- ${MAKEFILE_ENV}: $@"
	@if [ "${PROD_LIST}" ] && [ "${PROD}" != "${PROD_CHECK}" -o "${PROD}" = "" ] ; then \
	echo " ${MAKE_CMD} Error : wrong PROD value : ${PROD} !!!" ; echo "" ;\
		exit 1 ;\
	fi
endif
```

- @$${TRACE_TARGET:=:} "-- ${MAKEFILE_ENV}: $@"这条语句执行的shell命令，其中$$会解释成一个$，${TRACE_TARGET:=:}是shell脚本中的参数替换，意思为如果没有定义这个变量，则为:冒号，然后是后面的引号里面的内容，如果没有冒号，直接是引号里面的内容会报错，因为在shell中会将其当作一个命令，但是没有这个命令，所以报错，加上冒号之后就不会报错了，因为不将其看作一个命令。冒号就是空命令。
- 这个冒号和后面要有一个空格。

##### 大坑和技巧

###### 术语

- **目标（Target）**：Makefile中用于执行特定任务、生成特定文件的一组程序块，以特定的标识符（目标名加半角冒号）开始，碰到下一个标识符或Makefile语句（如赋值语句、`include`）结束。
- **配方（Recipe）**：目标中用于执行具体操作的程序语句，为shell命令，统一以一个制表符开头。

###### 缩进问题

- 除了Python，Makefile是另一个严格要求缩进的编程语言，把缩进视为语法的一部分。更重要的是，Makefile的缩进有这样的特殊规则，堪比大坑：

  - 缩进只允许用Tab（制表符），不允许用空格。
  - 缩进后的语句一律视为编译目标的一部分，作为shell语句解释。
  - 因此，在Makefile中，用代码缩进增强可读性的方式不管用了。

- 举一个简单的例子：根据变量`ENABLE_OPTIMIZATION`定义与否，给`CFLAGS`赋不同的值。**注意`ifdef`分支下的语句是没有缩进的。**

  ```
  ifdef ENABLE_OPTIMIZATION
  CFLAGS += -O3
  else
  CFLAGS += -g -O0
  endif
  ```

  - 然而，一些像我当时一样的新手可能会觉得可读性不给力，于是习惯性地加上缩进：

  ```
  ifdef ENABLE_OPTIMIZATION
  	CFLAGS += -O3
  else
  	CFLAGS += -g -O0
  endif
  ```

  - 这样做会存在一定的风险。

  - **其一，**如果上例放在文件开头，在一些Make版本中不成问题。我目前的Make版本（`4.3`）仍会正常识别缩进后的赋值语句，而不解释为shell语句。比如这个完整的`Makefile`：

    ```
    ENABLE_OPTIMIZATION := true
    
    ifdef ENABLE_OPTIMIZATION
    	CFLAGS += -O3
    else
    	CFLAGS += -g -O0
    endif
    
    all:
    	@echo $(CFLAGS)
    ```

  - 在终端中运行，结果如下：

    ```
    $ make
    -O3
    $ make ENABLE_OPTIMIZATION=
    -g -O0
    ```

    - 可见结果正常。但无法保证其他版本的Make能正常工作。

  - **其二，**如果上例放在目标当中，条件分支语句仍能正常解析，但被缩进的赋值语句已经被解释成了shell语句，出错是必然的。

    略微修改“其一”中的代码清单，改成：

    ```
    ENABLE_OPTIMIZATION := true
    
    all:
    ifdef ENABLE_OPTIMIZATION
    	CFLAGS += -O3
    else
    	CFLAGS += -g -O0
    endif
    
    	@echo $(CFLAGS)
    ```

  - 在终端中运行，结果如下：

    ```
    $ make
    CFLAGS += -O3
    make: CFLAGS: No such file or directory
    make: *** [Makefile:5: all] Error 127
    ```

    - 可见，Make把那两句`CFLAGS += ...`当作一个配方来解析了，不会给变量`CFLAGS`赋值。

###### 不能在目标中使用赋值等语句

- 接着“第一坑：其二”中的例子，如果要在运行目标`all`时通过条件判断给`CFLAGS`变量赋值，似乎去掉赋值语句前的缩进就可以了：

  ```
  ENABLE_OPTIMIZATION := true
  
  all:
  ifdef ENABLE_OPTIMIZATION
  CFLAGS += -O3
  else
  CFLAGS += -g -O0
  endif
  
  	@echo $(CFLAGS)
  ```

- 但在运行后，却出现了这样的错误：

  ```
  Makefile:10: *** recipe commences before first target.  Stop.
  Makefile:10: *** 配方在第一个目标前开始。 停止。
  ```

- 这是因为在一个目标之下**只能出现配方，而不允许掺杂出现不属于配方的语句（例如赋值语句、`include`语句）**。条件分支语句虽也允许使用，但在目标中**它只能用于控制在不同条件下执行哪些配方**。在编写Makefile时应当尤其注意这一点。

###### 赋值语句的作用域

- 其他编程语言中，变量定义没有溯及既往的效力，即定义一个变量后，该变量定义之前的程序代码是不能使用该变量的。然而，Makefile却有，这非常类似于JavaScript函数的“先使用后定义”。且看下面的例子：

  ```
  all:
  	@echo $(VAR)
  
  VAR := abcdefg
  ```

- 按理来说，变量`VAR`定义在目标`all`之后，运行`make all`应该什么也不会输出。不过，**Makefile的变量允许先使用后定义**，所以运行`all`时，变量`VAR`已经被赋值了，最终是有输出的：

  ```
  $ make all
  abcdefg
  ```

###### 如何保证不再重新生成一个目标（例如文件下载）

- Make能够判断一个目标是否应该重新生成：如果源文件进行了修改，或目标文件被删除，则重新生成；否则保持原样。这个特性能够确保在只修改个别文件时，不至于一股脑儿全都重新编译，有助于保证程序员的工作效率。

- 但是，上述特性似乎只适用于编译，对于一些特殊的场合则不管用。例如编写一个下载文件的目标，让Make在检测到文件存在时不再重新下载：

  ```
  download/test.gz:
  	wget http://somewhere.org/test.gz -O $@    # $@ 为内置变量，自动设为目标名
  ```

- 然而事实上，Make总是会无条件重新生成这个目标，也就是总会重新下载`test.gz`这个文件。实践中，这非常不利于资源利用，同时给网络环境不理想的用户造成了麻烦。

- 有鉴于此，我们应该在该目标中，手动判断文件是否存在，如果不存在则重新下载。修改上述代码清单如下：

  ```
  download/test.gz:
  ifeq (, $(wildcard $@))
  	wget http://somewhere.org/test.gz -O $@    # $@ 为内置变量，自动设为目标名
  endif
  ```

- 这里，`$(wildcard)`函数返回一个文件列表的字符串，可用来判断文件是否存在，不存在则自然返回空值。条件判断语句`ifeq`比较两个表达式是否相等，第一个表达式为空。连起来，则是判断`$(wildcard)`是否返回空值，一旦返回空值，则目标文件不存在，应当重新下载。

- 到此，Make不至于反复重新下载我们需要的文件了。

###### 在Makefile编译目标中使用`cd`等Shell命令

- 在编写一些目标时，有时会需要切换到一个特定目录下进行操作，比如运行某个子目录中子项目的`configure`：

  ```
  build_libuv:
  	cd libuv
  	./configure
  ```

- 但是上面这种写法，一旦运行就直接提示“找不到`./configure`”。这是因为Makefile的目标中，**每一个配方都被视为一个独立的shell脚本，在不同的shell会话中运行**，以便处理并行任务。

- 也正因如此，在使用`cd`等要在同一个shell会话中运行的命令时，应当把它们写在同一行中。就像这样：

  ```
  build_libuv:
  # 第一种写法，用"&&"分隔多个命令
  	cd libuv && ./configure
  # 第二种写法，也可用分号分隔
  	cd libuv; ./configure
  ```

- 也可拆成多行，用反斜杠`\`断行。在书写多条命令或较长命令时会显得非常清爽。

  ```
  build_libuv:
  	cd libuv ; \
  	./configure
  ```

###### 调用子Makefile

- 有些大型的项目包含若干个子项目，每个项目都有自己的`Makefile`。如果想要调用子项目的`Makefile`，正确的做法并不是使用`include`语句，而是用`make`命令。

- 比如，项目`Test`的结构如图所示，包含两个子项目`doc`和`src`：

  ```
  Test/
  ├─doc/
  │ └─Makefile
  ├─Makefile
  └─src/
    └─Makefile
  ```

- 如果想编译`doc`和`src`，则在`Test/Makefile`中编写这样的目标：

  ```
  build_doc:
  	$(MAKE) -C doc
  build_src:
  	$(MAKE) -C src
  ```

- 即，运行一个新的`make`程序，切换到对应目录下并读取其`Makefile`。`$(MAKE)`为内置变量，指向用于运行当前Makefile的`make`命令路径。


###### 变量赋值运算符`=`和`:=`

- 设计Makefile时，如果要判断当前的系统版本，可以调用系统命令`uname`，这里假设用下列变量来存贮该命令的输出，并尝试在它们当中搜索字符串`"Linux"`：

  ```
  UNAME_1	:= `uname -a`
  UNAME_2	= `uname -a` 
  UNAME_3	:= $(shell uname -a)
  UNAME_4	= $(shell uname -a)
  
  all:	
  	@echo $(findstring Linux,$(UNAME_1))
  	@echo $(findstring Linux,$(UNAME_2))
  	@echo $(findstring Linux,$(UNAME_3))
  	@echo $(findstring Linux,$(UNAME_4))
  ```

  ```
  
  
  Linux
  Linux
  ```

  - 只有`UNAME_3 UNAME_4`的值能最终被`$(findstring)`函数正常识别并工作：

- 目前不知道为什么会产生上面这种情况，好像是反引号导致的，反引号的变量在函数当中不能展开，但是反引号的变量能正常输出。

- 在makefile中尽量使用$(shell )这种格式。

##### tab键说明

- 如果是shell命令的话需要有tab键，如果没有tab键会报错缺失分隔符

- Makefile是顺序执行的，在第一个目标之前不能有shell命令，用上面的话说是配方。但是可以有正常的变量赋值什么的

  ```
  ifeq (a, a)
  	test = abc   #makefile中没有字符串一说，变量不需要双引号
  	@echo "abc"   #这个引号因为是shell中的命令，需要加上
  endif
  
  all ：
  	@echo "abc"
  ```

  - 上面这种写法是错误的，因为在第一个目标all出现之前出现了shell命令，如果将ifeq中的echo去掉就正确了。

- 如果上面的ifeq语句出现在all目标里面，也是会出错的，因为目标里面不能有变量的赋值，所以将test去掉就正确了，目标里面可以是语句。

- 上面的理解是错误的，一般shell命令只能出现在目标下面，单独的ifeq这些只能有变量赋值或者makfile函数这些，不能有shell命令。

- 目标下的tab键都会解释成命令。

##### makefile字符串拼接

- makefile中没有字符串的概念，所以不用双引号，用变量时直接赋值就可以了

  ```
  test = abc
  test1 = $(test)123   #abc123
  all : 
  	@echo $(test1)
  ```

  - 上面的test1需要拼接，直接写在一起就行了，不用双引号，也不用特殊的处理。

##### export

- makefile中export可以先用export导出，然后在后面赋值，这样在其他的makefile中也能用

  ```
  export test
  test = 123
  all:
  	$(MAKE) -C src
  ```

  - src中的makefile直接能使用test变量。

##### Makefile中写了很多目标

- Makefile中如果写了很多目标,make命令只会执行第一个目标,将第一个目标当作默认目标来执行,如果后续写了很多目标,这时就需要使用make + 目标名来执行那些目标下面的命令,这些一般是用来打印一些信息,或者是执行一些伪目标类似的东西.这些目标只能是这样make+目标名来执行,直接使用make这些目标不执行.如果这些目标是第一个目标后面的依赖的时候,这些也会执行,如果和第一个目标没有任何联系,这些目标是不会执行的.只能使用make+目标名来执行.

##### define多行变量

- 还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。

- define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以 `Tab` 键开头，那么make 就不会把其认为是命令。

- makefile中的函数

  - make解释器提供了一系列的函数供makefile调用（即预定义函数，相当于库函数）

  - 在makefile中支持自定义函数实现，并调用执行

  - 通过`define`关键字实现自定义函数

  - 自定义的函数一般用于定义命令的集合，并且运用于规则中

  - 自定义函数的语法

    ```
    .PHONY : test
    
    define func1
        @echo "My name is $(0)"
    endef
    
    define func2
        @echo "my name is $(0)"
        @echo "param => $(1)"
    endef
    
    var := $(call func1)    
    new := $(func1)         
    
    test :
        @echo "var => $(var)"   # 输出结果："var => @echo My name is func1"：得到一个多行变量的值
        @echo "new => $(new)"   # 输出结果："new =>  @echo My name is":没有call 即没有函数名，call的作用是将实参替换到 $(0) 的位置
        $(call func1)  #等价于 @echo My name is func1
        $(call func2, jacob)
    ```

    ```
    var =>  @echo My name is func1
    new =>  @echo My name is 
    My name is func1
    my name is func2
    param =>  jacob
    ```

  - 总结：`define`本质上是定义一个**多行变量**，可以在`call`的作用下当作函数来使用，使用时必须**在规则下**，在其它位置使用只能作为多行变量的使用。`call`的作用是将实参替换到 $(0) 的位置。

- 深入理解自定义函数

  - 自定义函数是**一个多行变量**，无法直接调用
  - 自定义函数是**一个过程调用**，没有任何的返回值
  - 自定义函数**用于定义命令集合**，并应用于规则中

- make中的预定义函数

  - make的函数提供了**处理文件名，变量和命令**的函数
  - 可以在需要的地方**调用函数来处理指定的参数**
  - 预定义函数是**有返回值**，函数在**调用的地方被替换为处理结果**
  - 预定义函数就是make解释器定义的函数，和自定义函数是有区别的，一个有返回值一个没有。

- 为什么自定义函数和预定义函数的调用形式完全不同，即自定义函数使用call调用的，其余的直接用函数名

  - makefile中**不支持**真正意义上的自定义函数
  - 自定义函数的**本质是多行变量**
  - 预定义的`call`函数在调用时将参数传递给**多行变量**
  - **自定义函数是`call`函数的实参**，并在`call`中被执行

- 小结

  - make解释器**提供了一系列的函数**供makefile调用
  - 自定义函数是**一个多行变量**，无法直接调用
  - 自定义函数用于**定义命令集合**，并应用于规则中
  - 预定义的`call`函数在调用时**将参数传递给多行变量**
  - **自定义函数是`call`函数的实参**，并在`call`中被执

##### call函数

- call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以call函数来向这个表达式传递参数。其语法是：

  ```
  $(call <expression>,<parm1>,<parm2>,...,<parmn>)
  ```

- 当make执行这个函数时， `<expression>` 参数中的变量，如 `$(1)` 、 `$(2)` 等，会被参数 `<parm1>` 、 `<parm2>` 、 `<parm3>` 依次取代。而 `<expression>` 的返回值就是 call 函数的返回值。例如：

  ```
  reverse =  $(1) $(2)
  
  foo = $(call reverse,a,b)
  ```

- 那么， `foo` 的值就是 `a b` 。当然，参数的次序是可以自定义的，不一定是顺序的，如：

  ```
  reverse =  $(2) $(1)
  
  foo = $(call reverse,a,b)
  ```

  - 此时的 `foo` 的值就是 `b a` 。

- 需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。

- $(0)代表函数名。


##### 隐含规则

- 在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是 `.o` 文件，Windows下是 `.obj` 文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。
- “隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把 `.c` 文件编译成 `.o` 文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的 `.o` 文件。
- “隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量 `CFLAGS` 可以控制编译时的编译器参数。
- 我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。

###### 使用隐含规则

- 如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果 make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：

  ```
  foo : foo.o bar.o
      cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
  ```

- 我们可以注意到，这个Makefile中并没有写下如何生成 `foo.o` 和 `bar.o` 这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。

- make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 `.o` 的目标的依赖文件置成 `.c` ，并使用C的编译命令 `cc –c $(CFLAGS) foo.c` 来生成 `foo.o` 的目标。也就是说，我们完全没有必要写下下面的两条规则：

  ```
  foo.o : foo.c
      cc –c foo.c $(CFLAGS)
  bar.o : bar.c
      cc –c bar.c $(CFLAGS)
  ```

- 因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器 `cc` 生成 `.o` 文件的规则，这就是隐含规则。

- 当然，如果我们为 `.o` 文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。

- 还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：

  ```
  foo.o : foo.p
  ```

- 依赖文件 `foo.p` （Pascal程序的源文件）有可能变得没有意义。如果目录下存在了 `foo.c` 文件，那么我们的隐含规则一样会生效，并会通过 `foo.c` 调用C的编译器生成 `foo.o` 文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成 `foo.o` 的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。

###### 隐含规则一览

- 这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数 `-r` 或 `--no-builtin-rules` 选项来取消所有的预设置的隐含规则。
- 当然，即使是我们指定了 `-r` 参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有 “后缀列表”（也就一系统定义在目标 `.SUFFIXES` 的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。

- 编译C程序的隐含规则。

  `<n>.o` 的目标的依赖目标会自动推导为 `<n>.c` ，并且其生成命令是 `$(CC) –c $(CPPFLAGS) $(CFLAGS)`

- 编译C++程序的隐含规则。

  `<n>.o` 的目标的依赖目标会自动推导为 `<n>.cc` 或是 `<n>.C` ，并且其生成命令是 `$(CXX) –c $(CPPFLAGS) $(CXXFLAGS)` 。（建议使用 `.cc` 作为C++源文件的后缀，而不是 `.C` ）

- 汇编和汇编预处理的隐含规则。

  `<n>.o` 的目标的依赖目标会自动推导为 `<n>.s` ，默认使用编译器 `as` ，并且其生成命令是： `$ (AS) $(ASFLAGS)` 。 `<n>.s` 的目标的依赖目标会自动推导为 `<n>.S` ，默认使用C预编译器 `cpp` ，并且其生成命令是： `$(AS) $(ASFLAGS)` 。

###### 隐含规则使用的变量

- 在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的 `-R` 或 `--no–builtin-variables` 参数来取消你所定义的变量对隐含规则的作用。
- 例如，第一条隐含规则——编译C程序的隐含规则的命令是 `$(CC) –c $(CFLAGS) $(CPPFLAGS)` 。Make默认的编译命令是 `cc` ，如果你把变量 `$(CC)` 重定义成 `gcc` ，把变量 `$(CFLAGS)` 重定义成 `-g` ，那么，隐含规则中的命令全部会以 `gcc –c -g $(CPPFLAGS)` 的样子来执行了。
- 我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如 `CC` ；一种是参数相的关，如 `CFLAGS` 。下面是所有隐含规则中会用到的变量：
- 关于命令的变量
  - `AR` : 函数库打包程序。默认命令是 `ar`
  - `AS` : 汇编语言编译程序。默认命令是 `as`
  - `CC` : C语言编译程序。默认命令是 `cc`
  - `CXX` : C++语言编译程序。默认命令是 `g++`
  - `CO` : 从 RCS文件中扩展文件程序。默认命令是 `co`
  - `CPP` : C程序的预处理器（输出是标准输出设备）。默认命令是 `$(CC) –E`
  - `FC` : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 `f77`
  - `GET` : 从SCCS文件中扩展文件的程序。默认命令是 `get`
  - `LEX` : Lex方法分析器程序（针对于C或Ratfor）。默认命令是 `lex`
  - `PC` : Pascal语言编译程序。默认命令是 `pc`
  - `YACC` : Yacc文法分析器（针对于C程序）。默认命令是 `yacc`
  - `YACCR` : Yacc文法分析器（针对于Ratfor程序）。默认命令是 `yacc –r`
  - `MAKEINFO` : 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 `makeinfo`
  - `TEX` : 从TeX源文件创建TeX DVI文件的程序。默认命令是 `tex`
  - `TEXI2DVI` : 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 `texi2dvi`
  - `WEAVE` : 转换Web到TeX的程序。默认命令是 `weave`
  - `CWEAVE` : 转换C Web 到 TeX的程序。默认命令是 `cweave`
  - `TANGLE` : 转换Web到Pascal语言的程序。默认命令是 `tangle`
  - `CTANGLE` : 转换C Web 到 C。默认命令是 `ctangle`
  - `RM` : 删除文件命令。默认命令是 `rm –f`
- 关于命令参数的变量，下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。
  - `ARFLAGS` : 函数库打包程序AR命令的参数。默认值是 `rv`
  - `ASFLAGS` : 汇编语言编译器参数。（当明显地调用 `.s` 或 `.S` 文件时）
  - `CFLAGS` : C语言编译器参数。
  - `CXXFLAGS` : C++语言编译器参数。
  - `COFLAGS` : RCS命令参数。
  - `CPPFLAGS` : C预处理器参数。（ C 和 Fortran 编译器也会用到）。
  - `FFLAGS` : Fortran语言编译器参数。
  - `GFLAGS` : SCCS “get”程序参数。
  - `LDFLAGS` : 链接器参数。（如： `ld` ）
  - `LFLAGS` : Lex文法分析器参数。
  - `PFLAGS` : Pascal语言编译器参数。
  - `RFLAGS` : Ratfor 程序的Fortran 编译器参数。
  - `YFLAGS` : Yacc文法分析器参数。

###### 隐含规则链

- 有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个 `.o` 的文件生成，可能会是先被 Yacc的[.y]文件先成 `.c` ，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。
- 在上面的例子中，如果文件 `.c` 存在，那么就直接调用C的编译器的隐含规则，如果没有 `.c` 文件，但有一个 `.y` 文件，那么Yacc的隐含规则会被调用，生成 `.c` 文件，然后，再调用C编译的隐含规则最终由 `.c` 生成 `.o` 文件，达到目标。
- 我们把这种 `.c` 的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的 makefile发疯了？
- 在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以 `rm -f` 删除。
- 通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标 `.INTERMEDIATE` 来强制声明。（如： `.INTERMEDIATE : mid` ）
- 你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标 `.SECONDARY` 来强制声明（如： `.SECONDARY : sec` ）。你还可以把你的目标，以模式的方式来指定（如： `%.o` ）成伪目标 `.PRECIOUS` 的依赖目标，以保存被隐含规则所生成的中间文件。
- 在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。
- Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件 `foo.c` 生成目标程序 `foo` ，按道理，make会编译生成中间文件 `foo.o` ，然后链接成 `foo` ，但在实际情况下，这一动作可以被一条 `cc` 的命令完成（ `cc –o foo foo.c` ），于是优化过的规则就不会生成中间文件。

###### 定义模式规则

- 你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 `%` 字符。 `%` 的意思是表示一个或多个任意字符。在依赖目标中同样可以使用 `%` ，只是依赖目标中的 `%` 的取值，取决于其目标。

- 有一点需要注意的是， `%` 的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入 Makefile时，而模式规则中的 `%` 则发生在运行时。

- 模式规则介绍

  - 模式规则中，至少在规则的目标定义中要包含 `%` ，否则，就是一般的规则。目标中的 `%` 定义表示对文件名的匹配， `%` 表示长度任意的非空字符串。例如： `%.c` 表示以 `.c` 结尾的文件名（文件名的长度至少为3），而 `s.%.c` 则表示以 `s.` 开头， `.c` 结尾的文件名（文件名的长度至少为5）。

  - 如果 `%` 定义在目标中，那么，目标中的 `%` 的值决定了依赖目标中的 `%` 的值，也就是说，目标中的模式的 `%` 决定了依赖目标中 `%` 的样子。例如有一个模式规则如下：

    ```
    %.o : %.c ; <command ......>;
    ```

  - 其含义是，指出了怎么从所有的 `.c` 文件生成相应的 `.o` 文件的规则。如果要生成的目标是 `a.o b.o` ，那么 `%c` 就是 `a.c b.c` 。

  - 一旦依赖目标中的 `%` 模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。

- 模式规则示例

  - 下面这个例子表示了,把所有的 `.c` 文件都编译成 `.o` 文件.

    ```
    %.o : %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
    ```

    - 其中， `$@` 表示所有的目标的挨个值， `$<` 表示了所有依赖目标的挨个值。这些奇怪的变量我们叫“自动化变量”，后面会详细讲述。

  - 下面的这个例子中有两个目标是模式的：

    ```
    %.tab.c %.tab.h: %.y
        bison -d $<
    ```

    - 这条规则告诉make把所有的 `.y` 文件都以 `bison -d <n>.y` 执行，然后生成 `<n>.tab.c` 和 `<n>.tab.h` 文件。（其中， `<n>` 表示一个任意字符串）。如果我们的执行程序 `foo` 依赖于文件 `parse.tab.o` 和 `scan.o` ，并且文件 `scan.o` 依赖于文件 `parse.tab.h` ，如果 `parse.y` 文件被更新了，那么根据上述的规则， `bison -d parse.y` 就会被执行一次，于是， `parse.tab.o` 和 `scan.o` 的依赖文件就齐了。（假设， `parse.tab.o` 由 `parse.tab.c` 生成，和 `scan.o` 由 `scan.c` 生成，而 `foo` 由 `parse.tab.o` 和 `scan.o` 链接生成，而且 `foo` 和其 `.o` 文件的依赖关系也写好，那么，所有的目标都会得到满足）

- 自动化变量

  - 在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。

  - 自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。

  - `$@` : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， `$@` 就是匹配于目标中模式定义的集合。

  - `$%` : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 `foo.a(bar.o)` ，那么， `$%` 就是 `bar.o` ， `$@` 就是 `foo.a` 。如果目标不是函数库文件（Unix下是 `.a` ，Windows下是 `.lib` ），那么，其值为空。

  - `$<` : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 `%` ）定义的，那么 `$<` 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。

  - `$?` : 所有比目标新的依赖目标的集合。以空格分隔。

  - `$^` : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。

  - `$+` : 这个变量很像 `$^` ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。

  - `$*` : 这个变量表示目标模式中 `%` 及其之前的部分。如果目标是 `dir/a.foo.b` ，并且目标的模式是 `a.%.b` ，那么， `$*` 的值就是 `dir/foo` 。这个变量对于构造有关联的文件名是比较有效。如果目标中没有模式的定义，那么 `$*` 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 `$*` 就是除了后缀的那一部分。例如：如果目标是 `foo.c` ，因为 `.c` 是make所能识别的后缀名，所以， `$*` 的值就是 `foo` 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 `$*` ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 `$*` 就是空值。

  - 当你希望只对更新过的依赖文件进行操作时， `$?` 在显式规则中很有用，例如，假设有一个函数库文件叫 `lib` ，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：

    ```
    lib : foo.o bar.o lose.o win.o
        ar r lib $?
    ```

  - 在上述所列出来的自动量变量中。四个变量（ `$@` 、 `$<` 、 `$%` 、 `$*` ）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 `D` 或 `F` 字样。这是GNU make中老版本的特性，在新版本中，我们使用函数 `dir` 或 `notdir` 就可以做到了。 `D` 的含义就是Directory，就是目录， `F` 的含义就是File，就是文件。

    ```
    $(@D)
    表示 $@ 的目录部分（不以斜杠作为结尾），如果 $@ 值是 dir/foo.o ，那么 $(@D) 就是 dir ，而如果 $@ 中没有包含斜杠的话，其值就是 . （当前目录）。
    
    $(@F)
    表示 $@ 的文件部分，如果 $@ 值是 dir/foo.o ，那么 $(@F) 就是 foo.o ， $(@F) 相当于函数 $(notdir $@) 。
    
    $(*D), $(*F)
    和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， $(*D) 返回 dir ，而 $(*F) 返回 foo
    
    $(%D), $(%F)
    分别表示了函数包文件成员的目录部分和文件部分。这对于形同 archive(member) 形式的目标中的 member 中包含了不同的目录很有用。
    
    $(<D), $(<F)
    分别表示依赖文件的目录部分和文件部分。
    
    $(^D), $(^F)
    分别表示所有依赖文件的目录部分和文件部分。（无相同的）
    
    $(+D), $(+F)
    分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）
    
    $(?D), $(?F)
    分别表示被更新的依赖文件的目录部分和文件部分。
    ```

###### 模式的匹配

- 一般来说，一个目标的模式有一个有前缀或是后缀的 `%` ，或是没有前后缀，直接就是一个 `%` 。因为 `%` 代表一个或多个字符，所以在定义好了的模式中，我们把 `%` 所匹配的内容叫做“茎”，例如 `%.c` 所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有 `%` 时，依赖目标的“茎”会传给目标，当做目标中的“茎”。
- 当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式 `e%t` ，文件 `src/eat` 匹配于该模式，于是 `src/a` 就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 `c%r` ，那么，目标就是 `src/car` 。（“茎”被传递）

###### 重载内建隐含规则

- 你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：

  ```
  %.o : %.c
      $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)
  ```

- 你可以取消内建的隐含规则，只要不在后面写命令就行。如：

  ```
  %.o : %.s
  ```

- 同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。

###### 老式风格的后缀规则

- 后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：“双后缀”和“单后缀”。

  双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如 `.c.o` 相当于 `%o : %c` 。单后缀规则只定义一个后缀，也就是源文件的后缀。如 `.c` 相当于 `% : %.c` 。

- 后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如： `.c` 和 `.o` 都是make所知道。因而，如果你定义了一个规则是 `.c.o` 那么其就是双后缀规则，意义就是 `.c` 是源文件的后缀， `.o` 是目标文件的后缀。如下示例：

  ```
  .c.o:
      $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
  ```

- 后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：

  ```
  .c.o: foo.h
      $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
  ```

- 这个例子，就是说，文件 `.c.o` 依赖于文件 `foo.h` ，而不是我们想要的这样：

  ```
  %.o: %.c foo.h
      $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
  ```

- 后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。

- 而要让make知道一些特定的后缀，我们可以使用伪目标 `.SUFFIXES` 来定义或是删除，如：

  ```
  .SUFFIXES: .hack .win
  ```

- 把后缀 `.hack` 和 `.win` 加入后缀列表中的末尾。

  ```
  .SUFFIXES:              # 删除默认的后缀
  .SUFFIXES: .c .o .h   # 定义自己的后缀
  ```

  - 先清除默认后缀，后定义自己的后缀列表。

- make的参数 `-r` 或 `-no-builtin-rules` 也会使用得默认的后缀列表为空。而变量 `SUFFIXE` 被用来定义默认的后缀列表，你可以用 `.SUFFIXES` 来改变后缀列表，但请不要改变变量 `SUFFIXE` 的值。

###### 隐含规则搜索算法

- 比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是 `archive(member)` 的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把 `member` 当作T来搜索。
  1. 把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是 `src/foo.o` ，那么，D就是 `src/` ，N就是 `foo.o` ）
  2. 创建所有匹配于T或是N的模式规则列表。
  3. 如果在模式规则列表中有匹配所有文件的模式，如 `%` ，那么从列表中移除其它的模式。
  4. 移除列表中没有命令的规则。
  5. 对于第一个在列表中的模式规则：
     1. 推导其“茎”S，S应该是T或是N匹配于模式中 `%` 非空的部分。
     2. 计算依赖文件。把依赖文件中的 `%` 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。
     3. 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）
     4. 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。
  6. 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：
     1. 如果规则是终止规则，那就忽略它，继续下一条模式规则。
     2. 计算依赖文件。（同第5步）
     3. 测试所有的依赖文件是否存在或是理当存在。
     4. 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。
     5. 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。
     6. 如果没有隐含规则可以使用，查看 `.DEFAULT` 规则，如果有，采用，把 `.DEFAULT` 的命令给T使用。
- 一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。

##### %和*区别

- *号是通配符，通配符代替了你一系列的文件，如 *.c 表示所有后缀为c的文件
- % 的意思是匹配零或若干字符
- 在模式规则或一些规则中，我们并不是匹配文件，而是代替字符，所以需要用%
