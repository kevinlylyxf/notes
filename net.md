### 网络传输

- 网络数据传输：

    [知乎上讲的传输过程，包括交换机、路由器](https://www.zhihu.com/question/21546408)

    - 应用层（各种各样的应用服务，例如http，https等各种应用服务），应用层里面我们输入URL，可以看出具体使用什么协议来传输数据，http://www.baidu.com， ，可以看出是使用http传输数据，产生请求报文

    - 传输层TCP、UDP。TCP是一个协议叫传输控制协议。TCP拿到数据之后要做的是将数据分成一个一个的数据包，主要是为了数据的安全稳定。因为这样不容易被监听，监听需要将所有的数据包都拿到。

      - tcp协议头加上之后会传输到IP层，IP层会加上IP协议头，这是两个不同的协议，所干的工作也不同

        <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/127a3ac57e1a40c5bb459f9eed44efe5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" style="zoom:67%;" />

      <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89142dbacdae4285a2e4aba99d94841a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" style="zoom:67%;" />

      - IP协议头

        ![](https://img-blog.csdn.net/20171118172527691?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjkzNDQ3NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

    - 网络层IP。IP模块拿到TCP数据后，加上IP头信息，其中包含了IP地址。通过这个IP地址，就知道数据传输方向，从而找到下一个路由器的MAC地址。主要设备是路由器。ARP解析也是在这里完成的，ARP表也是在路由器里保存。

      - 分组（packet）是网络传输中的二进制格式单元，数据包（datapacket）是TCP/IP通信协议传输中的数据单位；通过网络传输的数据基本单元，包含一个报头和数据本身，其中报头描述了数据的目的地及其与其他数据之间的关系，可以理解为数据传输的分组，我们将通过网络传输的基本数据单元称为数据报（Datagram）

    - 数据链路层。是负责网络在现实世界的一个表现。主要功能是数据包分帧，物理寻址。数据链路层在拿到数据包之后，增加MAC头部信息，转换成光电信号。主要设备是网卡。MAC是网卡独一无二的身份认证。MAC头部有目的主机IP的MAC地址。其MAC地址由ARP协议转换目标主机IP为目标主机MAC地址。

      - 网卡的功能主要有两个: 一是将电脑的数据封装为帧，并通过网线(对无线网络来说就是电磁波)将数据发送到网络上去; 二是接收网络上其它设备传过来的帧，并将帧重新组合成数据，发送到所在的电脑中。 网卡能接收所有在网络上传输的信号，但正常情况下只接受发送到该电脑的帧和广播帧，将其余的帧丢弃。
          - 发送时将上一层传递来的数据加上首部和尾部，成为[以太网](https://baike.baidu.com/item/以太网/99684?fromModule=lemma_inlink)的帧。接收时将以太网的帧剥去首部和尾部，然后送交上一层
          - 网卡不具备模拟信号与光电信号的转换，这种转换是光猫来完成的。
      - 无论任何报文，在数据链路层都是分割成帧的，你只要在Linux下ifconfig一下，你会发现每个口都有一个参数叫MTU，什么意思呢？最大传输单元，意思即每个链路层报文所能够达到的最大长度，那么如果你在tcp中一次读写长度超过了这个值，到[链路层](https://www.zhihu.com/search?q=链路层&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A30064298})都会分割为长度小于MTU的单元。即分割为帧
      - 数据链路层定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：[ATM](https://baike.baidu.com/item/ATM/8133555)，[FDDI](https://baike.baidu.com/item/FDDI/572177)等。数据链路层必须具备一系列相应的[功能](https://baike.baidu.com/item/功能/10346898)，主要有：如何将数据组合成[数据块](https://baike.baidu.com/item/数据块/107672)，在数据链路层中称这种数据块为[帧](https://baike.baidu.com/item/帧/460387)，帧是数据链路层的传送单位；如何控制帧在[物理信道](https://baike.baidu.com/item/物理信道/3288982)上的传输，包括如何处理传输差错，如何调节发送[速率](https://baike.baidu.com/item/速率/1181335)以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。

    - 物理层。就是光纤这类实际的传输信息的载体。

- ARP地址解析协议，是一个通过解析网络层地址来寻找数据链路层地址的网络传输协议。

    - ARP是在网络层设备实现的，即路由器来实现的。
    - 同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。这是同一局域网内的
    - 当发送主机和目的主机不在同一个局域网中时，即便知道对方的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或ARP代理（ARP Proxy）。路由器在转发过程中并不知道路径，只知道下一个MAC地址。所以如果还需要转发，其MAC头就是下一个路由器的MAC地址，层层转发最后到目的IP的网卡。这一路过来每一层转发下MAC头部信息都是下一层的MAC地址，而不是最终的MAC地址。路由器工作在网络层，其主要功能是寻找最快的数据传输路径，就是寻找那个路由器可以使数据传输最快。网卡加的MAC头是目的IP的MAC地址。数据到达路由器后会脱掉MAC头，经过路由器转发后会加上下一级的MAC头，其是经过ARP代理实现的。
    - 每个路由器前面都加着光猫，都有光电信号和模拟信号转换。所有路由器在转发加下一级MAC头的时候会先进行信号转换，此时信号就是模拟信号，然后就可以修改MAC头。

- 关于IP头和MAC是在哪里加上和卸掉的问题

    - 最开始的IP头和MAC头是操作系统加上的，因为IP头中的源地址和目的地址IP操作系统就知道，可以直接加上，MAC地址头会在检查完IP地址是否在一个子网内加上，如果不在一个子网内就直接写上默认网关的MAC地址，即路由器的MAC地址。加上MAC头之后，由网卡进行数据分帧，加上以太网头发送出去。数据在TCP上是一个大的数据包，然后在网卡这里在分成帧。
    - 网卡收到信息后，将收到的帧拼接成一个大的数据包。然后在发给上一层，操作系统会卸掉IP地址和TCP头，然后交给应用层。


#### 其他

- 网关是设备与路由器之间的桥梁，正确的网关配置才能保证用户可以正常上网。 在一般的路由器网络中，默认网关最常见的一般是：192.168.1.1和192.168.0.1，也就是路由器LAN接口的默认IP地址。网关就是路由器的IP地址，这个地址和内网IP外网IP不是一回事。默认网关就是路由器找不到可用的网关就发送给默认网关。数据到网关就是数据到路由器的意思。为什么有网关，因为有的路由器他可以设置为没有路由功能只是无线AP，所以连接他的设备的网关是上一级路由的网关，其没有网关。这样可以增加网络的可使用性。

- B=byte=8bit,MB=8Mb,网络带宽300Mb，而我们说的传输速度说的是MB，所以传输速度为带宽/8，speedtest测出来的速度为Mb，所以有时候可以基本跑满带宽。千兆网口意思是传输速度可以达到1000Mb，所以带宽100以上要用千兆网口才能跑满带宽。千兆网口要用六类双绞网线才能跑满带宽。

- IP地址分为A、B、C类，公网IP是有限的，要分给好多个国家，每个国家都有自己的宽带运营商，所以运营商把公网IP连进来，然后通过路由器、交换机和网关这类技术弄成子网（网关是一个概念，路由器是一种设备，路由器有网关功能。路由器下面接路由器可以，但是一般用交换机来组成子网，交换机主要起分时复用的功能。一个网线进来用交换机来分出来很多，然后在网线上接路由器分子网。子网掩码就是来区分子网的，子网掩码下的IP地址都是可以直接通信的。可以将同一路由器下的子网掩码设置的不同来区分子网。）（多级路由也可以形成更大的子网，链接不同层级的路由器，但是速度会很慢，每经过一个路由就会有一次数据转发。一般用交换机和路由器来进行组成更大的子网，这样就不会很慢。网线进来的带宽是一样的，不管怎么分也不会突破这个限制。交换机也一样。），子网在通过交换机、路由器网关这类技术弄成小子网，一直这样进行下去，连到家里就是很多个子网的子网，数据传输的时候，家里路由器就会依次往上连接子网，路由->网关这类，如果需要连接外网就会通过公网IP发送数据出去，不需要外网数据就会在内网之间传输。

- 无线AP就是无线接入点，是将有线网络转化为无线网络组成子网，而路由器是有线网络和无线网络组成的一个子网，两者的应用场景不一样，无线AP用在大型的网络上面，只需要无线网络，而路由器用在家庭当中无线有线都能用,简单来说无线AP就是一个wifi信号收发器，相当于去掉了路由和管理功能的无线路由器，其不需要电源供电，网线供电。无线AP相当于无线交换机作为网络的延伸，（交换机就是一转多，每个都能享受到光电转换，但是每个转换出来的口都得经过这个原来的口），无线AP相当于路由器给了它一个接口，他用这个接口相当于无线交换机连接更多的设备，而每个设备都是通过无线交换机和主路由进行数据传输，所以它的IP是固定的，和主路由在一个网段。
  ![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/daliy/apac.png)

- WAN口和LAN口的作用和区别：简单来说WAN口用于外网（以太网），LAN口用于内网，例如要连接宽带运营商，可以用WAN口拉网线到光猫上去，LAN口连接你自己的设备，如笔记本，台式机，路由器，当WAN口连上外网，LAN端口上的各个设备和路由器一起组装成一个小型局域网，这个局域网内的设备可以互相发现，访问。无线路由器配置的WIFI相当于LAN端口，连接自己的无线设备，手机/ipad等。
  ![](https://raw.githubusercontent.com/kevinlylyxf/notes/master/pictures/daliy/wanlan.png)
    WAN口连接的就相当于另外一个局域网，不能互相访问，但是通过LAN口可以。

- 路由就是通过互联的网络把信息从原地址传输到目的地址的活动。路由发生在OSI网络参考模型中的第三层即网络层。路由引导分组转送，经过一些中间节点后，到他们最后的目的地。作为硬件的话，则成为路由器。简单来说路由器就是传输数据的，他可以引导传送到哪，而千兆网口只是数据传送的物理实现，不能引导数据传送。

- 网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1-192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1-192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）与主机的IP 地址作 “与” 运算的结果不同判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用都是路由来接入网络，因此通常指的网关就是路由器的IP！因为通过路由器可以找到局域网里的设备主机。简单来说网关就是一个门，你要找到门里面的设备就要通过这个门，一般的网络通过路由器连接，所以这个门就是路由器的IP地址。在数据传输的时候，最底层的网络通过路由器访问上一层的网关，如果需要访问网关下面的设备，就通过网关访问，如果需要在访问上层的网络，就通过网关访问上层的网关。

- DHCP动态主机配置协议，是一个局域网的网络协议，指的是由服务器控制一段IP地址范围，局域网内主机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。在LAN口中取消DHCP功能，此时LAN口不能和其他路由器WAN口相连，只相当于交换机，其wifi功能也类似。

- NAT（网络地址转换协议）主要用于将内网的主机与因特网上的主机通信，意思是将内网上的私有IP地址转化为公网IP地址与外界进行通信。NAT使数据传输速度降低，但是没有办法。IPV6就不需要NAT了。NAT一般和端口映射一起使用。端口映射就是将外网的端口映射到内网，这样访问外网时就访问到内网的主机的端口。

- 子网掩码又叫网络掩码、地址掩码、子网络遮罩，用来指明一个IP地址哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码只有一个作用，就是将某个IP地址划分为网络地址和主机地址两部分。简单来说子网掩码就是用来划分子网的网段和遮掩部分IP地址，遮掩的部分IP地址就是子网内的主机地址，我们不需要知道子网内的主机号，我们只需要根据子网掩码划分出来的子网网段就可以知道当前子网的网段，里面的主机可以通信。两个IP地址进行通信时，通过IP地址与子网掩码进行与操作就可以知道网段是否一样。子网掩码从外面来看就是将子网遮盖住，外面只看到一个网段，这样更有利于IP地址统一。就是相当于将子网都掩盖起来了，只留下子网网段。子网掩码一共32位，其中1和0必须是连续的，1的位数指示了子网网段，0的位数指示了子网的主机号。子网掩码和IP地址一起时，就把后面的主机位屏蔽了，只留下了子网网段，从外面看就是一个网络。

- [2.4G和5G频段的理解](https://www.bilibili.com/read/cv1719200/),2.4G共83.5M带宽，分13个信道，每个信道20M，其中有重叠，5G共900多M带宽，信道多，带宽大，干扰小。当某一地区信道干扰大时就需要换信道，减小网络之间的互相影响。在网络信号不多的环境下，我们可以选择增大信道的带宽，比如从20M扩大到40M，此时下载速率就会提高，跟宽带大了速度就变快了一个道理。,2.4G共83.5M带宽，分13个信道，每个信道20M，其中有重叠，5G共900多M带宽，信道多，带宽大，干扰小。当某一地区信道干扰大时就需要换信道，减小网络之间的互相影响。在网络信号不多的环境下，我们可以选择增大信道的带宽，比如从20M扩大到40M，此时下载速率就会提高，跟宽带大了速度就变快了一个道理。5G频段高，携带数据更多，比2.4G更快。

- 光猫在默认情况下是路由模式，其除了将光信号转化为网络信号还要拨号进行路由功能，通过WAN口连接可以划分一个新的网段给终端，转化NAT，寻找路由表，进行数据的传输，如果将光猫转化为桥接模式，光猫只负责将光信号转化为网络信号，不进行拨号，拨号功能由无线路由器来进行。这样设置的好处为光猫没有路由功能，整个网络只进行了一次路由，网络速度更快。

- 交换机理解。交换机就是将一个端口分成多个端口，类似于原来只有一根网线，现在多人要同时上网，就需要用交换机将一个多口分成多个端口供大家上网，但是原来的那一个端口带宽有限，所有的设备分享那一个带宽速度。

- 路由器可以给局域网自动自动分配IP地址、虚拟拨号，交换机只是用来分配网络数据的，所以将路由器设置成无线交换机或无线AP模式，路由器就相当于少了一次路由，速度更快

- 多级路由的作用是形成更大的子网，连接更多的设备，例如一个区域中有很多设备需要联网，此时一个路由器通过WAN口连接外网，网络中设备很多，就需要通过LAN口连接下一级路由，此时下一级路由可以分配一个新的网段，，一个路由器有很多LAN口，可以接很多路由器，连接更多的设备，如果LAN口不够时，也可以通过交换机多出LAN口来接更多的路由器，但是分出来的设备共享带宽，所以外面的带宽就要很大。如果两级路由不够的话，还可以通过两级路由的LAN口连接三级路由的WAN口来扩展，此时三级路由也会分配新的网段，如此下去。以上述三级路由为例，每层路由都会分配地址形成新的网段，每层路由都会有路由的功能，进行数据的转发，这样速度就会下降。如果区域中没有很多设备，此时一级路由就够了，只需要有设备进行数据的转发，二级路由不需要进行数据的转发，只需要充当无线AP的功能就可以了。在实际中，光猫设置了路由功能，无线路由器只需要设置为无线AP模式或无线交换机模式就可以了。无线交换机和有线交换机类似，也是为了连接更多的设备，但是需要共享带宽。一个路由器一次路由就有一个网关，外面的设备访问就需要过网关。一个路由器相当于一个子网，其网关和路由器的IP地址一样。洋葱那个R2S中如果将光猫设置成桥接，其路由功能由R2S来实现。如果不是类似于R2S的设备需要三级连接。只有光猫和无线路由器两个设备，其中有一个需要设置为路由模式进行路由功能,其中的路由器是刷了系统了也就没有了原来自带的AP模式什么的了，肯定带有路由功能。

- 桥接：桥接器是用于在两个或多个网段或子网间提供通信路径的互联设备。通俗来讲就是将多个子网连接到一起，形成一个子网。例如无线桥接，在家庭中一个路由器覆盖范围不够，需要扩大覆盖范围，此时就需要桥接，两个路由器在一个子网内，通过WDS将两个路由器桥接到一起，扩大信号覆盖范围。无线AP模式也需要网线的连接，而无线桥接不要有线的连接，只需要将第二个路由器连接上第一个路由器的wifi即可。光猫桥接也是类似的原理，光猫桥接之后路由器连接的设备都在一个子网内，要不然会进行两层路由，即使第二层路由设置为无线AP模式，光猫的路由功能也不理想，影响网络的速度。

- 内网穿透，反向代理的主要是用来作内网穿透，其实就是利用 VPS 访问不具有公网 IP 的内网服务器。具体的例子是，家里有一台 NAS，因为没有公网 IP，正常情况下在外面（离开了家里的网络）没法直接访问这台 NAS，但是通过反向代理就可以。简单来说就是在外面访问自己建设的内网的IP地址，比如内网设备NAS，或内网设备上运行着网站什么的。

- 透明代理透明网关，普通的家用路由器本就是一个网关。使用网关翻墙可以使局域网内的所有设备都具有直接翻墙的能力，并且能够全局代理，而不必每台设备都安装 V2Ray，配置更新时只需在网关修改配置。

- 正向代理反向代理透明代理：代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。
    - 正向代理就是局域网内的设备要访问外面都通过一个中间服务器来访问，访问得到的数据通过中间服务器传回。所有的数据都通过代理服务器来传输。
    - 反向代理:服务器根据客户端的请求，从其关系的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器集群的存在。这种用于负载均衡。若服务器集群中有负荷较高者，反向代理通过URL重写，根据连线请求从负荷较低者获取与所需相同的资源或备援。
    - 透明代理：透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改变你的request fields（报文），并会传送真实IP，多用于路由器的NAT转发中。防火墙作为实际存在的物理设备，其本身也起到路由的作用，所以在为用户安装防火墙时，就需要考虑如何改动其原有的网络拓扑结构或修改连接防火墙的路由表，以适应用户的实际需要，这样就增加了工作的复杂程度和难度。但如果防火墙采用了透明模式，即采用无IP方式运行，用户将不必重新设定和修改路由，防火墙就可以直接安装和放置到网络中使用，如交换机一样不需要设置IP地址。透明模式的防火墙就好象是一台网桥(非透明的防火墙好象一台路由器)，网络设备(包括主机、路由器、工作站等)和所有计算机的设置（包括IP地址和网关）无须改变，同时解析所有通过它的数据包，既增加了网络的安全性，又降低了用户管理的复杂程度。防火墙使用透明代理技术，这些代理服务对用户也是透明的，用户意识不到防火墙的存在，便可完成内外网络的通讯。当内部用户需要使用透明代理访问外部资源时，用户不需要进行设置，代理服务器会建立透明的通道，让用户直接与外界通信，这样极大地方便了用户的使用。一般使用代理服务器时，每个用户需要在客户端程序中指明要使用代理，自行设置Proxy参数（如在浏览器中有专门的设置来指明HTTP或FTP等的代理）。而透明代理服务，用户不需要任何设置就可以使用代理服务器，简化了网络的设置过程。透明代理的原理如下：假设A为内部网络客户机，B为外部网络服务器，C为防火墙。当A对B有连接请求时，TCP连接请求被防火墙截取并加以监控。截取后当发现连接需要使用代理服务器时，A和C之间首先建立连接，然后防火墙建立相应的代理服务通道与目标B建立连接，由此通过代理服务器建立A 和目标地址B的数据传输途径。从用户的角度看，A和B的连接是直接的，而实际上A 是通过代理服务器C和B建立连接的。反之，当B对A有连接请求时原理相同。由于这些连接过程是自动的，不需要客户端手工配置代理服务器，甚至用户根本不知道代理服务器的存在，因而对用户来说是透明的。网关翻墙就是使用透明代理，网关翻墙可以使局域网内的所有设备都具有直接翻墙的能力，并且能够全局代理，而不必每台设备都安装 V2Ray，配置更新时只需在网关修改配置，用一些网友的话说就是就感觉没有墙一样。例如mac下的surge，我们只需要连上mac的wifi，其余的翻墙的工作由mac做，我们感受不到翻墙的过程，这就是透明的意思。透明就是我们不需要额外的操作，只需要最简单的操作就能得到复杂的结果，这个过程由代理服务器来干，对我们来说是透明的。透明代理也是由代理服务器的，只是操作是透明的。

- 防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。

- 旁路由，旁路由是和主路由相对的概念，当主路由功能较为强大时，其运行压力比较大，此时就需要旁路由来运行主路由的一些服务，减轻主路由的压力，旁路由的处理数据会转发到主路由，此时连接一个路由器就得到了两个路由器的功能，其设置参考网络，其中有网关和IP地址、DHCP的设置。主路由和旁路由通过LAN口连接，没有经过WAN口，两个路由在一个子网上。旁路由还有一个应用就是当主路由不想动时，但又想用一个功能，此时就需要旁路由。我们也可以通过设置让设备连接旁路由的wifi，此时就相当于旁路由是一个主路由，前面的路由器只是收发数据用的。旁路由也就是透明网关，网关是一个子网的大门，旁路由没有添加子网，所以其没有网关，也就是透明网关。只有主路由一个网关。也可以设置两个路由器都能上网，但是功能不一样，我们可以让旁路由多一些科学上网的功能。

- 主路由LAN口后面接一个无线AP，相当于在一个子网内，只要没有接路由器WAN口进行路由功能，就在一个子网内，上述旁路由虽然有两级路由，但是没有通过WAN口来连接，其数据还是在一个子网内。


#### 小米路由器设置

- 在主路由上接出来一个路由器作为旁路由时，旁路由需要接在主路由的LAN口上，如果主路由设置了开启DHCP服务器，这时旁路由就会自动获取到IP地址，旁路由也设置开启DHCP功能，这样就能使用了，如果主路由没有开启DHCP功能，这时旁路由就需要自己配置静态IP，此时的静态IP需要在主路由的子网里面。
- 路由器的静态配置IP是需要配置IP地址，网关，子网掩码，DNS等设置的，DHCP自动获取的IP是不需要配置的，因为其在网关的子网路面，IP是自动获取的，子网掩码和网关都是自动获取和网关设置的一样，旁路由的网关和子网掩码设置的要和主路由一样，IP是在子网里面，这样才能使用，如果是旁路由静态配置，此时的设置需要自己设置，子网掩码和网关都要设置的和主路由一样才能使用，其中的IP根据子网掩码设置为子网的网段
  - IP的设置，例如小米路由器的默认网关是192.168.31.1，子网掩码为255.255.255.0，相当于可以配置256个设备在一个子网里面，此时我们的IP配置就应该是192.168.31-1~255，这样根据子网掩码和网关地址计算出来的才是在一个子网里面。如何需要更大的子网，可以将子网掩码设置为255.255.0.0，这样IP的范围就可以设置的更大一点，前面的那个31也可以自己配置了。
- 每一个WAN口连接都是一个网关，其连接的设备都是他的子网，所以旁路由有自己的网关，其也有自己的网段。在手动配置旁路由的地址时，配置的都是主路由的信息，因为其要接在主路由的子网里面。此时旁路由在主路由的子网里面，此时旁路由也可以看作是一个完整的网关，其也可以配置自己的网段，配置自己的网关，配置自己的子网掩码等。这些都可以在路由器里面配置，此时如果在旁路由里面在接一个路由器时，填写的信息就是此时旁路由信息。
  - 目前小米路由器AC2100是不支持修改默认网关和子网掩码的。默认的是192.168.31.1，255.255.255.0。主路由和旁路由设置都按照这个来，不支持修改。

#### 端口转发和端口映射

[知乎端口转发和端口映射](https://zhuanlan.zhihu.com/p/75648110)

- 按我的理解来看，端口转发是内网访问外网用的，内网有很多设备，共用一个公网IP，此时就是端口转发。端口映射是外网访问内网用的，外网访问不到内网服务器，当将内部IP映射到公网IP上，外网就可以访问内网了。这两种都会涉及到端口。
- 虚拟机设置中NAT端口转发看着像端口映射，即外网访问内网，这怎么叫端口转发
  - 在某些上下文中，“端口映射”和“端口转发”这两个术语的使用可能会产生混淆。其实，它们在很多情况下是指同一种技术，但具体的定义和使用上有一些细微差别。
  - 端口转发通常是指在网络层或路由器中设置规则，将外部（外网）请求的特定端口（通常是公网 IP 地址和端口组合）转发到内部（内网）机器的对应端口。常见的场景就是通过路由器或防火墙设置，把外部的某个端口（如 SSH 的 22 端口）转发到局域网内某台计算机的对应端口。
    - 但是，端口转发的概念并不限于外网访问内网。它可以指将流量从一个网络接口转发到同一设备或机器上的不同端口(同一设备，可能指的是相同类型的不同物理设备)。比如你提到的虚拟机情形，实际上依然可以归类为“端口转发”，只是这个过程发生在 **主机与虚拟机之间**，而非外网与内网之间。
  - 端口映射的概念在很多时候与端口转发是相似的，但更常见于一些 NAT 或 VPN 技术中。端口映射是将某个端口的流量映射到另一个端口。这个术语通常在描述 NAT 环境下的端口映射时出现。你提到的外网访问内网，就是典型的端口映射的一个例子，外部网络的某个端口（例如 8080）被映射到内网服务器的端口（例如 80）上。
  - 当你在虚拟机的设置中启用 **NAT 网络模式** 和端口转发时，实际上是在进行一种局部的网络流量转发，目的是允许你通过主机的端口（如 `127.0.0.1:2222`）访问虚拟机内部的服务（如虚拟机的 SSH 服务 `192.168.x.x:22`）。虽然外界的流量不会直接到达虚拟机，但这个流量还是通过主机的端口转发到达虚拟机。这个过程被称为 **端口转发**。
  - **端口映射** 通常强调流量在不同网络之间的映射，尤其是在外网访问内网时，或者内网多个设备之间的流量重定向。
  - **端口转发** 强调的是流量从一个端口被转发到另一个端口，可以发生在同一设备的不同接口或不同网络设备之间。它是 NAT 环境中实现内网与外网之间通信的常见手段。
- 按上述来看，端口映射更像是直接连接上了，即访问A就像是直接访问了B，但是端口转发更侧重于转发，虚拟机配置中访问2222，然后转发到内部的22.

##### virtualbox设置NAT端口转发

- 设置端口转发有名称、协议、主机IP、主机端口、子系统IP、子系统端口

  - 一般情况下我们只需要填写名称(随便起)，协议(TCP)，然后填写主机端口，例如设置为1234，然后设置子系统端口，这个一般是协议端口，例如ssh用的22端口，此处就设置为22

- 按上述配置，我们就可以访问1234端口，然后就转发到内部22端口了。ssh可以设置访问的端口，如果不设置就默认为22，如果设置就按照设置的端口访问。

  ```
  ssh -p 1234 lyl@127.0.0.1
  ```

- 为什么设置端口转发要访问127.0.0.1

  - 访问127.0.0.1（也就是localhost）通常是因为你想要访问的是运行在同一台计算机上的服务。
  - 127.0.0.1是本地回环地址，它指向的是本机。当你在宿主机上访问127.0.0.1时，实际上是在访问宿主机上的服务，而不是网络中的其他计算机。
  - `127.0.0.1` 是主机的本地回环地址，表示你在访问主机自己。使用这个地址可以绕过网络层的外部访问，通过本地网络接口与虚拟机进行通信。

- 每一个虚拟机都可以设置一个端口转发，所以我们不用担心，如果我们开了多个虚拟机是不是会访问出错的问题，只要我们对于每一个端口转发设置的主机端口不一样就可以了，子系统端口一样都可以是22

#### openwrt

- 在编译时如果找不到芯片的选择时，看看openwrt官网，选择型号后有相应芯片的介绍。
- 编译出来的固件有的是.bin，有的是.img，.bin应该是硬路由用的，.img应该是软路由用的
- 有的插件在源码里面是没有集成的需要后续去装，如果有ipk文件直接下载下来就行了，使用opkg install安装，如果没有需要将源码放到/package/lean中然后，make menuconfig选择安装的插件，然后 make package/lean/插件名称/compile V=s，必须这么写，否则编译不成功，必须从package开始写，编译好的文件在/bin/package/bash里面，ipk文件就是插件安装包，它在环境下运行，应该是不依赖硬件的，它是跑在系统之上的,ipk文件应该是通用的，（实际证明是错误的，每个平台都得单独编译）如果以前没有插件，需要重新安装就这样做，如果以前有就不需要make menuconfig继续配置了，直接make编译插件，不需要那个线程什么的下载，这是更新插件或是原来没有重新编译的步骤，不需要那个线程的下载，那个是下载很大的一个东西。
- 编译了ac2100的ssrp插件，可以试一下在树莓派能用吗，检验一下ipk文件。-不能用，还没搞清楚，没有编译成功插件。应该是单独编译不行，其需要的一些依赖比较多，有写不需要依赖的可以成功。
- 大部分情况下将源码放在package/lean下进行make编译应该能成功，ssrplus有一些依赖比较麻烦没有成功。
- ssrplus 使用前输入代码echo 0xDEADBEEF > /etc/config/google_fu_mode
- openwrt使用lean的固件编译时，将feeds.conf.default中的helloworld前面的注释去掉就有ssrplus了
- 树莓派只有一个网口，我们可以将wifi改成lan口，网卡弄成wan口，此时新加wan口，lan口设置进入系统，vi /ect/config/network，然后将lan口前面eth0取消。
- 尝试编译了adguardhome插件，如果原来没有这个插件，得进入menuconfig重新生成.config，选中插件，然后在make，只是不用那么线程下载什么的。
- 二次编译时make defconfig 是使用默认的配置文件，不需要重新配置，如果重新配置时得用重新编译的方法，二次编译相当于更新，其中有些文件需要删除，看网上二次编译openwrt教程。
- 如果第一次编译时没有编译插件库里的东西，我们不需要重新配置了，只需要将其编译一下就行了，插件库里有直接进入menuconfig，然后make，如果没有找到插件，放到/package/lean，然后make

---
- 子网掩码是用来判断任意两台计算机的ip地址是否属于同一子网络的根据。最为简单的理解就是两台计算机各自的ip地址与子网掩码进行and运算后，得出的结果是相同的，则说明这两台计算机是处于同一个子网络上的，可以进行直接的通讯。
- 网关实质上是一个网络通向其他网络的IP地址，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网关就是一个IP地址。网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。说明路由器是网关，但是无限AP不是网关，因为其没有路由功能。有一个网关就是有一个路由，网关就是路由，有一个路由就有一次转发过程，数据经过的路由越多，转发的越多，数据传输越慢。
- 有一个公网IP，需要设计子网时，里面的IP一般不重复，这是设计子网要考虑的，我们不需要考虑这个地址重复的问题。只需要管直到IP地址链接就行了。
- 在公司的电脑不能链接实验室的电脑，因为实验室电脑是局域网，要进行内网穿透才行，此时进行的是端口映射，ifconfig和实际我们要连的端口不一样。例如阿里云就是进行了内网穿透我们才能链接自己的小服务器。链接时我们不需要考虑IP地址问题，因为里面有各种机制，NAT转发什么的来确保IP地址不重复，而且我们链接是有用户名和密码。
- 一个IP地址有多级路由的时候，如果不再一个子网内，ping不通。举例来说，我的mac电脑链接焦伟电脑放出来的wifi，我的电脑能ping通国强的电脑，但是国强的ping不通我的电脑。我的理解是如果我的电脑链接国强的电脑，其会一级一级的网上找，如果国强的电脑没有建一个小子网，我就能ping通，如果国强电脑那新建了一个子网，我就ping不通。意思是网络一级一级往上找，如果寻找的IP地址和自己一级一级上去的地址在一个直接子网内即对方IP没有新建一个子网然后往下，就可以ping通。反之国强想连我的，我的是在新建的子网，所以联不通，但是我用内网穿透，映射到一个直接子网内就能使用。如果国强那新建了一个子网，但是它也使用内网穿透映射到上面，我就能ping通，能不能找到内网里面的IP我们就不管了，应该能找到。

#### IP地址

##### IPv4地址分类

- IPv4 地址由 32 位二进制数表示，通常写作四个十进制数（每个数范围是 0 到 255），例如：`192.168.1.1`。IPv4 地址根据地址范围分为以下几类：

- 划分ABC类地址以及确定网络位以及主机位，完全是为了不同的网络需求，因为网络有大小之分，所以ABC类也有大小之分

  - 区分ABC类地址主要是为了划分子网，划分子网之后可以更方便的进行路由，在同一个子网下的设备可以通过交换机进行数据交换，并不用通过路由。

  - 公有IP地址在互联网上都是可以找到的，划分出来不同的子网是为了更好的数据交互。

    - 例如B类128.0.0.1和128.0.0.2都是公有IP，都是可以在互联网上找到的，但是他两也划分了子网，都是在128.0的子网下面的，这两个公有IP可以直接进行数据交互，不需要通过上一级的路由进行转发。

  - 我们只需要弄私有IP就可以了。对于大中小网络，我们就用ABC类私有地址就可以了。

  - A类地址只能有127个子网，B类可以有16384个子网，C类可以有2,097,152个子网，子网是根据网络位来看的。例如我们需要划分260个子网，A类地址就不行了，我们就需要用B类或者C类。

    - 同一个子网是通过子网掩码也可以说是网络位来确定的，同一个子网可以通过交换机进行数据交互，不需要进行路由。

    - 例如公司有一个公有IP，公司里面就几个设备，这时候我们用C类地址就可以了，但是如果我们用了A类地址，相当于A类地址总共有127个子网，我们小公司就占了一个子网。

###### A类地址

- 范围：`1.0.0.0` 到 `127.255.255.255`
- 默认子网掩码：`255.0.0.0`（/8）
- 用途：A 类地址主要分配给大型网络，最多可以有约 1677 万个主机地址。地址中的第一位为 0，表示这是 A 类地址。
  - 主机数计算为`255*255*255=16,777,216`，是除了网络位后面的3个主机位数量相乘
  - 1的二进制位为0000 0001，127的二进制位为0111 1111，所以地址中第一位为0是A类地址。

###### B类地址

- 范围：`128.0.0.0` 到 `191.255.255.255`
- 默认子网掩码：`255.255.0.0`（/16）
- 用途：B 类地址用于中等规模的网络，最多支持约 65,000 个主机地址。地址中的前两位为 10，表示这是 B 类地址。
  - 主机数计算为`255*255=65536`，是除了网络位后面的2个主机位数量相乘
  - 128的二进制位为1000 0000 ，191的二进制位为1011 1111，所以地址中前两位为10是B类地址。

###### C类地址

- 范围：`192.0.0.0` 到 `223.255.255.255`
- 默认子网掩码：`255.255.255.0`（/24）
- 用途：C 类地址适用于小型网络，最多支持 254 个主机地址。地址中的前三位为 110，表示这是 C 类地址。
  - 192的二进制位为1100 0000，223二进制位为1101 1111，地址中的前三位为 110，表示这是 C 类地址
  - 最多支持254个主机地址参考下面

###### D类地址

- 范围：`224.0.0.0` 到 `239.255.255.255`
- 用途：D 类地址用于多播（Multicast）通信，不分配给主机，只用于网络中的多播数据传输。

###### E类地址

- 范围：`240.0.0.0` 到 `255.255.255.255`
- 用途：E 类地址为实验性地址，目前未被分配给任何实际用途。它主要用于研究和未来的开发。

##### 保留地址

- 以下是一些保留地址，它们在公共网络中不能用于设备的实际通信：

###### 私有地址（Private IP Address）

- 这些地址用于局域网（LAN）内，不会在互联网中路由，因此它们可以在不同的局域网中重复使用。下面的这个子网掩码和公有IP的子网掩码不太一样，但是都是为了划分子网来的，下面这个子网掩码可以变化。其中B类私有地址子网掩码为/12，相当于172.16-172.31都是在一个子网内，其余的是主机位，这个是可以重新修改子网掩码来修改子网的大小的。例如把B类地址修改为/16的子网掩码，这样16-31就是16个子网，不在一个子网内了。
- **A 类私有地址**：`10.0.0.0` 到 `10.255.255.255`（子网掩码 `255.0.0.0`）/8
- **B 类私有地址**：`172.16.0.0` 到 `172.31.255.255`（子网掩码 `255.240.0.0`）/12
- **C 类私有地址**：`192.168.0.0` 到 `192.168.255.255`（子网掩码 `255.255.0.0`）/16

###### 环回地址（Loopback Address）

- 范围：`127.0.0.0` 到 `127.255.255.255`
- 用途：环回地址用于本地计算机的自我测试。`127.0.0.1` 常用于访问本机（例如访问本机上的 Web 服务器）。

###### 广播地址（Broadcast Address）

- 广播地址是指所有主机都能接收到的地址，通常表示为网络的最后一个地址。例如，在 `192.168.1.0/24` 网络中，广播地址为 `192.168.1.255`。

###### 链路本地地址（Link-local Address）

- 范围：`169.254.0.0` 到 `169.254.255.255`
- 用途：用于设备在没有 DHCP 服务器时进行自我配置，通常用于自动配置和局域网通信。

##### C类地址为什么只有254个地址

- C 类地址的网络地址结构如下：

  - IP 地址格式，此处只是一个示例，前面24位是网络位，所以前面`192.168.1`是一个示例，也可以写成其他的

    ```
    192.168.1.0/24
    ```

    - 网络地址部分：`192.168.1.0`（即网络的起始地址）
    - 可用主机地址部分：`192.168.1.1` 到 `192.168.1.254`
    - 广播地址部分：`192.168.1.255`（即该网络的广播地址）

- 在 C 类地址中，默认的子网掩码是 `255.255.255.0`，即 `/24`。这意味着：
  - 网络地址：`192.168.1.0`，这是该网络的标识符，用来标明该地址段的网络本身，不可分配给任何主机。
  - 广播地址：`192.168.1.255`，这是用来向网络中的所有设备发送广播消息的地址，类似于向所有设备发送广播通知，也不可分配给主机。
- 因此，除去网络地址和广播地址，剩下的地址是可以分配给主机的。对于 `192.168.1.0/24` 网络，剩余的可用地址从 `192.168.1.1` 到 `192.168.1.254`，总共有 254 个地址。

- B 类地址有网络地址和广播地址
  - B 类地址的默认子网掩码是 `255.255.0.0`（即 `/16`）。这意味着一个 B 类地址可以支持较大的网络，每个网络中有 65536 个地址，其中包括网络地址和广播地址。对于一个典型的 B 类地址网络，例如 `172.16.0.0/16`，它的结构如下：
    - 网络地址：`172.16.0.0`，这是该网络的标识符，不能分配给主机。
    - 可用主机地址：从 `172.16.0.1` 到 `172.16.255.254`，这些是可分配给主机的地址。
    - 广播地址：`172.16.255.255`，这是用来广播到整个网络的地址，不能分配给主机。
  - 在 `172.16.0.0/16` 网络中，除去网络地址和广播地址，剩下的可分配给主机的地址范围是从 `172.16.0.1` 到 `172.16.255.254`，总共有 65534 个可用地址。

##### 为什么要区分网络位和主机位

- 区分 网络位（Network Bits）和 主机位（Host Bits）在 IP 地址中的作用非常重要，它直接影响到网络的组织结构和地址的分配方式。下面是为什么要区分网络位和主机位的一些关键原因：

###### 组织和管理网络

- 网络位用于标识网络本身，这意味着所有拥有相同网络部分的设备属于同一个网络。这使得可以将网络划分为多个子网络（即子网），每个子网络可以单独管理，并与其他子网络进行区分。
- 主机位用于标识网络内的具体设备或计算机。每个设备（如计算机、路由器、打印机等）在同一网络中有一个唯一的 IP 地址，由网络位和主机位共同确定。
- 例如：在 IP 地址 `192.168.1.100` 中，如果子网掩码是 `255.255.255.0`（即 /24)，那么：
  - 网络部分：`192.168.1`（由前 24 位表示）
  - 主机部分：`100`（由剩余的 8 位表示）
- 这样，你就可以知道该设备属于 `192.168.1.0/24` 网络，且它的具体主机地址是 `100`。

###### 提高地址利用效率

- 通过划分网络位和主机位，能够更好地管理和利用 IP 地址。具体的优点包括：
- 更好的地址规划：网络位的长度决定了网络可以容纳多少个子网，主机位的长度决定了每个子网内可以有多少个设备。根据实际需求，可以灵活地调整这两个部分来优化 IP 地址的分配。
  - 比如，一个企业可能有多个分支机构，每个分支需要一个独立的网络。通过改变网络位的长度，可以控制每个子网的规模，避免浪费 IP 地址。
- 减少浪费：通过子网划分，网络管理员可以根据实际的主机数量来合理分配地址，避免有些子网分配了过多的地址而导致浪费，其他子网又因为地址不足而无法满足需求。

###### 路由和数据传输

- 网络位的存在使得网络能够有效地进行 **路由**，即确定数据包从一个网络到另一个网络的路径。路由器通过查看数据包的网络位来确定该数据包应发送到哪个网络。
- 路由表：路由器会根据 IP 地址的网络位部分来决定如何将数据包传送到目标网络。如果没有网络位的区分，路由器就无法正确地决定路径。
- 跨网络通信：当一个设备想要与不同网络中的设备通信时，数据包需要通过路由器。路由器根据目标设备的网络位部分判断是否需要将数据包转发到其他网络，而不是直接发送到本地网络。

###### 简化网络管理和故障排除

- 子网划分：区分网络位和主机位的最大优势之一是可以通过 **子网掩码**（Subnet Mask）来细分网络。这使得网络管理员可以将一个大的网络分割成更小的子网，每个子网可以单独管理。
  - 比如，你有一个 `192.168.1.0/24` 网络，理论上可以容纳 254 个主机。如果你想为不同部门分配子网，可以通过修改子网掩码（比如 `/26`）将其划分为更小的子网。每个子网将有自己的网络位和主机位，从而方便管理和隔离。
- 故障排除：在进行故障排除时，如果能清楚地区分网络位和主机位，网络管理员可以更容易地定位问题。例如，网络位的问题通常涉及路由配置、子网划分等，而主机位的问题则可能是设备配置、地址冲突等。

###### 支持网络扩展

- 随着互联网的增长和企业网络的扩大，区分网络位和主机位是 **IP 地址扩展** 和 **网络扩展** 的基础。通过灵活的子网划分，网络可以随着需求的变化进行扩展。
- **IPv4** 地址是有限的，因此需要通过子网划分来最大化利用可用地址空间。通过调整网络位和主机位的比例，可以灵活调整网络的规模。
- **IPv6** 引入了更大的地址空间，它继续遵循类似的区分网络位和主机位的原则，但提供了更多的可用地址。

###### 避免地址冲突

- 当你在一个网络中分配 IP 地址时，必须确保每个主机的IP地址是唯一的。通过区分网络位和主机位，网络管理员可以有效地管理和分配 IP 地址，避免地址冲突。例如，在一个企业网络中，两个部门可以有各自独立的子网和地址段，避免了两个部门内部主机地址重复的问题。

##### C类地址子网掩码为255.255.255.0，为什么不是255.255.0.0

- C 类地址的子网掩码是 `255.255.255.0`（即 `/24`），而不是 `255.255.0.0`，这是因为C 类地址的设计目标是支持小型局域网，并且需要将主机部分划分出较小的地址范围，以便有效地管理和分配给较少数量的主机。
- `255.255.0.0` 对应的是 `/16` 子网掩码，这意味着网络部分包含了前 16 位，剩余的 后 16 位用于主机部分。这样每个网络就可以有 65536 个地址（包括网络地址和广播地址），这对于 C 类地址来说太大了，无法满足其设计目标。
- C 类地址是为较小规模的网络设计的，其目标是确保每个网络中只有较少数量的主机，通常是最多 254 台主机。为了实现这一点，C 类地址使用 `/24` 子网掩码（即 `255.255.255.0`），确保每个网络可以拥有最多 254 个主机地址，并且避免过多的地址浪费。
- 如果将 C 类地址的子网掩码改为 `255.255.0.0`，那么一个 C 类网络就会包含太多的地址，甚至浪费了大量本应用于其他小网络的地址。
- ABC类IP地址是从大中小型网络依次排下来的，如果C类的子网掩码也设置为/16(B类地址的子网掩码)，则对于一个子网来说支持65536个地址，但是我们需要的是小网络，不需要这么大，如果我们需要大一点的网络，完全可以使用B类地址的IP。
- 对于地址来说我们最重要的是区分子网，

##### 默认网关的IP

- 默认网关的IP和设备的IP通常在同一个子网下
- 例如：
  - 设备的IP地址：`192.168.1.10`
  - 默认网关IP地址：`192.168.1.1`

- 这两个IP地址位于相同的子网 `192.168.1.0/24`，其中 `/24` 表示子网掩码是 `255.255.255.0`。因此，设备能够通过默认网关与其他子网或外部网络进行通信。
- 如果设备的IP和默认网关的IP不在同一个子网内，设备将无法通过该网关进行通信，通常会导致无法连接到其他网络。
- 路由表是通过子网来确定要从哪个端口发送出去，所以路由表里面有子网，而子网是通过IP和子网掩码来确定的，所以路由器的端口有子网掩码的概念。
- 路由器端口发送出来的数据在这一端口下是同一子网的，所以当前设备IP和路由器端口IP是一个子网的。

#### 网关配置

- 查看当前主机的路由表有两个命令`route -n`和`ip route show`

  - ip route显示如下

    ```
    $ ip route show 
    default via 192.168.56.2 dev eth0 
    169.254.0.0/16 dev eth0  scope link  metric 1002 
    192.168.56.0/24 dev eth0  proto kernel  scope link  src 192.168.56.11
    
    $ ip route show | column -t       # 格式化一下
    default          via  192.168.56.2  dev    eth0
    169.254.0.0/16   dev  eth0          scope  link    metric  1002
    192.168.56.0/24  dev  eth0          proto  kernel  scope   link  src  192.168.56.1
    ```

    - 看环境路由表的时候，会看到一些如下的字段`proto kernel scope link src`
    - `scope` *类型* 指的是路由前缀覆盖的目标地址范围。 `scope link`表示在设备的网段内允许通过该路由进行通信。 通过其他往网段的话的话，应该使用路由。
    - `protocol`*类型* 是该路由的路由协议标识符。`proto kernel`的意思是: 在自动配置过程中由内核安装的路由。
    - 这里可以明白`scope` 和 `protocol`应该是是需要分开理解的。 一个代表路由范围，另一个代表路由标识符
    - proto和scope后面都可以跟一些其他的，不只是跟着link

  - route -n显示如下

    ```
    $ route -n
    Kernel IP routing table
    Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
    0.0.0.0         192.168.79.2    0.0.0.0         UG    100    0        0 ens33
    192.168.79.0    0.0.0.0         255.255.255.0   U     100    0        0 ens33
    192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0
    ```

    - Destination 目标网络(network)或者目标主机(host)

    - Gateway: 网关地址

    - Genmask: 子网掩码，此处的子网掩码是目标网络的子网掩码，并不是网关的子网掩码。

    - Flags: 标记，可能的标记如下

      ```
      U (route is up)： 路由是活动的
      H (target is a host)： 目标是一个主机而非网络
      G (use gateway)： 需要透过外部的主机（gateway)来转递封包
      R (reinstate route for dynamic routing)： 使用动态路由时，对动态路由进行复位设置的标志
      D (dynamically installed by daemon or redirect)： 由后台程序或转发程序动态安装的路由
      M (modified from routing daemon or redirect)： 由后台程序或转发程序修改的路由
      A (installed by addrconf)： 由addrconf安装的路由
      C (cache entry)： 缓存的路由信息
      !  (reject route)： 这个路由将不会被接受（主要用来抵御不安全的网络）
      
      如果只在内部使用的情况下，FLags只有U，如果需要外部来使用的话，一般为UG
      Gateway为0.0.0.0是本主机有好几个网卡，这几个网卡内部联系使用的，并不用走到网关，所以是0.0.0.0
      如果Gateway不是0.0.0.0，就需要外部使用，而且Flags一般是UG
      
      如果Destination为0.0.0.0的话一般是默认网关，所有的目的地址都走这，所以是，也可以用ip route show看一下是不是默认的，默认网关在ip route show中会明显标示出来。
      ```

    - Metric: 路由距离，到达指定网络所需的中转数。当前Linux内核并未使用，但是routing daemons可能会需要这个值

    - Ref: 路由项引用次数（linux内核中没有使用）

    - Use: 此路由项被路由软件查找的次数

    - Iface: 当前路由会使用哪个接口来发送数据

  - route -n和ip route show显示对比

    ```
    wherfdp1ali:run > ip route show
    10.192.0.0/10 dev eth3  proto kernel  scope link  src 10.217.22.1
    172.30.0.0/16 via 10.200.0.239 dev eth3
    172.31.0.0/16 via 10.200.0.239 dev eth3
    192.168.11.0/24 dev eth1  proto kernel  scope link  src 192.168.11.1
    192.168.110.0/24 via 10.200.0.1 dev eth3
    192.168.111.0/24 dev eth0  proto kernel  scope link  src 192.168.111.1
    192.168.117.0/24 via 10.200.0.239 dev eth3
    192.168.211.0/24 dev eth2  proto kernel  scope link  src 192.168.211.1
    wherfdp1ali:run > route -n
    Kernel IP routing table
    Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
    10.192.0.0      0.0.0.0         255.192.0.0     U     0      0        0 eth3
    172.30.0.0      10.200.0.239    255.255.0.0     UG    0      0        0 eth3
    172.31.0.0      10.200.0.239    255.255.0.0     UG    0      0        0 eth3
    192.168.11.0    0.0.0.0         255.255.255.0   U     0      0        0 eth1
    192.168.110.0   10.200.0.1      255.255.255.0   UG    0      0        0 eth3
    192.168.111.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0
    192.168.117.0   10.200.0.239    255.255.255.0   UG    0      0        0 eth3
    192.168.211.0   0.0.0.0         255.255.255.0   U     0      0        0 eth2
    ```

    - route -n中Gateway显示0.0.0.0的在ip route中显示proto和scope，不是0.0.0.0的就显示via dev eth这些

- route和ip route是两个命令，但是功能是一样的，都是配置网络的

- 添加路由，路由类型分三种：主机路由、网络路由、默认路由

  - route命令

    - 添加到达目标主机的路由

      ```
      route add -host 10.1.111.111 gw 10.2.111.111 dev eth0
      ```

    - 添加到达目标网络的路由

      ```
      route add -net 10.1.0.0 netmask 255.255.0.0 gw 10.2.111.111 dev eth0
      或者 route add -net 10.1.0.0/16 gw 10.2.111.111 dev eth0
      ```

    - 添加默认路由

      ```
      route add default gw 10.2.111.111
      ```

  - ip route命令，这个命令也可以在每一个后面使用dev eth这样的结构，为某个网卡添加路由

    - 添加到达目标主机的路由记录

      ```
      ip route add 目标主机 via 网关 
      ip route add 10.2.111.112 via 10.1.111.112. 后面的是添加的网关，前面的是需要的目标主机
      ```

    - 添加到达网络的路由记录

      ```
      ip route add 目标网络/掩码 via 网关
      ip route add 192.168.56.0/24 via 192.168.56.2 dev eth0
      ```

    - 添加默认路由

      ```
      ip route add default via 网关
      ```

- 删除路由

  - route命令

    ```
    1）删除到达目标主机的路由记录
    route del -host 主机名
    2）删除到达目标网络的路由记录
    route del -net 目标网络/子网掩码
    ip route del 192.168.56.0/24
    3）删除默认路由
    route del default
    ```

  - ip route命令

    ```
    ip route del 目标网络/掩码
    ip route del default
    ```

- 添加永久静态路由

  - `ip route`指令对路由的修改不能保存，重启就没了。把`ip route`指令写到`/etc/rc.local`也是徒劳的。 RHEL7 官网文档没有提到`/etc/sysconfig/static-routes`，经测试此文件已经无效； `/etc/sysconfig/network`配置文件仅仅可以提供全局默认网关，语法同 CentOS 6 一样： GATEWAY= ； 永久静态路由需要写到`/etc/sysconfig/network-scripts/route-interface`文件中，比如添加两条静态路由：

    ```
    [root@linux-node1 network-scripts]# cat /etc/sysconfig/network-scripts/route-eth0
    10.18.196.0/255.255.254.0 via 192.168.56.11 dev eth0
    
    [root@linux-node1 network-scripts]# nmcli dev connect eth0 # 重启计算机，或者重新启用设备 eth0 才能生效。
    
    [root@linux-node1 network-scripts]# nmcli dev disconnect eth0 && nmcli dev connect eth0
    # 一般直接连接一次设备即可，如果不成功就先断开设备再连接设备，注意必须两个指令一起运行
    ```

- 清除永久静态路由

  ```
  可以删除 route-eth0 文件或者注释掉文件里的相应静态路由条目，重启计算机。
  想要让修改后的静态路由立即生效，只能用ip route del手工删除静态路由条目。
  ```

### 公钥和私钥

- 公钥（Public Key）与私钥（Private Key）是通过加密算法得到的一个密钥对（即一个公钥和一个私钥，也就是非对称加密方式）。公钥可对会话进行加密、验证数字签名，只有使用对应的私钥才能解密会话数据，从而保证数据传输的安全性。公钥是密钥对外公开的部分，私钥则是非公开的部分，由用户自行保管。
- 通过加密算法得到的密钥对可以保证在世界范围内是唯一的。使用密钥对的时候，如果用其中一个密钥加密一段数据，只能使用密钥对中的另一个密钥才能解密数据。例如：用公钥加密的数据必须用对应的私钥才能解密；如果用私钥进行加密也必须使用对应的公钥才能解密，否则将无法成功解密。
- 举例说明[非对称加密](https://so.csdn.net/so/search?q=非对称加密&spm=1001.2101.3001.7020)：如果A想要给B秘密的发一条信息，只需要B创建一套公钥（盒子）和私钥（钥匙），盒子可以随意分发，但是钥匙只能B自己所有，当A想要给B发信息时，只需要把信息（纸条）通过B的公钥加密（放入盒子里锁上），再由B用私钥（钥匙）进行解密（打开盒子），即可获取A发送的信息。此时如果C想要截取信息，但是由于没有B的私钥，C即使拿到了信息也无法解密（只有盒子没有钥匙），从而保证了数据的安全性。
- 那么B是否可以通过私钥加密信息，然后由A使用公钥解密信息呢？从原理上讲，是可以的。 非对称密钥是可以用于双向加解密的。但是我们为什么不这么用呢，很好理解，因为所谓公钥，是公开的，不只A一个人拥有，因此虽然A能够正常读取到信息，但是其他人也可以解密该条信息，从而无法保证信息的安全性。但是签名验证就不同了。

##### 数字签名

- 数字签名就是附加在数据单元上的一些数据,或是对数据单元所作的密码变换。这种数据或变换允许数据单元的接收者用以确认数据单元的来源和数据单元的完整性并保护数据,防止被人(例如接收者)进行伪造。它是对电子形式的消息进行签名的一种方法,一个签名消息能在一个通信网络中传输。基于公钥密码体制和私钥密码体制都可以获得数字签名,主要是基于公钥密码体制的数字签名。
- 数字签名是个加密的过程，数字签名验证是个解密的过程。

###### 数字签名原理

- 数字签名技术是将原文通过特定HASH函数得到的摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文提炼出一个摘要信息，与解密得到的摘要进行对比。哪怕只是一个字符不相同，用HASH函数生成的摘要就一定不同。如果比对结果一致，则说明收到的信息是完整的，在传输过程中没有被修改，否则信息一定被修改过，因此数字签名能够验证信息的完整性。
- 哈希函数是开发人员约定的，因为服务器是开发人员写的，请求这部分也是开发人员写的，接收回复也是开发人员写的，所以开发人员可以自己约定哈希函数。
- 为什么会用哈希函数：
  - 懂得一点公钥密码基础知识的人都知道，发信息的人用自己的私钥对所发信息进行加密( Encryption )，接收信息者用发信者的公钥来解密( Decryption )，就可以保证信息的真实性、完整性和不可否认性。（注：这里提到的加密、解密是指密码运算，其目的并非信息保密。）那么，我们也可以笼统地说，以上方法就已经达到了数字签名的目的。因为首先，私钥是发信者唯一持有的，别的任何人不可能制造出这份密文来，所以可以相信这份密文以及对应的明文不是伪造的（当然，发信者身份的确定还要通过数字证书来保证）；出于同样原因，发信者也不能抵赖、否认自己曾经发过这份信息；另外，信息在传输当中不可能被篡改，因为如果有人试图篡改，密文就解不出来。这样，用私钥加密，公钥解密的技术方法就可以代替传统签名、盖章，保证了信息的真实性、完整性和不可否认性。
  - 但是，这样做在实际使用中却存在一个问题：要发的信息可能很长，非对称密码又比较复杂，运算量大，而为了保证安全，私钥通常保存在USB Key或IC卡中，加密运算也是在Key或卡中进行。一般来说，小小的USB Key或IC卡中的微处理器都做得比较简单而处理能力较弱，这样，加密所用的时间就会很长而导致无法实用。
  - 另外，即使对于网站服务器而言，虽然它的处理能力很强，但服务器要同时处理许许多多签名加密的事情，也同样存在着加密耗时长系统效率低的问题。
  - 有没有解决这个问题的办法呢？有的，常用的方法是使用哈希函数。
  - Hash算法是把任意长度的输入数据经过算法压缩，输出一个尺寸小了很多的固定长度的数据，即哈希值。哈希值也称为输入数据的数字指纹（Digital Fingerprint）或消息摘要（Message Digest）等
  - 哈希计算是计算输入数据的信息摘要，并不是直接加密数据，这样就能保证计算的快速性。如果私钥加密整个数据，这是很耗费计算量和时间的。
- [数字签名和哈希函数理解](https://www.cfca.com.cn/20150811/101230821.html)

###### 数字签名作用

- 一是能确定消息的不可抵赖性，因为他人假冒不了发送方的私钥签名。发送方是用自己的私钥对信息进行加密的，只有使用发送方的公钥才能解密。
- 二是数字签名能保障消息的完整性。一次数字签名采用一个特定的哈希函数，它对不同文件产生的数字摘要的值也是不相同的。

### TCP

- TCP 其实是非常复杂的协议，我们先聊一些基础的。我们知道 TCP 是一种可靠的协议，它主要通过解决这几个问题来实现可靠性的，分别是：乱序、丢包重传、流控、拥塞控制。

  ![](https://s2.51cto.com/images/blog/202108/31/524eb7ce68d3f7cc50e0d7976c9f52e5.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_750)

- `Sequence Number` 是记录包的序号，TCP 会按照报文字节进行编号，它是用来解决包在网络中乱序的问题。

- `Acknowledgement Number` 确认序列号，是用于向发送方确认已经收到了哪些包，用来解决不丢包的问题。

- `Windows` 也叫 `Advertised-Windows`，也就是著名的滑动窗口，主要是用来解决流控的。

- `TCP Flag` 就是包的类型，主要是用于操控 TCP 状态机的。

- TCP协议工作在OSI的传输层，是一种可靠的面向连接的数据流协议，TCP之所以可靠，是因为它保证了传送数据包的顺序。顺序是用一个序列号来保证的。响应包内也包括一个序列号，表示接收方准备好这个序列号的包。在TCP传送一个数据包时，它会把这个数据包放入重发队列中，同时启动计时器，如果收到了关于这个包的确认信息，便将此数据包从队列中删除，如果在计时器超时的时候仍然没有收到确认信息，则需要重新发送该数据包。另外，TCP通过数据分段中的序列号来保证所有传输的数据可以按照正常的顺序进行重组，从而保障数据传输的完整。

- TCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。
  - 第一次握手：客户端发送 `SYN` 报文，并进入 `SYN_SENT` 状态，等待服务器的确认；
  - 第二次握手：服务器收到 `SYN` 报文，需要给客户端发送 `ACK` 确认报文，同时服务器也要向客户端发送一个 `SYN` 报文，所以也就是向客户端发送 `SYN + ACK` 报文，此时服务器进入 `SYN_RCVD` 状态；
  - 第三次握手：客户端收到 `SYN + ACK` 报文，向服务器发送确认包，客户端进入 `ESTABLISHED` 状态。待服务器收到客户端发送的 `ACK` 包也会进入 `ESTABLISHED` 状态，完成三次握手。

- 当我们的应用程序不需要数据通信了，就会发起断开 TCP 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。
  - 第一次挥手。客户端发起 `FIN` 包（FIN = 1）,客户端进入 `FIN_WAIT_1` 状态。TCP 规定，即使 `FIN` 包不携带数据，也要消耗一个序号。
  - 第二次挥手。服务器端收到 `FIN` 包，发出确认包 `ACK`（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 `CLOSE_WAIT` 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 `ACK` 后，进入了 `FIN_WAIT_2` 状态。
  - 第三次挥手。服务器端数据发送完毕后，向客户端发送 `FIN` 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 `LAST_ACK` 状态。
  - 第四次挥手。客户端收到服务器的 `FIN` 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 `TIME_WAIT` 状态。注意此时 TCP 连接还没有释放，必须经过 `2*MSL` 后，才进入 `CLOSED` 状态。而服务器端收到客户端的确认包 `ACK` 后就进入了 `CLOSED` 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。
- 为什么建立连接握手三次，关闭连接时需要是四次呢？
  - 其实在 TCP 握手的时候，接收端发送 `SYN+ACK` 的包是将一个 `ACK` 和一个 `SYN` 合并到一个包中，所以减少了一次包的发送，三次完成握手。
  - 对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 `FIN` 包与对客户端的 `ACK` 包合并发送，只能先确认 `ACK`，然后服务器待无需发送数据时再发送 `FIN` 包，所以四次挥手时必须是四次数据包的交互。
- 为什么TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？
  - `MSL` 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 `FIN` 的确认包 `ACK` 后，这个 `ACK` 包是有可能不可达的，服务器端如果收不到 `ACK` 的话需要重新发送 `FIN` 包。
  - 所以客户端发送 `ACK` 后需要留出 `2MSL` 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。
  - 也就是说客户端如果等待 `2MSL` 时间也没有收到服务器端的重传包 `FIN`，说明可以确认服务器已经收到客户端发送的 `ACK`。
  - 还有第 *2* 个理由，避免新旧连接混淆。
  - 在客户端发送完最后一个 `ACK` 报文段后，在经过 `2MSL` 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。
  - 你要知道，有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。

##### 两次握手可以吗

- 为什么 TCP 采用三次握手，二次握手可以吗？我们可以从几个方面来解释：

###### 确认双方的收发能力

- TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。

  *1.* 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

  *2.* 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

  *3.* 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

  所以，只有三次握手才能确认双方的接收与发送能力是否正常。

###### 序列号可靠同步

- 如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。

###### 阻止重复历史连接的初始化

- 客户端由于某种原因发送了两个不同序号的 `SYN` 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 `SYN` 就会立刻建立连接，那么会造成网络异常。
- 如果是三次握手，服务器需要回复 `SYN+ACK` 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 `RST` 报文，直到正常的 `SYN` 到达服务器后才正常建立连接。
- 主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

- 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。
- 所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。

### SSH

- SSH是英文Secure Shell的简写形式。通过使用SSH，你可以把所有传输的数据进行加密，这样"中间人"这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是**传输的数据是经过压缩的**，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、Pop、甚至为PPP提供一个安全的"通道"。

##### SSH基本框架

- SSH协议有两个主要版本，分别是SSH-1和SSH-2。

- SSH协议是建立在不安全的网络之上的进行远程安全登陆的协议。它是一个协议族，其中有三个子协议，分别是：

  - [传输层]()协议 [SSH-TRANS] 提供了服务器认证，保密性及完整性。此外它有时还提供压缩功能。 SSH-TRANS 通常运行在 TCP/IP连接上，也可能用于其它可靠数据流上。 SSH-TRANS 提供了强力的[加密技术]()、密码[主机]()认证及完整性保护。该协议中的认证基于主机，并且该协议不执行[用户认证]()。更高层的用户认证协议可以设计为在此协议之上。

  - [用户认证协议]() [SSH-USERAUTH] 用于向服务器提供客户端用户鉴别功能。它运行在[传输层]()协议 SSH-TRANS 上面。当 SSH-USERAUTH 开始后，它从低层协议那里接收会话[标识符]()（从第一次[密钥]()交换中的交换哈希 H ）。会话标识符唯一标识此会话并且适用于标记以证明私钥的所有权。 SSH-USERAUTH 也需要知道低层协议是否提供保密性保护。

    - 向服务器验证客户端用户，有基于用户名密码和公钥两种验证方式，建立在传输层协议`[SSH-TRANS]`之上。

  -  连接协议（The Connection Protocol） 将加密的信息隧道复用成若干个逻辑通道，提供给更高层的应用协议使用； 各种高层应用协议可以相对地独立于SSH基本体系之外，并依靠这个基本框架，通过连接协议使用SSH的安全机制。

  - 同时SSH协议框架中还为许多高层的网络安全应用协议提供扩展的支持。它们之间的层次关系可以用如下图来表示：

    ![](https://images0.cnblogs.com/blog/626398/201408/302106194382318.gif)

    <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/27/1661abf180526d4c~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" style="zoom: 80%;" />

- [SSH工作流程分为五部，版本号协商、密钥和算法协商、认证阶段、会话请求阶段、交互会话阶段](https://www.cnblogs.com/zmlctt/p/3946860.html)
  
  - 密钥和算法协商阶段可以交换数字签名HASH算法，压缩算法，加密算法等
  - ssh会话阶段服务器返回的数据一般情况下应该是数字签名，不会是直接非对称加密，那样太耗费资源了。

##### SSH的安全验证

- 在客户端来看，SSH提供两种级别的安全验证。上面链接中也有写安全验证方式。

- 第一种级别（基于密码的安全验证），知道帐号和密码，就可以登录到远程主机，并且所有传输的数据都会被加密。但是，可能会有别的服务器在冒充真正的服务器，无法避免被“中间人”攻击。

  - 所以一般在首次登录服务器时，系统会出现下面的提示：

    ```
    　　$ ssh user@host
    　　The authenticity of host 'host (192.168.100.1)' can't be established.
    　　RSA key fingerprint is 2d:37:16:58:4d:28:c2:42:2d:37:16:58:4d.
    　　Are you sure you want to continue connecting (yes/no)?
    ```

    - 确认之后，就可以登录（其实在实际生活中并没有什么用啊？谁会去手动比对fingerprint~）。当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台服务器，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。

  - 第一种就是简单的ssh协议中的请求链接，获取服务器的公钥，然后进行加密的这种过程，我最开始的理解就是这样的，但是这种有中间人攻击的可能性，第二种安全验证方法避免了中间人攻击。

- 第二种级别（基于密钥的安全验证），需要依靠密钥，也就是你必须为自己创建一对密钥，并把公有密钥放在需要访问的服务器上。客户端软件会向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求之后，先在你在该服务器的用户根目录下寻找你的公有密钥，然后把它和你发送过来的公有密钥进行比较。如果两个密钥一致，服务器就用公有密钥加密“质询”（challenge）并把它发送给客户端软件。从而避免被“中间人”攻击。 在服务器端，SSH也提供安全验证。 在第一种方案中，主机将自己的公用密钥分发给相关的客户端，客户端在访问主机时则使用该主机的公开密钥来加密数据，主机则使用自己的私有密钥来解密数据，从而实现主机密钥认证，确保数据的保密性。 在第二种方案中，存在一个密钥认证中心，所有提供服务的主机都将自己的公开密钥提交给认证中心，而任何作为客户端的主机则只要保存一份认证中心的公开密钥就可以了。在这种模式下，客户端必须访问认证中心然后才能访问服务器主机。

  <img src="https://img-blog.csdnimg.cn/2018110115284477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hcnl3YW5nNTY=,size_16,color_FFFFFF,t_70" style="zoom:80%;" />

  - 可以看到基于密钥的安全验证需要先在client端产生公私钥，然后将公钥拷贝到服务器上，然后进行数据传输验证，这样抵抗了中间人攻击。

##### SSH和SSL区别

- 如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，**SSH协议的公钥是没有证书中心（CA）公证的**，也就是说，都是自己签发的。
- SSL是带CA公证的协议，主要用于https的加密传输，SSH用的端口是22，SSL用的端口是443
- 现在SSH协议应该也有一些CA证书。

### 代理

- 目前代理分为两种，socks代理和http代理

##### socks

[socks协议的工作过程和协议细节](https://wiyi.org/socks5-protocol-in-deep.html)

[上网限制和翻墙基本原理](https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/)

- **SOCKS**是一种[网络传输协议](https://zh.m.wikipedia.org/wiki/网络传输协议)，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是"SOCKet Secure"的[缩写](https://zh.m.wikipedia.org/wiki/缩写)
- 当[防火墙](https://zh.m.wikipedia.org/wiki/防火墙_(网络))后的客户端要访问外部的服务器时，就跟SOCKS[代理服务器](https://zh.m.wikipedia.org/wiki/代理服务器)连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。
- 根据[OSI模型](https://zh.m.wikipedia.org/wiki/OSI模型)，SOCKS是[会话层](https://zh.m.wikipedia.org/wiki/会话层)的协议，位于[表示层](https://zh.m.wikipedia.org/wiki/表示层)与[传输层](https://zh.m.wikipedia.org/wiki/传输层)之间。
- *SOCKS*工作在比[HTTP代理](https://zh.m.wikipedia.org/wiki/代理服务器)更低的层次：SOCKS使用[握手协议](https://zh.m.wikipedia.org/w/index.php?title=握手协议&action=edit&redlink=1)来通知代理软件其客户端试图进行的SOCKS连接，然后尽可能透明地进行操作，而常规代理可能会解释和重写报头（例如，使用另一种底层协议，例如[FTP](https://zh.m.wikipedia.org/wiki/文件传输协议)；然而，HTTP代理只是将HTTP请求转发到所需的HTTP服务器）。虽然HTTP代理有不同的使用模式，[HTTP CONNECT](https://zh.m.wikipedia.org/wiki/超文本传输协议)方法允许转发TCP连接；然而，SOCKS代理还可以转发[UDP](https://zh.m.wikipedia.org/wiki/用户数据报协议)流量（仅SOCKS5），而HTTP代理不能。HTTP代理通常更了解HTTP协议，执行更高层次的过滤（虽然通常只用于GET和POST方法，而不用于CONNECT方法）。

##### http

- 当在浏览器上下载网页的时候使用的是http代理，我们的网络不能直接连接外网，而http代理服务器可以直接连接，所以HTTP代理将HTTP请求转发到所需的HTTP服务器。这样我们就能访问网页了。

##### socks代理和http代理区别

[主要区别网上讲的](https://www.dailiproxy.com/http-proxies-vs-socks-proxies/)

###### socks

- Bill希望通过互联网与Jane沟通，但他们的网络之间存在一个[防火墙](https://zh.m.wikipedia.org/wiki/防火墙)，Bill不能直接与Jane沟通。所以，Bill连接到他的网络上的SOCKS代理，告知它他想要与Jane建立连接；SOCKS代理打开一个能穿过防火墙的连接，并促进Bill和Jane之间的通信。

###### http

- Bill希望从Jane的Web服务器下载一个网页。Bill不能直接连接到Jane的服务器，因为在他的网络上设置了防火墙。为了与该服务器通信，Bill连接到其网络的HTTP代理。他的网页浏览器与代理通信的方式与他直接连接Jane的服务器的方式相同；也就是说，网页浏览器会发送一个标准的HTTP请求头。HTTP代理连接到Jane的服务器，然后将Jane的服务器返回的任何数据传回Bill。

###### 区别

- SOCKS代理和HTTP代理有什么不同？SOCKS工作在会话层上，而HTTP工作在[应用层](https://baike.baidu.com/item/应用层?fromModule=lemma_inlink)上，SOCKS代理只是简单地传递数据包，而不必关心是何种应用协议(比如FTP、HTTP和NNTP请求)，所以SOCKS[代理服务器](https://baike.baidu.com/item/代理服务器?fromModule=lemma_inlink)比应用层代理服务器要快得多。
- 通常按照不同的用途选择不同的代理:[浏览器](https://baike.baidu.com/item/浏览器?fromModule=lemma_inlink)用HTTP或SOCKS代理、[下载软件](https://baike.baidu.com/item/下载软件?fromModule=lemma_inlink)用HTTP或SOCKS代理、上传软件用FTP或SOCKS代理、其他方面(聊天，MUD游戏等)一般用SOCKS代理。

##### 一些疑惑

- 所有的代理就是应用层的数据先发送到代理服务器，然后由代理服务器建立和数据服务器的TCP连接，这样我们就可以在其中干一些事情，例如在客户端和代理服务器连接的时候，我们可以在代理服务器上将客户端发过来的数据进行加密，然后将IP地址修改为我们VPS地址，VPS服务器上拿到数据之后，在进行解密，然后去请求我们想要的数据，请求完成之后，数据进行加密返回到代理服务器，代理服务器解密之后在发送给客户端。
  - 为什么需要中间加一个代理服务器，如果我们不加代理服务器，例如直接访问google，此时就会带有google的真正IP，这时候长城防火墙看到这个IP就把所有的数据拦截了。如果我们在代理服务器上将数据加密，修改IP地址，这样长城防火墙就不能拦截数据了。
  - 为什么加了一个VPS，我们发出的数据进行了加密，如果直接访问到google，那边是不认这个数据的，所以我们只能加一个VPS，由VPS进行解密，然后发送数据到google，然后请求的数据加密在返回来，代理服务器在解密，这样就完成了数据的请求。
  - 为什么有的只是需要一个代理服务器，而我们这样就有了两个(一个代理服务器一个VPS)，需要两个是因为我们有一个请求数据加密解密的过程，而需要一个的情况是客户端因为防火墙的原因不能直接与外面的服务器进行TCP连接，此时我们就需要将请求数据发送到代理服务器，然后由代理服务器与外面的数据服务器建立连接，然后在返回来数据，这个过程不需要请求数据的加密解密，只是一个数据转发的过程，所以只需要一个代理服务器。
- 代理服务器最初的功能有两种，一种是匿名性或安全性，第二种因为客户端或服务器设置了防火墙，并且它们彼此之间无法通过。
  - 第一种的安全性我们可以理解为，我们可以在代理服务器上弄一些安全检测的软件，这样我们可以检测数据，不安全的我们就不发送给客户端了。
  - 第二种就是上面我们说的。
- 代理服务器有两种协议，http和socks，这两种只是一种协议，就跟ssh协议一样，工作在传输层之上，我们可以根据协议数据然后让传输层发送，然后创建连接，然后我们就跟代理服务器发送数据，然后代理服务器和外面的服务器进行连接。客户端就不直接和服务器进行连接了。
  - 我们本地代理设置的127.0.0.1：8889这种是什么意思，127是本地回环地址，我们的数据产生之后就直接发送给8889端口了，这个8889端口就相当于对应着一个服务器，服务器在收到数据之后，例如我们的翻墙软件，对数据进行加密，然后在发送出去。充当了数据加密和转发的过程。为什么不能少这个过程，因为少了这个过程IP地址就直接看到了，防火墙就直接拦掉了。
  - 代理服务器可以设置为其他的IP地址吗？如果代理服务器在另一台主机上，我们可以将这个地址设置为代理服务器的IP，过程和上面一样。
- 协议只是数据交互的一种两人约定好的一种信息。大家按照这个协议头和协议信息进行一些数据的传输什么的。
- socks协议这种协议就是规定了，如果请求数据到了代理服务器，而且是用的socks协议，此时代理服务器解析IP这些数据，然后发送出去，相当于断开了客户端与服务器的直接连接。
  - 这种协议也是需要用TCP这些传输层来传输的，只是规定了一些数据，就跟ssh一样。在应用层的数据来了之后通过TCP发送给代理服务器，代理服务器在根据socks协议来解析这些数据，然后转发数据。如果没有会话层，就需要到应用层解析数据然后发送，这样就慢了很多。
  - 数据是在应用层产生的，但是具体的断开连接，需要的IP是在会话层协商的，在跟代理服务器连接的时候，我们会协商请求的地址什么的，然后代理服务器在和数据服务器连接，真个过程连接完了之后，数据在发送给socks代理服务器，然后代理服务器在转发。
