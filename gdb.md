- 在编译时使用-g选项编译源文件，即可生成满足GDB要求的可执行文件。

- gdb 可执行文件  就可以使用gdb调试。

  | 调试指令           | 作用                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | break  xxx   b xxx | 在源代码指定的某一行设置断点，其中 xxx 用于指定具体打断点的位置。 |
  | run    r           | 执行被调试的程序，其会自动在第一个断点处暂停执行。           |
  | continue    c      | 当程序在某一断点处停止运行后，使用该指令可以继续执行，直至遇到下一个断点或者程序结束。 |
  | next    n          | 令程序一行代码一行代码的执行。                               |
  | print xxx    p xxx | 打印指定变量的值，其中 xxx 指的就是某一变量名。              |
  | list   l           | 显示源程序代码的内容，包括各行代码所在的行号。默认显示10行，按回车显示剩下的。 |
  | quit    q          | 终止调试                                                     |

- 在进行 run 或者 start 指令启动目标程序之前，还可能需要做一些必要的准备工作，大致包括以下几个方面：

  - 如果启动 GDB 调试器时未指定要调试的目标程序，或者由于各种原因 GDB 调试器并为找到所指定的目标程序，这种情况下就需要再次手动指定；file 命令+可执行文件
  - 有些 C 或者 C++ 程序的执行，需要接收一些参数（程序中用 argc 和 argv[] 接收）启动时--args ， 启动后set args a.txt，启动后 run a.txt或者直接set args --test
  - 目标程序在执行过程中，可能需要临时设置 PATH 环境变量；path
  - 默认情况下，GDB 调试器将启动时所在的目录作为工作目录，但很多情况下，该目录并不符合要求，需要在启动程序手动为 GDB 调试器指定工作目录。cd 
  - 默认情况下，GDB 调试器启动程序后，会接收键盘临时输入的数据，并将执行结果会打印在屏幕上。但 GDB 调试器允许对执行程序的输入和输出进行重定向，使其从文件或其它终端接收输入，或者将执行结果输出到文件或其它终端。run > a.txt

##### break设置断点

- break常用的语法格式有两种，其中打断点的位置有几种表示方法：
  - linenum     linenum 是一个整数，表示要打断点处代码的行号。要知道，程序中各行代码都有对应的行号，可通过执行 l（小写的 L）命令看到。
  - filename:linenum     filename 表示源程序文件名；linenum 为整数，表示具体行数。整体的意思是在指令文件 filename 中的第 linenum 行打断点。
  - \+ offset  \- offset   offset 为整数（假设值为 2），+offset 表示以当前程序暂停位置（例如第 4 行）为准，向后数 offset 行处（第 6 行）打断点；-offset 表示以当前程序暂停位置为准，向前数 offset 行处（第 2 行）打断点。
  - function    function 表示程序中包含的函数的函数名，即 break 命令会在该函数内部的开头位置打断点，程序会执行到该函数第一行代码处暂停。
  - filename:function     filename 表示远程文件名；function 表示程序中函数的函数名。整体的意思是在指定文件 filename 中 function 函数的开头位置打断点。
  - 两种格式第二种 break  location if cond，cond为某个表达式，表达式为真，程序暂停设断点，反之，程序继续运行

- tbreak 命令可以看到是 break 命令的另一个版本，tbreak 和 break 命令的用法和功能都非常相似，唯一的不同在于，使用 tbreak 命令打的断点仅会作用 1 次，即使程序暂停之后，该断点就会自动消失。
- rbreak 命令的作用对象是 C、C++ 程序中的函数，它会在指定函数的开头位置打断点。break regex其中 regex 为一个正则表达式，程序中函数的函数名只要满足 regex 条件，tbreak 命令就会其内部的开头位置打断点。值得一提的是，tbreak 命令打的断点和 break 命令打断点的效果是一样的，会一直存在，不会自动消失。会匹配所有的并把所有的打上断点

##### watch监控变量值的变化设置观察断点

- 借助观察断点可以监控程序中某个变量或者表达式的值，只要发生改变，程序就会停止执行。相比普通断点，观察断点不需要我们预测变量（表达式）值发生改变的具体位置。
- watch cond，cond指的是要监控的变量或表达式
- rwatch 命令：只要程序中出现读取目标变量（表达式）的值的操作，程序就会停止运行；
- awatch 命令：只要程序中出现读取目标变量（表达式）的值或者改变值的操作，程序就会停止运行。
- info watchpoints 查看当前建立的观察点的数量
- 当监控的变量（表达式）为局部变量（表达式）时，一旦局部变量（表达式）失效，则监控操作也随即失效；
- 如果监控的是一个指针变量（例如 *p），则 watch *p 和 watch p 是有区别的，前者监控的是 p 所指数据的变化情况，而后者监控的是 p 指针本身有没有改变指向
- 这 3 个监控命令还可以用于监控数组中元素值的变化情况，例如对于 a[10] 这个数组，watch a 表示只要 a 数组中存储的数据发生改变，程序就会停止执行。
- watch设置条件断点和普通断点一样 watch num if cond

##### catch设置捕捉断点

- 捕捉断点的作用是，监控程序中某一事件的发生，例如程序发生某种异常时、某一动态库被加载时等等，一旦目标时间发生，则程序停止执行。用捕捉断点监控某一事件的发生，等同于在程序中该事件发生的位置打普通断点。
- catch event，event表示要监控的具体事件
  - throw [exception]    当程序中抛出 exception 指定类型异常时，程序停止执行。如果不指定异常类型（即省略 exception），则表示只要程序发生异常，程序就停止执行。 catch throw int
  - catch [exception]   当程序中捕获到 exception 异常时，程序停止执行。exception 参数也可以省略，表示无论程序中捕获到哪种异常，程序都暂停执行。
  - load [regexp]   unload [regexp]    其中，regexp 表示目标动态库的名称，load 命令表示当 regexp 动态库加载时程序停止执行；unload 命令表示当 regexp 动态库被卸载时，程序暂停执行。regexp 参数也可以省略，此时只要程序中某一动态库被加载或卸载，程序就会暂停执行。
- tcatch 命令和 catch 命令的用法完全相同，唯一不同之处在于，对于目标事件，catch 命令的监控是永久的，而 tcatch 命令只监控一次，也就是说，只有目标时间第一次触发时，tcath 命令才会捕获并使程序暂停，之后将失效。

- 当 catch 命令捕获到指定的 event 事件时，程序暂停执行的位置往往位于某个系统库（例如libstdc++）中。这种情况下，通过执行 up 命令，即可返回发生 event 事件的源代码处。
- GDB condition命令condition 命令的功能是：既可以为现有的普通断点、观察断点以及捕捉断点添加条件表达式，也可以对条件断点的条件表达式进行修改。if不可以为捕捉断点设置条件。
  - condition bnum expression 用于为 bnum 编号的断点添加或修改 expression 条件表达式
  - condition bnum 用于删除 bnum 编号断点的条件表达式，使其变成普通的无条件断点。
  - 参数 bnum 用于代指目标断点的编号；参数 expression 表示为断点添加或修改的条件表达式。info break可以查看断点的类型以及编号

##### GDB单步调试程序

- GDB 调试器共提供了 3 种可实现单步调试程序的方法，即使用 next、step 和 until 命令，next和step可以指定执行几行，例如 n 2     s 2
- next 是最常用来进行单步调试的命令，其最大的特点是当遇到包含调用函数的语句时，无论函数内部包含多少行代码，next 指令都会一步执行完。也就是说，对于调用的函数来说，next 命令只会将其视作一行代码。
- 当 step 命令所执行的代码行中包含函数时，会进入该函数内部，并在函数第一行代码处停止执行。step 命令可以缩写为 s 命令
- until 命令可以简写为 u 命令，有 2 种语法格式until   until location    不带参数的 until 命令，可以使 GDB 调试器快速运行完当前的循环体，并运行至循环体外停止。注意，until 命令并非任何情况下都会发挥这个作用，只有当执行至循环体尾部（最后一行代码）时，until 命令才会发生此作用；反之，until 命令和 next 命令的功能一样，只是单步执行程序。until 命令还可以后跟某行代码的行号，以指示 GDB 调试器直接执行至指定位置后停止。

##### GDB断点调试

- 通过在程序的适当位置打断点，观察程序执行至该位置时某些变量（或表达式）的值，进而不断缩小导致程序出现异常或 Bug 的语句的搜索范围，并最终找到，整个过程就称为断点调试。

| 命令                                    | 功能                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| run（r）                                | 启动或者重启一个程序。                                       |
| list（l）                               | 显示带有行号的源码。                                         |
| continue（c）                           | 让暂停的程序继续运行。                                       |
| next（n）                               | 单步调试程序，即手动控制代码一行一行地执行。不会退出循环体。 |
| step（s）                               | 如果有调用函数，进入调用的函数内部；否则，和 next 命令的功能一样。 |
| until（u） until location（u location） | 当你厌倦了在一个循环体内单步跟踪时，单纯使用 until 命令，可以运行程序直到退出循环体。 until n 命令中，n 为某一行代码的行号，该命令会使程序运行至第 n 行代码处停止。 |
| finish（fi）                            | 结束当前正在执行的函数，并在跳出函数后暂停程序的执行。       |
| return（return）                        | 结束当前调用函数并返回指定值，到上一层函数调用处停止程序执行。 |
| jump（j）                               | 使程序从当前要执行的代码处，直接跳转到指定位置处继续执行后续的代码。 |
| print（p）                              | 打印指定变量的值。                                           |
| quit（q）                               | 退出 GDB 调试器。                                            |

- 实际调试时，在某个函数中调试一段时间后，可能不需要再一步步执行到函数返回处，希望直接执行完当前函数，这时可以使用 finish 命令。与 finish 命令类似的还有 return 命令，它们都可以结束当前执行的函数。finish 命令和 return 命令的区别是，finish 命令会执行函数到正常退出；而 return 命令是立即结束执行当前函数并返回，也就是说，如果当前函数还有剩余的代码未执行完毕，也不会执行了。除此之外，return 命令还有一个功能，即可以指定该函数的返回值。例如return 5，指定函数返回值。

##### 查看变量的值

- Printf：在 GDB 调试程序的过程中，输出或者修改指定变量或者表达式的值。其可以输出变量的值，也可以修改变量的值。例如p result = 10

- Display：用于调试阶段查看某个变量或表达式的值，它们的区别是，使用 display 命令查看变量或表达式的值，每当程序暂停执行（例如单步执行）时，GDB 调试器都会自动帮我们打印出来，而 print 命令则不会。使用 1 次 print 命令只能查看 1 次某个变量或表达式的值，而同样使用 1 次 display 命令，每次程序暂停执行时都会自动打印出目标变量或表达式的值。因此，当我们想频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 display 命令可以一劳永逸。

  - 常用命令格式display expr ， expr表示要查看的目标变量或表达式

  - display/fmt expr ，参数fmt用于指定输出变量或者表达式的格式。display和/fmt之间不要有空格。以/x为例，应写为display/x expr

    | /fmt | 功 能                                |
    | ---- | ------------------------------------ |
    | /x   | 以十六进制的形式打印出整数。         |
    | /d   | 以有符号、十进制的形式打印出整数。   |
    | /u   | 以无符号、十进制的形式打印出整数。   |
    | /o   | 以八进制的形式打印出整数。           |
    | /t   | 以二进制的形式打印出整数。           |
    | /f   | 以浮点数的形式打印变量或表达式的值。 |
    | /c   | 以字符形式打印变量或表达式的值。     |

对于使用 display 命令查看的目标变量或表达式，都会被记录在一张列表（称为自动显示列表）中。通过执行info dispaly命令，可以打印出这张表。对于不需要再打印值的变量或表达式，可以将其删除或者禁用。undisplay num , delete display num，num可以是变量的名称也可以是info dispaly查出来的num编号。enable display num激活当前处于禁用状态的变量或表达式

- print 命令还有更高级的功能和用法，例如以指定的格式输出变量或者表达式的值、输出数组中指定区间内的所有元素。print [options --] [/fmt] expr  ，options 参数和 /fmt 或者 expr 之间，必须用`--`（ 2 个 - 字符）分隔。当 print 命令不指定任何 options 参数时，print 和 /fmt 之间不用添加空格，例如以十六进制的形式输出 num 整形变量的值，执行命令为 (gdb) print/x num。

| options 参数           | 功 能                                                        |
| ---------------------- | ------------------------------------------------------------ |
| -address on\|off       | 查看某一指针变量的值时，是否同时打印其占用的内存地址，默认值为 on。该选项等同于单独执行 set print address on\|off 命令。 |
| -array on\|off         | 是否以便于阅读的格式输出数组中的元素，默认值为 off。该选项等同于单独执行 set printf array on\|off 命令。 |
| -array-indexes on\|off | 对于非字符类型数组，在打印数组中每个元素值的同时，是否同时显示每个元素对应的数组下标，默认值为 off。该选项等同于单独执行 set print array-indexes on\|off 命令。 |
| -pretty on\|off        | 以便于阅读的格式打印某个结构体变量的值，默认值为 off。该选项等同于单独执行 set print pretty on\|off 命令。 |

- GDB 调试器还支持使用`@`和`::`运算符
  - `@`运算符用于输出数组中指定区域的元素 print first@len  参数 first 用于指定数组查看区域内的首个元素的值；参数 len 用于指令自 first 元素开始查看的元素个数。 print array[0]@2
  - 当程序中包含多个作用域不同但名称相同的变量或表达式时，可以借助`::`运算符明确指定要查看的目标变量或表达式print file::variable
    ，print function::variable 其中 file 用于指定具体的文件名，funciton 用于指定具体所在函数的函数名，variable 表示要查看的目标变量或表达式。例如函数中全局变量和局部变量同名时，用文件名指出全局变量，函数名指出局部变量。

##### 禁用和删除断点

- info break[n]，n为可选项，为某个断点的编号。可以查看当前调试环境中存在的所有断点，包括普通断点、观察断点以及捕捉断点。info watchpoint用来查询观察断点，这是专有的命令，普通断点和捕捉断点没有。
- clear 命令可以删除指定位置处的所有断点clear location参数 location 通常为某一行代码的行号或者某个具体的函数名。当 location 参数为某个函数的函数名时，表示删除位于该函数入口处的所有断点。
- delete 命令（可以缩写为 d ）通常用来删除所有断点，也可以删除指定编号的各类型断点。不加编号就是删除所有断点。
- 禁用断点可以使用 disable 命令。没有参数表示禁用所有断点。enable激活断点，不指定参数表示激活所有断点。

##### 调试多线程

| 调试命令                            | 功 能                                                        |
| ----------------------------------- | ------------------------------------------------------------ |
| info threads                        | 查看当前调试环境中包含多少个线程，并打印出各个线程的相关信息，包括线程编号（ID）、线程名称等。 |
| thread id                           | 将线程编号为 id 的线程设置为当前线程。                       |
| thread apply id... command          | id... 表示线程的编号；command 代指 GDB 命令，如 next、continue 等。整个命令的功能是将 command 命令作用于指定编号的线程。当然，如果想将 command 命令作用于所有线程，id... 可以用 all 代替。 |
| break location thread id            | 在 location 指定的位置建立普通断点，并且该断点仅用于暂停编号为 id 的线程。 |
| set scheduler-locking off\|on\|step | 默认情况下，当程序中某一线程暂停执行时，所有执行的线程都会暂停；同样，当执行 continue 命令时，默认所有暂停的程序都会继续执行。该命令可以打破此默认设置，即只继续执行当前线程，其它线程仍停止执行。 |

- 使用 GDB 调试多线程程序时，同一时刻我们调试的焦点都只能是某个线程，被称为当前线程。整个调试过程中，GDB 调试器总是会从当前线程的角度为我们打印调试信息。GDB 调试器为了方便用户快速识别出当前线程，执行 info thread 命令后，Id 列（ID号）前标有 * 号的线程即为当前线程。我们输入的调试命令并不仅仅作用于当前线程，例如 continue、next 等，默认情况下它们作用于所有线程。

- thread id将线程编号为id的线程设置为当前线程。就是看其他线程的默认调试信息。调试器默认只输出当前线程的调试信息，修改后就可以查看其他线程了。

- 设置线程锁set scheduler-locking mode
  - off：不锁定线程，任何线程都可以随时执行；
  - on：锁定线程，只有当前线程或指定线程可以运行；
  - step：当单步执行某一线程时，其它线程不会执行，同时保证在调试过程中当前线程不会发生改变。但如果该模式下执行 continue、until、finish 命令，则其它线程也会执行，并且如果某一线程执行过程遇到断点，则 GDB 调试器会将该线程作为当前线程。
  
- 对于调试多线程程序，GDB 默认采用的是 all-stop 模式，即只要有一个线程暂停执行，所有线程都随即暂停。这种调试模式可以适用于大部分场景的需要，借助适当数量的断点，我们可以清楚地监控到各个线程的具体执行过程。但在某些场景中，我们可能需要调试个别的线程，并且不想在调试过程中，影响其它线程的运行。这种情况下，可以将 GDB 的调试模式由 all-stop 模式更改为 non-stop 模式，该模式下调试多线程程序，当某一线程暂停运行时，其它线程仍可以继续执行。non-stop 模式下可以进行 all-stop 模式无法做到的调试工作，例如：
  - 保持其它线程继续执行的状态下，单独调试某个线程；
  - 在所有线程都暂停执行的状态下，单步调试某个线程；
  - 单独执行多个线程等等。
  
  另外还有一点和 all-stop 模式不同的是，在 all-stop 模式下，continue、next、step 命令的作用对象并不是当前线程，而是所有的线程；但在 non-stop 模式下，continue、next、step 命令只作用于当前线程。在 non-stop 模式下，如果想要 continue 命令作用于所有线程，可以为 continue 命令添加一个 -a 选项，即执行 continue -a 或者 c -a 命令，即可实现令所有线程继续执行的目的。set non-stop mode，mode有on和off两个选项。non-stop 模式和 all-stop 模式的不同。在 all-stop 模式下，当某一线程暂停执行时，GDB 调试器会自行将其切换为当前线程；而在 non-stop 模式下不会。这也就解释了上面实例中，当 thread1_job 因断点暂停时当前线程仍为 main.exe 主线程。

##### 后台执行调试命令

- command&，意思是不用等调试执行结束，其后台执行（异步），直接就可以执行下一条调试信息。后台执行命令异步调试程序的方法，多用于 non-stop 模式中。虽然 all-stop 模式中也可以使用，但在前一个异步命令未执行完毕前，仍旧不能执行其它命令。
- 对于在后台处于执行状态的线程，可以使用 interrupt 命令将其中断。在 all-stop 模式下，interrupt 命令作用于所有线程，即该命令可以令整个程序暂停执行；而在 non-stop 模式下，interrupt 命令仅作用于当前线程。 如果想另其作用于所有线程，可以执行 interrupt -a 命令。

##### 调试多进程程序

- attach PID号
- pidof命令可以手动获取进程id号

##### 反向调试

- 回退调试

##### 信号处理

- 信号是kill -l显示的32个信号
- handle命令handle signal mode

##### 查看栈信息

- 对于 C、C++ 程序而言，异常往往出现在某个函数体内，例如 main() 主函数、调用的系统库函数或者自定义的函数等。要知道，程序中每个被调用的函数在执行时，都会生成一些必要的信息，包括：

  - 函数调用发生在程序中的具体位置；
  - 调用函数时的参数；
  - 函数体内部各局部变量的值等等。

  这些信息会集中存储在一块称为“栈帧”的内存空间中。也就是说，程序执行时调用了多少个函数，就会相应产生多少个栈帧，其中每个栈帧自函数调用时生成，函数调用结束后自动销毁。

  这也就意味着，当程序因某种异常暂停执行时，如果其发生在某个函数内部，我们可以尝试借助该函数对应栈帧中记录的信息，找到程序发生异常的原因。

- main() 主函数对应的栈帧，又称为初始帧或者最外层的帧。除此之外，每当程序中多调用一个函数，执行过程中就会生成一个新的栈帧。更甚者，如果该函数是一个递归函数，则会生成多个栈帧。在程序内部，各个栈帧用地址作为它们的标识符，注意这里的地址并不一定为栈帧的起始地址。我们知道，每个栈帧往往是由连续的多个字节构成，每个字节都有自己的地址，不同操作系统为栈帧选定地址标识符的规则不同，它们会选择其中一个字节的地址作为栈帧的标识符。

- backtrace 命令用于打印当前调试环境中所有栈帧的信息

  ```gdb
  backtrace [-full] [n]
  ```

  用 [ ] 括起来的参数为可选项，它们的含义分别为：

  - n：一个整数值，当为正整数时，表示打印最里层的 n 个栈帧的信息；n 为负整数时，那么表示打印最外层 n 个栈帧的信息；
  - -full：打印栈帧信息的同时，打印出局部变量的值。

  当调试多线程程序时，该命令仅用于打印当前线程中所有栈帧的信息。如果想要打印所有线程的栈帧信息，应执行`thread apply all backtrace`命令。

-  借助如下命令，我们可以查看当前栈帧中存储的信息

  ```
  info frame
  ```

  该命令会依次打印出当前栈帧的如下信息：

  - 当前栈帧的编号，以及栈帧的地址；
  - 当前栈帧对应函数的存储地址，以及该函数被调用时的代码存储的地址
  - 当前函数的调用者，对应的栈帧的地址；
  - 编写此栈帧所用的编程语言；
  - 函数参数的存储地址以及值；
  - 函数中局部变量的存储地址；
  - 栈帧中存储的寄存器变量，例如指令寄存器（64位环境中用 rip 表示，32为环境中用 eip 表示）、堆栈基指针寄存器（64位环境用 rbp 表示，32位环境用 ebp 表示）等。

  除此之外，还可以使用`info args`命令查看当前函数各个参数的值；使用`info locals`命令查看当前函数中各局部变量的值。

- 根据栈帧编号或者栈帧地址，选定要查看的栈帧，语法格式如下

  ```
  frame spec
  ```

  该命令可以将 spec 参数指定的栈帧选定为当前栈帧。spec 参数的值，常用的指定方法有 3 种：

  1. 通过栈帧的编号指定。0 为当前被调用函数对应的栈帧号，最大编号的栈帧对应的函数通常就是 main() 主函数；
  2. 借助栈帧的地址指定。栈帧地址可以通过 info frame 命令（后续会讲）打印出的信息中看到；
  3. 通过函数的函数名指定。注意，如果是类似递归函数，其对应多个栈帧的话，通过此方法指定的是编号最小的那个栈帧。

  通过up和down调整当前栈帧。

- frame可以简写为f，gdb起来bt之后显示结果中

  ```c
  (gdb) bt
  #0  0x00007f949f622ff4 in _int_malloc () from /lib64/libc.so.6
  #1  0x00007f949f62678c in malloc () from /lib64/libc.so.6
  #2  0x000000000040857d in print_string_ptr (str=0x7f9490000a40 "module") at ../common/cJSON.c:222
  #3  0x00000000004092e4 in print_object (item=<optimized out>, fmt=1, depth=1) at ../common/cJSON.c:472
  #4  print_value (item=<optimized out>, depth=0, fmt=1) at ../common/cJSON.c:314
  #5  0x0000000000404981 in createJsonQueryUser (model=model@entry=0x40b2d8 "user_manage", type=type@entry=0x40b2d2 "query", query_info=...,
      wParam=wParam@entry=0, lParam=<optimized out>) at xUiMessage.cpp:76
  #6  0x00000000004037a2 in XUISession::__requestLogin (this=this@entry=0x7f9498000900, rpc=0x7f94980009f0, req=req@entry=0x7f94900008f0) at xUISession.cpp:119
  #7  0x000000000040477f in XUISession::Run (this=0x7f9498000900) at xUISession.cpp:640
  #8  0x0000000000406bfa in XThread::__threadFunc (lParam=0x7f9498000900) at ../common/xThread.cpp:228
  #9  0x0000000000406b27 in __posixThread (lParam=0x7f94980008e0) at ../common/xThread.cpp:101
  #10 0x00007f94a05acea5 in start_thread () from /lib64/libpthread.so.0
  #11 0x00007f949f69fb0d in clone () from /lib64/libc.so.6
  ```

  - 其中#0这一行是栈，#0代表第一层栈，#1代表第二层栈，需要看第几层的时候直接看#后面的数字，然后f 数字就能看到第几层栈的信息

##### GDB编辑和搜索源码

- 在调试文件时，某些时候可能会去找寻找某一行或者是某一部分的代码。可以使用 list 显示全部的源码，然后进行查看。当源文件的代码量较少时，我们可以使用这种方式搜索。如果源文件的代码量很大，使用这种方式寻找效率会很低。所以 GDB 中提供了相关的源代码搜索的的 search 命令。

  ```shell
  search <regexp>
  reverse-search <regexp>
  ```

  第一项命令格式表示从当前行的开始向前搜索，后一项表示从当前行开始向后搜索。其中 regexp 就是正则表达式，正则表达式描述了一种字符串匹配的模式，可以用来检查一个串中是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串。很多的编程语言都支持使用正则表达式。

##### GDB调试core文件

###### core文件

- 当程序运行过程中出现Segmentation fault (core dumped)错误时，程序停止运行，并产生core文件。core文件是程序运行状态的内存映象。使用gdb调试core文件，可以帮助我们快速定位程序出现段错误的位置。当然，可执行程序编译时应加上-g编译选项，生成调试信息。
- 当程序访问的内存超出了系统给定的内存空间，就会产生Segmentation fault (core dumped)，因此，段错误产生的情况主要有：
  - 访问不存在的内存地址；
  - 访问系统保护的内存地址；
  - 数组访问越界等。
- core dumped又叫核心转储, 当程序运行过程中发生异常, 程序异常退出时, 由操作系统把程序当前的内存状况存储在一个core文件中, 叫core dumped。
- core意指core memory，用线圈做的内存。如今 ，半导体工业澎勃发展，已经没有人用 core memory 了，不过，在许多情况下，人们还是把记忆体叫作 core 。

###### 控制core文件生成

- 使用ulimit -c命令可查看core文件的生成开关。若结果为0，则表示关闭了此功能，不会生成core文件。

- 使用ulimit -c filesize命令，可以限制core文件的大小（filesize的单位为KB）。如果生成的信息超过此大小，将会被裁剪，最终生成一个不完整的core文件。在调试此core文 件的时候，gdb会提示错误。比如：ulimit -c 1024。

- 使用ulimit -c unlimited，则表示core文件的大小不受限制。

- 在终端通过命令`ulimit -c unlimited`只是临时修改，重启后无效 ，要想永久修改有三种方式：

  - 在/etc/rc.local 中增加一行 ulimit -c unlimited 

  - 在/etc/profile 中增加一行 ulimit -c unlimited 

  - 在/etc/security/limits.conf最后增加如下两行记录：

    ```
    @root soft core unlimited
    @root hard core unlimited
    ```

###### core文件的名称和生成路径

- core默认的文件名称是core.pid，pid指的是产生段错误的程序的进程号。  默认路径是产生段错误的程序的当前目录。
- 如果想修改core文件的名称和生成路径，相关的配置文件为：  
  - **/proc/sys/kernel/core_uses_pid：**控制产生的core文件的文件名中是否添加pid作为扩展，如果添加则文件内容为1，否则为0。
  - **/proc/sys/kernel/core_pattern：**可以设置格式化的core文件保存的位置和文件名，比如原来文件内容是core-%e。  可以这样修改:  echo “/corefile/core-%e-%p-%t” > /proc/sys/kernel/core_pattern  将会控制所产生的core文件会存放到/corefile目录下，产生的文件名为：core-命令名-pid-时间戳。
    -  %p - insert pid into filename 添加pid 
    -  %u - insert current uid into filename 添加当前uid  
    - %g - insert current gid into filename 添加当前gid  
    - %s - insert signal that caused the coredump into the filename 添加导致产生core的信号 
    -  %t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间 
    -  %h - insert hostname where the coredump happened into filename 添加主机名  
    - %e - insert coredumping executable name into filename 添加命令名。  
    - 一般情况下，无需修改，按照默认的方式即可。

###### GDB调试core文件

- 使用gdb调试core文件来查找程序中出现段错误的位置时，要注意的是可执行程序在编译的时候需要加上-g编译命令选项。
- gdb调试core文件的步骤常见的有如下几种，推荐第一种。
- 第一种
  - 启动gdb，进入core文件，命令格式：**gdb [exec file] [core file]**。
  - 在进入gdb后，查找段错误位置：**where或者bt** 
- 第二种
  - 启动gdb，进入core文件，命令格式：**gdb –core=[core file]**
  - 在进入gdb后，指定core文件对应的符号表，命令格式：**file [exec file]** .
  - 查找段错误位置：**where或者bt**。
- 第三种
  - 启动gdb，进入core文件，命令格式：**gdb -c [core file]**。 
  - 在进入gdb后，指定core文件对应的符号表，命令格式：**file [exec file]** . 
  - 查找段错误位置：**where或者bt**。

##### GDB技巧

###### 源码路径查看与设置

- 查看源码搜索路径`show dir`，其中cdir表示编译路径compilation directory，cwd表示当前路径current working directory。
- 用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。dir命令+绝对路径。

###### 一些其他

- info的简写是i
- n不会跳过if和循环，只是会跳过函数，但是其有判断条件，可能会不执行这个if和循环代码，直接往下走好多行。
- 回车键是重复上一个命令
- list <源文件> ，例list test.c ，以后的list都是显示显示这个test.c的源文件。
- 编译的时候-g选项会将文件名这些选项加上去，虽然我们list看不到源文件，但是我们可以根据文件名直接打断点，因为文件名包含在了gdb启动的程序中，不用list看到源文件也可以打断点。

- Info frame简写为i f，表示打印当前栈的一些信息，f <数字>表示将数字表示的第几层栈设置为当前的栈，用i f可以查看栈信息。可以用bt查看当前所有的栈的信息，然后用f设置即可。
