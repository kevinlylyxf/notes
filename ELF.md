[ELF文件格式理解-天聪](https://www.cnblogs.com/qscfyuk/p/11697816.html)

- 符号表在节中的位置.symtab：这个节中是一个**符号表**，保存了变量名，函数名等。
- .text：这个节中保存了程序的可执行代码。
- 程序的执行方式：通过main函数进入代码段执行代码，在遇到全局变量的时候跳转到数据段进行操作，如果在一个函数内临时需要的临时变量就会在栈上申请空间进行跳转操作，如果不是临时的就会在堆空间上申请空间进行操作。栈会自己释放的，堆需要自己释放。整个的执行是从代码段开始的，以代码段位主线，需要什么数据就跳转到那个段里面进行操作，然后在跳转回来执行后面的代码。如果是自己写的函数都会在自己的代码段里面，直接跳转执行代码就可以。如果依赖其他的动态库，此时会在启动程序的时候修改重定位表，此时就能找到地址，然后跳转过去执行代码进行操作。
- .dynamic 段存的是依赖的动态库，从下面转载共享对象一节可以看出动态链接器在自举时会读取这个段，得到所有需要的动态库，然后进行加载。
- 这里面所有的地址都是在虚拟内存里面的地址，虚拟内存到物理内存中间还有一个映射关系，所以装载动态库时是装载到虚拟内存中的，装载的顺序不一样，其在虚拟内存中的地址就不一样，所以我们需要地址重定位，所以需要重定位表，至于所有的虚拟内存最后映射到物理内存中是一个地址这个目前就不考虑了。所以有动态符号表，我们将动态符号表里面的符号都找到，而且动态重定位表里面的地址都修正之后我们就可以找到具体的调用的函数。
  - 链接器在处理目标文件的时候，需要对目标文件中的某些部位进行重定位，也就是代码和数据节中对绝对地址的引用的位置。这些重定位的信息都是保存在一系列重定位表中，对于每一个需要重定位的代码节或者数据节，都有一个对应的重定位表。比如这个“.rel.text”就是一个代码相关的重定位表。比如在其他库中定义的函数或者变量，在本文件中引用到的了，编译器在编译的时候不知道他们的真实地址，所以暂时用一个假的地址（记作A）代替，同时生成一个重定位条目（包含P和S，后面会讲到）放到“.rel.text”节中，等到以后链接的时候由链接器根据重定位表中的信息计算出他们的真实地址。（每一个需要被重定位的地方叫做一个“重定位入口”。）
- 符号表里面只有函数名和变量名称，具体的变量是什么类型是不会有的，例如定义一个结构体Student，这个定义是不会在符号表里面出现的。为什么定义不会出现，因为定义了一个结构体，其所占用的内存是固定的，到时候定义数据的时候直接给分配空间就可以了，这个数据定义在符号表里面也没有意义。

所看书籍：链接器和加载器、程序员的自我修养、深入linux内核架构

## 动态链接的步骤和实现

动态链接的步骤分为3步：动态链接器自举，装载共享对象，重定位和初始化。

### 动态链接器自举

​        动态链接器本身也是一个共享对象，但有一些特殊性。首先，动态链接器本身不可以依赖于其他任何共享对象；其次动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成。对于第一个条件，可以人为的控制在编写动态链接器时保证不使用任何系统库、运行库；对于第二个条件，动态链接器必须在启动时有一段非常精巧的代码可以完成这项艰巨的工作而同时又不能用到全局和静态变量。这种具有一定限制条件的启动代码往往被称为自举（Bootstrap）。

​        动态链接器入口地址即是自举代码的入口，当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码即开始执行。自举代码首先会找到它自己的GOT。而GOT的第一个入口保存的即是“.dynamic”段的偏移地址，由此找到了动态连接器本身的“.dynamic”段。通过“.dynamic”中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。从这一步开始，动态链接器代码中才可以开始使用自己的全局变量和静态变量。

​        实际上在动态链接器的自举代码中，除了不可以使用全局变量和静态变量之外，甚至不能调用函数，即动态链接器本身的函数也不能调用。因为使用PIC模式编译的共享对象，对于模块内部的函数调用也是采用跟模块外部函数调用一样的方式，即使用GOT/PLT的方式，所以在GOT/PLT没有被重定位之前，自举代码不可以使用任何全局变量，也不可以调用函数。

### 装载共享对象

​        完成基本自举以后，动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表当中，称它为全局符号表（Global Symbol Table）。然后链接器开始寻找可执行文件所依赖的共享对象。在“.dynamic”段中，有一种类型的入口是DT_NEEDED，它所指出的是该可执行文件（或共享对象）所依赖的共享对象。由此，链接器可以列出可执行文件所需要的所有共享对象，并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合里取一个所需要的共享对象的名字，找到相应的文件后打开该文件，读取相应的ELF文件头和“.dynamic”段，然后将它相应的代码段和数据段映射到进程空间中。如果这个ELF共享对象还依赖于其他共享对象，那么将所依赖的共享对象的名字放到装载集合中。如此循环直到所有依赖的共享对象都被装载进来为止，当然链接器可以有不同的装载顺序，如果把依赖关系看作一个图的话，那么这个装载过程就是一个图的遍历过程，链接器可能会使用深度优先或者广度优先或者其他的顺序来遍历整个图，这取决于链接器，比较常见的算法一般都是广度优先的。

当应用程序需要使用动态链接里的函数函数时，由ld.so负责加载。搜索动态链接的顺序依此是

- 环境变量环境变量LD_AOUT_LIBRARY_PATH（a.out]格式）、LD_LIBRARY_PATH（ELF格式）；在Linux中，LD_PRELOAD指定的目录具有最高优先权。
- 缓存文件/etc/ld.so.cache。此为上述环境变量指定目录的二进制索引文件。更新缓存的命令是ldconfig。
- 默认目录，先在/lib中寻找，再到/usr/lib中寻找。

​        当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接所需要的符号。

### 重定位和初始化

​        当上面的步骤完成之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将它们的GOT/PLT中的每个需要重定位的位置进行修正。因为此时动态链接器已经拥有了进程的全局符号表，所以这个修正过程也显得比较容易，跟前面提到的地址重定位的原理基本相同。

​        重定位完成之后，如果某个共享对象有“.init”段，那么动态链接器会执行“.init”段中的代码，用以实现共享对象特有的初始化过程，比如最常见的，共享对象中的C++的全局/静态对象的构造就需要通过“.init”来初始化。相应地，共享对象中还可能有“.finit”段，当进程退出时会执行“.finit”段中的代码，可以用来实现类似C++全局对象析构之类的操作。

​        如果进程的可执行文件也有“.init”段，那么动态链接器不会执行它，因为可执行文件中的“.init”段和“.finit”段由程序初始化部分代码负责执行。

​        当完成了重定位和初始化之后，所有的准备工作就宣告完成了，所需要的共享对象也都已经装载并且链接完成了，这时候动态链接器就如释重负，将进程的控制权转交给程序的入口并且开始执行。

---

## 显示运行时链接

​        显式运行时链接是一种更加灵活的模块加载方式，也叫做运行时加载，相应的模块叫动态状态库。 在Linux中，从文件本身的格式上来看，动态库实跟一般的共享对象没有区别。主要的区别是共享对象是由动态链接器在程序启动之前负责装载和链接的，这一系列步骤都由动态连接器自动完成，对于程序本身是透明的；而动态库的装载则是通过一系列由动态链接器提供的API，具体地讲共有4个函数：打开动态库（dlopen）、查找符号（dlsym）、错误处理（dlerror）以及关闭动态库（dlclose），程序通过这几个API对动态库进行操作。这几个API的实现是在/lib/libdl.so.2里面，它们的声明和相关常量被定义在系统标准头文件。

#### dlopen()

dlopen()用来打开一个动态库，并将其加载到进程的地址空间，完成初始化过程，它的C原型定义为：

```c++
void *dlopen (const char *file, int mode)
{
 return __dlopen (file, mode, RETURN_ADDRESS (0));
}
```

​        filename 是被加载的动态库的路径，如果是绝对路径，则该函数将会尝试直接打开该动态库；如果是相对路径，那么dlopen()会尝试在以一定的顺序去查找该动态库文件。按上述加载过程加载。

​        如果filename为0，dlopen会返回全局符号表的句柄，即可以在运行时找到全局符号表里面的任何一个符号，并且可以执行它们，这有些类似高级语言反射（Reflection）的特性。全局符号表包括了程序的可执行文件本身、被动态链接器加载到进程中的所有共享模块以及在运行时通过dlopen打开并且使用了`RTLD_GLOBAL`方式的模块中的符号。

​        mode表示函数符号的解析方式，常量`RTLD_LAZY`表示使用延迟绑定，即PLT机制；而`RTLD_NOW`表示当模块被加载时即完成所有的函数绑定工作，如果有任何未定义的符号引用的绑定工作没法完成，那么dlopen()就返回错误。两种绑定方式必须选其一。另外还有一个常量`RTLD_GLOBAL`可以跟它们一起使用（通过“|”操作），它表示将被加载的模块的全局符号合并到进程的全局符号表中，使得以后加载的模块可以使用这些符号。在调试程序的时候可以使用`RTLD_NOW`作为加载参数，因为如果模块加载时有任何符号未被绑定的话，可以使用dlerror()立即捕获到相应的错误信息；而如果使用`RTLD_LAZY`的话，这种符号未绑定的错误会在加载后发生，则难以捕获。

​        dlopen的返回值是被加载的模块的句柄，这个句柄在后面使用dlsym或者dlclose时需要用到。如果加载模块失败，则返回NULL。如果模块已经通过dlopen被加载过了，那么返回的是同一个句柄。另外如果被加载的模块依赖其他模块，需要先手工加载依赖的模块。

​        dlopen的加载过程基本跟动态链接器一致，在完成装载、映射和重定位以后，就会执行“.init”段的代码然后返回。

#### dlsym()

dlsym函数是运行时装载的核心部分，通过这个函数找到所需要的符号。定义如下：

```c++
void *dlsym (void *handle, const char *name)
{
  return __dlsym (handle, name, RETURN_ADDRESS (0));
}
```

​        第一个参数是由dlopen()返回的动态库的句柄；第二个参数即所要查找的符号的名字，一个以“\0”结尾的C字符串。如果dlsym()找到了相应的符号，则返回该符号的值；没有找到相应的符号，则返回NULL。dlsym()返回的值对于不同类型的符号，意义是不同的。如果查找的符号是个函数，那么它返回函数的地址；如果是个变量，它返回变量的地址；如果这个符号是个常量，那么它返回的是该常量的值。这里有一个问题是：如果常量的值刚好是NULL或者0，需要使用dlerror()函数。如果符号找到了，那么dlerror()返回NULL，如果没找到，dlerror()就会返回相应的错误信息。

​        符号不仅仅是函数和变量，有时还是常量，比如表示编译单元文件名的符号等，这一般由编译器和链接器产生，而且对外不可见，但它们的确存在于模块的符号表中。dlsym()是可以查找到这些符号的，可以通过“objdump –t”来查看符号表，常量在符号表里面的类型是“`*ABS*`”。

​        关于符号优先级（及全局符号介入）的问题，当多个同名符号冲突时，先装入的符号优先，把这种优先级方式称为装载序列（Load Ordering）。不管是之前由动态链接器装入的还是之后由dlopen装入的共享对象，动态链接器在进行符号的解析以及重定位时，都是采用装载序列。

​        dlsym()对符号的查找优先级分两种类型。第一种是在全局符号表中进行符号查找，即dlopen()时，参数filename为NULL，那么由于全局符号表使用的装载序列，所以dlsym()使用的也是装载序列。第二种是对某个通过dlopen()打开的共享对象进行符号查找的话，那么采用叫做依赖序列（Dependency Ordering）的优先级。依赖序列以被dlopen()打开的那个共享对象为根节点，对它所有依赖的共享对象进行广度优先遍历，直到找到符号为止。

#### dlerror()

​        每次调用dlopen()、dlsym()或dlclose()以后，都可以调用dlerror()函数来判断上一次调用是否成功。dlerror()的返回值类型是char*，如果返回NULL，则表示上一次调用成功；如果不是，则返回相应的错误消息。

#### dlclose()

​        dlclose()的作用跟dlopen()刚好相反，它的作用是将一个已经加载的模块卸载。系统会维持一个加载引用计数器，每次使用dlopen()加载某模块时，相应的计数器加一；每次使用dlclose()卸载某模块时，相应计数器减一。只有当计数器值减到0时，模块才被真正地卸载掉。卸载的过程跟加载刚好相反，先执行“.finit”段的代码，然后将相应的符号从符号表中去除，取消进程空间跟模块的映射关系，然后关闭模块文件。

---

## 动态链接相关结构

​        动态链接情况下，操作系统首先会读取可执行文件的头部，检查文件的合法性，然后从头部中的“Program Header”中读取每个“Segment”的虚拟地址、文件地址和属性，并将它们映射到进程虚拟空间的相应位置。接着，以同样的映射的方式将动态链接器ld.so加载到进程的地址空间中，将控制权交给动态链接器的入口地址。然后动态链接器开始执行一系列自身的初始化操作，根据当前的环境参数，开始对可执行文件进行动态链接。最后动态链接器将控制权转交到可执行文件的入口地址，程序开始正式执行。

#### .interp 段

​        在动态链接的ELF可执行文件中，有一个`.interp`段，用于保存可执行文件所需要的动态链接器的路径字符串。使用objdump查看`.interp`的内容：

```shell
$ objdump -s main

main:     file format elf64-x86-64

Contents of section .interp:

400238 2f6c6962 36342f6c 642d6c69 6e75782d  /lib64/ld-linux-

400248 7838362d 36342e73 6f2e3200           x86-64.so.2.
```

在Linux的系统中，/lib64/ld-linux-x86-64.so.2通常是一个软链接，指向真正的动态链接器。
动态链接器在Linux下是Glibc的一部分，属于系统库级别的，版本号跟系统中的Glibc库版本号一样。
当系统中的Glibc库更新时，lib64/ld-linux-x86-64.so.2这个软链接就会指向到新的动态链接器， 而可执行文件本身不需要修改.interp中的动态链接器路径来适应系统的升级。

#### .dynamic 段

​        动态链接ELF中最重要的结构应该是`.dynamic`段，它保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。`.dynamic`段是一个结构数组，结构定义在elf.h中：

```c
typedef struct {
 	Elf64_Sxword d_tag;		//类型
	 union {
		 Elf64_Xword d_val; //类型对应的值
  	 Elf64_Addr d_ptr;  //类型对应的指针
  } d_un;
} Elf64_Dyn;

//常见类型值
#define DT_NULL		   0
#define DT_NEEDED	   1  
#define DT_PLTRELSZ	 2
#define DT_PLTGOT	   3
#define DT_HASH		   4
#define DT_STRTAB	   5
#define DT_SYMTAB	   6
#define DT_RELA		   7
#define DT_RELASZ	   8
#define DT_RELAENT	 9
#define DT_STRSZ	   10
#define DT_SYMENT	   11
#define DT_INIT		   12
#define DT_FINI		   13
#define DT_SONAME	   14
#define DT_RPATH 	   15
#define DT_SYMBOLIC	 16
#define DT_REL	     17
#define DT_RELSZ	   18
#define DT_RELENT	   19
#define DT_PLTREL	   20
#define DT_DEBUG	   21
#define DT_TEXTREL	 22
#define DT_LOPROC	   0x70000000
#define DT_HIPROC	   0x7fffffff

```

![img](https://img2018.cnblogs.com/blog/1746865/201910/1746865-20191018133226749-1477359730.png)

`.dynamic`段可以看成是动态链接下ELF文件的“文件头”。使用readelf查看“.dynamic”段的内容：

```
readelf -d ls

Dynamic section at offset 0x1ad24 contains 24 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libselinux.so.1]
 0x00000001 (NEEDED)                     Shared library: [librt.so.1]
 0x00000001 (NEEDED)                     Shared library: [libcap.so.2]
 0x00000001 (NEEDED)                     Shared library: [libacl.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000c (INIT)                       0x80495a4
 0x0000000d (FINI)                       0x805ba8c
 0x6ffffef5 (GNU_HASH)                   0x804818c
 0x00000005 (STRTAB)                     0x80489f4
 0x00000006 (SYMTAB)                     0x80481f4
 0x0000000a (STRSZ)                      1542 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000015 (DEBUG)                      0x0
 0x00000003 (PLTGOT)                     0x8063e58
 0x00000002 (PLTRELSZ)                   824 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x804926c
 0x00000011 (REL)                        0x80491dc
 0x00000012 (RELSZ)                      144 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x80490fc
 0x6fffffff (VERNEEDNUM)                 3
 0x6ffffff0 (VERSYM)                     0x8048ffa
 0x00000000 (NULL)                       0x0
```



#### 动态符号表

​        动态符号表，段名通常叫做`.dynsym`，用于表示模块之间的符号导入导出关系。`.dynsym`只保存了与动态链接相关的符号，`.symtab`中往往保存了所有符号，包括`.dynsym`中的符号。一般动态链接的模块同时拥有`.dynsym`和`.symtab`两个表。

​        与`.symtab`类似，动态符号表也需要一些辅助的表，比如动态符号字符串表`.dynstr`。 由于动态链接在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号哈希表`.hash`。

使用readelf -s来查看符号表

符号表保存了查找程序符号、为符号赋值、重定位符号所需的全部信息。

```c
typedef struct elf64_sym {
  Elf64_Word st_name;		/* Symbol name, index in string tbl */
  unsigned char	st_info;	/* Type and binding attributes */
  unsigned char	st_other;	/* No defined meaning, 0 */
  Elf64_Half st_shndx;		/* Associated section index */
  Elf64_Addr st_value;		/* Value of the symbol */
  Elf64_Xword st_size;		/* Associated symbol size */
} Elf64_Sym;
```

​        符号的主要任务是将一个字符串和一个值关联起来。例如，printf符号表示printf函数在虚拟地址空间中的地址，该函数的机器代码就存在于该地址。符号也可能有绝对值，由程序解释，例如数值常数。

数据结构中一些常见宏定义：

- 局部符号(STB_LOCAL)
- 全局符号(STB_GLOBAL)
- 弱符号(STB_WEAK)

- STT_OBJECT表示符号关联到一个数据对象，如变量、数组或指针

- STT_FUNC表示符号关联到一个函数或过程

- STT_NOTYPE表示符号的类型未指定。它用于未定义引用
- SHN_ABS指定符号是绝对值，不因重定位而改变
- SHN_UNDEF标识未定义符号，必须通过外部来源(如其他目标文件或库)解决

#### 动态链接重定位表

​        重定位是将ELF文件中未定义符号关联到有效值的处理过程。

​        在动态链接中，导入符号的地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正，即需要重定位。不论是可执行文件还是共享对象，不管是否使用PIC机制，只要有导入符号，就需要重定位。对于使用PIC技术的可执行文件或共享对象来说，虽然它们的代码段不需要重定位（因为地址无关），但是数据段还包含了绝对地址的引用，因为代码段中绝对地址相关的部分被分离了出来，变成了GOT，而GOT实际上是数据段的一部分。除了GOT以外，数据段还可能包含绝对地址引用。

​        动态链接的文件中，重定位表叫做`.rel.dyn`和`.rel.plt`。`.rel.dyn`是对数据引用的修正，它所修正的位置位于`.got`以及数据段；而`.rel.plt`是对函数引用的修正，它所修正的位置位于`.got.plt`。

​        使用readelf -r 查看一个动态链接的文件的重定位表：

```c
$ readelf -r Lib.so

Relocation section '.rel.dyn' at offset 0x2c8 contains 5 entries:
 Offset     Info    Type          Sym.Value  Sym. Name
000015e4  00000008 R_386_RELATIVE
000015e8  00000008 R_386_RELATIVE
000015bc  00000106 R_386_GLOB_DAT 00000000   __gmon_start__
000015c0  00000206 R_386_GLOB_DAT 00000000   _Jv_RegisterClasses
000015c4  00000506 R_386_GLOB_DAT 00000000   __cxa_finalize

Relocation section '.rel.plt' at offset 0x2f0 contains 4 entries:
 Offset     Info    Type             Sym.Value  Sym. Name
000015d4  00000107 R_386_JUMP_SLOT   00000000   __gmon_start__
000015d8  00000307 R_386_JUMP_SLOT   00000000   printf
000015dc  00000407 R_386_JUMP_SLOT   00000000   sleep
000015e0  00000507 R_386_JUMP_SLOT   00000000   __cxa_finalize
$readelf -S Lib.so
...
[19] .got        PROGBITS     000015bc 0005bc 00000c 04  WA  0   0  4
[20] .got.plt    PROGBITS     000015c8 0005c8 00001c 04  WA  0   0  4
[21] .data       PROGBITS     000015e4 0005e4 000008 00  WA  0   0  4 
...
```

​        不同的重定位类型表示重定位时不同的地址计算方法，这里有几种简单的重定位入口类型：`R_386_RELATIVE`、`R_386_GLOB_DAT`和`R_386_JUMP_SLOT`。其中`R_386_GLOB_DAT`和`R_386_JUMP_SLOT` 类型表示被修正的位置只需要直接填入符号的地址即可。根据`.rel.plt`中符号的偏移，可以得到`.got.plt`的结构如下图所示：

<img src="/var/folders/xb/s2j9v4kj6y36zhhz0ywj2ph80000gn/T/ro.nextwave.Snappy/ro.nextwave.Snappy/4427D9D3-C95A-41E1-9BAE-B59C6B1CA5E0.png" alt="4427D9D3-C95A-41E1-9BAE-B59C6B1CA5E0" style="zoom: 50%;" />

​        类似于`R_386_JUMP_SLOT`是对“`.got.plt`”的重定位，`R_386_GLOB_DAT`是对“`.got`”的重定位。 `R_386_RELATIVE`类型的重定位实际上就是基址重置（Rebasing），专门用来重定位指针变量类型。
如果某个ELF文件是以PIC模式编译的（动态链接的可执行文件一般是PIC的），并调用了一个外部函数bar，则bar会出现在“.rel.plt ”中；而如果不是以PIC模式编译，则bar将出现在“.rel.dyn”中。

---

## 动态链接

[网上介绍](https://markrepo.github.io/kernel/2018/08/19/dynamic-link/)

动态链接遇到的问题：共享对象在被装载时，如何确定它在进程虚拟地址空间中的位置?

程序模块的指令和数据中可能会包含一些绝对地址的引用，在链接产生输出文件的时候，就要假设模块被装载的目标地址。

共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。

为了能够使共享对象在任意地址装载，基本思路是：在链接时对所有绝对地址的引用不作重定位而把这一步推迟到装载时完成，一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。这种被称为装载时重定位。

装载时重定位遇到的问题：动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来讲是不同的。动态链接库中的可修改数据部分对于不同的进程来讲有多个副本，所以数据部分可以采用装载时重定位的方法来解决。

Linux和GCC支持装载时重定位的方法，GCC关于动态链接库有两个参数-shared和-fPIC，如果只使用            -shared，那么输出的共享对象就是使用装载时重定位的方法。

#### 地址无关代码(PIC)

- 装载时重定位是解决动态模块中有绝对地址引用的办法之一，缺点是指令部分无法在多个进程之间共享。为解决共享对象指令中对绝对地址的重定位问题，要让程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码（PIC, Position-independent Code）的技术。
- 如果**不使用PIC模式**编译，那么装载时肯定是要重定位的，而且时每个进程都有一个副本（相对比较占用内存）
- 如果**使用PIC模式**编译，将会在编译期生成地址无关代码（PIC Position-Independent Code），则代码段可以实现多程序共享，而仅数据段部分会在每个程序中有一个副本（节省内存）
- 对于这两种模式来说都是要重定位的，当相对PIC模式编译的模块仅需要对数据段进行重定位（因为代码段中的绝对地址引用部分被分离到了GOT中，而GOT是数据段的一部分；数据段中也可能包含绝对地址的引用，正好重定位数据段）

先来分析模块中各种类型的地址引用方式。把共享对象模块中的地址引用按照是否为跨模块分成两类：模块内部引用和模块外部引用；按照不同的引用方式分为指令引用和数据访问，得到4种情况：

- 模块内部的函数调用、跳转
- 模块内部的数据访问。比如模块中定义的全局变量、静态变量
- 模块外部的函数调用、跳转
- 模块外部的数据访问。比如其他模块中定义的全局变量

#### 模块内部函数调用、跳转

被调用的函数与调用者都处于同一个模块，它们之间的相对位置是固定的。所以对现代的系统来讲，模块内部的跳转、函数调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。

#### 模块内部数据访问

模块内部数据的访问，采用相对于当前指令加上固定的偏移量来实现。现代的体系结构中，数据的相对寻址往往没有相对于当前指令地址（PC）的寻址方式，所以ELF用了一个很巧妙的办法来得到当前的PC值。ELF的共享对象里面得到PC值的方法：

```c
0000044c <bar>:
 44c: 55                    push   %ebp
 44d: 89 e5                 mov    %esp,%ebp
 44f: e8 40 00 00 00        call   494 <__i686.get_pc_thunk.cx>
 454: 81 c1 8c 11 00 00     add    $0x118c,%ecx
 45a: c7 81 28 00 00 00 01  movl   $0x1,0x28(%ecx)         // a = 1
 461: 00 00 00 
 464: 8b 81 f8 ff ff ff     mov 0xfffffff8(%ecx),%eax
 46a: c7 00 02 00 00 00     movl   $0x2,(%eax)             // b = 2
 470: 5d                    pop    %ebp
 471: c3                    ret    

00000494 <__i686.get_pc_thunk.cx>:
 494: 8b 0c 24              mov    (%esp),%ecx
 497: c3  
```

44f,454,45a这三行是bar()中访问变量a的相应代码。`__i686.get_pc_thunk.cx`函数的作用就是把返回地址的值放到ecx寄存器，即把call的下一条指令的地址放到ecx寄存器。

当处理器执行call指令以后，下一条指令的地址会被压到栈顶，而esp寄存器就是始终指向栈顶的，那么当`__i686.get_pc_thunk.cx`执行mov (%esp),%ecx的时候，返回地址就被赋值到ecx寄存器了。

接着是add和mov指令，变量a的地址是add指令地址（保存在ecx寄存器）加上两个偏移量0x118c和0x28，即如果模块被装载到0x10000000地址，那么变量a的地址是0x10000000 + 0x454 + 0x118c + 0x28 = 0x10001608。如下图所示:

![](https://markrepo.github.io/assets/images/load-dynamic/inner-data.png)

#### 模块外部的数据访问

对于模块间的数据访问，ELF会在数据段里面建立一个指向这些变量的指针数组，称为全局偏移表（Global Offset Table，GOT）。 基本机制如下图所示：

![](https://markrepo.github.io/assets/images/load-dynamic/inter-data.png)

当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4个字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。

GOT如何做到指令的地址无关性？从第2种类型的数据访问可知，模块在编译时可以确定模块内部变量相对于当前指令的偏移，那么也可以在编译时确定GOT相对于当前指令的偏移，然后根据变量地址在GOT中的偏移就可以得到变量的地址。GOT中每个地址对应于哪个变量是由编译器决定的。
回顾bar()的反汇编代码，为访问变量b，程序首先计算出变量b的地址在GOT中的位置，即0x10000000 + 0x454 + 0x118c + (-8) = 0x100015d8（0xfffffff8为-8的补码表示），然后使用寄存器间接寻址方式给变量b赋值2。

#### 模块外部的函数调用

对于模块间调用和跳转，也可以采用模块间数据访问的方式来解决。不同的是，GOT中相应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转，基本的原理如下图所示：

![](https://markrepo.github.io/assets/images/load-dynamic/inter-call.png)

调用ext()函数的方法与上面访问变量b的方法基本类似，先得到当前指令地址PC，然后加上一个偏移得到函数地址在GOT中的偏移，然后一个间接调用。

#### 如何区分一个.so是否为PIC

```shell
readelf -d libhdca_util.so | grep TEXTREL
```

如果上面的命令有任何输出，那么.so就不是PIC的，否则就是PIC的，PIC的.so是不包含任何代码段重定位表的，TEXTREL表示代码段重定位表地址。

#### 延迟绑定(PLT)

由于动态链接下对于全局数据的访问和跨模块的调用都要进行复杂的GOT定位，然后间接寻址或调用，导致程序的运行速度减慢大概1%~%5。又因为动态链接的链接工作在运行时完成，导致程序的启动速度减慢。

程序运行过程中，会有很多函数没有用到（错误处理函数，没有使用的功能模块等），所以没有必要一开始就把所有函数都链接好，ELF采用延迟绑定的方法，基本思想是当函数第一次被用到时才由动态链接器进行绑定（符号查找，重定位等），没用到的不绑定。这提高了程序的启动速度。

ELF使用PLT（Procedure Linkage Table）来实现延迟绑定，它使用了一些很精巧的指令序列来完成。在Glibc中，动态链接器完成绑定工作的函数叫`_dl_runtime_resolve()`，它必须知道绑定发生在哪个模块中的哪个函数，因此假设其函数原型为`_dl_runtime_resolve(module, function)`。 当调用某个外部模块的函数时，并不直接通过GOT跳转，而是通过一个叫作PLT项的结构来进行跳转，每个外部函数在PLT中都有一个相应的项，比如bar()函数在PLT中的项的地址称为bar@plt。来看看bar@plt的实现：

```shell
bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jump _dl_runtime_resolve
```

bar@plt的第一条指令是通过GOT间接跳转的指令。bar@GOT表示GOT中保存bar()这个函数相应的项。如果链接器在初始化阶段已将bar()的地址填入该项，就跳转到bar()。但为了实现延迟绑定，链接器在初始化阶段并没有将bar()的地址填入到该项，而是将上面代码中第二条指令`push n`的地址填入到bar@GOT中，这个步骤不需要查找任何符号，所以代价很低。很明显，第一条指令的效果是跳转到第二条指令，相当于没有进行任何操作。第二条指令将一个数字n压入堆栈中，这个数字是bar这个符号引用在重定位表`.rel.plt`中的下标。接着又是一条push指令将模块的ID压入到堆栈，然后跳转到`_dl_runtime_resolve`。这实际上就是在实现`_dl_runtime_resolve`函数调用，它在进行一系列符号解析和重定位工作以后将bar()的真正地址填入到bar@GOT中。

之后当我们再次调用bar@plt时，第一条jmp指令就能够跳转到真正的bar()函数中，bar()函数返回的时候会根据堆栈里面保存的EIP直接返回到调用者，而不会再继续执行bar@plt中第二条指令开始的那段代码，那段代码只会在符号未被解析时执行一次。

上面描述的是PLT的基本原理，PLT真正的实现要比它的结构稍微复杂一些。ELF将GOT拆分成了两个表叫做“.got”和“.got.plt”。其中“.got”用来保存全局变量引用的地址，“.got.plt”用来保存函数引用的地址，即把外部函数的引用分离到“.got.plt”中。另外“.got.plt”的前三项是有特殊意义的：

- 第一项保存的是“.dynamic”段的地址，这个段描述了本模块动态链接相关的信息
- 第二项保存的是本模块的ID。
- 第三项保存的是`_dl_runtime_resolve()`的地址。

其中第二项和第三项由动态链接器在装载共享模块的时候负责将它们初始化。“.got.plt”的其余项分别对应每个外部函数的引用

---

## 重定位类型

c程序中引用全局变量的语句，经过编译得到的机器码会包含一个地址值部分，机器码执行时，该值必须为变量在内存中的绝对地址。

调用函数的语句，经过编译得到的机器码也包含一个地址值部分，机器码执行时，该值必须为内存中函数地址与下一条指令地址的偏移。

但是在编译、静态链接，甚至动态链接之后，该地址值部分可能暂时无法满足最终要求，从而必须相应设置一个重定项，要求后续过程对该值进行修改，重定项一方面标记了地址值的位置，另一方面提供了计算正确地址值的方法和计算参数。

对于局部变量的使用，由于程序执行时，esp寄存器保存的一定是栈顶的内存地址，那么从逻辑上讲，编译阶段就可以确定所有局部变量运行时的内存地址，所以不需要设置重定项。

引用变量的指令中，需要使用变量的绝对地址，而函数调用指令，需要使用函数与下一条指令地址的相对地址。

ELF规范总共定义了10种重定位类型，之所以需要这么多种不同类型的重定位信息，是由于如下原因：
  ① 硬件对变量和函数的寻址方式不同，寻找变量要求绝对地址，寻找函数要求相对地址；
  ② 不同场合下，程序员对最终可执行文件或动态库的期望不一样（位置无关、动态库函数重定位延迟），从而加了不同的编译选项（比如-fPIC、-Ox等）；
  ③ C语言的static、extern特性，导致不同特性的变量或函数地址可以被确定的时机不同；
  ④ 内核加载可执行文件，约定从固定地址0x80480000开始，但加载.so的起始地址无法约定（一个可执行程序只有一个main()，但可能依赖多个动态库）。

重定位表项描述如何修改后面的指令和数据字段。一般，共享目标文件在创建时，其基本虚拟地址是 0，不过执行地址将随着动态加载而发生变化。

重定位的过程，按照如下标记：

A：用来计算可重定位字段的取值的补齐。

B：共享目标在执行过程中被加载到内存中的位置（基地址）。

G：在执行过程中，重定位项的符号的地址所处的位置 —— 全局偏移表的索引。GOT：全局偏移表（GOT）的地址。

L：某个符号的过程链接表项的位置（节区偏移/地址）。过程链接表项把函数调用重定位到正确的目标位置。链接编辑器构造初始的过程链接表，动态链接器在执行过程中修改这些项目。

p：存储单位被重定位（用 r_offset 计算）到的位置（节区偏移或者地址）。

s：其索引位于重定位项中的符号的取值。重定位类型可以用readelf -r elf文件名查看。

## 基本理解

#### ELF格式和程序在内存中的理解

- 全局区内存(静态区、数据区、全局静态区、静态全局区) 在程序编译的时候就已经分配好，这块内存在程序的**生命周期**是**整个运行期间都存在**。它主要存放静态数据、全局数据和常量。  全局区中主要存放的数据有：全局变量、静态变量(static int a;)、常量(const int a = 5 ; )，全局区可以细分为data区和bss区。 常量区是全局区中划分的一个小区域，里面存放的是常量，如const修饰的全局变量、字符串常量等。data区里主要存放的是已经初始化的全局变量、静态变量和常量。 bss区主要存放的是未初始化的全局变量、静态变量，这些未初始化的数据在程序执行前会自动被系统初始化为0或者NULL
- 代码段（.text）是可执行指令的集合；数据段(.data)和 BSS 段(.bss)是数据的集合，其中.data 表示已经初始化的数据，.bss 表示未初始化的数据。从可执行程序的角度来说，如果一个数据未被初始化，就不需要为其分配空间，所以.data 和.bss 的区别就是 .bss 并不占用可执行文件的大小，仅仅记录需要用多少空间来存储这些未初始化的数据，而不分配实际空间。
- 一般情况下，一个可执行二进制程序（在 linux 下为一个进程单元），在存储时（**没有加载到内存运行**），至少拥有三个部分，分别是代码段(text)、数据段(data)、和BSS 段。
- 当应用程序运行时（**运行态**），此时需要另外两个域：堆和栈。正在运行的程序：**代码段 + 数据段 + BSS 段 + 堆 + 栈**。





  
